//==========섹터1==========

/* [신규] 명령어 자동 등록 시스템 (Command Registry) */
var USER_COMMANDS = {}; 
var ADMIN_COMMANDS = {}; 

function registerUserCmd(cmd, desc, cat, func) {
    USER_COMMANDS[cmd] = { desc: desc, cat: cat, execute: func };
}

function registerAdminCmd(cmd, desc, func) {
    ADMIN_COMMANDS[cmd] = { desc: desc, execute: func };
}

/* 파일 및 데이터 동기화 객체 */
var Lock = java.util.concurrent.locks.ReentrantLock; 
var lock = new Lock(); 
var logLock = new Lock(); // [v5.8] 저널링(블랙박스) 전용 독립 락 추가
var SD_PATH = android.os.Environment.getExternalStorageDirectory().getAbsolutePath(); 
var BASE_DIR = SD_PATH + "/kakaobot/data/"; 
var FILE_PATH = BASE_DIR + "attendance.json"; 
var JOURNAL_PATH = BASE_DIR + "transaction.log"; // [v5.8] 실시간 거래 기록용 블랙박스 경로
var BACKUP_DIR = BASE_DIR + "backup/"; 

/* [최적화] 전역 UID 캐시 시스템 */
var uidCache = uidCache || {}; 

/* [최적화] 병렬 처리 엔진 분리 */
// 1. 명령어 처리 엔진: 8개의 스레드가 유저와 소통 (응답 속도 담당)
var Executor = java.util.concurrent.Executors.newFixedThreadPool(6);
// 2. [신규] 저장 전담 엔진: 단 1개의 스레드가 순차적으로 파일 기록 (안전성 담당)
var SaveExecutor = java.util.concurrent.Executors.newSingleThreadExecutor();

/* 로그 저장 경로 및 디렉토리 설정 */ 
var BUG_LOG_PATH = BASE_DIR + "logs/bug_report.txt"; 
var ERROR_LOG_PATH = BASE_DIR + "logs/error_log.txt"; 
var logDir = new java.io.File(BASE_DIR + "logs/"); 
if (!logDir.exists()) logDir.mkdirs(); 
var dir = new java.io.File(BACKUP_DIR); 
if (!dir.exists()) dir.mkdirs(); 

/* 전역 상태 변수 */ 
var globalData = null; 
var isRecovering = false; // [v5.8] 부팅 시 복구 프로세스 진행 여부 플래그
var menuWaitState = {}; 
var lottoPurchaseState = {}; 
var sprinkleData = { active: false, winners: [] }; 
var activeThefts = {}; 
var duelData = {}; 
var selectWaitState = {}; 
var bankProcessState = {}; 
var marketOpenPrice = 0; 
var loanRegisterState = {}; 
var loanContractWaitState = {}; 
var miningState = {}; 
var feverData = { active: false, endTime: 0, scheduled: [] };

/* [Gemini 요청 사항] 경마 시스템 실시간 상태 및 상수 설명 통합 */
var racingData = {
    round: 1,           // [회차]: 경마의 진행 차수를 기록 (봇 재시작 시 1로 초기화됨)
    horses: [           // [출전마 정보]: 각 말의 고유 ID, 이름, 우승 가중치(weight), 상태 아이콘 저장
        { id: 1, name: "어마어마", weight: 1.0, icon: "☁️ 보통" },
        { id: 2, name: "어서말을해", weight: 1.0, icon: "☁️ 보통" },
        { id: 3, name: "마의웨이", weight: 1.0, icon: "☁️ 보통" },
        { id: 4, name: "핵탄두", weight: 1.0, icon: "☁️ 보통" },
        { id: 5, name: "돌격앞으", weight: 1.0, icon: "☁️ 보통" }
    ],
    bets: {},           // [배팅 기록]: { UID: {horseId, amount, name} } 형식으로 현재 회차 배팅 정보를 저장
    totalPool: 0,       // [당기 누적금]: 이번 회차에 유저들이 배팅한 순수 포인트 합계
    carryOver: 0,       // [이월금/Jackpot]: 이전 회차에서 당첨자가 없어 넘어온 포인트 (70% 비율 적용액)
    // [운영 플래그]: 봇 로드 시 현재 시간을 즉시 판별하여 09:00~23:59 사이면 자동으로 가동 상태(true)로 설정
    isOperating: (function() {
        var h = new Date().getHours();
        return h >= 9 && h <= 23; 
    })(),
    isDeadlineNotified: false, // [알림 제어]: 49분 59초 마감 공지가 중복 발송되는 것을 방지하는 스위치
    isResultProcessed: false   // [정산 제어]: 정각(00분) 결과 정산 로직이 중복 실행되는 것을 방지하는 스위치
};

/* 관리자 UID 기반 인증 */ 
var adminUIDs = ["fixed-uuid-관리자1", "fixed-uuid-관리자2"]; 

/* 관리자 명령어 목록 */ 
var ADMIN_CMD_LIST = [ 
    "1. /봇구동 [온|오프]", "2. /유저데이터 [닉네임]", "3. /데이터교정 (로직동기화)", 
    "4. /데이터이전 [구닉 > 신닉]", "5. /닉네임기록 [닉네임]", "6. /출석초기화 [닉네임]", 
    "7. /전체포인트지급 [금액]", "8. /포인트차감 [닉] [금액]", "9. /뿌리기 (랜덤 포인트)", 
    "10. /관리자등록/해제/목록", "11. /관리자로그", "12. /승급횟수초기화", 
    "13. /시즌강제종료", "14. /출석일수수정 [닉] [일]", "15. /전체출석수정 [일수]", 
    "16. /로또데이터초기화", "17. /도박제한 [온|오프]", "18. /강제재가동", 
    "19. /유저삭제 [닉네임]", "20. /시스템자가복원 (최적화)", "21. /전체복원 (데이터 롤백)", 
    "22. /유저복원 [닉네임] (부분복구)", "23. /제보목록 (버그확인)", "24. /오류로그 (로직검증)", 
    "25. /제보초기화", "26. /오류초기화", "27. /포인트지급 [닉네임] [수량]", 
    "28. /물가조정 [기준값|초기화]", "29. /관리자해제 [닉네임]", "30. /관리자목록", 
    "31. /물가완충 [0.0~1.0]", "32. /재원수정 [금액] (은행금고수정)", "33. /경제정보(통합지표확인)",
    "34. /시장자산복구 (주가복구)", "35. /종목추가 [이름] [가격]", "36. /종목수정 [기존] [신규] [가격]",
    "37. /재원충전 [금액]", "38. /신용조정 [닉네임] [점수]"
];

/* 시스템 핵심 상수 설정 */
var SYSTEM_CONFIG = {
    ECO: {
        /* [기초 경제 설정] */
        ATTEND_MIN: 1000, // [출석 최소 지급]: 출석 체크 시 무작위로 지급되는 포인트의 하한선
        ATTEND_MAX: 1500, // [출석 최대 지급]: 출석 체크 시 무작위로 지급되는 포인트의 상한선
        GAMBLE_MIN: 300,  // [홀짝 최소 베팅]: 홀짝 게임 진행 시 입력 가능한 최소 포인트 단위
        GAMBLE_MAX: 2000, // [홀짝 최대 베팅]: 홀짝 게임의 1회당 최대 베팅 한도 (사행성 조절)
        
        /* [신규] 중앙은행 지급준비제도 설정 */
        BANK: {
            RESERVE_RATIO: 0.20, // [지급준비율]: 은행 총 예금액 중 대출해줄 수 없는 최소 현금 보유 비중 (20%)
            INITIAL_RESERVE: 10000 // [초기 재원]: 데이터 초기화 시 은행 금고에 기본으로 들어있는 포인트
        },

        /* [신규] 경마 시스템 세부 설정 상술 */
        RACING: {
            MIN_BET: 1000,       // [최소 배팅액]: 경마 참여를 위한 최소 포인트
            MAX_BET: 30000,      // [최대 배팅액]: 한 회차에 걸 수 있는 최대 포인트 상한선
            TAX_RATE: 0.1,       // [기본 수수료]: 당첨금 정산 전 전체 판돈에서 국고로 환수되는 비율 (10%)
            CANCEL_FEE: 0.1,     // [취소 위약금]: 배팅 취소 시 원금에서 차감되어 국고로 귀속되는 수수료 (10%)
            WINLESS_BANK_RATE: 0.3,   // [무승자 국고행]: 우승자 없을 시 판돈의 30%를 은행 금고로 즉시 회수
            WINLESS_JACKPOT_RATE: 0.7, // [무승자 이월액]: 우승자 없을 시 판돈의 70%를 다음 회차 carryOver로 누적
            OPEN_HOUR: 9,        // 경마장 자동 개장 시각 (오전 9시)
            CLOSE_HOUR: 23       // 경마장 마지막 배팅 마감 시각 (오후 11시 59분)
        },
        
        STOCK: {
            PREFIXES: ["롯데", "엘지", "한화", "삼성", "두바이쫀득", "현대", "카카오", "네이버", "애플", "테슬라", "광어", "도다리", "두유노"], 
            SUFFIXES: ["전자", "생명", "화학", "건설", "중공업", "바이오", "제약", "엔터", "식품", "모터스", "쿠키", "에너지", "보험", "통신", "증권"], 
            TRAITS: { // [종목 특성]: 각 주식 타입별 변동성 및 생성 확률 정의
                "normal": { label: "일반", volatility: 1.5, prob: 44, icon: "🌱" }, 
                "bluechip": { label: "우량주", volatility: 1, prob: 28, icon: "🛡️" }, 
                "scam": { label: "작전주", volatility: 2, prob: 28, icon: "🔥" } 
            },
            MANIPULATION: { // [주가 조작 프리셋]: 관리자가 특정 종목의 시세를 강제로 제어할 때 참조
                TARGET: "애플모터스", // 조작 대상 종목명
                IS_UP: true,       // 상승(true) 또는 하락(false) 여부
                RATE: 0.25,        // 조작 시 변동률 (0.25 = 25%)
                ACTIVE: false      // 조작 시스템 활성화 상태 (평소엔 false)
            },
            SETTINGS: { // [주식 시장 세부 설정]
                MAX_COUNT: 10,     // 시장에 동시 상장 가능한 최대 종목 수
                OPEN_HOUR: 7,      // 주식 장 개장 시간
                CLOSE_HOUR: 23,    // 주식 장 마감 시간
                MANI_RATE: 0.25,   // 기본 특수 이벤트(폭등/폭락) 변동폭
                DELIST_LIMIT: 0.03, // [상폐 기준]: 시장 평균가 대비 해당 비율 이하로 떨어지면 상장폐지 검토
                CLOSING_LIMIT: 1.20, // [종가 제한]: 당일 시가 대비 최대 상승폭 (+20%)
                RESISTANCE_START: 1.15, // [저항 시작]: 가격이 시가 대비 15% 상승 시 하락 압력 발생
                GRAVITY: 0.05      // [중력 계수]: 저항 구간에서 가격을 아래로 끌어내리는 힘의 세기
            }
        },
        MINE: { // [광산 채굴 설정]
            BASE_PER_MIN: 3, // 분당 획득하는 기본 채굴 포인트 (물가 배율 적용 전)
            COPPER_PROB: 0.05, // 구리 발견 확률 (5%)
            GOLD_PROB: 0.03,   // 금 발견 확률 (3%)
            DIA_PROB: 0.005,   // 다이아몬드 발견 확률 (0.5%)
            COPPER_MULT: 1.5,  // 구리 발견 시 수익 배율
            GOLD_MULT: 2.0,    // 금 발견 시 수익 배율
            DIA_MULT: 10.0,    // 다이아몬드 발견 시 수익 배율
            ARTIFACT_CHANCE: 0.001, // [유물 조각]: 매 분마다 유물을 찾을 확률 (0.1%)
            ARTIFACT_GOAL: 10  // [도굴왕 칭호]: 유물 조각을 이 갯수만큼 모으면 자동 부여
        },
        PRIVATE_LOAN: { // [사채(P2P) 시장 설정]
            MIN_AMOUNT: 1000,       // 사채 매물 등록 시 최소 단위
            MAX_RATE: 15,           // 법정 최고 이율 (3시간당 최대 15%)
            COLLECTION_LIMIT: 24,   // [추심 시작]: 대출 후 24시간 경과 시 수익 압류(50%) 시작
            INTEREST_PERIOD: 3,     // 이자가 복리로 계산되어 붙는 주기 (3시간)
            MIN_BORROW: 1000,       // 유저가 사채를 빌릴 때 최소 단위
            DAILY_LIMIT: 1          // 은행 대출 일일 이용 제한 횟수
        },
        CREDIT: { // [은행 신용 등급 체계]
            SCORES: [900, 800, 700, 600, 500], // 각 등급을 나누는 기준 점수
            LIMITS: [30000, 20000, 15000, 10000, 8000, 3000], // 등급별 대출 가능 한도
            RATES: [1.03, 1.05, 1.13, 1.17, 1.20, 1.35], // 등급별 대환 이율 (원금 대비 상환액)
            LABELS: ["1등급", "2등급", "3등급", "4등급", "5등급", "신용불량자"], 
            ICONS: ["👑", "💎", "🥇", "🥈", "🥉", "🚫"] 
        }
    },

    SPAM: { // [도배 방지 엔진 설정]
        LIMIT_COUNT: 5,        // 제한 시간 내 허용되는 최대 메시지 수
        LIMIT_WINDOW: 3000,    // 도배 판정 시간 범위 (3000ms = 3초)
        TIMEOUT_MS: 300000     // 도배 적발 시 봇 이용이 제한되는 시간 (5분)
    },

    PROB: { // [핵심 게임 확률 엔진]
        ODD_EVEN_WIN: 0.47,        // 홀짝 기본 승률 (47%)
        ODD_EVEN_FEVER: 0.52,      // 피버타임 시 홀짝 승률 (52%)
        STOCK_NEW_LISTING: 0.5,    // 매 변동 타임마다 신규 종목이 상장될 확률 (50%)
        STOCK_SPECIAL: 0.5,        // 특정 종목에 특수 이벤트(폭등/폭락)가 발생할 확률 (50%)
        STOCK_UP_CHANCE: 0.45      // 특수 이벤트 발생 시 '상승'일 확률 (45%, 하락이 조금 더 높음)
    },
    
    MSG: { // [시스템 메시지 설정]
        PREFIX: {
            INFO: "ℹ️", ERROR: "🚫", ADMIN: "⚙️", SUCCESS: "✅", 
            WARN: "⚠️", GAMBLE_WIN: "🎊", GAMBLE_LOSE: "💀", LOAN: "🚬", MINE: "⛏️", TIMEOUT: "🔇"
        }, 
        ERR_FORM: "형식이 올바르지 않습니다.", 
        ERR_MONEY: "포인트가 부족합니다.", 
        ERR_USER: "대상을 찾을 수 없습니다.", 
        ERR_TIMEOUT: "도배로 인해 이용이 일시 제한되었습니다." 
    }
};

//==========섹터2==========

/**
 * [v5.8 신규] 블랙박스 복구 엔진 (Replay Journal)
 * 기능: 봇 재시작 시 JSON에 미처 저장되지 못한 최신 거래 내역을 로그 파일에서 읽어 복구함.
 * 이 로직 덕분에 "10초 오차 없는 복구"가 실현됩니다.
 */
function recoverFromJournal(data) {
    try {
        var journalFile = new java.io.File(JOURNAL_PATH);
        if (!journalFile.exists() || journalFile.length() === 0) return;

        var logs = FileStream.read(JOURNAL_PATH).split("\n");
        var recoveryCount = 0;

        logs.forEach(function(line) {
            if (!line.trim()) return;
            var parts = line.split("|"); // 형식: UID|RoomName|Delta|BankReserveDelta
            if (parts.length < 3) return;

            var uid = parts[0];
            var room = parts[1];
            var delta = Number(parts[2]);
            var brDelta = Number(parts[3] || 0);

            // 해당 방과 유저를 찾아 메모리 데이터에 즉시 합산
            if (data.rooms[room] && data.rooms[room].users[uid]) {
                data.rooms[room].users[uid].point += delta;
                data.rooms[room].bankReserve += brDelta;
                recoveryCount++;
            }
        });

        if (recoveryCount > 0) {
            Log.info("[Recovery] 블랙박스 엔진이 " + recoveryCount + "건의 누락된 최신 거래를 복구했습니다.");
        }
    } catch (e) {
        Log.error("Journal Recovery Error: " + e);
    }
}

/* 데이터베이스 로드 함수 (복구 로직 및 경마 데이터 동기화 통합) */
function getDatabase() {
    if (globalData !== null) return globalData; 
    try {
        var file = new java.io.File(FILE_PATH);
        var initialData;
        
        if (!file.exists()) {
            initialData = {
                rooms: {}, admins: ["관리자"], botActive: true,
                lotto: { round: 1, entries: {}, dailyPool: 0, jackpot: 0, lastWinNums: [] },
                /* [신규] 경마 데이터 초기 구조 등록 */
                racing: { round: 1, bets: {}, totalPool: 0, carryOver: 0, lastWinner: null },
                nickHistory: {}, adminLogs: [], stockMarket: {}, stockTraffic: {},
                economyBase: 0, economyDamping: 0.5, lastDailyReset: "", lastDietDate: "",
                feverData: { active: false, endTime: 0, scheduled: [] }, isCalibrated: false,
                loanPools: {}, loanContracts: {}, marketOpenPrice: 0 
            };
        } else {
            var content = FileStream.read(FILE_PATH);
            if (!content) throw new Error("Empty File");
            initialData = JSON.parse(content);
        }

        // [v5.8 핵심] JSON 로드 직후, 아직 파일에 안 적힌 '블랙박스 로그'를 읽어 데이터 정밀 보정
        recoverFromJournal(initialData);
        
        globalData = initialData;
        
        if (globalData.marketOpenPrice !== undefined) marketOpenPrice = globalData.marketOpenPrice;

        /* [Gemini 요청 사항] 경마 데이터 영속성(Persistence) 연동 */
        // 파일에 저장된 경마 정보가 있으면 메모리 객체(racingData)에 동기화
        if (globalData.racing) {
            for (var key in globalData.racing) {
                // bets, round, carryOver 등 파일의 최신 값을 메모리로 복사
                racingData[key] = globalData.racing[key];
            }
        } else {
            // 파일에 경마 항목이 없으면 섹터 1의 기본값을 DB 구조에 삽입
            globalData.racing = racingData;
        }
        
        if (globalData.rooms) {
            for (var r in globalData.rooms) {
                var targetRoom = globalData.rooms[r];
                if (!targetRoom.loanPools) targetRoom.loanPools = {};
                if (!targetRoom.loanContracts) targetRoom.loanContracts = {};
                if (targetRoom.bankReserve === undefined) {
                    targetRoom.bankReserve = SYSTEM_CONFIG.ECO.BANK.INITIAL_RESERVE; 
                }
            }
        }
        return globalData;
    } catch (e) {
        Log.error("DB Load Error: " + e);
        var stableFile = new java.io.File(BACKUP_DIR + "last_stable_backup.json");
        if (stableFile.exists()) {
            globalData = JSON.parse(FileStream.read(BACKUP_DIR + "last_stable_backup.json"));
            if (globalData.marketOpenPrice !== undefined) marketOpenPrice = globalData.marketOpenPrice;
            
            // 백업 로드 시에도 경마 데이터 동기화
            if (globalData.racing) racingData = globalData.racing;
            
            return globalData;
        }
        return null;
    }
}

/* 로직 추적 시작 */
function startTracking(user, commandName) {
    if (!user) return;
    user.lastAction = { cmd: commandName, status: "PENDING", time: Date.now(), msg: "수행 시작" };
}

/**
 * [v5.8 업그레이드] 포인트 변동 검증 및 실시간 블랙박스 기록
 * 기능: 전체 파일을 저장(safeSaveData)하기 전, 텍스트 한 줄을 먼저 써서 '무조건적인 유실 방지' 달성
 */
function verifyPointTransaction(user, prePoint, changeAmount, reason, roomName, brDelta) {
    try {
        var expected = Number(prePoint) + Number(changeAmount);
        var actual = Number(user.point);
        
        if (actual !== expected) {
            var errorMsg = "[" + new Date().toLocaleString() + "] [불일치] " + (user.name||"") + ": " + reason + " (예상:" + fp(expected) + "/실제:" + fp(actual) + ")\n";
            FileStream.append(ERROR_LOG_PATH, errorMsg);
            try { Api.replyRoom("내리다", "⚠️ 포인트 불일치 발생\n" + errorMsg); } catch(e){}
            user.lastAction = { cmd: reason, status: "FAIL", amount: changeAmount, time: Date.now(), msg: "데이터 불일치" };
        } else {
            // [v5.8 핵심] 고속 저널링(Journaling) 기록
            // 방 이름(roomName)과 은행재원변동(brDelta)이 있을 경우에만 블랙박스에 남김
            if (roomName) {
                logLock.lock();
                try {
                    // 형식: UID|방이름|변동량|은행변동량
                    var journalEntry = user.uid + "|" + roomName + "|" + changeAmount + "|" + (brDelta || 0) + "\n";
                    FileStream.append(JOURNAL_PATH, journalEntry);
                } finally {
                    logLock.unlock();
                }
            }

            if (user.lastAction && user.lastAction.status !== "FAIL") {
                user.lastAction = { cmd: reason, status: "SUCCESS", amount: changeAmount, time: Date.now(), msg: "정상 완료" };
            }
        }
    } catch(e) { 
        FileStream.append(ERROR_LOG_PATH, "검증오류: " + e + "\n"); 
        try { Api.replyRoom("내리다", "⚠️ 포인트 검증 오류\n" + e); } catch(err){}
    }
}

/* 로직 추적 종료 */
function endTracking(user, isSuccess, resultMsg) {
    if (!user || !user.lastAction) return;
    if (user.lastAction.status === "FAIL") return; 
    user.lastAction.status = isSuccess ? "SUCCESS" : "CRASH";
    user.lastAction.msg = resultMsg;
    user.lastAction.endTime = Date.now();
}

//==========섹터3==========

/* [최적화] 하이브리드 비동기 영속화(Asynchronous Persistence) 엔진 v5.8 */
/**
 * @param {Object} data - 저장할 데이터 객체
 * @param {Boolean} isForceBackup - true일 경우 백업 파일까지 물리적으로 기록
 */
function safeSaveData(data, isForceBackup) {
    if (!data) return;

    /* [Gemini 요청 사항] 경마 데이터 영속성 통합 */
    // 저장 전 메모리의 최신 경마 데이터를 DB 객체에 동기화하여 리로드 시에도 유지되도록 합니다.
    data.racing = racingData;

    globalData = data; // 메모리 데이터 즉시 동기화 (응답 속도 최우선)

    // [방어형 로직] 무거운 직렬화 및 무결성 검증은 메인 스레드에서 먼저 수행
    var content;
    try {
        content = JSON.stringify(data);
        var check = JSON.parse(content);
        if (!check || !check.rooms) {
            throw new Error("데이터 구조 불완전 (rooms 누락)");
        }
    } catch (e) {
        // [복구] 기존 시스템의 알림 기능 유지
        Log.error("Save Guard Blocked: " + e.message);
        try {
            Api.replyRoom("내리다", "⚠️ 데이터 보호 작동: 오염된 데이터의 쓰기 시도를 차단했습니다.\n사유: " + e.message);
        } catch (err) {}
        return; // 오염된 데이터는 배경 일꾼에게 넘기지 않고 즉시 차단
    }

    // [비동기 처리] 실제 파일 쓰기는 저장 전담 일꾼(SaveExecutor)에게 위임
    SaveExecutor.execute(new java.lang.Runnable({
        run: function() {
            // [안정성] 싱글 스레드 환경에서 락을 통한 순차적 기록 보장
            lock.lock(); 
            try {
                var targetPath = FILE_PATH;
                var tempPath = FILE_PATH + ".tmp";
                var tempFile = new java.io.File(tempPath);
                
                FileStream.write(tempPath, content);

                // 원자적 교체 (Atomic Rename)
                if (tempFile.exists() && tempFile.length() > 0) {
                    var orgFile = new java.io.File(targetPath);
                    if (orgFile.exists()) orgFile.delete();
                    tempFile.renameTo(orgFile);

                    // [v5.8 핵심] 전체 저장이 성공했으므로 블랙박스(Journal) 로그 초기화
                    // 데이터가 영구 파일에 안착했으므로 임시 기록된 로그들은 더 이상 필요 없음
                    logLock.lock();
                    try {
                        var jFile = new java.io.File(JOURNAL_PATH);
                        if (jFile.exists()) jFile.delete();
                    } finally {
                        logLock.unlock();
                    }
                } else {
                    throw new Error("임시 파일 생성 실패 또는 데이터 유실");
                }

                // 주기적 백업 처리
                if (isForceBackup) {
                    var backupPath = BACKUP_DIR + "last_stable_backup.json";
                    FileStream.write(backupPath + ".tmp", content);
                    var bTemp = new java.io.File(backupPath + ".tmp");
                    if (bTemp.exists() && bTemp.length() > 0) {
                        var oldB = new java.io.File(backupPath);
                        if (oldB.exists()) oldB.delete();
                        bTemp.renameTo(oldB);
                    }
                }
            } catch (e) {
                Log.error("Async File Write Error: " + e);
                try {
                    Api.replyRoom("내리다", "⚠️ 시스템 오류: 배경 저장 실패\n" + e.message);
                } catch (err) {}
            } finally {
                lock.unlock(); // 작업 완료 후 락 해제
            }
        }
    }));
}

//==========섹터4==========

/* 관리자 및 시스템 설정 */
var FIXED_ADMINS = ["95 남 광어"]; // 여기에 본인의 정확한 닉네임을 입력하세요
var TIERS = ["아이언", "브론즈", "실버", "골드", "플레티넘", "에메랄드", "다이아몬드", "마스터", "그랜드마스터", "챌린저"];
var ALLOWED_ROOMS = ["내리다", "테스트"]; 

//==========섹터5==========

/* 고티어 승급 확률 설정 */
var TIER_PROBS = {
    0: { up: 95, stay: 5, down: 0 },
    1: { up: 85, stay: 15, down: 0 },
    2: { up: 70, stay: 25, down: 5 },
    3: { up: 50, stay: 40, down: 10 },
    4: { up: 35, stay: 50, down: 15 },
    5: { up: 20, stay: 60, down: 20 },
    6: { up: 12, stay: 68, down: 20 },
    7: { up: 8, stay: 67, down: 25 },  
    8: { up: 5, stay: 70, down: 25 }  
};

/* 상점 카테고리 정의 */
var SHOP_CATEGORIES = {
    1: "🎨 장착/꾸미기 (아이콘)",
    2: "🔂 성장/게임 (승급, 방어)",
    3: "💳 경제/지원 (신용, 인증)",
    4: "🎁 랜덤 뽑기 (아이콘 박스)",
    5: "🎫 특수/복권 (로또)"
};

/* [수정] 상점 아이템 데이터 (카테고리화 및 신규 아이템 2종 추가) */
var SHOP_ITEMS = [
    { id: 1, name: "활동가 아이콘", icon: "🌱", price: 500, effect: "icon", title: "", cat: 1 },
    { id: 2, name: "숙련자 아이콘", icon: "⚔️", price: 2000, effect: "icon", title: "", cat: 1 },
    { id: 3, name: "러블리 아이콘", icon: "❣️", price: 5000, effect: "icon", title: "", cat: 1 },
    { id: 4, name: "베테랑 아이콘", icon: "💎", price: 9000, effect: "icon", title: "", cat: 1 },
    { id: 5, name: "에이리언 아이콘", icon: "👾", price: 12000, effect: "icon", title: "", cat: 1 },
    { id: 6, name: "네임드 아이콘", icon: "👑", price: 15000, effect: "icon", title: "", cat: 1 },
    { id: 8, name: "승급 기회 구매", icon: "🔂", price: 150, effect: "promotion", cat: 2 },  
    { id: 9, name: "강등 방어권", icon: "🛡️", price: 2000, effect: "tierGuard", cat: 2 },
    { id: 10, name: "신용 점수 회복", icon: "💊", price: 1500, effect: "credit", value: 50, cat: 3 },
    { id: 11, name: "[시즌] 롤 판수 인증권", icon: "🎫", price: 15000, effect: "gameAuth", cat: 3 },
    { id: 12, name: "랜덤 아이콘 박스", icon: "🎁", price: 3000, effect: "randomBox", cat: 4 },
    { id: 7, name: "로또 구매", icon: "🎟️", price: 100, effect: "lotto", cat: 5 }
];

/* [신규] 랜덤 아이콘 박스 상세 구성 및 확률 설정 */
var RANDOM_BOX_CONFIG = {
    PROBS: [
        { grade: "꽝 (Trash)", icon: "💩", prob: 0.60, items: ["💩", "🤡", "🧤", "👞", "🌂", "🪠", "🚽", "🦴", "🧱", "🧹", "🧺", "🧻", "🧼", "🦶", "🦟"] },
        { grade: "노말 (Normal)", icon: "🌱", prob: 0.20, items: ["🌱", "⚔️", "❣️", "🍀", "🎀", "🎈", "🧸", "🪁", "🍭", "🍏", "🍄", "🌻", "🐱", "🐶", "🍎"] },
        { grade: "레어 (Rare)", icon: "💎", prob: 0.10, items: ["💎", "👾", "🛡️", "🎰", "🔱", "🧿", "🎭", "🎨", "🧪", "🔭", "🎸", "🏹", "🕯️", "⛓️", "🧬"] },
        { grade: "에픽 (Epic)", icon: "🔮", prob: 0.05, items: ["👑", "☄️", "🧨", "🔮", "⛩️", "🎡", "🚁", "🌋", "🐅", "🦅", "🏹", "🏰", "🛥️", "🧿"] },
        { grade: "유니크 (Unique)", icon: "🦄", prob: 0.03, items: ["🪐", "🏮", "🐲", "🦾", "🛰️", "🦄", "🧞", "🦁", "🐋", "🦜", "🕸️", "🎃", "🎅", "🧜"] },
        { grade: "레전더리 (Legendary)", icon: "🎰", prob: 0.02, items: ["🔥", "💫", "🌌", "⚡", "🛸", "🌈", "☀️", "❄️", "🌑", "🔱", "💮", "💠", "🎖️" ] }
    ],
    PAYBACK: 2000 // 중복 아이콘 당첨 시 환급금
};

//==========섹터6==========

/**
 * [시스템 모듈] 명령어 자동 등록 및 도움말 관리
 * 기능: CMD_LIST의 데이터를 USER_COMMANDS/ADMIN_COMMANDS 레지스트리에 매핑하고 도움말 생성
 */

/* [1] 도움말 생성 함수 (동적 렌더링) */
function generateHelpMenu(category) {
    var list = [];
    for (var cmd in USER_COMMANDS) {
        var item = USER_COMMANDS[cmd];
        if (item.cat === category) {
            list.push("• " + cmd + ": " + item.desc);
        }
    }
    return list.length > 0 ? list.join("\n") : "해당 카테고리에 준비된 명령어가 없습니다.";
}

function generateAdminHelp() {
    var list = [];
    var idx = 1;
    for (var cmd in ADMIN_COMMANDS) {
        list.push(idx + ". " + cmd + " (" + ADMIN_COMMANDS[cmd].desc + ")");
        idx++;
    }
    return "⚙️ [관리자 전용 명령어]\n" + list.join("\n");
}

/* [2] 명령어 리스트 데이터 (수정됨: 결투 응답 및 경마 명령어 통합 추가) */
var CMD_LIST = {
    user: [
        { cmd: "/출석", desc: "매일 포인트 획득", cat: "조회", func: "_gameShopLogic" },
        { cmd: "/내정보", desc: "내 스탯 확인", cat: "조회", func: "_gameInfoLogic" }, 
        { cmd: "/신용등급", desc: "신용 점수와 등급 확인", cat: "조회", func: "_gameInfoLogic" },
        { cmd: "/출석순위", desc: "포인트 랭킹 확인", cat: "조회", func: "_gameInfoLogic" },
        { cmd: "/유저정보", desc: "[닉네임] 상세정보 보기", cat: "조회", func: "_gameInfoLogic" },
        { cmd: "/명예의전당", desc: "챌린저 명단 확인", cat: "조회", func: "_gameInfoLogic" },
        { cmd: "/버그제보", desc: "[내용] 오류 및 버그 신고", cat: "조회", func: "response" }, 
        { cmd: "/경마", desc: "현재 출전마 정보 및 배당 확인", cat: "조회", func: "_gameInfoLogic" }, // [신규 경마 조회]
        { cmd: "/홀짝", desc: "[홀|짝] [포인트] 도박", cat: "게임", func: "_gameActionLogic" },
        { cmd: "/승급", desc: "티어 승급 도전", cat: "게임", func: "_gameActionLogic" },
        { cmd: "/배팅", desc: "[말번호] [포인트] 경마 참여", cat: "게임", func: "_gameActionLogic" }, // [신규 경마 배팅]
        { cmd: "배팅취소", desc: "현재 회차 배팅 철회 (수수료 10%)", cat: "게임", func: "_gameActionLogic" }, // [신규 경마 취소]
        { cmd: "/결투", desc: "[닉네임] [포인트] 신청", cat: "게임", func: "_gameActionLogic" },
        { cmd: "수락", desc: "결투 신청 승낙", cat: "게임", func: "_gameActionLogic" },
        { cmd: "거절", desc: "결투 신청 거절", cat: "게임", func: "_gameActionLogic" },
        { cmd: "취소", desc: "결투 신청 철회", cat: "게임", func: "_gameActionLogic" },
        { cmd: "/도둑질", desc: "[닉네임] 포인트 탈취 시도", cat: "게임", func: "_gameActionLogic" },
        { cmd: "잡았다요놈", desc: "도둑질 방어 (1분 이내)", cat: "게임", func: "_gameActionLogic" },
        { cmd: "줍기", desc: "바닥에 떨어진 포인트 획득", cat: "게임", func: "_gameActionLogic" },
        { cmd: "/상점", desc: "아이콘 및 방어권 구매", cat: "상점", func: "_gameShopLogic" },
        { cmd: "/구매", desc: "[번호] 상점 물품 구매", cat: "상점", func: "_gameShopLogic" },
        { cmd: "/가방", desc: "보유 중인 아이콘/칭호 확인", cat: "상점", func: "_handleInventoryLogic" },
        { cmd: "/장착", desc: "[번호] 보유 아이템 장착", cat: "상점", func: "_handleInventoryLogic" },
        { cmd: "/분해", desc: "[번호] 아이콘 분해 및 포인트 회수", cat: "상점", func: "_handleInventoryLogic" },
        { cmd: "/로또정보", desc: "내 로또 번구 및 결과 확인", cat: "상점", func: "_handleLottoLogic" },
        { cmd: "/아이콘초기화", desc: "설정한 아이콘 삭제", cat: "상점", func: "_handleLottoLogic" },
        { cmd: "/은행", desc: "예금/출금/송금/대출/사채 종합 관리", cat: "경제", func: "_gameBankLogic" },
        { cmd: "/대출한도", desc: "신용 등급별 한도 확인", cat: "경제", func: "_gameInfoLogic" },
        { cmd: "/상환", desc: "[금액] 대출금 직접 상환", cat: "경제", func: "_gameBankLogic" },
        { cmd: "/주식", desc: "실시간 주가 확인", cat: "주식", func: "_gameStockLogic" },
        { cmd: "/내주식", desc: "보유 주식 및 수익률 확인", cat: "주식", func: "_gameStockLogic" },
        { cmd: "/매수", desc: "[종목명] [수량] 주식 구매", cat: "주식", func: "_gameStockLogic" },
        { cmd: "/매도", desc: "[종목명] [수량] 주식 판매", cat: "주식", func: "_gameStockLogic" },
        { cmd: "/광산시작", desc: "방치형 포인트 채굴 시작", cat: "광산", func: "_handleMiningLogic" },
        { cmd: "/광산정보", desc: "현재 채굴 현황 및 예상 수익 확인", cat: "광산", func: "_handleMiningLogic" },
        { cmd: "/광산종료", desc: "채굴 완료 및 포인트 정산", cat: "광산", func: "_handleMiningLogic" },
        { cmd: "/유물도감", desc: "유물 조각 수집 현황 확인", cat: "광산", func: "_handleMiningLogic" }
    ],
    admin: [
        { cmd: "/봇구동", desc: "[온|오프] 시스템 제어", func: "_adminSystemLogic" },
        { cmd: "/시장자산복구", desc: "유저 평단가 기반 주가 긴급 복구", func: "_adminEconomyLogic" },
        { cmd: "/종목추가", desc: "[이름] [가격] 신규 상장", func: "_adminEconomyLogic" },
        { cmd: "/종목수정", desc: "[기존] [새이름] [가격] 수정", func: "_adminEconomyLogic" },
        { cmd: "/경제정보", desc: "은행 재원 및 경제 지표 확인", func: "_adminEconomyLogic" },
        { cmd: "/재원수정", desc: "[금액] 은행 금고 자본 조정", func: "_adminEconomyLogic" },
        { cmd: "/데이터교정", desc: "은행 재원 및 유저 데이터 동기화", func: "_adminEconomyLogic" },
        { cmd: "/물가조정", desc: "[기준값] 인플레 반영 상점가 조절", func: "_adminEconomyLogic" },
        { cmd: "/물가완충", desc: "[0.0~1.0] 물가 변동폭 조절", func: "_adminEconomyLogic" },
        { cmd: "/강제재가동", desc: "시스템 락 해제 및 리셋", func: "_adminSystemLogic" },
        { cmd: "/유저삭제", desc: "[닉네임] 데이터 영구 삭제", func: "_adminUserManageLogic" },
        { cmd: "/유저데이터", desc: "상세 JSON 데이터 확인", func: "_adminUserManageLogic" },
        { cmd: "/데이터이전", desc: "[구닉] > [신닉] 자산 이전", func: "_adminUserManageLogic" },
        { cmd: "/닉네임기록", desc: "[닉네임] 변경 이력 조회", func: "_adminUserManageLogic" },
        { cmd: "/출석초기화", desc: "[닉네임] 오늘 기록 삭제", func: "_adminUserManageLogic" },
        { cmd: "/포인트지급", desc: "[닉네임] [수량] 직접 지급", func: "_adminEconomyLogic" },
        { cmd: "/전체포인트지급", desc: "[수량] 전원 지급", func: "_adminEconomyLogic" },
        { cmd: "/포인트차감", desc: "[닉네임] [수량] 차감", func: "_adminEconomyLogic" },
        { cmd: "/도박제한", desc: "[온|오프] 시스템 제어", func: "_adminSystemLogic" },
        { cmd: "/뿌리기", desc: "랜덤 포인트 선착순 이벤트", func: "_adminEconomyLogic" },
        { cmd: "/관리자등록", desc: "[닉네임] 부관리자 추가", func: "_adminSystemLogic" },
        { cmd: "/관리자해제", desc: "[닉네임] 관리자 권한 박탈", func: "_adminSystemLogic" },
        { cmd: "/관리자목록", desc: "권한 보유자 명단 조회", func: "_adminSystemLogic" },
        { cmd: "/관리자로그", desc: "최근 관리 활동 내역", func: "_adminLogLogic" },
        { cmd: "/제보목록", desc: "버그 제보 확인", func: "_adminLogLogic" },
        { cmd: "/제보초기화", desc: "제보 내역 전체 삭제", func: "_adminLogLogic" },
        { cmd: "/오류로그", desc: "시스템 에러 로그 확인", func: "_adminLogLogic" },
        { cmd: "/오류초기화", desc: "시스템 에러 로그 삭제", func: "_adminLogLogic" },
        { cmd: "/승급횟수초기화", desc: "전체 승급 기회 리셋", func: "_adminEconomyLogic" },
        { cmd: "/시즌강제종료", desc: "모든 티어 초기화", func: "_adminEconomyLogic" },
        { cmd: "/출석일수수정", desc: "[닉네임] [수치] 수정", func: "_adminUserManageLogic" },
        { cmd: "/전체출석수정", desc: "모든 유저 출석일 고정", func: "_adminUserManageLogic" },
        { cmd: "/로또데이터초기화", desc: "로또 시스템 리셋", func: "_adminEconomyLogic" },
        { cmd: "/전체복원", desc: "데이터 롤백 (안전 지점)", func: "_adminEconomyLogic" },
        { cmd: "/유저복원", desc: "[닉네임] 부분 복구", func: "_adminUserManageLogic" },
        { cmd: "/시스템자가복원", desc: "메모리 최적화 및 변수 초기화", func: "_adminEconomyLogic" },
        { cmd: "/재원충전", desc: "[금액] 은행 금고 자본 긴급 수혈", func: "_adminEconomyLogic" },
        { cmd: "/신용조정", desc: "[닉네임] [점수] 신용점수 직접 가감", func: "_adminUserManageLogic" }
    ]
};

//==========섹터7==========

/* 전역 상태 변수들 (섹터1과 중복 방지 처리) */ 
var sprayData = { 
    totalPoint: 0, 
    remainingPoint: 0, 
    maxWinners: 0, 
    currentWinners: 0, 
    winnersList: [], 
    isActive: false, 
    timer: null 
};

/* 섹터1에 없는 변수만 신규 선언 */ 
var selectWaitState = {}; 
var bankProcessState = {};

/**
 * [Gemini 요청 사항] 통합 순자산 계산 엔진 (칭호 및 Ecobase 표준)
 * 기능: 유저의 모든 자산(현금, 예금, 주식, 채권)에서 모든 부채를 차감하여 실질 자산을 산출합니다.
 */
function util_calculateNetWorth(user, roomData) {
    if (!user) return 0;

    // 1. 가용 현금 자산 (지갑 + 통장)
    var liquidAssets = Number(user.point || 0) + Number(user.bank || 0);

    // 2. 투자 자산 (보유 주식액: 평단가 기준)
    var stockAssets = 0;
    if (user.stockHoldings && user.stockAvg) {
        for (var sName in user.stockHoldings) {
            var count = Number(user.stockHoldings[sName] || 0);
            var avg = Number(user.stockAvg[sName] || 0);
            if (!isNaN(count) && !isNaN(avg)) stockAssets += (count * avg);
        }
    }

    // 3. 채무 및 채권 계산 (사채 시장 연동)
    var bankDebt = (user.loan && user.loan.debt) ? Number(user.loan.debt) : 0;
    var sacheDebt = 0;   // 내가 빌린 돈 (부채)
    var sacheClaims = 0; // 내가 빌려준 돈 (채권/자산)

    if (roomData && roomData.loanContracts) {
        for (var cid in roomData.loanContracts) {
            var c = roomData.loanContracts[cid];
            // 부채 합산 (채무자 식별)
            if (c.borrowerUid === user.uid || (user.name && c.borrowerName === user.name)) {
                sacheDebt += Number(c.currentDebt);
            }
            // 채권 합산 (채권자 식별)
            if (c.lenderUid === user.uid || (user.name && c.lenderName === user.name)) {
                sacheClaims += Number(c.currentDebt);
            }
        }
    }

    // [최종 공식]: 순자산 = (가용자산 + 주식자산 + 미수채권) - (은행대출 + 사채부채)
    var netWorth = (liquidAssets + stockAssets + sacheClaims) - (bankDebt + sacheDebt);
    return Math.floor(netWorth);
}

/* [핵심] 지능형 포인트 통합 처리 및 순자산 기반 칭호 엔진 (v5.8 저널링 대응) */
function util_updatePoint(user, roomData, delta, reason, roomName) {
    if (!user || isNaN(delta) || delta === 0) return;
    
    var prePoint = Number(user.point || 0);
    var bankOutputReasons = ["출석 보상", "민생지원금 지급", "홀짝 적중", "주식 매도", "광산 채굴", "로또 1등 당첨", "로또 2등 당첨", "로또 3등 당첨", "아이템 분해 회수", "랜덤박스 중복 환급", "결투 승리 보상", "뿌리기 줍기", "경마 당첨금"];
    var bankInputReasons = ["주식 매수", "홀짝 미적중", "도둑질 체포 벌금", "대출 상환", "상점 구매: ", "경찰 체포 벌금", "경찰 벌금", "도둑질 성공", "은행 기부", "경마 배팅", "배팅 취소 수수료"];

    var brDelta = 0; 

    if (roomData) {
        if (roomData.bankReserve === undefined) roomData.bankReserve = SYSTEM_CONFIG.ECO.BANK.INITIAL_RESERVE;
        if (delta > 0) {
            if (bankOutputReasons.some(function(r){ return reason.indexOf(r) !== -1; })) brDelta = -delta;
        } else {
            if (bankInputReasons.some(function(r){ return reason.indexOf(r) !== -1; }) || reason.indexOf("벌금") !== -1 || reason.indexOf("상환") !== -1) {
                brDelta = Math.abs(delta);
            }
        }
        roomData.bankReserve += brDelta;
    }

    user.point = prePoint + delta;

    /* [Gemini 요청 사항] 실질 순자산 기반 자산가 칭호 실시간 판별 엔진 */
    var totalNetWorth = util_calculateNetWorth(user, roomData);
    
    var assetTitles = [
        { name: "대부호", limit: 1000000 },
        { name: "부호", limit: 500000 },
        { name: "거상", limit: 300000 },
        { name: "재벌", limit: 100000 }
    ];

    var currentTitle = user.title || "";
    var suitableTitle = "";
    var requiredLimit = 0;

    // 1. 현재 실질 순자산에 맞는 적정 칭호 찾기
    for (var i = 0; i < assetTitles.length; i++) {
        if (totalNetWorth >= assetTitles[i].limit) {
            suitableTitle = assetTitles[i].name;
            requiredLimit = assetTitles[i].limit;
            break;
        }
    }

    // 2. 칭호 변경 감지 (상승 또는 하락)
    var isAssetTitle = assetTitles.some(function(t){ return t.name === currentTitle; });

    if (currentTitle !== suitableTitle) {
        var targetRoom = roomName || (roomData && roomData.roomName ? roomData.roomName : "내리다");

        // A. 새로운 상위 칭호 획득 (순자산 기준)
        if (suitableTitle !== "" && (currentTitle === "" || totalNetWorth >= requiredLimit)) {
            if (!user.inventory) user.inventory = [];
            if (!user.inventory.some(function(it){ return it.title === suitableTitle; })) {
                user.inventory.push({ id: 700 + i, name: "[" + suitableTitle + "] 칭호", icon: "💰", effect: "title", title: suitableTitle });
            }
            user.title = suitableTitle;
            var winMsg = "[🎖️ 신규 칭호 획득]\n━━━━━━━━━━━━━━━\n" + (user.name || "유저") + "님\n\n축하합니다! 실질 순자산이 " + fp(totalNetWorth) + "P를 돌파하여 [" + suitableTitle + "] 칭호를 획득했습니다!\n\n✨ 상태: [" + suitableTitle + "] 칭호 자동 장착 완료\n💼 보관: 가방에 영구 저장되었습니다.\n━━━━━━━━━━━━━━━\n⚠️ 순자산(현금+주식+채권-부채) 기준 미달 시 자동 해제됩니다.";
            try { Api.replyRoom(targetRoom, winMsg); } catch(e){}
        } 
        // B. 자격 미달로 인한 칭호 소멸 또는 강등
        else if (isAssetTitle && (suitableTitle === "" || totalNetWorth < assetTitles.find(function(t){return t.name === currentTitle}).limit)) {
            var oldTitle = currentTitle;
            user.title = suitableTitle; 
            var loseMsg = "📉 [칭호 자격 상실]\n━━━━━━━━━━━━━━━\n" + (user.name || "유저") + "님\n실질 순자산이 기준치 미만으로 하락하여 [" + oldTitle + "] 칭호가 해제되었습니다.";
            if (suitableTitle !== "") loseMsg += "\n(현재 자산에 맞는 [" + suitableTitle + "] 칭호로 교체되었습니다.)";
            try { Api.replyRoom(targetRoom, loseMsg); } catch(e){}
        }
    }

    if (typeof verifyPointTransaction === 'function') {
        verifyPointTransaction(user, prePoint, delta, reason, roomName, brDelta);
    }
}

/* [신규] 포인트 단위 쉼표 포맷팅 함수 (안전 모드) */
function fp(val) {
    if (val === undefined || val === null || isNaN(val)) return "0";
    return String(Math.floor(Number(val))).replace(/\B(?=(\d{3})+(?!\d))/g, ",");
}

/* fP 별칭 설정 (호환성 유지) */
var fP = fp;

/**
 * [UI] 명령어 결과 포맷팅 함수
 */
function formatCommand(title, user, content, nextStep) { 
    var msg = title + "\n━━━━━━━━━━━━━━━\n"; 
    if (user !== null) { 
        var nameTag = (typeof user === "string") ? user : getDisplayName(user); 
        msg += nameTag + "님\n"; 
    } 
    msg += content + "\n━━━━━━━━━━━━━━━"; 
    if (nextStep) msg += "\n💡 [가이드]: " + nextStep; 
    return msg; 
}

/**
 * [UI] 단순 정보 조회 포맷팅 함수
 */
function formatSimple(title, content, nextStep) {
    var msg = "ℹ️ " + title + "\n━━━━━━━━━━━━━━━\n" + content + "\n━━━━━━━━━━━━━━━";
    if (nextStep) msg += "\n💡 [가이드]: " + nextStep;
    return msg;
}

/**
 * [UI] 관리자 전용 포맷팅 함수
 */
function formatAdmin(title, content) { 
    return "⚙️ " + title + "\n━━━━━━━━━━━━━━━\n" + content + "\n━━━━━━━━━━━━━━━"; 
}

/**
 * [UI] 시스템 에러 포맷팅 함수
 */
function formatError(user, content, nextStep) { 
    var nameTag = (typeof user === "string") ? user : getDisplayName(user); 
    var msg = "🚫 오류 발생\n━━━━━━━━━━━━━━━\n" + nameTag + "님\n사유: " + content + "\n━━━━━━━━━━━━━━━"; 
    if (nextStep) msg += "\n💡 [가이드]: " + nextStep; 
    return msg; 
}

/**
 * [신규] 주식 가격 변동 엔진
 */
function stock_calculateNextPrice(currentPrice) {
    if (!marketOpenPrice || marketOpenPrice <= 0) return currentPrice;
    var cfg = SYSTEM_CONFIG.ECO.STOCK.SETTINGS;
    var growthRate = (currentPrice - marketOpenPrice) / marketOpenPrice;
    var change = (Math.random() * 2.4 - 1.2) / 100;
    if (growthRate > cfg.RESISTANCE_START) {
        var now = new Date();
        var elapsed = (now.getHours() - cfg.OPEN_HOUR) * 60 + now.getMinutes();
        var total = (cfg.CLOSE_HOUR - cfg.OPEN_HOUR) * 60;
        var timeWeight = Math.min(Math.max(elapsed / total, 0), 1.0); 
        var resistance = (growthRate - cfg.RESISTANCE_START) * cfg.GRAVITY * (1 + timeWeight);
        change -= resistance;
        if (growthRate >= (cfg.CLOSING_LIMIT - 0.01) && change > 0) {
            if (Math.random() < 0.8) change = -Math.abs(change) * 0.5;
        }
    }
    return Math.max(10, currentPrice + (currentPrice * change));
}

/**
 * [신규] 장 마감 보정 로직
 */
function stock_applyClosingCorrection(currentPrice) {
    if (!marketOpenPrice || marketOpenPrice <= 0) return currentPrice;
    var cfg = SYSTEM_CONFIG.ECO.STOCK.SETTINGS;
    var growthRate = (currentPrice - marketOpenPrice) / marketOpenPrice;
    if (growthRate >= cfg.CLOSING_LIMIT) {
        var safeRate = (cfg.CLOSING_LIMIT - 0.01) + (Math.random() * 0.008);
        var correctedPrice = marketOpenPrice * safeRate;
        return Math.max(10, Math.round(correctedPrice));
    }
    return currentPrice;
}

//==========섹터8==========

/**
 * [Gemini 요청 사항] 경제 지표 계산 함수 (실질 순자산 기준 일원화)
 * 기능: 섹터 7의 util_calculateNetWorth를 호출하여 국가 전체 자산을 집계합니다.
 * 반영: 유저의 채권(빌려준 돈)을 자산으로 정식 포함하여 통계 누락을 방지함.
 */
function calculateEconomy(data, roomName) {
    var totalAssets = 0;
    var userCount = 0;
    if (!data || !data.rooms) return { total: 0, count: 0, average: 0 };

    // 특정 방만 스캔할지, 전체 방을 스캔할지 결정
    var roomsToScan = roomName ? [roomName] : Object.keys(data.rooms);
    
    for (var i = 0; i < roomsToScan.length; i++) {
        var r = roomsToScan[i];
        var roomData = data.rooms[r];
        if (!roomData) continue;

        for (var uid in roomData.users) {
            var u = roomData.users[uid];
            if (!u) continue;

            /* [핵심] 섹터 7의 통합 계산 엔진 호출 */
            // 각 유저의 (현금 + 예금 + 주식 + 채권) - (부채)를 계산합니다.
            var userNetWorth = 0;
            if (typeof util_calculateNetWorth === 'function') {
                userNetWorth = util_calculateNetWorth(u, roomData);
            } else {
                // 예외 처리: 함수가 없을 경우 기본 포인트 기반 (안전장치)
                userNetWorth = Number(u.point || 0) + Number(u.bank || 0);
            }

            totalAssets += userNetWorth;
            userCount++;
        }
    }

    return {
        total: totalAssets,
        count: userCount,
        average: userCount > 0 ? Math.floor(totalAssets / userCount) : 0
    };
}

//==========섹터9==========

/**
 * [시스템] 아이템 가격 계산 함수
 * 기능: 국가 경제 지표(Ecobase) 배율을 적용하여 실시간 상점가를 산출합니다.
 */
function getItemPrice(item, user, roomName) {
    var data = getDatabase();
    var multiplier = 1.0;
    var roomData = data.rooms[roomName];

    if (roomData && roomData.economyBase && roomData.economyBase > 0) {
        // [연동] 섹터 8의 통합 경제 지표를 호출 (이미 채권/부채가 반영된 수치)
        var currentEco = calculateEconomy(data, roomName);
        var rawRatio = currentEco.total / roomData.economyBase;
        
        var damping = (data.economyDamping !== undefined) ? data.economyDamping : 0.5;
        multiplier = 1 + (rawRatio - 1) * damping;
        
        if (multiplier < 0.5) multiplier = 0.5; 
    }

    var basePrice = Math.floor(Number(item.price) * multiplier);

    // 승급권(id:8)은 구매 횟수에 따른 할증 로직 유지
    if (item.id === 8) { 
        var boughtCount = Number(user.purchasedPromotionAttempts || 0);
        return basePrice + (boughtCount * 50);
    }
    return basePrice;
}

/**
 * [Gemini 요청 사항] 경제 부양 지원금 체크 함수 (실질 순자산 기준 일원화)
 * 기능: 섹터 7의 통합 엔진을 사용하여 '부자 연체자'를 걸러내고 공정한 복지를 실현합니다.
 * 반영: 유저의 채권(빌려준 돈)이 많으면 지원 대상에서 제외됩니다.
 */
function checkEconomicStimulus(user, roomName, isManual) {
    if ((user.totalAttendance || 0) < 2) return;
    
    var currentCount = user.dailyStimulusCount || 0;
    if (currentCount >= 1) return;

    var data = getDatabase();
    if (!data) return;
    
    var eco = calculateEconomy(data, roomName);
    var avgAsset = eco.average;
    var roomData = data.rooms[roomName];

    /* [수정] 수동 자산/부채 계산 로직을 섹터 7 통합 엔진 호출로 대체 */
    // 이 한 줄로 (지갑 + 통장 + 주식 + 빌려준돈) - (은행빚 + 사채빚)이 모두 계산됩니다.
    var myNetWorth = 0;
    if (typeof util_calculateNetWorth === 'function') {
        myNetWorth = util_calculateNetWorth(user, roomData);
    } else {
        myNetWorth = Number(user.point || 0) + Number(user.bank || 0);
    }

    // 지급 기준선: 평균 순자산의 40% 미만일 때
    var targetLine = Math.floor(avgAsset * 0.4);
    
    if (myNetWorth < targetLine) {
        var multiplier = 1.0;
        if (roomData.economyBase && roomData.economyBase > 0) {
            var rawRatio = eco.total / roomData.economyBase;
            var damping = (data.economyDamping !== undefined) ? data.economyDamping : 0.5;
            multiplier = 1 + (rawRatio - 1) * damping;
            if (multiplier < 0.5) multiplier = 0.5;
        }

        var gap = targetLine - myNetWorth;
        var baseGive = Math.floor(2000 * multiplier);
        var giveAmount = Math.min(baseGive, gap); 
        
        if (giveAmount < 100) return;

        /* [연동] 중앙은행 금고 차감 및 포인트 지급 */
        util_updatePoint(user, roomData, giveAmount, "민생지원금 지급", roomName);
        
        user.dailyStimulusCount = currentCount + 1;

        var msg = "\n경제 활성화를 위한 민생지원금이 지급되었습니다.\n" +
                  "💰 지원금 지급: +" + fp(giveAmount) + "P";

        Api.replyRoom(roomName, formatCommand("🎁 민생지원금 안내", user, msg, "내 잔액: " + fP(user.point) + "P"));
        safeSaveData(data);
    }
}

//==========섹터10==========

/* 신용 정보 계산 함수 (상수 연동) */
function getCreditInfo(score) {
    var s = Number(score || 600);
    var conf = SYSTEM_CONFIG.ECO.CREDIT;
    
    for(var i=0; i<conf.SCORES.length; i++) {
        if(s >= conf.SCORES[i]) {
            return { grade: i+1, limit: conf.LIMITS[i], label: conf.LABELS[i], rate: conf.RATES[i], icon: conf.ICONS[i] };
        }
    }
    // 마지막 등급 (신용불량)
    var lastIdx = conf.SCORES.length;
    return { grade: lastIdx+1, limit: conf.LIMITS[lastIdx], label: conf.LABELS[lastIdx], rate: conf.RATES[lastIdx], icon: conf.ICONS[lastIdx] };
}

/* 신용 한도 표 생성 함수 (수정: 신용불량자 대출 금액 동적 표시) */
function getCreditLimitTable() {
    var conf = SYSTEM_CONFIG.ECO.CREDIT;
    var list = [];
    for(var i=0; i<conf.SCORES.length; i++) {
        var ratePct = Math.round((conf.RATES[i] - 1) * 100);
        list.push(conf.ICONS[i] + " " + conf.LABELS[i] + " (" + conf.SCORES[i] + "점~): " + fp(conf.LIMITS[conf[i]]) + "P (이율 " + ratePct + "%)");
    }
    var lastIdx = conf.SCORES.length;
    var lastRate = Math.round((conf.RATES[lastIdx] - 1) * 100);
    list.push(conf.ICONS[lastIdx] + " " + conf.LABELS[lastIdx] + " (<" + conf.SCORES[lastIdx-1] + "): " + fp(conf.LIMITS[lastIdx]) + "P (이율 " + lastRate + "%)");
    
    return list.join("\n");
}

/* 닉네임 표시 생성 함수 (수정: 신용불량자 칭호 우선순위 및 중복 방지) */
function getDisplayName(user) {
    if (!user) return "알 수 없음";
    var userIcon = user.icon || "";
    var tierIcon = (user.tier === 9 ? "🏆" : ""); 
    var credit = getCreditInfo(user.creditScore || 600);
    
    var titleStr = "";
    
    // [Gemini 요청 사항 반영]
    // 1순위: 신용불량자일 경우 무조건 [신용불량자] 표시
    if (credit.label === "신용불량자") {
        titleStr = "[신용불량자] ";
    } 
    // 2순위: 일반 상태일 때만 장착 중인 칭호 표시
    else if (user.title && user.title.length > 0) {
        titleStr = "[" + user.title + "] ";
    }
    
    return titleStr + tierIcon + userIcon + (user.name || "알 수 없음");
}

/* [수정] 관리자 여부 확인 함수 (FIXED_ADMINS 체크 추가) */
function isAdmin(sender, data, uid) {
    if (FIXED_ADMINS.indexOf(String(sender).trim()) !== -1) return true;
    if (adminUIDs.indexOf(uid) !== -1) return true;
    var name = String(sender).trim();
    if (data && data.admins && data.admins.indexOf(name) !== -1) return true;

    return false;
}

//==========섹터11==========

/* 유저 상태 체크 함수 */
function isUserBusy(uid) {
    if (activeThefts[uid]) return true;
    for (var vKey in activeThefts) {
        if (activeThefts[vKey].thiefUid === uid) return true;
    }
    if (duelData[uid]) return true;
    for (var dKey in duelData) {
        if (duelData[dKey].challengerUid === uid) return true;
    }
    /* [추가] 광산 채굴 중인 유저도 '활동 중'으로 처리하여 중복 활동 방지 */
    if (miningState[uid]) return true;
    
    return false;
}

/* 유저 이름 검색 함수 */
function findUserByName(roomData, name) {
    var res = [];
    var searchName = name.trim();
    if (searchName === "") return res; 
    for (var id in roomData.users) {
        var u = roomData.users[id];
        if (u.name === searchName) {
            return [{ id: id, data: u }];
        }
        if (u.name.indexOf(searchName) !== -1) {
            res.push({ id: id, data: u });
        }
    }
    return res;
}

/* 중복 유저 선택 핸들러 함수 */
function handleUserSelection(replier, targetUid, found, type, extra, user) {
    selectWaitState[targetUid] = { 
        timestamp: Date.now(), 
        results: found, 
        type: type, 
        extra: extra 
    };
    var list = [];
    for(var i=0; i<found.length; i++) {
        list.push((i + 1) + ". " + found[i].data.name);
    }
    
    setTimeout(function() {
        if (selectWaitState[targetUid]) {
            delete selectWaitState[targetUid];
            replier.reply(formatError(user, "선택 시간이 초과되었습니다."));
        }
    }, 30000);

    replier.reply(formatCommand("🔍 중복 닉네임 선택", user, "여러 유저가 검색되었습니다.\n번호를 선택해주세요.\n\n" + list.join("\n") + "\n\n(취소: [취소])", "입력 대기: 30초"));
}

/* 날짜 및 시즌 유틸 함수 */
function getSimpleDate() { var d = new Date(); return d.getFullYear() + "-" + ("0" + (d.getMonth() + 1)).slice(-2) + "-" + ("0" + d.getDate()).slice(-2); }
function getSimpleSeason() { var d = new Date(); return d.getFullYear().toString().slice(-2) + "-" + (d.getMonth() + 1) + "시즌"; }
function generateUUID() { return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) { var r = Math.random() * 16 | 0, v = c == 'x' ? r : (r & 0x3 | 0x8); return v.toString(16); }); }

/**
 * [신규] 성취 기반 칭호 자동 부여 및 알림 통합 함수 (v5.5)
 * @param {Object} user - 유저 객체
 * @param {Object} replier - 응답 객체
 * @param {String} titleName - 부여할 칭호 이름
 * @param {Number} titleId - 칭호 고유 ID (인벤토리 관리용)
 * @param {String} icon - 칭호 아이콘
 * @param {String} condDesc - 달성 조건 문구 (예: "도박 횟수 100회")
 * @param {String} guideText - 하단 가이드 멘트
 */
function util_checkAndAwardTitle(user, replier, titleName, titleId, icon, condDesc, guideText) {
    if (!user.inventory) user.inventory = [];
    
    // 1. 중복 획득 방지 (이미 가방에 동일한 칭호가 있으면 종료)
    var hasTitle = false;
    for (var i = 0; i < user.inventory.length; i++) {
        if (user.inventory[i].title === titleName) {
            hasTitle = true;
            break;
        }
    }
    if (hasTitle) return false;

    // 2. 가방(인벤토리)에 칭호 아이템 추가
    user.inventory.push({ 
        id: titleId, 
        name: "[" + titleName + "] 칭호", 
        icon: icon, 
        effect: "title", 
        title: titleName 
    });

    // 3. 칭호 즉시 자동 장착
    user.title = titleName;

    // 4. 요청된 포맷의 칭호 획득 알림 발송 (강조 기호 제거 완료)
    var msg = "[🎖️ 신규 칭호 획득]\n" +
              "━━━━━━━━━━━━━━━\n" +
              (user.name || "유저") + "님\n\n" +
              condDesc + "를 달성하여 [" + titleName + "] 칭호를 획득했습니다!\n\n" +
              "✨ 상태: [" + titleName + "] 칭호 자동 장착 완료\n" +
              "💼 보관: 가방에 영구 저장되었습니다.\n" +
              "━━━━━━━━━━━━━━━\n" +
              "💡 " + guideText;

    replier.reply(msg);
    return true;
}

//==========섹터12==========

/* 경찰 출동 결과 처리 함수 */
function processPoliceResult(roomName, thiefUid, victimUid) {
    var theftData = activeThefts[victimUid];
    if (!theftData) return;
    
    var data = getDatabase();
    if (!data) return;
    var room = data.rooms[roomName];
    if (!room) return;
    var thief = room.users[thiefUid];
    
    if (activeThefts[victimUid].successTimer) clearTimeout(activeThefts[victimUid].successTimer);
    delete activeThefts[victimUid]; 
    
    /* [수정] 벌금 물가 배율 (완충 설정 적용) */
    var multiplier = 1.0;
    if (room.economyBase && room.economyBase > 0) {
        var eco = calculateEconomy(data, roomName);
        var rawRatio = eco.total / room.economyBase;
        var damping = (data.economyDamping !== undefined) ? data.economyDamping : 0.5;
        multiplier = 1 + (rawRatio - 1) * damping;
        if (multiplier < 0.5) multiplier = 0.5;
    }

    var basePenalty = Math.floor(Math.random() * 81) + 20; 
    var penalty = Math.floor(basePenalty * multiplier);
    var actualPenalty = Math.min(penalty, Number(thief.point));
    
    // [검증] 경찰 벌금
    var prePoint = Number(thief.point);
    thief.point = Number(thief.point) - actualPenalty;
    verifyPointTransaction(thief, prePoint, -actualPenalty, "경찰 체포 벌금", roomName, actualPenalty);
    
    var jailTime = 1 * 60 * 60 * 1000;
    thief.jailReleaseTime = Date.now() + jailTime;
    
    /* [수정] 물가/완충 멘트 삭제 완료 */
    var msg = "🚨 [경찰 출동]\n대상: " + getDisplayName(thief) + "\n내용: 도둑질 현행범 체포\n패널티: -" + fp(actualPenalty) + "P / 감옥 1시간\n내 잔액: " + fp(thief.point) + "P";
    Api.replyRoom(roomName, formatAdmin("🚓 체포 완료", msg));
    safeSaveData(data);
}

/* 도둑질 성공 결과 처리 함수 (검증 및 칭호 부여 적용) */
function processTheftResult(roomName, thiefUid, victimUid) {
    var data = getDatabase();
    if (!data) return;
    var room = data.rooms[roomName];
    if (!room) return;
    
    if (!room.users[thiefUid] || !room.users[victimUid]) { delete activeThefts[victimUid]; return; }
    
    if (activeThefts[victimUid] && activeThefts[victimUid].policeTimer) clearTimeout(activeThefts[victimUid].policeTimer);

    var thief = room.users[thiefUid];
    var victim = room.users[victimUid];
    
    var maxSteal = Math.floor(Number(victim.point) * 0.1);
    if (maxSteal < 1) maxSteal = 1;
    var stealAmount = Math.floor(Math.random() * maxSteal) + 1;
    if (Number(victim.point) < stealAmount) stealAmount = Number(victim.point); 
    
    // [검증] 피해자 차감
    var vPre = Number(victim.point);
    victim.point = Number(victim.point) - stealAmount;
    verifyPointTransaction(victim, vPre, -stealAmount, "도둑질 당함", roomName, 0);

    var res = processRepayment(thief, stealAmount, thiefUid, roomName); 
    
    // [검증] 도둑 획득
    var tPre = Number(thief.point);
    thief.point = Number(thief.point) + Number(res.actualGain);
    verifyPointTransaction(thief, tPre, Number(res.actualGain), "도둑질 성공", roomName, 0);
    
    /* [신규] 도둑질 누적 통계 및 칭호 체크 */
    if (thief.totalTheftSuccess === undefined) thief.totalTheftSuccess = 0;
    thief.totalTheftSuccess++;

    // 칭호 부여 로직 (섹터 11의 util_checkAndAwardTitle 사용)
    var replierStub = { reply: function(m) { Api.replyRoom(roomName, m); } };
    if (thief.totalTheftSuccess >= 50) {
        util_checkAndAwardTitle(thief, replierStub, "괴도", 1203, "👤", "도둑질 성공 50회", "흔적도 없이 사라지는 전설의 도둑이 되었습니다.");
    } else if (thief.totalTheftSuccess >= 30) {
        util_checkAndAwardTitle(thief, replierStub, "대도", 1202, "👺", "도둑질 성공 30회", "50회 성공 시 전설의 [괴도]가 됩니다.");
    } else if (thief.totalTheftSuccess >= 10) {
        util_checkAndAwardTitle(thief, replierStub, "좀도둑", 1201, "🧤", "도둑질 성공 10회", "30회 성공 시 [대도]에 도전하세요!");
    }
    
    delete activeThefts[victimUid]; 
    
    var content = "🕵️ 도둑질 성공!\n" + getDisplayName(victim) + "님의 지갑에서\n" + fp(stealAmount) + "P를 훔쳤습니다!" + res.repayMsg;
    // [수정] 도둑질 결과에 보유 포인트 표시 추가
    Api.replyRoom(roomName, formatCommand("💰 도둑질 결과", thief, content, "내 잔액: " + fp(thief.point) + "P"));
    safeSaveData(data);
}

//==========섹터13==========

/**
 * [경제 시스템 모듈] 통합 자동 상환 및 신용 관리 (수정된 차등 비율 버전)
 * 수정 내용: 
 * 1. 일반 은행 빚 상환: 30%
 * 2. 신용불량자/사채 강제추심: 50%
 * 3. 은행 대환 채무(대납건): 70%
 */

/* [기능 1] 신용불량자 상태 제어 */
function checkAndHandleDefaulter(user, roomName) {
    var currentScore = Number(user.creditScore || 600);
    if (currentScore < 500) {
        if (!user.isDefaulter) {
            user.isDefaulter = true;
            user.icon = ""; 
            var msg = "신용 점수 500점 미만 하락\n\n1. 보유 아이콘 몰수\n2. 획득 포인트 50% 자동 상환 적용";
            try { Api.replyRoom(roomName, formatCommand("📉 신용불량자 지정", user, msg, "대출 상환을 권장합니다.")); } catch(e){}
        }
    } else {
        if (user.isDefaulter) { user.isDefaulter = false; }
    }
}

/* [기능 2] 은행 대출금 분산 상환 엔진 */
function distributeRepayment(user, amount) {
    if (!user.loan || Number(user.loan.debt) < 1) {
        if (user.loan) { user.loan.debt = 0; user.loan.items = []; user.isTransferred = false; }
        return { actualRepay: 0, creditGain: 0, clearedCount: 0 };
    }
    
    var remainingRepay = Math.floor(Number(amount));
    var initialAmount = remainingRepay;
    var clearedCount = 0;
    
    if (!user.loan.items) user.loan.items = [];
    user.loan.items.sort(function(a, b) { return a - b; });
    
    var newItems = [];
    for (var i = 0; i < user.loan.items.length; i++) {
        var loanItem = Number(user.loan.items[i]);
        if (loanItem > 0 && remainingRepay >= loanItem) {
            remainingRepay -= loanItem;
            clearedCount++;
        } else {
            loanItem -= remainingRepay;
            remainingRepay = 0;
            if (loanItem > 0) newItems.push(loanItem);
        }
    }
    
    var actualRepayed = initialAmount - remainingRepay;
    user.loan.items = newItems;
    user.loan.debt = 0;
    for(var i=0; i<newItems.length; i++) user.loan.debt += Number(newItems[i]);

    user.creditScore = Math.min(1000, Number(user.creditScore || 600) + (clearedCount * 15));
    if (user.loan.debt <= 0) { user.loan.debt = 0; user.loan.items = []; user.isTransferred = false; }
    
    return { actualRepay: actualRepayed, creditGain: clearedCount * 15, clearedCount: clearedCount };
}

/* [기능 3] 사채(P2P) 자동 추심 처리 (수정: 추심 비율 50% 적용) */
function processPrivateCollection(user, userUid, amount, roomName) {
    var data = getDatabase();
    if (!roomName || !data.rooms[roomName]) return { collected: 0, msg: "" };

    var roomData = data.rooms[roomName];
    
    // [설정 수정] 직접 추심 한도를 수익의 50%로 변경
    var totalLimit = Math.floor(Number(amount) * 0.5); 
    var remainingAmount = totalLimit; 
    
    var totalCollected = 0;
    var collectionLog = "";

    if (roomData.loanContracts) {
        for (var cid in roomData.loanContracts) {
            var c = roomData.loanContracts[cid];
            if (c.borrowerUid === userUid && c.status === 'overdue' && remainingAmount > 0) {
                var collectTarget = Math.min(remainingAmount, c.currentDebt);
                
                var lender = roomData.users[c.lenderUid];
                if (lender) {
                    var preL = Number(lender.point);
                    lender.point += collectTarget;
                    verifyPointTransaction(lender, preL, collectTarget, "사채 추심 수익 (" + c.borrowerName + ")");
                }

                c.currentDebt -= collectTarget;
                totalCollected += collectTarget;
                remainingAmount -= collectTarget;
                collectionLog += "\n- " + c.lenderName + "님께 " + fp(collectTarget) + "P 송금";

                if (c.currentDebt <= 0) {
                    delete roomData.loanContracts[cid];
                    collectionLog += " (완납 종료)";
                }
            }
        }
    }

    if (totalCollected > 0) {
        var msg = "\n\n🚨 [사채 강제 추심 안내]\n사채 연체로 인해 수익의 50%가 채권자에게 자동 귀속되었습니다." + collectionLog;
        return { collected: totalCollected, msg: msg };
    }
    return { collected: 0, msg: "" };
}

/* [기능 4] 통합 자동 상환 프로세스 (수정: 비율 체계 전면 개편) */
function processRepayment(user, amount, userUid, roomName) {
    var amt = Number(amount) || 0;
    var currentGain = amt;
    var totalRepayMsg = "";
    var data = getDatabase();

    if (!user.loan || Number(user.loan.debt || 0) <= 0) {
        user.isTransferred = false;
    }

    // 1. 사채 직접 추심 (50% 비율 작동)
    var privateRes = processPrivateCollection(user, userUid, currentGain, roomName);
    if (privateRes.collected > 0) {
        currentGain -= privateRes.collected;
        totalRepayMsg += privateRes.msg;
    }

    // 2. 은행 대출 자동 상환
    if (currentGain > 0 && user.loan && Number(user.loan.debt) > 0) {
        // [기본값] 일반 유저 상환 비율 30%
        var repaymentRate = 0.3; 
        var typeLabel = "일반 상환";

        // [조건 1] 대환 채무(은행이 사채를 대신 갚아준 경우)는 70% 압류
        if (user.isTransferred === true || user.isTransferred === "true") {
            repaymentRate = 0.7; 
            typeLabel = "🚨 대환 채무 강제 추심";
        } 
        // [조건 2] 신용불량자(500점 미만)는 50% 압류
        else if (Number(user.creditScore || 600) < 500) {
            repaymentRate = 0.5; 
            typeLabel = "신용불량 제한 상환";
        }

        var intendedRepay = Math.floor(currentGain * repaymentRate);
        if (intendedRepay > Number(user.loan.debt)) intendedRepay = Number(user.loan.debt);
        
        var res = distributeRepayment(user, intendedRepay);
        currentGain -= res.actualRepay;
        
        if (roomName && data.rooms[roomName]) {
            var rData = data.rooms[roomName];
            if (rData.bankReserve === undefined || rData.bankReserve === null) rData.bankReserve = 10000;
            rData.bankReserve += res.actualRepay;
        }

        totalRepayMsg += "\n\n🏦 [은행 " + typeLabel + "]\n💰 " + fp(res.actualRepay) + "P 상환됨 (" + Math.floor(repaymentRate * 100) + "%)\n(남은 대출: " + fp(user.loan.debt) + "P)";
        if (res.creditGain > 0) totalRepayMsg += "\n📈 신용 점수 +" + res.creditGain + " 상승";
    }
    
    return { actualGain: currentGain, repayMsg: totalRepayMsg };
}

//==========섹터14==========

/* 주식 이름 생성 함수 */
function generateStockName(data) {
    var conf = SYSTEM_CONFIG.ECO.STOCK; // [수정] 경로 참조 보정
    var name = "";
    for (var i = 0; i < 10; i++) {
        var pre = conf.PREFIXES[Math.floor(Math.random() * conf.PREFIXES.length)];
        var suf = conf.SUFFIXES[Math.floor(Math.random() * conf.SUFFIXES.length)];
        name = pre + suf;
        if (!data.stockMarket[name]) break;
    }
    return name;
}

/* 주식 타입 할당 함수 */
function assignStockType() {
    var conf = SYSTEM_CONFIG.ECO.STOCK; // [수정] 경로 참조 보정
    var rand = Math.random() * 100;
    var cumulative = 0;
    for (var type in conf.TRAITS) {
        cumulative += conf.TRAITS[type].prob;
        if (rand < cumulative) return type;
    }
    return "normal";
}

/* 주식 리스트 생성 함수 (아이콘 우측 배치 및 하단 경고 추가) */
function generateStockList(data) {
    var list = [];
    var dangerStocks = [];
    var keys = Object.keys(data.stockMarket || {});
    if (keys.length === 0) return null;

    // [수정] SYSTEM_CONFIG 참조로 경로 보정 (전역 변수 STOCK_TRAITS 제거 대응)
    var stockTraits = SYSTEM_CONFIG.ECO.STOCK.TRAITS;

    for (var i = 0; i < keys.length; i++) {
        var name = keys[i];
        var stock = data.stockMarket[name];
        var trait = stockTraits[stock.type] || stockTraits.normal;
        
        var diff = Number(stock.price) - Number(stock.lastPrice);
        var rate = stock.lastPrice > 0 ? ((diff / stock.lastPrice) * 100).toFixed(1) : "0.0";
        var sign = diff > 0 ? "🔺" : (diff < 0 ? "🔹" : "➖");
        
        // [수정] 정리매매 아이콘 로직 (우측 표시용)
        var warningMark = "";
        if (stock.delistTick && stock.delistTick > 0) {
            warningMark = " ⚠️";
            dangerStocks.push(name);
        }
        
        // [수정] 주가 포인트 수치에 .toLocaleString() 적용 및 아이콘 배치 유지
        list.push(trait.icon + " " + name + ": " + fp(stock.price) + "P (" + sign + " " + Math.abs(rate) + "%)" + warningMark);
    }

    var result = list.join("\n");

    // [수정] 하단 경고 섹션 생성
    if (dangerStocks.length > 0) {
        result += "\n\n⚠️ 주가 폭락으로 정리매매 단계 진입!\n해당 종목 : " + dangerStocks.join(", ");
    }
    
    return result;
}

//==========섹터15==========

/* 주식 이름 생성 함수 (상수 참조 경로 수정) */
function generateStockName(data) {
    var conf = SYSTEM_CONFIG.ECO.STOCK;
    var name = "";
    for (var i = 0; i < 20; i++) {
        var pre = conf.PREFIXES[Math.floor(Math.random() * conf.PREFIXES.length)];
        var suf = conf.SUFFIXES[Math.floor(Math.random() * conf.SUFFIXES.length)];
        name = pre + suf;
        if (!data.stockMarket || !data.stockMarket[name]) break;
    }
    return name;
}

/* 주식 타입 할당 함수 */
function assignStockType() {
    var conf = SYSTEM_CONFIG.ECO.STOCK;
    var rand = Math.random() * 100;
    var cumulative = 0;
    for (var type in conf.TRAITS) {
        cumulative += conf.TRAITS[type].prob;
        if (rand < cumulative) return type;
    }
    return "normal";
}

/* 주식 시세 변동 로직 함수 (정밀도 보정 및 조작 연동) */
function updateStockPrices(data) {
    var conf = SYSTEM_CONFIG.ECO.STOCK;
    if (!data.stockMarket) data.stockMarket = {};
    if (!data.stockTraffic) data.stockTraffic = {}; 

    var now = new Date();
    var currentHour = now.getHours();
    var currentMin = now.getMinutes();
    var isMarketOpen = (currentHour >= conf.SETTINGS.OPEN_HOUR && currentHour <= conf.SETTINGS.CLOSE_HOUR);
    
    var totalSum = 0;
    var count = 0;
    for (var k in data.stockMarket) { totalSum += Number(data.stockMarket[k].price); count++; }
    var marketAvg = count > 0 ? (totalSum / count) : 1000;
    var eco = calculateEconomy(data);
    var activeUserCount = Math.max(1, eco.count); 

    var mainRoom = data.rooms["내리다"];
    var ecoBase = (mainRoom && mainRoom.economyBase) ? mainRoom.economyBase : 100000;
    var ecoBaseFloor = Math.floor((ecoBase / activeUserCount) * conf.SETTINGS.DELIST_LIMIT); 
    if (ecoBaseFloor < 50) ecoBaseFloor = 50; 

    var eventNews = [];

    /* [1] 신규 상장 처리 (참조 에러 수정 완료) */
    if (data.pendingNewStock && isMarketOpen) {
        if (Object.keys(data.stockMarket).length < conf.SETTINGS.MAX_COUNT) {
            var newName = generateStockName(data);
            var newType = assignStockType();
            var startPrice = Math.floor(marketAvg * ((Math.random() * 0.3) + 0.8));
            var randomLimit = Math.floor(Math.random() * 4) + 2; 
            
            data.stockMarket[newName] = { 
                price: Number(startPrice), lastPrice: Number(startPrice), 
                type: newType, delistTick: 0, delistLimit: randomLimit,
                trend: "none", trendTick: 0, lastTrafficImpact: 0 
            };
            eventNews.push("📢 신규 상장: " + conf.TRAITS[newType].icon + " " + newName + " (" + fp(startPrice) + "P)");
        }
        data.pendingNewStock = false;
    }

    /* [2] 조작 프리셋 설정 로드 */
    var mani = conf.MANIPULATION;
    var specStock = (mani && mani.ACTIVE) ? mani.TARGET : null;
    var specFactor = (mani && mani.ACTIVE) ? (mani.IS_UP ? Math.abs(mani.RATE) : -Math.abs(mani.RATE)) : 0;

    // 예약된 특수 효과가 있다면 조작 설정보다 우선하거나 대체함
    if (!specStock && data.pendingSpecialEffect && isMarketOpen) {
        specStock = data.pendingSpecialEffect.stock;
        specFactor = data.pendingSpecialEffect.factor;
    }

    /* [3] 시세 변동 계산 루프 */
    for (var name in data.stockMarket) {
        var stock = data.stockMarket[name];
        var trait = conf.TRAITS[stock.type] || conf.TRAITS.normal;
        var changePercent = 0;
        
        stock.lastPrice = Number(stock.price);

        // 상장폐지 체크
        if (stock.price < marketAvg * 0.25 || stock.price < ecoBaseFloor) { stock.delistTick++; } else { stock.delistTick = 0; }

        if (isMarketOpen) {
            if (name === specStock) { 
                changePercent = specFactor;
                eventNews.push("🚨 [변동성 알림]\n종목: " + name + "\n내용: " + (specFactor > 0 ? "🚀 폭등" : "📉 폭락") + " (" + (Math.abs(specFactor * 100)).toFixed(0) + "%)");
            } else {
                // 추세 기반 변동
                if (stock.trendTick <= 0) {
                    stock.trendTick = Math.floor(Math.random() * 4) + 2;
                    var p = Math.random(); stock.trend = (p < 0.35) ? "up" : (p < 0.70 ? "down" : "volatile");
                }
                var baseRate = (stock.trend === "up" ? 0.025 : (stock.trend === "down" ? -0.025 : (Math.random()*0.08-0.04)));
                changePercent = baseRate * trait.volatility;
                if (stock.trendTick > 0) stock.trendTick--;
            }
            
            // 거래량 반영
            var traffic = data.stockTraffic[name] || { buy: 0, sell: 0 };
            var trafficImpact = Math.max(-0.15, Math.min(0.15, ((traffic.buy - traffic.sell) / (activeUserCount * 5)) * 0.01));
            changePercent += trafficImpact;

            /* [신규 통합] 동적 저항(Dynamic Resistance) 시스템 */
            // 시가가 설정되어 있고 현재가가 저항 시작점(+15%)을 넘었을 때 작동
            if (marketOpenPrice > 0) {
                var growthRate = (stock.price - marketOpenPrice) / marketOpenPrice;
                var sConf = conf.SETTINGS;

                if (growthRate > sConf.RESISTANCE_START) {
                    // 장 시간에 따른 가중치 계산
                    var elapsed = (currentHour - sConf.OPEN_HOUR) * 60 + currentMin;
                    var totalTime = (sConf.CLOSE_HOUR - sConf.OPEN_HOUR) * 60;
                    var timeWeight = Math.min(Math.max(elapsed / totalTime, 0), 1.0);

                    // 저항 압력(Gravity) 적용: 멀어질수록, 시간이 지날수록 강해짐
                    var resistance = (growthRate - sConf.RESISTANCE_START) * sConf.GRAVITY * (1 + timeWeight);
                    changePercent -= resistance;

                    // +19% 초과 시 상승 시도 확률적 차단 (심리적 상한선 연출)
                    if (growthRate >= (sConf.CLOSING_LIMIT - 0.01) && changePercent > 0) {
                        if (Math.random() < 0.85) {
                            changePercent = -Math.abs(changePercent) * 0.4; // 85% 확률로 상승분 반납 및 미세 하락
                        }
                    }
                }
            }
        }
        
        /* [핵심 수정] Math.floor 대신 Math.round를 사용하여 미세 변동이 절사되는 문제 해결 */
        var nextPrice = stock.price * (1 + changePercent);
        stock.price = Math.max(10, Math.round(nextPrice)); 
    }

    // 상장폐지 집행
    var delisted = [];
    for (var name in data.stockMarket) {
        if (data.stockMarket[name].delistTick >= data.stockMarket[name].delistLimit) delisted.push(name);
    }
    
    for (var i=0; i<delisted.length; i++) { 
        var delName = delisted[i];
        for (var r in data.rooms) {
            var users = data.rooms[r].users;
            for (var uid in users) {
                if (users[uid].stockHoldings) {
                    delete users[uid].stockHoldings[delName];
                    if (users[uid].stockAvg) delete users[uid].stockAvg[delName];
                }
            }
        }
        delete data.stockMarket[delName]; 
        eventNews.push("🚨 [상장폐지] " + delName + "\n사유: 주가 요건 미달 (하한선: " + fp(ecoBaseFloor) + "P)"); 
    }

    data.stockTraffic = {}; 
    data.pendingSpecialEffect = null; 
    
    return eventNews;
}

/* 주식 시장 수동 제어 엔진 (참조 보정) */
function market_forceNewListing() {
    var data = getDatabase();
    data.pendingNewStock = true;
    return "✅ 다음 변동 타임에 신규 상장이 확정되었습니다.";
}

function market_setSpecialEffect(stockName, isUp, factor) {
    var data = getDatabase();
    var conf = SYSTEM_CONFIG.ECO.STOCK.SETTINGS;
    if (!data.stockMarket[stockName]) return "❌ 존재하지 않는 종목입니다.";
    var useFactor = (factor !== undefined) ? factor : conf.MANI_RATE;
    var finalFactor = isUp ? Math.abs(useFactor) : -Math.abs(useFactor);
    data.pendingSpecialEffect = { stock: stockName, factor: finalFactor };
    return "✅ [" + stockName + "] " + (Math.abs(useFactor*100)).toFixed(0) + "% " + (isUp ? "폭등" : "폭락") + " 예약 완료.";
}

function market_updateNow(roomName) {
    var data = getDatabase();
    var result = updateStockPrices(data);
    var body = "📉 주식 시세 변동\n━━━━━━━━━━━━━━━\n🟢 장 운영 중\n\n" + (generateStockList(data) || "시세 정보 없음");
    if (result.length > 0) body += "\n\n" + result.join("\n");
    // [수정] 실시간 차트 링크 제거
    body += "\n━━━━━━━━━━━━━━━"; 
    Api.replyRoom(roomName || "내리다", body);
    safeSaveData(data);
    return "✅ 시장 갱신 완료.";
}

//==========섹터16-1==========

/* 통합 스케줄러 실행 함수 (독립 모듈형 엔진 + 대시보드 연동) */
function runScheduler() {
    var SCHEDULER_KEY = "kakaobot_scheduler_v5";
    var oldTimer = java.lang.System.getProperty(SCHEDULER_KEY);
    if (oldTimer) try { clearInterval(parseInt(oldTimer)); } catch (e) {}
    
    var newTimer = setInterval(function() {
        try {
            var data = getDatabase(); 
            if (!data) return; 

            // 모든 섹터가 공유할 상태 객체 (Context)
            var ctx = {
                isUpdated: false,
                isForceBackup: false,
                now: new Date(),
                today: getSimpleDate(),
                season: getSimpleSeason(),
                targetRoom: "내리다",
                // 아래 URL에 본인의 구글 웹 앱 URL을 입력하세요.
                dashboardUrl: "https://script.google.com/macros/s/AKfycbyoURblg3-nLNgSE57Pb9RmjqK3wXyMSRpm9WrkWe3z2kyE_q_wmoabNECLNXWQ2SBZ/exec"
            };

            /* [모듈 실행] 섹터 16-2 비즈니스 로직 */
            if (typeof _runSector16Logic === 'function') {
                _runSector16Logic(data, ctx);
            }

            /* [모듈 실행] 섹터 17, 18 로직 안전 호출 */
            if (typeof _runSector17Logic === 'function') _runSector17Logic(data, ctx);
            if (typeof _runSector18Logic === 'function') _runSector18Logic(data, ctx);

            /* [신규] 10분 주기 구글 시트 대시보드 동기화 */
            var currentMin = ctx.now.getMinutes();
            if (currentMin % 10 === 0 && data.lastWebSyncMin !== currentMin && ctx.dashboardUrl.indexOf("http") === 0) {
                data.lastWebSyncMin = currentMin;
                _sendToDashboard(data, ctx);
            }

            /* [최종 저장] 하이브리드 비동기 저장 처리 */
            if (ctx.isUpdated) {
                Executor.execute(new java.lang.Runnable({
                    run: function() { safeSaveData(data, ctx.isForceBackup); }
                }));
            }

        } catch (e) { Log.error("Scheduler Error: " + e); }
    }, 1000);
    java.lang.System.setProperty(SCHEDULER_KEY, String(newTimer));
}

/* 대시보드 데이터 전송 함수 (비동기) */
function _sendToDashboard(data, ctx) {
    var totalPoints = 0;
    var userCount = 0;
    
    for (var r in data.rooms) {
        for (var u in data.rooms[r].users) {
            var userObj = data.rooms[r].users[u];
            totalPoints += (Number(userObj.point || 0) + Number(userObj.bank || 0));
            userCount++;
        }
    }

    var payload = {
        total_money: totalPoints,
        user_count: userCount,
        stocks: data.stockMarket || {}
    };

    Executor.execute(new java.lang.Runnable({
        run: function() {
            try {
                org.jsoup.Jsoup.connect(ctx.dashboardUrl)
                    .header("Content-Type", "application/json")
                    .requestBody(JSON.stringify(payload))
                    .ignoreContentType(true)
                    .ignoreHttpErrors(true)
                    .method(org.jsoup.Connection.Method.POST)
                    .execute();
            } catch (e) { Log.error("Dashboard Sync Error: " + e); }
        }
    }));
}

//==========섹터16-2==========

/* 독립 로직 함수: 사채 및 시스템 관리 + 경마 스케줄러 통합 엔진 */
function _runSector16Logic(data, ctx) {
    var nowTs = ctx.now.getTime();
    var currentHour = ctx.now.getHours();
    var currentMin = ctx.now.getMinutes();
    var currentSec = ctx.now.getSeconds();
    var conf = SYSTEM_CONFIG.ECO.STOCK;
    var rConf = SYSTEM_CONFIG.ECO.RACING; // 섹터1에서 설정한 경마 상수 참조

    var DASHBOARD_URL = "https://docs.google.com/spreadsheets/d/e/2PACX-1vQWUH4iH7iLI2ZAR1MC3OERD4I2LcJVX23waSW7MLhjgGwjr6hTXKSNiAD048B9K4dtr8OosHqbTsrb/pubchart?oid=121239500&format=interactive";

    /* [신규] 5분 주기 오토세이브 엔진 */
    if (currentMin % 5 === 0 && data.lastAutoSaveMin !== currentMin) {
        data.lastAutoSaveMin = currentMin;
        ctx.isUpdated = true;
        ctx.isForceBackup = true; 
    }

    /* [수정] 주식 장 오픈 시가 기록 및 DB 저장 */
    if (currentHour === conf.SETTINGS.OPEN_HOUR && currentMin === 0 && data.lastMarketOpenMin !== currentMin) {
        data.lastMarketOpenMin = currentMin;
        if (data.stockMarket) {
            var stocks = Object.keys(data.stockMarket);
            if (stocks.length > 0) {
                marketOpenPrice = data.stockMarket[stocks[0]].price; 
                data.marketOpenPrice = marketOpenPrice;
                ctx.isUpdated = true;
            }
        }
    }

    /* 1. 방별 유저 간 사채 시스템 및 경제 감시 엔진 (무결성 유지) */
    for (var rName in data.rooms) {
        var roomData = data.rooms[rName];
        if (!roomData.loanContracts) roomData.loanContracts = {};

        if (roomData.bankReserve !== undefined) {
            var reserve = roomData.bankReserve;
            if (!roomData.lastBankAlert) roomData.lastBankAlert = "normal";

            var roomBase = roomData.economyBase || 1000000;
            var warningLimit = Math.floor(roomBase * 0.1);
            var disasterLimit = Math.floor(roomBase * 0.01);
            var normalLimit = warningLimit * 2;

            if (reserve < disasterLimit && roomData.lastBankAlert !== "disaster") {
                roomData.lastBankAlert = "disaster";
                var disasterMsg = "🚨 [국가 경제 재난 선포] 🚨\n━━━━━━━━━━━━━━━\n현 시각부로 국가 경제 재난 상태를 선포합니다.\n중앙은행 금고 자산이 임계치(" + fp(disasterLimit) + "P) 아래로 급락하여 모든 보상 및 출금이 정지될 위험이 큽니다.\n\n🏦 현재 금고: " + fp(reserve) + "P\n⚠️ 조치: 관리자의 즉각적인 재원 수혈이 필요합니다.";
                Api.replyRoom(rName, disasterMsg);
                ctx.isUpdated = true;
            }
            else if (reserve < warningLimit && reserve >= disasterLimit && roomData.lastBankAlert === "normal") {
                roomData.lastBankAlert = "warning";
                var warningMsg = "⚠️ [국가 경제 마비 예비 경보]\n━━━━━━━━━━━━━━━\n중앙은행 금고 잔액이 " + fp(warningLimit) + "P 미만으로 하락했습니다.\n지속적인 보상 유지를 위해 경제 활동 활성화 또는 재원 보충이 권고됩니다.\n\n🏦 현재 금고: " + fp(reserve) + "P";
                Api.replyRoom(rName, warningMsg);
                ctx.isUpdated = true;
            }
            else if (reserve >= normalLimit && (roomData.lastBankAlert === "warning" || roomData.lastBankAlert === "disaster")) {
                roomData.lastBankAlert = "normal";
                var normalMsg = "✅ [국가 경제 정상화 알림]\n━━━━━━━━━━━━━━━\n재원 수혈 및 유동성 확보를 통해 금고가 다시 안정권(" + fp(normalLimit) + "P 이상)에 진입했습니다.\n중단되었던 각종 경제 로직이 정상화되었습니다.\n\n🏦 현재 금고: " + fp(reserve) + "P";
                Api.replyRoom(rName, normalMsg);
                ctx.isUpdated = true;
            }
        }

        for (var cid in roomData.loanContracts) {
            var c = roomData.loanContracts[cid];
            var periodsPassed = Math.floor((nowTs - c.startTime) / 10800000); 
            
            if (c.appliedPeriods === undefined) c.appliedPeriods = 0;
            if (periodsPassed > c.appliedPeriods) {
                var pendingPeriods = periodsPassed - c.appliedPeriods;
                var totalNewInterest = 0;
                for (var i = 0; i < pendingPeriods; i++) {
                    var interest = Math.floor(c.currentDebt * (c.rate / 100));
                    c.currentDebt += interest;
                    totalNewInterest += interest;
                }
                c.appliedPeriods = periodsPassed;
                ctx.isUpdated = true;
                try {
                    var interestMsg = "🚬 [사채 이자 갱신]\n━━━━━━━━━━━━━━━\n" +
                                      "👤 대상: " + c.borrowerName + "님\n" +
                                      "🤝 채권자: " + c.lenderName + "\n" +
                                      "🕒 경과: " + (periodsPassed * 3) + "시간\n" +
                                      "💰 추가 이자: +" + fp(totalNewInterest) + "P\n" +
                                      "📉 현재 채무: " + fp(c.currentDebt) + "P\n" +
                                      "━━━━━━━━━━━━━━━";
                    Api.replyRoom(rName, interestMsg);
                } catch(e) {}
            }

            var duration = nowTs - c.startTime;
            var overdueLimit = 24 * 60 * 60 * 1000;
            var bankTakeoverLimit = 36 * 60 * 60 * 1000;

            if (c.status === 'active' && duration > overdueLimit && duration <= bankTakeoverLimit) {
                c.status = 'overdue'; 
                ctx.isUpdated = true;
                try {
                    var collectionMsg = "🚨 [강제 추심 집행 알림]\n대상: " + c.borrowerName + "님\n사유: 상환 기한(24시간) 초과\n\n지금부터 수익의 50%가 채권자에게 자동 귀속됩니다.";
                    Api.replyRoom(rName, collectionMsg);
                } catch(e) {}
            }
            else if (duration > bankTakeoverLimit) {
                var amountToPay = Number(c.currentDebt);
                var lender = roomData.users[c.lenderUid];
                var borrower = roomData.users[c.borrowerUid];

                if (lender && borrower) {
                    if (roomData.bankReserve === undefined) roomData.bankReserve = 10000;
                    roomData.bankReserve -= amountToPay;
                    var preLenderPoint = Number(lender.point);
                    lender.point = preLenderPoint + amountToPay;
                    verifyPointTransaction(lender, preLenderPoint, amountToPay, "사채 은행 대납 회수 (" + c.borrowerName + ")");
                    if (!borrower.loan) borrower.loan = { debt: 0, items: [] };
                    borrower.loan.debt = Number(borrower.loan.debt) + amountToPay;
                    borrower.loan.items.push(amountToPay);
                    borrower.isTransferred = true; 
                    borrower.creditScore = Math.max(0, (borrower.creditScore || 600) - 50);
                    checkAndHandleDefaulter(borrower, rName);
                    var takeoverMsg = "🏛️ [중앙은행 대환 집행]\n━━━━━━━━━━━━━━━\n👤 대상: " + c.borrowerName + "님\n\n내용: 사채 연체 36시간 경과로 인해 은행이 " + fp(amountToPay) + "P를 대납 처리하였습니다.\n\n⚠️ [페널티]: 신용점수 -50점 강등\n⚠️ 해당 채무는 [은행 대환 대출]로 전환되었으며, 완납 시까지 모든 수익의 70%가 강제 상환됩니다.\n━━━━━━━━━━━━━━━";
                    Api.replyRoom(rName, takeoverMsg);
                    delete roomData.loanContracts[cid];
                    ctx.isUpdated = true;
                }
            }
        }
    }

    /* 2. 주식 주기적 변동 처리 (무결성 유지) */
    if (currentHour >= conf.SETTINGS.OPEN_HOUR && currentHour <= conf.SETTINGS.CLOSE_HOUR && currentMin % 10 === 0 && data.lastStockUpdateMin !== currentMin) {
        data.lastStockUpdateMin = currentMin; 
        var mani = conf.MANIPULATION;
        if (mani && mani.ACTIVE === true) {
            data.pendingSpecialEffect = { stock: mani.TARGET, factor: mani.IS_UP ? Math.abs(mani.RATE) : -Math.abs(mani.RATE), forceMani: true };
        } else {
            var currentStockCount = Object.keys(data.stockMarket || {}).length;
            if (currentStockCount < 10 && Math.random() < SYSTEM_CONFIG.PROB.STOCK_NEW_LISTING) { 
                data.pendingNewStock = true;
            } else if (Math.random() < SYSTEM_CONFIG.PROB.STOCK_SPECIAL) {
                var stocks = Object.keys(data.stockMarket || {});
                if (stocks.length > 0) {
                    var target = stocks[Math.floor(Math.random() * stocks.length)];
                    var isUp = Math.random() < SYSTEM_CONFIG.PROB.STOCK_UP_CHANCE;
                    var randFactor = (Math.random() * 0.10) + 0.15; 
                    data.pendingSpecialEffect = { stock: target, factor: isUp ? randFactor : -randFactor };
                }
            }
        }
        try { java.lang.Thread.sleep(1000); } catch(e){}
        if (currentHour === conf.SETTINGS.CLOSE_HOUR && currentMin === 50 && typeof stock_applyClosingCorrection === 'function') {
            for (var sName in data.stockMarket) { data.stockMarket[sName].price = stock_applyClosingCorrection(data.stockMarket[sName].price); }
        }
        var stockResult = updateStockPrices(data); 
        var isMarketOpen = (currentHour >= conf.SETTINGS.OPEN_HOUR && currentHour <= conf.SETTINGS.CLOSE_HOUR);
        var statusText = isMarketOpen ? "🟢 장 운영 중 (07:00 ~ 23:59)" : "🔴 장 마감";
        var body = "📉 주식 시세 변동\n━━━━━━━━━━━━━━━\n" + statusText + "\n\n" + (generateStockList(data) || "시세 정보 없음"); 
        if (stockResult.length > 0) body += "\n\n" + stockResult.join("\n");
        // [수정] 실시간 차트 링크 제거
        body += "\n━━━━━━━━━━━━━━━";
        try { Api.replyRoom(ctx.targetRoom, body); } catch(err) {}
        ctx.isUpdated = true;
    }

    /* [수정] 3. 경마 시스템 통합 스케줄러 (09시 예외 처리 반영) */
    
    // A. 개장 알림 (09:00:00) - 개장 시에는 결과 프로세스를 건너뛰기 위해 플래그 선제 조정
    if (currentHour === rConf.OPEN_HOUR && currentMin === 0 && currentSec === 0) {
        racingData.isOperating = true;
        racingData.isResultProcessed = true; // [수정] 09시 결과 출력을 막기 위해 즉시 처리 완료로 간주
        var startMsg = "🏇 [내리다 경마장 개장 알림]\n━━━━━━━━━━━━━━━\n지금부터 제 " + racingData.round + "회차 경마 배팅이 가능합니다!\n\n🕒 배팅 시간: 매시 00분 ~ 49분 59초\n🏁 결과 발표: 매시 00분 00초\n🚫 운영 종료: 23:59 (00:00 최종 결과)\n━━━━━━━━━━━━━━━\n💡 현황 확인: [/경마] 입력";
        Api.replyRoom(ctx.targetRoom, startMsg);
    }

    // B. 배팅 마감 알림 (매시 49:59)
    if (racingData.isOperating && currentMin === 49 && currentSec === 59 && !racingData.isDeadlineNotified) {
        racingData.isDeadlineNotified = true;
        var deadlineMsg = "📢 [경마 배팅 마감 알림]\n━━━━━━━━━━━━━━━\n제 " + racingData.round + "회차 배팅이 종료되었습니다!\n\n🏦 최종 집계 포인트: " + fp(racingData.totalPool) + "P\n🏁 우승마 판독 및 정산 진행 중...\n━━━━━━━━━━━━━━━\n🏇 잠시 후 정각(00분)에 결과가 발표됩니다!";
        Api.replyRoom(ctx.targetRoom, deadlineMsg);
    }

    // C. 결과 발표 및 새 라운드 시작 (매시 00:00:00)
    // [수정] currentHour !== rConf.OPEN_HOUR 조건을 추가하여 09시에는 결과가 발표되지 않도록 함
    if ((racingData.isOperating || currentHour === 0) && currentMin === 0 && currentSec === 0 && currentHour !== rConf.OPEN_HOUR && !racingData.isResultProcessed) {
        racingData.isResultProcessed = true;
        
        var totalW = 0; racingData.horses.forEach(function(h){ totalW += h.weight; });
        var rVal = Math.random() * totalW; var accum = 0; var winner = racingData.horses[0];
        for(var i=0; i<racingData.horses.length; i++){ accum += racingData.horses[i].weight; if(rVal < accum){ winner = racingData.horses[i]; break; } }

        var tax = Math.floor(racingData.totalPool * rConf.TAX_RATE);
        var distributePool = racingData.totalPool - tax + racingData.carryOver;
        var winPool = 0; var winnerUids = [];
        for(var uid in racingData.bets){ if(racingData.bets[uid].horseId === winner.id){ winPool += racingData.bets[uid].amount; winnerUids.push(uid); } }

        var mainRoom = data.rooms[ctx.targetRoom];
        if(mainRoom) mainRoom.bankReserve = (mainRoom.bankReserve || 0) + tax;

        var resultHeader = "🏁 [제 " + racingData.round + "회 경마 결과 및 새 경기 안내]\n━━━━━━━━━━━━━━━\n[🏆 지난 경기 결과]\n\"마지막 직선 주로에서 " + winner.id + "번 " + winner.name + "가 골인!\"\n\n🥇 우승마: [" + winner.id + "번 " + winner.name + "]\n";
        var resultBody = "";
        
        if(winnerUids.length > 0) {
            var rate = (distributePool / winPool).toFixed(1);
            resultBody += "💰 최종 배당률: x" + rate + "\n🏛️ 국고 수수료(10%): " + fp(tax) + "P 입고\n\n[🎖️ 주요 당첨자]";
            winnerUids.forEach(function(uId){
                var b = racingData.bets[uId]; var u = null;
                for(var r in data.rooms){ if(data.rooms[r].users[uId]){ u = data.rooms[r].users[uId]; break; } }
                if(u){
                    var share = b.amount / winPool; var prize = Math.floor(share * distributePool);
                    var res = processRepayment(u, prize, uId, ctx.targetRoom);
                    u.point += res.actualGain; resultBody += "\n• " + b.name + " (+" + fp(res.actualGain) + "P)";
                }
            });
            racingData.carryOver = 0;
        } else {
            var toBank = Math.floor(distributePool * rConf.WINLESS_BANK_RATE);
            var toJackpot = distributePool - toBank;
            if(mainRoom) mainRoom.bankReserve += toBank;
            racingData.carryOver = toJackpot;
            resultBody += "💀 당첨 유저 없음\n💰 이월금(70%): " + fp(toJackpot) + "P\n🏛️ 국고 귀속(30%): " + fp(toBank) + "P";
        }

        var isClosing = (currentHour === 0);
        if (isClosing) {
            racingData.isOperating = false;
            resultBody += "\n━━━━━━━━━━━━━━━\n💤 금일 경마 운영이 종료되었습니다.\n다음 경기는 내일 오전 09:00에 시작됩니다.";
        } else {
            resultBody += "\n━━━━━━━━━━━━━━━\n✨ [제 " + (racingData.round + 1) + "회 경기 시작] ✨\n지금부터 다음 경기 배팅이 가능합니다.";
        }

        Api.replyRoom(ctx.targetRoom, resultHeader + resultBody);

        racingData.round++; racingData.bets = {}; racingData.totalPool = 0;
        racingData.isDeadlineNotified = false; racingData.isResultProcessed = false;
        var conds = [{l:"🚀 최상",w:1.5},{l:"☀️ 양호",w:1.2},{l:"☁️ 보통",w:1.0},{l:"💧 부진",w:0.7}];
        racingData.horses.forEach(function(h){ var c=conds[Math.floor(Math.random()*conds.length)]; h.icon=c.l; h.weight=c.w; });
        ctx.isUpdated = true;
    }

    /* 4. 홀짝 피버타임 및 결투 체크 (기존 로직 유지) */
    if (!data.feverData) data.feverData = { active: false, endTime: 0, scheduled: [] };
    var timeKey = (currentHour < 10 ? "0"+currentHour : currentHour) + ":" + (currentMin < 10 ? "0"+currentMin : currentMin);
    if (data.feverData.scheduled.indexOf(timeKey) !== -1 && !data.feverData.active) {
        data.feverData.active = true; data.feverData.endTime = nowTs + (5 * 60 * 1000);
        data.feverData.scheduled.splice(data.feverData.scheduled.indexOf(timeKey), 1);
        try { Api.replyRoom(ctx.targetRoom, "🔥 홀짝 피버타임 시작\n━━━━━━━━━━━━━━━\n지금부터 5분간 홀짝 승률이 상승합니다!"); } catch(e){}
        ctx.isUpdated = true;
    }
    if (data.feverData.active && data.feverData.endTime > 0 && nowTs > Number(data.feverData.endTime)) {
        data.feverData.active = false; data.feverData.endTime = 0;
        try { Api.replyRoom(ctx.targetRoom, "❄️ 홀짝 피버타임 종료\n━━━━━━━━━━━━━━━\n이벤트 시간이 마감되어 승률이 정상화되었습니다."); } catch(e){}
        ctx.isUpdated = true;
    }

    for (var dKey in duelData) {
        var d = duelData[dKey];
        if (nowTs > d.expire) {
            var room = data.rooms[d.room];
            if (room && room.users[d.challengerUid]) {
                room.users[d.challengerUid].point += Number(d.point);
                try { Api.replyRoom(d.room, "⏰ 결투 만료\n━━━━━━━━━━━━━━━\n상대방 응답 없음으로 " + fp(d.point) + "P 환급 완료\n내 잔액: " + fp(room.users[d.challengerUid].point) + "P"); } catch(err) {}
            }
            delete duelData[dKey]; ctx.isUpdated = true; 
        }
    }
}

// 엔진 가동
runScheduler();

//==========섹터17==========

/**
 * 섹터 17 로직 함수: 주식 장 마감, 일일 데이터 초기화 및 시즌 리셋 관리
 */
function _runSector17Logic(data, ctx) {
    var currentHour = ctx.now.getHours();
    var currentMin = ctx.now.getMinutes();

    if (currentHour === 0 && currentMin === 0) {
        if (data.lastStockClose !== ctx.today) {
            data.lastStockClose = ctx.today;
            try { 
                Api.replyRoom(ctx.targetRoom, formatAdmin("📉 장 마감 알림", "금일 주식 시장이 종료되었습니다.")); 
            } catch(e) {}
            ctx.isUpdated = true;
        }

        if (data.lastDailyReset !== ctx.today) {
            data.lastDailyReset = ctx.today; 
            if (!data.lotto) data.lotto = {}; 
            data.lotto.entries = {}; 
            
            data.feverData.scheduled = [];
            while(data.feverData.scheduled.length < 5) {
                var h = Math.floor(Math.random() * 15) + 9; 
                var m = Math.floor(Math.random() * 60);
                var tStr = (h < 10 ? "0"+h : h) + ":" + (m < 10 ? "0"+m : m);
                if (data.feverData.scheduled.indexOf(tStr) === -1) data.feverData.scheduled.push(tStr);
            }
            data.feverData.active = false; 

            var dayOfWeek = ctx.now.getDay(); 
            if (dayOfWeek === 0) {
                try { Api.replyRoom(ctx.targetRoom, formatAdmin("🔥 피버타임 시작", "일요일 한정 이벤트!\n승급 확률 +5% 상승이 적용됩니다.")); } catch(e){}
            } else if (dayOfWeek === 1) {
                try { Api.replyRoom(ctx.targetRoom, formatAdmin("❄️ 피버타임 종료", "이벤트가 종료되어\n승급 확률이 정상화되었습니다.")); } catch(e){}
            }

            for (var r in data.rooms) {
                for (var id in data.rooms[r].users) {
                    var u = data.rooms[r].users[id];
                    u.dailyLoanCount = 0; 
                    u.dailyGambleCount = 0; 
                    u.dailyPromotionAttempts = 1; 
                    u.dailyStimulusCount = 0; 
                    /* [신규] 신용 회복제 일일 사용량 초기화 */
                    u.dailyCreditRestoreCount = 0; 
                    
                    if (Number(u.bank) > 0) u.bank = Number(u.bank) + Math.floor(Number(u.bank) * 0.02); 
                    
                    if (u.loan && Number(u.loan.debt) > 0) { 
                        u.creditScore = Math.max(0, Number(u.creditScore) - 5); 
                        var dailyInterest = Math.floor(Number(u.loan.debt) * 0.05);
                        u.loan.debt = Number(u.loan.debt) + dailyInterest;
                        checkAndHandleDefaulter(u, r); 
                    }
                }
            }
            try { 
                Api.replyRoom(ctx.targetRoom, formatAdmin("🎫 로또 판매 시작", "새로운 로또 판매가 시작되었습니다.")); 
            } catch(e) {}
            ctx.isUpdated = true;
        }

        if (ctx.now.getDate() === 1 && data.lastSeasonReset !== ctx.season) {
            data.lastSeasonReset = ctx.season;
            for (var r in data.rooms) { 
                for (var id in data.rooms[r].users) { 
                    var u = data.rooms[r].users[id];
                    u.tier = 0;
                    u.gameAuthCount = 0; 
                    u.purchasedAuthCount = 0; 
                } 
            }
            try { 
                Api.replyRoom(ctx.targetRoom, formatAdmin("🏆 시즌 리셋", "새로운 시즌이 시작되어 모든 티어 및 게임 인증 기록이 초기화되었습니다.")); 
            } catch(e) {}
            ctx.isUpdated = true;
        }
    }
}

//==========섹터18==========

/**
 * 섹터 18 로직 함수: 로또 판매 마감 알림 및 당첨 추첨 프로세스
 * 수정 사항: 당첨금 지급 전 강제 추심/상환 엔진 연동 및 '당구' 오타 수정
 */
function _runSector18Logic(data, ctx) {
    var currentHour = ctx.now.getHours();
    var currentMin = ctx.now.getMinutes();
    var roomData = data.rooms[ctx.targetRoom]; 

    /* 7. 로또 판매 마감 알림 (21:00) */
    if (currentHour === 21 && currentMin === 0 && data.lotto.notifiedClose !== ctx.today) {
        data.lotto.notifiedClose = ctx.today;
        var pool = Number(data.lotto.dailyPool || 0) + Number(data.lotto.jackpot || 0);
        try { 
            // [수정] '당구' 오타를 'pool'로 수정하여 시스템 중단 방지
            Api.replyRoom(ctx.targetRoom, formatAdmin("🏁 로또 판매 마감", "잠시 후 22시 추첨!\n현재 누적 상금: " + fp(pool) + "P")); 
        } catch(e) {}
        ctx.isUpdated = true;
    }

    /* 8. 로또 당첨 번호 추첨 및 상금 지급 (22:00) */
    if (currentHour === 22 && currentMin === 0 && data.lotto.notifiedDraw !== ctx.today) {
        data.lotto.notifiedDraw = ctx.today;
        
        var win = []; 
        while(win.length < 3) { 
            var n = Math.floor(Math.random() * 15) + 1; 
            if(win.indexOf(n) === -1) win.push(n); 
        }
        win.sort(function(a,b){return a-b}); 
        data.lotto.lastWinNums = win;
        
        var tp = Number(data.lotto.dailyPool || 0) + Number(data.lotto.jackpot || 0);
        var w1 = [], w2 = [], w3 = [];
        
        // 당첨자 분류 및 방 정보 매핑
        for(var uid in data.lotto.entries) {
            var userFound = null;
            var userRoom = null;
            for(var rn in data.rooms) { 
                if(data.rooms[rn].users[uid]) {
                    userFound = data.rooms[rn].users[uid];
                    userRoom = rn; // 유저가 속한 방 이름 저장
                    break;
                }
            }
            if(!userFound) continue;

            data.lotto.entries[uid].forEach(function(tk){
                var m = 0; 
                tk.forEach(function(n){ if(win.indexOf(n) !== -1) m++; });
                // 당첨 리스트에 유저 정보와 해당 유저의 UID, 방 이름을 함께 저장
                if(m === 3) w1.push({u: userFound, id: uid, rm: userRoom}); 
                else if(m === 2) w2.push({u: userFound, id: uid, rm: userRoom}); 
                else if(m === 1) w3.push({u: userFound, id: uid, rm: userRoom});
            });
        }
        
        var resM = "당첨 번호: [" + win.join(", ") + "]\n";
        var totalPayout = 0;
        
        // 1등 처리 (중앙은행 재원 기반 배당)
        if(w1.length > 0) { 
            var p1 = Math.floor(tp / w1.length); 
            w1.forEach(function(obj){ 
                /* [핵심 수정] 당첨금 지급 전 상환 엔진 호출 (방 정보 포함) */
                var res = processRepayment(obj.u, p1, obj.id, obj.rm);
                var preP = Number(obj.u.point);
                obj.u.point = Number(obj.u.point) + Number(res.actualGain); 
                if (typeof verifyPointTransaction === 'function') verifyPointTransaction(obj.u, preP, Number(res.actualGain), "로또 1등 당첨", obj.rm, 0);
            }); 
            resM += "🥇 1등: " + w1.length + "명 (각 " + fp(p1) + "P)\n"; 
            data.lotto.jackpot = 0; 
        } else { 
            resM += "🥇 1등 없음 (이월)\n"; 
            data.lotto.jackpot = tp; 
        }
        
        // 2등 상금 처리 (고정 500P)
        w2.forEach(function(obj){ 
            /* [핵심 수정] 상환 엔진 호출 */
            var res = processRepayment(obj.u, 500, obj.id, obj.rm);
            var preP = Number(obj.u.point);
            obj.u.point = Number(obj.u.point) + Number(res.actualGain); 
            if (typeof verifyPointTransaction === 'function') verifyPointTransaction(obj.u, preP, Number(res.actualGain), "로또 2등 당첨", obj.rm, 0);
            totalPayout += 500;
        }); 
        resM += "🥈 2등: " + w2.length + "명 (각 " + fp(500) + "P)\n";
        
        // 3등 상금 처리 (고정 100P)
        w3.forEach(function(obj){ 
            /* [핵심 수정] 상환 엔진 호출 */
            var res = processRepayment(obj.u, 100, obj.id, obj.rm);
            var preP = Number(obj.u.point);
            obj.u.point = Number(obj.u.point) + Number(res.actualGain); 
            if (typeof verifyPointTransaction === 'function') verifyPointTransaction(obj.u, preP, Number(res.actualGain), "로또 3등 당첨", obj.rm, 0);
            totalPayout += 100;
        }); 
        resM += "🥉 3등: " + w3.length + "명 (각 " + fp(100) + "P)";
        
        /* 중앙은행 재원에서 실제 지급된 상금만큼 차감 */
        if (roomData && totalPayout > 0) {
            if (roomData.bankReserve === undefined || roomData.bankReserve === null) roomData.bankReserve = 10000;
            roomData.bankReserve -= totalPayout;
            resM += "\n\n🏦 상금 총액 " + fp(totalPayout) + "P가 은행 재원에서 지급되었습니다.";
        }
        
        try {
            java.lang.Thread.sleep(500); 
            Api.replyRoom(ctx.targetRoom, formatAdmin("🎰 로또 추첨 결과", resM));
        } catch(e) { Log.error("로또 결과 발송 실패: " + e); }
        
        data.lotto.dailyPool = 0; 
        ctx.isUpdated = true;
    }
}

//==========섹터19==========

/* 메인 메시지 리스너 함수 */
action=function(room, msg, sender, isGroupChat, replier, imageDB) {
    /* [최적화] 고정 스레드 풀 엔진 가동: 모든 처리를 비동기 작업 큐에 할당하여 반응 속도 극대화 및 씹힘 방지 */
    Executor.execute(new java.lang.Runnable({
        run: function() {
            try {
                var roomName = room.trim();
                var cleanSender = String(sender).trim(); 
                
                if (ALLOWED_ROOMS.indexOf(roomName) === -1 || cleanSender === "오픈채팅봇") return;

                var data = getDatabase(); 
                if (!data) return;

                /* [신규] 도배 방지 및 타임아웃 체크 엔진 */
                var roomData = data.rooms[roomName] || { users: {} };
                var user = null;
                var currentImgHash = null;
                try { if (imageDB) currentImgHash = imageDB.getProfileHash(); } catch(e) {}

                // 유저 객체 선제 탐색 (도배 체크용)
                for (var id in roomData.users) {
                    var u = roomData.users[id];
                    if ((currentImgHash && u.imageHash === currentImgHash) || u.name === cleanSender) {
                        user = u;
                        break;
                    }
                }

                if (user) {
                    var now = Date.now();
                    var conf = SYSTEM_CONFIG.SPAM;

                    // 1. 이미 타임아웃 상태인 경우 즉시 종료 (무응답)
                    if (user.timeoutEndTime && now < user.timeoutEndTime) {
                        return;
                    }

                    // 2. 채팅 로그 기록 및 슬라이딩 윈도우 필터링
                    if (!user.chatLog) user.chatLog = [];
                    user.chatLog.push(now);
                    user.chatLog = user.chatLog.filter(function(time) {
                        return now - time < conf.LIMIT_WINDOW;
                    });

                    // 3. 도배 기준 초과 시 타임아웃 부여
                    if (user.chatLog.length > conf.LIMIT_COUNT) {
                        user.timeoutEndTime = now + conf.TIMEOUT_MS;
                        user.chatLog = []; // 로그 초기화
                        
                        var expireTime = new Date(user.timeoutEndTime).toLocaleTimeString();
                        var timeoutMsg = "🔇 [도배 감지: 이용 제한]\n" +
                                         "━━━━━━━━━━━━━━━\n" +
                                         "대상: " + getDisplayName(user) + "님\n" +
                                         "사유: 단시간 과도한 채팅 발송\n" +
                                         "제한: " + Math.floor(conf.TIMEOUT_MS / 60000) + "분간 봇 이용 불가\n" +
                                         "━━━━━━━━━━━━━━━\n" +
                                         "💡 해제 시각: " + expireTime;
                        
                        replier.reply(timeoutMsg);
                        safeSaveData(data);
                        return;
                    }
                }

                /* [핵심] 버그 제보 및 진실 판별 시스템 */
                if (msg.startsWith("/버그제보 ")) {
                    var content = msg.substring(6).trim();
                    if (content.length < 2) return replier.reply("내용을 상세히 적어주세요.");
                    
                    // 위에서 이미 user를 찾았으므로 재사용
                    if(!user) return; 

                    var lastAct = user.lastAction;
                    var timeDiff = lastAct ? (Date.now() - lastAct.time) : 99999999;
                    var diagnosis = "";
                    var isConfirmed = false;

                    if (lastAct && timeDiff < 300000) { 
                        if (lastAct.status === "PENDING") { diagnosis = "⚠️ 로직 중단됨(응답없음)"; isConfirmed = true; }
                        else if (lastAct.status === "CRASH") { diagnosis = "🚫 시스템 에러(Crash)"; isConfirmed = true; }
                        else if (lastAct.status === "FAIL") { diagnosis = "📉 데이터 불일치(계산오류)"; isConfirmed = true; }
                        else if (lastAct.status === "SUCCESS") { 
                            replier.reply("🤖 [시스템 진단: 정상]\n직전 작업(" + lastAct.cmd + ")이 성공적으로 완료되었습니다.\n오류가 발견되지 않았습니다.");
                            return;
                        }
                    } else { 
                        diagnosis = "❓ 실행 기록 없음(로직 미진입/오타)"; isConfirmed = true; 
                    }

                    var logTime = new Date().toLocaleString();
                    var logTxt = "[" + logTime + "] " + cleanSender + ": " + content + "\n    ㄴ 판독: " + diagnosis + "\n";
                    FileStream.append(BUG_LOG_PATH, logTxt);
                    
                    if(isConfirmed) replier.reply("✅ [제보 접수]\n판독 결과: " + diagnosis + "\n분석 내용이 버그 리스트에 등록되었습니다.");
                    else replier.reply("📝 제보가 접수되었습니다.");
                    return;
                }

                /* 관리자용 시스템 제어 */
                if (isAdmin(sender, data)) {
                    if (msg === "/강제재가동") {
                        if (lock.isLocked()) lock.unlock(); 
                        globalData = getDatabase(); 
                        if (globalData) { globalData.botActive = true; safeSaveData(globalData); }
                        replier.reply(formatAdmin("🔄 시스템 재가동", "결과: 락 해제 및 메모리 동기화, 시스템 정상화 완료"));
                        return;
                    }
                 }

//==========섹터20-1==========

if (!data) return;
var roomData = data.rooms[roomName] || { users: {} };
data.rooms[roomName] = roomData;

/* [최적화] 전역 UID 캐시 객체 체크 */
if (typeof uidCache === 'undefined') var uidCache = {};

/* 유저 식별 로직 (캐시 우선 검색 방식 적용) */
var currentImgHash = null;
try { if (imageDB) currentImgHash = imageDB.getProfileHash(); } catch(e) { currentImgHash = null; }

var targetUid = null;
var cacheKey = roomName + "_" + cleanSender + (currentImgHash ? "_" + currentImgHash : "");

// 1. 캐시에서 먼저 찾기
if (uidCache[cacheKey] && roomData.users[uidCache[cacheKey]]) {
    targetUid = uidCache[cacheKey];
} else {
    // 2. 루프 탐색 (최초 1회 실행)
    for (var id in roomData.users) {
        var u = roomData.users[id];
        if (!u) continue;
        
        if (currentImgHash && u.imageHash === currentImgHash) {
            targetUid = id;
            if (u.name !== cleanSender) {
                if (!data.nickHistory[id]) data.nickHistory[id] = [];
                data.nickHistory[id].push({ old: u.name, date: getSimpleDate() });
                u.name = cleanSender;
            }
            break;
        }
        
        if (u.name === cleanSender) { 
            targetUid = id; 
            if (currentImgHash) u.imageHash = currentImgHash; 
            break; 
        }
    }
    if (targetUid) uidCache[cacheKey] = targetUid;
}

/* 신규 유저 등록 및 환영 메시지 (도배 방지 시스템 변수 통합 및 칭호 통계 필드 추가) */
if (!targetUid) {
    targetUid = generateUUID();
    roomData.users[targetUid] = { 
        name: cleanSender, point: 1000, tier: 0, creditScore: 600, totalAttendance: 0, 
        loan: { debt: 0, items: [] }, lastDate: "", icon: "", title: "", 
        inventory: [], tierGuard: 0,
        imageHash: currentImgHash, chatCount: 0, dailyGambleCount: 0,
        bank: 0, jailReleaseTime: 0, stockHoldings: {}, stockAvg: {}, 
        dailyPromotionAttempts: 1, purchasedPromotionAttempts: 0, lastBonusTriggeredCount: -1,
        /* [신규] 게임 판수 인증 시스템 변수 */
        gameAuthCount: 0,      // 현재 인증 완료 횟수
        purchasedAuthCount: 0, // 이번 시즌 인증권 구매 횟수
        /* [신규] 도배 방지 및 타임아웃 데이터 */
        chatLog: [],           // 채팅 발송 시각 기록 배열
        timeoutEndTime: 0,     // 타임아웃 종료 시각 (0이면 정상 상태)
        /* [신규] 유물 시스템 데이터 초기화 */
        artifactPieces: 0,     // 보유 중인 유물 조각 수
        /* [신규] 칭호 시스템용 누적 통계 데이터 */
        totalGambleCount: 0,   // 홀짝 총 판수
        totalGambleWins: 0,    // 홀짝 총 승리수
        totalTheftSuccess: 0,  // 도둑질 총 성공 횟수
        totalInvestAmount: 0,  // 주식 총 누적 매수액
        totalMiningTime: 0,    // 광산 총 누적 채굴 시간(분)
        totalDonation: 0,      // 누적 기부 금액 기록 필드
        /* [개편] 랜덤박스 조각 및 이용권 시스템 */
        boxFragments: 0,       // 분해 시 획득하는 조각
        boxTickets: 0,         // 조각 5개가 모여 변환된 랜덤박스 이용권
        collectedIcons: [],     // [신규] 한 번이라도 뽑았던 아이콘 기록 (분해해도 유지됨)
        dailyCreditRestoreCount: 0 // 신용 회복제 일일 사용량 제
    };
    
    uidCache[cacheKey] = targetUid;
    
    var welcomeMsg = "🎊 [" + cleanSender + "]님 환영합니다!\n━━━━━━━━━━━━━━━\n" +
                     "🎁 입장 축하 보너스: " + fP(3000) + "P 지급!\n" + 
                     "🕹️ 미니게임 및 출석체크 기능 제공\n" +
                     "💳 신용 등급: 4등급 (600점) 부여\n\n" + 
                     "📖 이용 전 반드시 '/도움말'을 확인해주세요!";
                     
    replier.reply(welcomeMsg); 
    safeSaveData(data);
}

//==========섹터20-2==========

var user = roomData.users[targetUid];

/* [수정] 데이터 구조 보정 및 초기화 */
if (!user.inventory) user.inventory = [];
if (user.tierGuard === undefined) user.tierGuard = 0;
if (user.gameAuthCount === undefined) user.gameAuthCount = 0;
if (user.purchasedAuthCount === undefined) user.purchasedAuthCount = 0;

/* [개편] 랜덤박스 시스템 관련 변수 안전 초기화 및 자동 마이그레이션 */
if (user.boxFragments === undefined) user.boxFragments = 0;
if (user.boxTickets === undefined) user.boxTickets = 0;

// 1. 기록장(collectedIcons)이 없으면 생성
if (user.collectedIcons === undefined) {
    user.collectedIcons = [];
}

// 2. [Gemini 요청 사항] 기존 보유 아이콘 기록 자동 마이그레이션
// 가방에 있는 아이콘들을 전수 조사하여 한 번이라도 뽑은 기록에 자동 등록합니다.
if (user.inventory && user.inventory.length > 0) {
    user.inventory.forEach(function(it) {
        if (it.effect === "icon" && user.collectedIcons.indexOf(it.icon) === -1) {
            user.collectedIcons.push(it.icon);
        }
    });
}

/* [핵심] 강제 추심 플래그 초기화 및 보정 */
if (user.isTransferred === undefined) user.isTransferred = false;

/* [기능] 기존 아이콘 및 칭호 가방 자동 마이그레이션 */
if (user.inventory) {
    // 1. 아이콘 마이그레이션
    if (user.icon && user.icon !== "") {
        var hasIconInInv = false;
        for (var j = 0; j < user.inventory.length; j++) {
            if (user.inventory[j].icon === user.icon) { hasIconInInv = true; break; }
        }
        if (!hasIconInInv) {
            for (var k = 0; k < SHOP_ITEMS.length; k++) {
                if (SHOP_ITEMS[k].effect === "icon" && SHOP_ITEMS[k].icon === user.icon) {
                    user.inventory.push({
                        id: SHOP_ITEMS[k].id, name: SHOP_ITEMS[k].name, icon: SHOP_ITEMS[k].icon,
                        effect: "icon", title: ""
                    });
                    // 마이그레이션 시 기록장에도 동시 등록
                    if (user.collectedIcons.indexOf(user.icon) === -1) user.collectedIcons.push(user.icon);
                    break;
                }
            }
        }
    }
    
    // 2. 칭호 마이그레이션 (누락분 추가)
    if (user.title && user.title !== "") {
        var hasTitleInInv = false;
        for (var j = 0; j < user.inventory.length; j++) {
            if (user.inventory[j].title === user.title) { hasTitleInInv = true; break; }
        }
        if (!hasTitleInInv) {
            for (var k = 0; k < SHOP_ITEMS.length; k++) {
                if (SHOP_ITEMS[k].effect === "title" && SHOP_ITEMS[k].title === user.title) {
                    user.inventory.push({
                        id: SHOP_ITEMS[k].id, name: SHOP_ITEMS[k].name, icon: SHOP_ITEMS[k].icon || "",
                        effect: "title", title: SHOP_ITEMS[k].title
                    });
                    break;
                }
            }
        }
    }
}

var today = getSimpleDate();
user.point = Number(user.point || 0);

/* 민생지원금 즉시 체크 */
checkEconomicStimulus(user, roomName, false);

/* 중복 유저 선택 처리부 (사채 보전 및 국고 회수 로직 통합) */
if (selectWaitState[targetUid]) {
    if (Date.now() - selectWaitState[targetUid].timestamp > 30000) {
        delete selectWaitState[targetUid];
    } 
    else if (msg === "취소") {
        delete selectWaitState[targetUid];
        replier.reply(formatCommand("🚫 선택 취소", user, "작업이 취소되었습니다."));
        return;
    }
    else {
        var choice = parseInt(msg);
        if (!isNaN(choice) && choice >= 1 && choice <= selectWaitState[targetUid].results.length) {
            var selected = selectWaitState[targetUid].results[choice - 1];
            var type = selectWaitState[targetUid].type;
            var extra = selectWaitState[targetUid].extra;
            var targetUser = selected.data;
            delete selectWaitState[targetUid];

            if (type === "info") {
                var cr = getCreditInfo(targetUser.creditScore);
                var info = "💰 포인트: " + fp(targetUser.point) + "P\n🏦 예금: " + fp(targetUser.bank) + "P\n💳 신용: " + cr.label + " (" + targetUser.creditScore + "점)\n🏅 티어: " + TIERS[targetUser.tier];
                replier.reply(formatCommand("🔍 유저 상세 정보", targetUser, info, null));
            }
            else if (type === "transfer") {
                if (selected.id === targetUid) return replier.reply(formatError(user, "송금 불가", "자기 자신에게는 송금할 수 없습니다."));
                var preSender = Number(user.point);
                user.point -= extra.amount;
                verifyPointTransaction(user, preSender, -extra.amount, "송금 보냄");

                var res = processRepayment(targetUser, extra.amount, selected.id, roomName);
                var preRc = Number(targetUser.point);
                targetUser.point = Number(targetUser.point) + Number(res.actualGain);
                verifyPointTransaction(targetUser, preRc, Number(res.actualGain), "송금 받음");

                replier.reply(formatCommand("💸 송금 완료", user, getDisplayName(targetUser) + "님께 " + fp(extra.amount) + "P 보냈습니다." + res.repayMsg, "내 잔액: " + fp(user.point) + "P"));
                safeSaveData(data);
            }
            else if (type === "admin_userdata") { 
                replier.reply(formatAdmin("유저 데이터 조회", JSON.stringify(targetUser, null, 2))); 
            }
            else if (type === "admin_point_give") {
                var preP = Number(targetUser.point);
                targetUser.point = Number(targetUser.point) + extra.amount;
                verifyPointTransaction(targetUser, preP, extra.amount, "관리자 지급");
                replier.reply(formatAdmin("포인트 지급 완료", getDisplayName(targetUser) + "님: +" + fp(extra.amount) + "P\n(현재: " + fp(targetUser.point) + "P)"));
                safeSaveData(data);
            }
            else if (type === "admin_point_take") {
                var preP = Number(targetUser.point);
                targetUser.point = Math.max(0, Number(targetUser.point) - extra.amount);
                verifyPointTransaction(targetUser, preP, -extra.amount, "관리자 차감");
                replier.reply(formatAdmin("포인트 차감 완료", getDisplayName(targetUser) + "님: -" + fp(extra.amount) + "P"));
                safeSaveData(data);
            }
            else if (type === "admin_attend_edit") {
                targetUser.totalAttendance = extra.days;
                replier.reply(formatAdmin("출석 수정 완료", getDisplayName(targetUser) + "님: " + extra.days + "일"));
                safeSaveData(data);
            }
            /* [수정] 유저 삭제 (중복 선택 케이스) - 사채 보전 및 국고 회수 적용 */
            else if (type === "admin_delete") {
                var tName = targetUser.name;
                var targetId = selected.id;
                var refundLog = "";
                var refundCount = 0;
                var totalRefunded = 0;

                // 1. 모든 사채 계약 강제 정산 및 삭제 (채권자 보호)
                if (roomData.loanContracts) {
                    for (var cid in roomData.loanContracts) {
                        var c = roomData.loanContracts[cid];
                        if (c.borrowerUid === targetId) {
                            var lender = roomData.users[c.lenderUid];
                            if (lender) {
                                var debtAmt = Number(c.currentDebt);
                                lender.point = Number(lender.point) + debtAmt;
                                totalRefunded += debtAmt;
                                refundCount++;
                                try { Api.replyRoom(roomName, "🚬 [사채 강제 정산]\n" + tName + "님의 데이터 삭제로 인해 " + lender.name + "님께 미수금 " + fp(debtAmt) + "P가 전액 반환되었습니다."); } catch(e){}
                            }
                            delete roomData.loanContracts[cid];
                        }
                    }
                }

                // 2. 은행 대출금 국고 회수
                if (targetUser.loan && Number(targetUser.loan.debt) > 0) {
                    var bankDebt = Number(targetUser.loan.debt);
                    roomData.bankReserve = (Number(roomData.bankReserve) || 0) + bankDebt;
                    refundLog += "\n\n🏦 은행 대출금 " + fp(bankDebt) + "P가 국고로 자동 회수되었습니다.";
                }

                if (refundCount > 0) refundLog += "\n⚠️ 사채 보전 완료: " + refundCount + "건 (" + fp(totalRefunded) + "P)";

                // 3. 데이터 삭제 처리
                if (typeof uidCache !== 'undefined') {
                    for (var key in uidCache) {
                        if (uidCache[key] === targetId) delete uidCache[key];
                    }
                }
                delete roomData.users[targetId];
                safeSaveData(data);
                replier.reply(formatAdmin("유저 삭제 완료", "[" + tName + "]님의 데이터를 영구 삭제했습니다." + refundLog));
            }
            else if (type === "admin_attend_reset") {
                targetUser.lastDate = "";
                replier.reply(formatAdmin("출석 초기화", getDisplayName(targetUser) + "님의 오늘 출석 기록을 삭제했습니다."));
                safeSaveData(data);
            }
            else if (type === "user_restore") {
                var stablePath = BASE_DIR + "backup/last_stable_backup.json";
                if (new java.io.File(stablePath).exists()) {
                    var backupData = JSON.parse(FileStream.read(stablePath));
                    var backupUser = null;
                    for (var r in backupData.rooms) { 
                        if (backupData.rooms[r].users[selected.id]) { 
                            backupUser = backupData.rooms[r].users[selected.id]; 
                            break; 
                        } 
                    }
                    if (backupUser) { 
                        roomData.users[selected.id] = backupUser; 
                        safeSaveData(data); 
                        replier.reply(formatAdmin("유저 복구 완료", getDisplayName(backupUser) + "님 복구 성공")); 
                    }
                }
            }
            else if (type === "admin_nick_log") {
                var hist = data.nickHistory[selected.id] || [];
                if (hist.length === 0) {
                    replier.reply(formatAdmin("닉네임 기록", getDisplayName(targetUser) + "님은 변경 이력이 없습니다."));
                } else {
                    var logMsg = [];
                    for(var i=0; i<hist.length; i++) logMsg.push((i+1) + ". " + hist[i].old + " (" + hist[i].date + ")");
                    replier.reply(formatAdmin("📋 닉네임 변경 이력", "현재: " + targetUser.name + "\n\n[과거 기록]\n" + logMsg.join("\n")));
                }
            }
            return;
        }
    }
}

//==========섹터21==========

        /* 로또 번호 입력 처리부 (가격 연동 및 포맷 적용) */
        if (lottoPurchaseState[targetUid]) {
            if (Date.now() - lottoPurchaseState[targetUid].time > 30000) {
                delete lottoPurchaseState[targetUid];
            } 
            else if (msg === "취소") {
                delete lottoPurchaseState[targetUid];
                replier.reply(formatCommand("🚫 로또 구매 취소", user, "구매가 취소되었습니다."));
                return;
            }
            else {
                var rawNums = msg.match(/\d+/g);
                if (!rawNums || rawNums.length !== 3) {
                    replier.reply(formatError(user, "입력 오류", "숫자 3개를 정확히 입력해주세요. (예: 1 5 10)"));
                    return;
                }
                var nums = rawNums.map(Number).sort(function(a, b) { return a - b; });
                var isInvalid = false;
                if (new Set(nums).size !== 3) isInvalid = true;
                for (var i = 0; i < 3; i++) { if (nums[i] < 1 || nums[i] > 15) isInvalid = true; }
                if (isInvalid) {
                    replier.reply(formatError(user, "번호 오류", "1~15 사이의 중복 없는 숫자 3개를 입력하세요."));
                    return;
                }

                var lottoPrice = (lottoPurchaseState[targetUid].price !== undefined) ? lottoPurchaseState[targetUid].price : 100;

                if (Number(user.point) < lottoPrice) {
                    delete lottoPurchaseState[targetUid];
                    replier.reply(formatError(user, "포인트 부족", "로또 구매 비용(" + fp(lottoPrice) + "P)이 부족합니다."));
                    return;
                }

                var prePoint = Number(user.point);
                user.point = Number(user.point) - lottoPrice;
                verifyPointTransaction(user, prePoint, -lottoPrice, "로또 구매");

                if (!data.lotto.entries[targetUid]) data.lotto.entries[targetUid] = [];
                data.lotto.entries[targetUid].push(nums);
                data.lotto.dailyPool = (data.lotto.dailyPool || 0) + lottoPrice;
                
                delete lottoPurchaseState[targetUid];
                replier.reply(formatCommand("🎫 로또 구매 완료", user, "선택 번호: [" + nums.join(", ") + "]\n비용: " + fp(lottoPrice) + "P\n추첨 시간: 매일 밤 22:00", "내 잔액: " + fP(user.point) + "P"));
                
                /* [중요 데이터] 로또 구매는 자산 변동이므로 즉시 저장 유지 */
                safeSaveData(data);
                return;
            }
        }

        /* 채팅 보너스 로직 (하이브리드 방식 적용: 실시간 저장 제거로 렉 방지) */
        if (msg.indexOf("/") !== 0) {
            user.chatCount = (user.chatCount || 0) + 1;
            user.chatCycleCount = (user.chatCycleCount || 0) + 1;
            if (user.chatCycleCount > 13 || !user.chatBonusTarget) {
                user.chatCycleCount = 1; 
                user.chatBonusTarget = Math.floor(Math.random() * 12) + 1;
                user.chatBonusGiven = false; 
            }
            if (user.chatCycleCount >= user.chatBonusTarget && !user.chatBonusGiven) {
                var multiplier = 1.0;
                var roomDataForChat = data.rooms[roomName];
                if (roomDataForChat && roomDataForChat.economyBase && roomDataForChat.economyBase > 0) {
                    var currentEco = calculateEconomy(data, roomName);
                    var rawRatio = currentEco.total / roomDataForChat.economyBase;
                    var damping = (data.economyDamping !== undefined) ? data.economyDamping : 0.5;
                    multiplier = 1 + (rawRatio - 1) * damping;
                    if (multiplier < 0.5) multiplier = 0.5;
                }

                var basePrize = Math.floor(Math.random() * 21) + 80;
                var prize = Math.floor(basePrize * multiplier);
                
                var prePoint = Number(user.point);
                
                /* [핵심] 사채 추심 로직이 포함된 통합 상환 함수 호출 */
                // targetUid를 인자로 넘겨 사채 계약자 식별 및 추심 진행
                var res = processRepayment(user, prize, targetUid, roomName);
                
                user.point = Number(user.point) + Number(res.actualGain);
                verifyPointTransaction(user, prePoint, res.actualGain, "채팅 보너스", roomName, 0);

                user.creditScore = Math.min(1000, Number(user.creditScore || 600) + 1);
                
                // 추심 및 상환 내역이 포함된 메시지 출력
                var output = "🎁 채팅 보너스\n━━━━━━━━━━━━━━━\n" + getDisplayName(user) + "님\n" + fp(prize) + "P를 획득했습니다!" + (res.repayMsg ? res.repayMsg : "") + "\n━━━━━━━━━━━━━━━";
                replier.reply(output + "\n내 잔액: " + fP(user.point) + "P");
                
                user.chatBonusGiven = true; 
                
                /* [최적화] 하이브리드 방식 적용: 고빈도 작업인 채팅 보너스는 실시간 저장을 생략함 */
                // 실제 저장은 5분 주기 스케줄러(섹터 16)가 담당하여 I/O 부하를 제거함.
                // safeSaveData(data); 
            }
        }
        
//==========섹터22-1==========

/* [수정] 통합 업무 처리 핸들러 (1단계: 송금, 예금 및 기부) */
if (bankProcessState && bankProcessState[targetUid]) {
    var state = bankProcessState[targetUid];

    if (Date.now() - state.time > 30000) {
        delete bankProcessState[targetUid];
    } 
    else if (msg === "취소") {
        delete bankProcessState[targetUid];
        replier.reply(formatCommand("🚫 업무 취소", user, "요청하신 업무가 취소되었습니다."));
    } 
    else {
        /* [기능 1] 송금 처리 */
        if (state.type === 'transfer') {
            var ps = msg.split(" ");
            if (ps.length < 2) {
                replier.reply(formatError(user, "입력 오류", "형식: [닉네임] [금액]"));
            } else {
                var am = parseInt(ps.pop().replace(/,/g, "")); 
                var tn = ps.join(" ").trim(); 
                var found = findUserByName(roomData, tn);

                if (found.length === 0) {
                    replier.reply(formatError(user, "대상 없음", "[" + tn + "]님을 찾을 수 없습니다."));
                } else if (found.length > 1) {
                    handleUserSelection(replier, targetUid, found, "transfer", { amount: am }, user);
                } else if (found[0].id === targetUid) {
                    replier.reply(formatError(user, "본인 송금 불가", "자신에게는 보낼 수 없습니다."));
                } else if (isNaN(am) || am <= 0) {
                    replier.reply(formatError(user, "금액 오류", "정확한 숫자를 입력하세요."));
                } else if (user.point < am) {
                    replier.reply(formatError(user, "잔액 부족", "보유 포인트가 부족합니다."));
                } else {
                    var rc = found[0].data;
                    var preSender = Number(user.point);
                    user.point -= am;
                    verifyPointTransaction(user, preSender, -am, "송금 보냄");

                    var res = processRepayment(rc, am, found[0].id, roomName);
                    var preRc = Number(rc.point);
                    rc.point = Number(rc.point) + Number(res.actualGain);
                    verifyPointTransaction(rc, preRc, Number(res.actualGain), "송금 받음");

                    replier.reply(formatCommand("💸 송금 완료", user, getDisplayName(rc) + "님께 " + fp(am) + "P를 보냈습니다." + res.repayMsg, "(현재 잔액: " + fp(user.point) + "P)"));
                    delete bankProcessState[targetUid];
                    safeSaveData(data);
                }
            }
        }

        /* [기능 2] 예금 처리 */
        else if (state.type === 'deposit') {
            var amt = parseInt(msg.replace(/,/g, ""));
            if (isNaN(amt) || amt <= 0) {
                replier.reply(formatError(user, "금액 오류", "예금할 숫자를 입력하세요."));
            } else if (user.point < amt) {
                replier.reply(formatError(user, "포인트 부족", "보유하신 포인트보다 많습니다."));
            } else {
                var preP = Number(user.point);
                user.point -= amt;
                user.bank = (user.bank || 0) + amt;

                if (roomData.bankReserve === undefined || roomData.bankReserve === null) {
                    roomData.bankReserve = SYSTEM_CONFIG.ECO.BANK.INITIAL_RESERVE;
                }
                roomData.bankReserve += amt;

                verifyPointTransaction(user, preP, -amt, "은행 예금", roomName, amt);

                replier.reply(formatCommand("💰 예금 완료", user, fp(amt) + "P를 통장에 입금했습니다.\n(중앙은행 가용 재원으로 편입됨)", "내 잔액: " + fp(user.point) + "P"));
                delete bankProcessState[targetUid];
                safeSaveData(data);
            }
        }

        /* [수정] 기부 처리 (누적 기부 칭호 시스템 연동) */
        else if (state.type === 'donate') {
            var amt = parseInt(msg.replace(/,/g, ""));
            if (isNaN(amt) || amt <= 0) {
                replier.reply(formatError(user, "금액 오류", "기부할 금액을 숫자로 정확히 입력하세요."));
            } else if (user.point < amt) {
                replier.reply(formatError(user, "잔액 부족", "보유하신 포인트보다 많은 금액은 기부할 수 없습니다."));
            } else {
                /* 1. 중앙은행 연동 기부금 처리 */
                util_updatePoint(user, roomData, -amt, "은행 기부", roomName);
                
                /* 2. 누적 기부 금액 합산 */
                user.totalDonation = (user.totalDonation || 0) + amt;

                /* 3. 기부 칭호 체크 로직 (Gemini 요청 사항: 4단계) */
                var donation = user.totalDonation;
                var replierStub = { reply: function(m) { Api.replyRoom(roomName, m); } };

                if (donation >= 1000000) {
                    util_checkAndAwardTitle(user, replierStub, "기부의왕", 5004, "👑", "누적 기부 1,000,000P", "국가 경제의 진정한 수호자로 등극하셨습니다.");
                } else if (donation >= 500000) {
                    util_checkAndAwardTitle(user, replierStub, "자선가", 5003, "✨", "누적 기부 500,000P", "1,000,000P 달성 시 기부의왕 칭호를 획득합니다.");
                } else if (donation >= 300000) {
                    util_checkAndAwardTitle(user, replierStub, "기부천사", 5002, "👼", "누적 기부 300,000P", "500,000P 달성 시 자선가 칭호를 획득합니다.");
                } else if (donation >= 100000) {
                    util_checkAndAwardTitle(user, replierStub, "선한손길", 5001, "🌱", "누적 기부 100,000P", "300,000P 달성 시 기부천사 칭호를 획득합니다.");
                }

                var thanksMsg = "중앙은행에 " + fp(amt) + "P를 기부하셨습니다.\n" +
                                "보내주신 소중한 자산은 국가 경제 위기 극복과 \n" +
                                "전체 유저 복지 향상을 위해 귀하게 사용됩니다.\n" +
                                "따뜻한 마음에 진심으로 감사드립니다!\n\n" +
                                "🏦 [국고 입고]: 기부금이 중앙은행 재원으로 귀속됨\n" +
                                "📊 누적 기부액: " + fp(donation) + "P";

                replier.reply(formatCommand("🎁 기부 완료", user, thanksMsg, "(현재 잔액: " + fp(user.point) + "P)"));
                delete bankProcessState[targetUid];
                safeSaveData(data);
            }
        }
    }
}
            
//==========섹터22-2==========

/* [독립형] 통합 업무 처리 핸들러 (2단계: 출금, 대출, 상환) */
if (bankProcessState && bankProcessState[targetUid]) {
    var state = bankProcessState[targetUid];
    var roomData = data.rooms[roomName]; // 재원 관리를 위해 roomData 참조

    // 중앙은행 재원 초기화 (섹터 1의 설정값 사용)
    if (roomData.bankReserve === undefined) roomData.bankReserve = SYSTEM_CONFIG.ECO.BANK.INITIAL_RESERVE;

    // 가드 로직: 시간 초과 및 취소 처리
    if (Date.now() - state.time > 30000) {
        delete bankProcessState[targetUid];
    } 
    else if (msg === "취소") {
        delete bankProcessState[targetUid];
        replier.reply(formatCommand("🚫 은행 업무 취소", user, "요청하신 업무가 취소되었습니다."));
    } 
    else {
        /* [기능 3] 출금 처리 (지급준비제도 반영: 금고 실재고 확인) */
        if (state.type === 'withdraw') {
            var amt = parseInt(msg.replace(/,/g, ""));
            if (isNaN(amt) || amt <= 0) {
                replier.reply(formatError(user, "금액 오류", "출금할 숫자를 정확히 입력하세요."));
            } else if (user.bank < amt) {
                replier.reply(formatError(user, "잔고 부족", "통장 잔고보다 많은 금액은 출금할 수 없습니다."));
            } else if (roomData.bankReserve < amt) {
                /* [신규] 뱅크런 방지: 은행 실자산이 부족할 경우 출금 제한 */
                replier.reply(formatError(user, "은행 지급 불능", "죄송합니다. 현재 은행의 현금 유동성(실재고)이 부족하여 출금이 일시 제한됩니다.\n대출금 회수 및 수수료 적립 시까지 기다려주세요.\n\n🏦 현재 은행 금고: " + fp(roomData.bankReserve) + "P"));
            } else {
                var preP = Number(user.point);
                user.bank -= amt;
                user.point += amt;
                
                /* [핵심] 출금 시 중앙은행 금고에서 포인트 유출 */
                roomData.bankReserve -= amt;
                
                // [v5.8] 블랙박스 기록: 유저 +amt, 은행 -amt
                verifyPointTransaction(user, preP, amt, "은행 출금", roomName, -amt);

                replier.reply(formatCommand("🏧 출금 완료", user, fp(amt) + "P를 현금으로 출금했습니다.", "보유 포인트: " + fp(user.point) + "P"));
                delete bankProcessState[targetUid];
                safeSaveData(data);
            }
        }

        /* [기능 4] 은행 대출 실행 (loan) - 지급준비율 제어 적용 */
        if (state.type === 'loan') {
            var amt = parseInt(msg.replace(/,/g, ""));
            var cr = getCreditInfo(user.creditScore);
            var bConf = SYSTEM_CONFIG.ECO.BANK;
            var lConf = SYSTEM_CONFIG.ECO.PRIVATE_LOAN;

            /* [핵심] 지급준비제도 기반 가용 대출 자산 계산 */
            var totalDeposits = 0;
            for (var id in roomData.users) { totalDeposits += (roomData.users[id].bank || 0); }
            
            var requiredReserve = Math.floor(totalDeposits * bConf.RESERVE_RATIO);
            var lendableAmount = roomData.bankReserve - requiredReserve;

            if (isNaN(amt) || amt <= 0) {
                replier.reply(formatError(user, "금액 오류", "대출받을 숫자를 입력하세요."));
            } 
            else if (amt > lendableAmount) {
                var reserveInfo = "현재 은행의 대출 가능 한도를 초과했습니다.\n(지급준비율 " + (bConf.RESERVE_RATIO * 100) + "% 준수 중)\n\n" +
                                  "🏦 현재 금고: " + fp(roomData.bankReserve) + "P\n" +
                                  "🛡️ 법정 준비금: " + fp(requiredReserve) + "P\n" +
                                  "💰 실제 대출 가능액: " + fp(Math.max(0, lendableAmount)) + "P";
                replier.reply(formatError(user, "은행 자금 동결", reserveInfo));
            }
            else if ((user.dailyLoanCount || 0) >= lConf.DAILY_LIMIT) {
                delete bankProcessState[targetUid];
                replier.reply(formatError(user, "대출 제한", "대출은 하루에 최대 " + lConf.DAILY_LIMIT + "회까지만 가능합니다."));
            } 
            else if (amt > cr.limit) {
                replier.reply(formatError(user, "한도 초과", cr.label + "의 최대 한도는 " + fp(cr.limit) + "P입니다."));
            } 
            else {
                user.dailyLoanCount = (user.dailyLoanCount || 0) + 1;
                if (user.dailyLoanCount >= 2) {
                    user.creditScore = Math.max(0, Number(user.creditScore || 600) - 20);
                    checkAndHandleDefaulter(user, roomName);
                }

                var total = Math.floor(amt * cr.rate);
                if (!user.loan || typeof user.loan !== 'object') user.loan = { debt: 0, items: [] };
                if (!user.loan.items) user.loan.items = [];

                user.loan.debt = Number(user.loan.debt || 0) + Number(total);
                user.loan.items.push(Number(total));

                var preP = Number(user.point);
                user.point = Number(user.point || 0) + Number(amt);
                
                // [중요] 은행 재원에서 대출금 차감
                roomData.bankReserve -= amt;

                // [v5.8] 블랙박스 기록: 유저 +amt, 은행 -amt
                verifyPointTransaction(user, preP, amt, "대출 실행", roomName, -amt);

                replier.reply(formatCommand("🏦 대출 승인", user, fp(amt) + "P 입금 완료\n(상환 예정액: " + fp(total) + "P)\n\n🏛️ 남은 가용 재원: " + fp(roomData.bankReserve - requiredReserve) + "P", "보유 포인트: " + fp(user.point) + "P"));
                delete bankProcessState[targetUid];
                safeSaveData(data);
            }
        }

        /* [기능 5] 은행 대출 상환 (repay) - 재원 복구 로직 포함 */
        if (state.type === 'repay') {
            var amt = parseInt(msg.replace(/,/g, ""));
            if (isNaN(amt) || amt <= 0) {
                replier.reply(formatError(user, "금액 오류", "상환할 숫자를 입력하세요."));
            } else if (user.point < amt) {
                replier.reply(formatError(user, "포인트 부족", "보유하신 포인트가 상환액보다 적습니다."));
            } else {
                var preP = Number(user.point);
                var res = distributeRepayment(user, amt);
                user.point = Number(user.point) - Number(res.actualRepay); 
                
                // [중요] 상환된 원금은 은행 재원으로 다시 복구 (재원 순환)
                roomData.bankReserve = (roomData.bankReserve || 0) + res.actualRepay;

                // [v5.8] 블랙박스 기록: 유저 -actualRepay, 은행 +actualRepay
                verifyPointTransaction(user, preP, -res.actualRepay, "대출 상환", roomName, res.actualRepay);

                var currentDebt = (user.loan && user.loan.debt) ? Number(user.loan.debt) : 0;
                replier.reply(formatCommand("📉 상환 완료", user, fp(res.actualRepay) + "P 상환되었습니다.\n\n🏦 은행 재원 충전: +" + fp(res.actualRepay) + "P", "남은 대출금: " + fp(currentDebt) + "P"));
                delete bankProcessState[targetUid];
                safeSaveData(data);
            }
        }
    }
}
            
//==========섹터22-3==========

/* [독립형] 통합 업무 처리 핸들러 (3단계: 사채 등록 및 빌리기) */
if (bankProcessState && bankProcessState[targetUid]) {
    var state = bankProcessState[targetUid];

    // 가드 로직: 시간 초과 및 취소 처리 (독립성 유지)
    if (Date.now() - state.time <= 30000 && msg !== "취소") {
        
        /* [기능 6] 사채 매물 등록 처리 (p2p_reg_input) */
        if (state.type === 'p2p_reg_input') {
            var parts = msg.split(" ");
            if (parts.length < 2) {
                replier.reply(formatError(user, "입력 오류", "형식: [금액] [이율]\n예) 10000 5"));
            } else {
                var amt = parseInt(parts[0]);
                var rate = parseInt(parts[1]);
                var conf = SYSTEM_CONFIG.ECO.PRIVATE_LOAN;

                // 1. 등록 조건 검증 (최소 금액, 법정 이율 범위)
                if (isNaN(amt) || amt < conf.MIN_AMOUNT) {
                    replier.reply(formatError(user, "금액 오류", "최소 " + fp(conf.MIN_AMOUNT) + "P 이상 등록 가능합니다."));
                } else if (isNaN(rate) || rate < 5 || rate > conf.MAX_RATE) {
                    replier.reply(formatError(user, "이율 오류", "이율은 5% ~ " + conf.MAX_RATE + "% 사이로 설정하세요."));
                } else if (user.point < amt) {
                    replier.reply(formatError(user, "포인트 부족", "등록하려는 포인트가 보유 자산보다 많습니다."));
                } else {
                    // 2. 포인트 차감 및 검증
                    var preP = Number(user.point);
                    user.point -= amt;
                    verifyPointTransaction(user, preP, -amt, "사채 풀 등록", roomName, 0);

                    // 3. 매물 데이터 생성 및 저장
                    var poolId = generateUUID();
                    if (!roomData.loanPools) roomData.loanPools = {};
                    roomData.loanPools[poolId] = {
                        lenderUid: targetUid,
                        lenderName: cleanSender,
                        totalAmount: amt,
                        remainingAmount: amt,
                        rate: rate,
                        time: Date.now()
                    };

                    replier.reply(formatCommand("💰 사채 등록 완료", user, fp(amt) + "P (이자 " + rate + "%/3h) 매물을 시장에 올렸습니다.", "남은 잔액: " + fp(user.point) + "P"));
                    delete bankProcessState[targetUid];
                    safeSaveData(data);
                }
            }
        }

        /* [기능 7] 사채 빌리기 신청 처리 (p2p_borrow_amt) */
        if (state.type === 'p2p_borrow_amt') {
            var amt = parseInt(msg);
            var pool = roomData.loanPools[state.extra.poolId];
            var conf = SYSTEM_CONFIG.ECO.PRIVATE_LOAN;

            // 1. 매물 및 금액 유효성 검증
            if (!pool) {
                replier.reply(formatError(user, "매물 정보 없음", "해당 사채 매물이 이미 삭제되었거나 유효하지 않습니다."));
            } else if (isNaN(amt) || amt < conf.MIN_BORROW) {
                replier.reply(formatError(user, "금액 오류", "최소 " + fp(conf.MIN_BORROW) + "P 이상 빌려야 합니다."));
            } else if (amt > pool.remainingAmount) {
                replier.reply(formatError(user, "금액 초과", "해당 매물의 잔여 금액(" + fp(pool.remainingAmount) + "P)까지만 가능합니다."));
            } else if (pool.lenderUid === targetUid) {
                replier.reply(formatError(user, "계약 불가", "본인이 등록한 사채는 직접 빌릴 수 없습니다."));
            } else {
                // 2. 매물 잔액 차감 및 소진 시 삭제
                pool.remainingAmount -= amt;
                if (pool.remainingAmount <= 0) delete roomData.loanPools[state.extra.poolId];

                // 3. [핵심] 즉시 이자 10% 가산 로직 적용
                var initialDebt = Math.floor(amt * 1.1);

                // 4. 계약서 생성 및 저장
                var contractId = generateUUID();
                if (!roomData.loanContracts) roomData.loanContracts = {};
                roomData.loanContracts[contractId] = {
                    lenderUid: pool.lenderUid,
                    lenderName: pool.lenderName,
                    borrowerUid: targetUid,
                    borrowerName: cleanSender,
                    principal: amt,
                    currentDebt: initialDebt, // 10% 선이자 포함 채무 시작
                    rate: pool.rate,
                    startTime: Date.now(),
                    status: 'active'
                };

                // 5. 포인트 지급 및 검증
                var preP = Number(user.point);
                user.point += amt;
                verifyPointTransaction(user, preP, amt, "사채 빌림 승인");

                replier.reply(formatCommand("📝 사채 계약 체결", user, pool.lenderName + "님으로부터 " + fp(amt) + "P를 빌렸습니다.\n(즉시 이자 10% 포함 채무: " + fp(initialDebt) + "P)", "내 잔액: " + fp(user.point) + "P"));
                delete bankProcessState[targetUid];
                safeSaveData(data);
            }
        }
    }
}

//==========섹터22-4==========

/* [독립형] 통합 업무 처리 핸들러 (4단계: 사채 상환, 회수, 수거) */
if (bankProcessState && bankProcessState[targetUid]) {
    var state = bankProcessState[targetUid];

    // 1. 입력 대기 시간 초과 검증 (30초)
    if (Date.now() - state.time > 30000) {
        delete bankProcessState[targetUid];
    } 
    // 2. 작업 취소 처리
    else if (msg === "취소") {
        delete bankProcessState[targetUid];
        replier.reply(formatCommand("🚫 은행 업무 취소", user, "요청하신 업무가 취소되었습니다."));
    } 
    else {
        /* [기능 8] 빌린 사채 상환 처리 (p2p_repay_amt) */
        if (state.type === 'p2p_repay_amt') {
            var amt = parseInt(msg);
            var contract = roomData.loanContracts[state.extra.contractId];
            if (!contract) {
                replier.reply(formatError(user, "계약 정보 없음"));
            } else if (isNaN(amt) || amt <= 0 || user.point < amt) {
                replier.reply(formatError(user, "금액/포인트 오류"));
            } else {
                var actualRepay = Math.min(amt, contract.currentDebt);
                var preP = Number(user.point);
                user.point -= actualRepay;
                verifyPointTransaction(user, preP, -actualRepay, "사채 상환 지불", roomName, 0);

                var lender = roomData.users[contract.lenderUid];
                if (lender) {
                    var preL = Number(lender.point);
                    lender.point += actualRepay;
                    verifyPointTransaction(lender, preL, actualRepay, "사채 이자 수입");
                }

                // 부채 차감 및 완납 체크 로직
                contract.currentDebt -= actualRepay;
                var footerMsg = "남은 빚: " + fp(contract.currentDebt) + "P";
                if (contract.currentDebt <= 0) {
                    delete roomData.loanContracts[state.extra.contractId];
                    footerMsg = "모든 채무가 변제되었습니다.";
                }

                replier.reply(formatCommand("📉 사채 상환 완료", user, contract.lenderName + "님께 " + fp(actualRepay) + "P를 갚았습니다.\n" + footerMsg, "내 잔액: " + fp(user.point) + "P"));
                delete bankProcessState[targetUid];
                safeSaveData(data);
            }
        }

        /* [기능 9] 등록한 사채 매물 회수 (p2p_withdraw_amt) */
        if (state.type === 'p2p_withdraw_amt') {
            var amt = (msg === "전액") ? state.extra.max : parseInt(msg);
            var pool = roomData.loanPools[state.extra.poolId];
            if (!pool) {
                replier.reply(formatError(user, "매물 정보 없음"));
            } else if (isNaN(amt) || amt <= 0 || amt > pool.remainingAmount) {
                replier.reply(formatError(user, "금액 오류"));
            } else {
                pool.remainingAmount -= amt;
                var preP = Number(user.point);
                user.point += amt;
                verifyPointTransaction(user, preP, amt, "사채 풀 회수");

                if (pool.remainingAmount <= 0) delete roomData.loanPools[state.extra.poolId];
                replier.reply(formatCommand("✅ 사채 회수 완료", user, fp(amt) + "P를 시장에서 회수했습니다.", "내 잔액: " + fp(user.point) + "P"));
                delete bankProcessState[targetUid];
                safeSaveData(data);
            }
        }

        /* [기능 10] 채무자 자산 강제 수거 (p2p_collect_manual) */
        if (state.type === 'p2p_collect_manual') {
            var contract = roomData.loanContracts[state.extra.contractId];
            if (!contract) {
                replier.reply(formatError(user, "계약 정보 없음"));
            } else {
                var debtor = roomData.users[contract.borrowerUid];
                if (!debtor) {
                    replier.reply(formatError(user, "채무자 정보 없음"));
                } else {
                    var collectAmt = Math.min(Number(debtor.point), contract.currentDebt);
                    if (collectAmt <= 0) {
                        delete bankProcessState[targetUid];
                        replier.reply(formatError(user, "수거 실패", debtor.name + "님의 지갑이 비어있어 수거할 포인트가 없습니다."));
                    } else {
                        // 채무자 차감 및 채권자 가산 정밀 검증
                        var preDebtor = Number(debtor.point);
                        debtor.point -= collectAmt;
                        verifyPointTransaction(debtor, preDebtor, -collectAmt, "사채 강제 수거 당함");

                        var preLender = Number(user.point);
                        user.point += collectAmt;
                        verifyPointTransaction(user, preLender, collectAmt, "사채 직접 수거 수익");

                        contract.currentDebt -= collectAmt;
                        var footer = "남은 빚: " + fp(contract.currentDebt) + "P";
                        if (contract.currentDebt <= 0) {
                            delete roomData.loanContracts[state.extra.contractId];
                            footer = "해당 유저의 모든 채무가 변제되었습니다.";
                        }

                        replier.reply(formatCommand("🚬 사채 직접 수거 완료", user, debtor.name + "님의 지갑에서 " + fp(collectAmt) + "P를 수거했습니다.\n" + footer, "내 잔액: " + fp(user.point) + "P"));
                        delete bankProcessState[targetUid];
                        safeSaveData(data);
                    }
                }
            }
        }
    }
}

//==========섹터22-5==========

/* [독립형] 통합 업무 처리 핸들러 (5단계: 상점 아이템 구매 처리) */
if (bankProcessState && bankProcessState[targetUid] && bankProcessState[targetUid].type === 'shop_buy') {
    var state = bankProcessState[targetUid];

    // 1. 입력 대기 시간 초과 검증 (30초)
    if (Date.now() - state.time > 30000) {
        delete bankProcessState[targetUid];
    }
    // 2. 작업 취소 처리
    else if (msg === "취소") {
        delete bankProcessState[targetUid];
        replier.reply(formatCommand("🚫 상점 구매 취소", user, "아이템 구매를 취소했습니다."));
    }
    else {
        /* [기능 11] 상점 아이템 구매 처리 핸들러 */
        var idx = parseInt(msg) - 1;
        var filteredItems = (state.extra && state.extra.items) ? state.extra.items : [];

        // 1. 번호 유효성 검사
        if (isNaN(idx) || idx < 0 || idx >= filteredItems.length) {
            replier.reply(formatError(user, "번호 오류", "목록에 있는 번호를 입력해주세요."));
        } else {
            var item = filteredItems[idx];

            /* [수정] 신용 점수 회복제 일일 제한 체크 */
            if (item.effect === "credit" && (user.dailyCreditRestoreCount || 0) >= 1) {
                delete bankProcessState[targetUid];
                return replier.reply(formatError(user, "구매 제한", "신용 점수 회복제는 하루에 1개만 사용 가능합니다."));
            }
            
            /* [수정] 복수 구매 가능 여부 판별 (소모성 아이템 추출) */
            // 가방(인벤토리)에서 수량으로 누적되는 소모품 효과들
            var stackableEffects = ["promotion", "tierGuard"];
            var isStackable = stackableEffects.indexOf(item.effect) !== -1;

            if (isStackable) {
                // 수량 입력 상태(shop_quantity)로 전환
                bankProcessState[targetUid] = {
                    type: 'shop_quantity',
                    time: Date.now(),
                    extra: { item: item }
                };
                replier.reply(formatCommand("🔢 수량 입력", user, "구매하실 [" + item.name + "]의 수량을 숫자로 입력해주세요.", "취소: [취소]"));
            } else {
                // 단권 구매 로직 (아이콘, 랜덤박스, 로또 등)
                var finalPrice = getItemPrice(item, user, roomName);
                var isUsingTicket = (item.effect === "randomBox" && (user.boxTickets || 0) > 0);

                // 2. 자산 보유 확인
                if (!isUsingTicket && Number(user.point) < finalPrice) {
                    delete bankProcessState[targetUid];
                    replier.reply(formatError(user, "포인트 부족", fp(finalPrice) + "P가 필요합니다."));
                } else {
                    // 3. 중복 소유 체크 (아이콘/칭호 전용)
                    var hasItem = false;
                    if (item.effect === "icon" || item.effect === "title") {
                        var inv = user.inventory || [];
                        for (var i = 0; i < inv.length; i++) {
                            if (inv[i].id === item.id) { hasItem = true; break; }
                        }
                    }

                    if (hasItem) {
                        delete bankProcessState[targetUid];
                        replier.reply(formatError(user, "중복 소유", "이미 보유 중인 아이템입니다."));
                    } else {
                        // [수정] 게임 인증권 시즌 한도 체크
                        if (item.effect === "gameAuth" && (user.purchasedAuthCount || 0) >= 2) {
                            delete bankProcessState[targetUid];
                            return replier.reply(formatError(user, "구매 한도 초과", "인증권은 시즌당 최대 2회까지만 구매 가능합니다."));
                        }

                        // 4. 포인트 차감 및 실시간 검증
                        if (!isUsingTicket) {
                            var preP = Number(user.point);
                            user.point -= finalPrice;
                            verifyPointTransaction(user, preP, -finalPrice, "상점 구매: " + item.name, roomName, finalPrice);
                        }

                        // 5. 상태 초기화 후 단권(qty:1) 효과 실행
                        delete bankProcessState[targetUid];
                        if (typeof _handleShopEffect === 'function') {
                            _handleShopEffect(item, user, roomName, replier, data, targetUid, finalPrice, isUsingTicket, 1);
                        }
                        safeSaveData(data);
                    }
                }
            }
        }
    }
}

/* [신규 추가] 복수 수량 입력 처리 핸들러 */
else if (bankProcessState && bankProcessState[targetUid] && bankProcessState[targetUid].type === 'shop_quantity') {
    var state = bankProcessState[targetUid];
    var item = state.extra.item;

    if (Date.now() - state.time > 30000) {
        delete bankProcessState[targetUid];
    } else if (msg === "취소") {
        delete bankProcessState[targetUid];
        replier.reply(formatCommand("🚫 구매 취소", user, "아이템 구매를 취소했습니다."));
    } else {
        // 숫자만 추출
        var qty = parseInt(msg.replace(/[^0-9]/g, ""));
        if (isNaN(qty) || qty <= 0) {
            replier.reply(formatError(user, "입력 오류", "구매할 수량을 숫자로 정확히 입력해주세요."));
        } else {
            // 단가 계산 및 총액 산출
            var unitPrice = getItemPrice(item, user, roomName);
            var totalPrice = unitPrice * qty;

            if (Number(user.point) < totalPrice) {
                replier.reply(formatError(user, "포인트 부족", "총 " + fp(totalPrice) + "P가 필요합니다. (보유: " + fp(user.point) + "P)"));
            } else {
                // 포인트 차감 및 검증
                var preP = Number(user.point);
                user.point -= totalPrice;
                verifyPointTransaction(user, preP, -totalPrice, "상점 구매: " + item.name + " x" + qty, roomName, totalPrice);
                
                // 효과 엔진 호출 (수량 인자 전달)
                delete bankProcessState[targetUid];
                if (typeof _handleShopEffect === 'function') {
                    _handleShopEffect(item, user, roomName, replier, data, targetUid, totalPrice, false, qty);
                }
                safeSaveData(data);
            }
        }
    }
}

//==========섹터23-1==========

/* [섹터 통합 수정] 도움말 및 메뉴 선택 대기 처리 (공통 핸들러 및 1단계) */
if (menuWaitState && menuWaitState[targetUid]) {
    var state = menuWaitState[targetUid];
    var roomData = data.rooms[roomName];
    
    // 중앙은행 재원 초기화 (UI 출력용)
    if (roomData.bankReserve === undefined) roomData.bankReserve = 10000;

    // 1. 공통: 시간 초과 체크
    if (Date.now() - state.time > 30000) { 
        delete menuWaitState[targetUid]; 
    } 
    // 2. 공통: 취소 요청 체크
    else if (msg === "취소") {
        delete menuWaitState[targetUid];
        replier.reply(formatCommand("🚫 메뉴 선택 취소", user, "작업이 취소되었습니다."));
    }
    // 3. 각 메뉴별 로직 처리
    else {
        var choice = msg.trim();
        
        /* [1단계] 은행 메인 메뉴 선택 처리 (v5.2 기부 선택 추가) */
        if (state.type === 'bank_menu') {
             if (choice === "1") { 
                bankProcessState[targetUid] = { type: 'deposit', time: Date.now() };
                replier.reply(formatCommand("💰 예금 진행", user, "예금할 금액을 입력해주세요.\n(보유: " + fP(user.point) + "P)", "취소: [취소]"));
                delete menuWaitState[targetUid];
             } else if (choice === "2") { 
                bankProcessState[targetUid] = { type: 'withdraw', time: Date.now() };
                replier.reply(formatCommand("🏧 출금 진행", user, "출금할 금액을 입력해주세요.\n(잔고: " + fp(user.bank) + "P)", "취소: [취소]"));
                delete menuWaitState[targetUid];
             } else if (choice === "3") { 
                bankProcessState[targetUid] = { type: 'transfer', time: Date.now() };
                replier.reply(formatCommand("💸 송금 진행", user, "받을 사람의 [닉네임]과 [금액]을 띄어쓰기로 입력하세요.\n(예: 홍길동 5000)", "취소: [취소]"));
                delete menuWaitState[targetUid];
             } else if (choice === "4") { 
                var cr = getCreditInfo(user.creditScore);
                if (cr.limit <= 0) { 
                    delete menuWaitState[targetUid]; 
                    replier.reply(formatError(user, "대출 불가", "신용등급이 너무 낮습니다.")); 
                }
                else {
                    bankProcessState[targetUid] = { type: 'loan', time: Date.now() };
                    var loanMsg = "희망 대출금을 입력해주세요.\n" +
                                  "내 한도: " + fp(cr.limit) + "P (이율: " + ((cr.rate-1)*100).toFixed(0) + "%)\n" +
                                  "🏦 은행 가용 재원: " + fp(roomData.bankReserve) + "P";
                    replier.reply(formatCommand("🏦 대출 진행", user, loanMsg, "취소: [취소]"));
                    delete menuWaitState[targetUid];
                }
             } else if (choice === "5") { 
                if (!user.loan || user.loan.debt <= 0) { 
                    delete menuWaitState[targetUid]; 
                    replier.reply(formatError(user, "상환 불가", "갚을 대출금이 없습니다.")); 
                }
                else {
                    bankProcessState[targetUid] = { type: 'repay', time: Date.now() };
                    replier.reply(formatCommand("📉 상환 진행", user, "상환할 금액을 입력해주세요.\n(대출 잔액: " + fp(user.loan.debt) + "P)\n보유 포인트: " + fp(user.point) + "P", "취소: [취소]"));
                    delete menuWaitState[targetUid];
                }
             } 
             else if (choice === "6") {
                menuWaitState[targetUid] = { type: 'p2p_loan_menu', time: Date.now() };
                var p2pMenu = "1. 💰 사채 등록 (매물 올리기)\n" +
                              "2. 📋 사채 목록 (분할 대출 받기)\n" +
                              "3. 📉 사채 상환 (빌린 돈 갚기)\n" +
                              "4. 📥 사채 회수 (등록 매물 회수)\n" +
                              "5. 👥 내 채무자 현황 (직접 수거 가능)";
                replier.reply(formatCommand("🚬 사채 시장 업무 선택", user, p2pMenu, "원하시는 번호를 입력하세요."));
                return;  
             }
             /* [신규] 7번 기부 메뉴 처리 */
             else if (choice === "7") {
                bankProcessState[targetUid] = { type: 'donate', time: Date.now() };
                replier.reply(formatCommand("🎁 기부 진행", user, "기부할 금액을 입력해주세요.\n(보유: " + fP(user.point) + "P)", "취소: [취소]"));
                delete menuWaitState[targetUid];
             }
        }
    }
}

//==========섹터23-2==========

/* [2단계] 사채 시장 서브 메뉴 선택 처리 (독립형) */
if (menuWaitState && menuWaitState[targetUid]) {
    var state = menuWaitState[targetUid];
    var choice = msg.trim();

    if (state.type === 'p2p_loan_menu') {
        if (choice === "1") {
            bankProcessState[targetUid] = { type: 'p2p_reg_input', time: Date.now() };
            replier.reply(formatCommand("💰 사채 매물 등록", user, "등록할 [금액]과 [이율]을 입력하세요.\n(예: 10000 5)", "취소: [취소]"));
        } 
        else if (choice === "2") {
            var pools = Object.keys(roomData.loanPools || {});
            if (pools.length === 0) { 
                replier.reply(formatSimple("📋 사채 시장", "현재 이 방에 등록된 매물이 없습니다.", null));
            } else {
                var list = [];
                var tempPools = [];
                for(var i=0; i<pools.length; i++) {
                    var p = roomData.loanPools[pools[i]];
                    list.push((i+1) + ". [" + p.lenderName + "] 잔여: " + fp(p.remainingAmount) + "P (이자 " + p.rate + "%/3h)");
                    tempPools.push(pools[i]);
                }
                menuWaitState[targetUid] = { type: 'p2p_select_pool', time: Date.now(), extra: { pools: tempPools } };
                return replier.reply(formatCommand("📋 사채 매물 목록", user, list.join("\n"), "빌리고 싶은 매물 번호를 입력하세요."));
            }
        }
        else if (choice === "3") {
            var myContracts = [];
            if (roomData.loanContracts) {
                for(var id in roomData.loanContracts) {
                    if(roomData.loanContracts[id].borrowerUid === targetUid) myContracts.push({ id: id, data: roomData.loanContracts[id] });
                }
            }
            if (myContracts.length === 0) return replier.reply(formatError(user, "내역 없음", "현재 이 방에서 빌려 쓰고 있는 사채가 없습니다."));
            
            var list = [];
            for(var i=0; i<myContracts.length; i++) {
                var c = myContracts[i].data;
                list.push((i+1) + ". [" + c.lenderName + "] 채무액: " + fp(c.currentDebt) + "P (이율 " + c.rate + "%)");
            }
            menuWaitState[targetUid] = { type: 'p2p_select_repay', time: Date.now(), extra: { contracts: myContracts.map(x => x.id) } };
            return replier.reply(formatCommand("📉 사채 상환 선택", user, list.join("\n"), "갚을 사채의 번호를 선택하세요."));
        }
        else if (choice === "4") {
            var myPools = [];
            if (roomData.loanPools) {
                for(var id in roomData.loanPools) {
                    if(roomData.loanPools[id].lenderUid === targetUid) myPools.push({ id: id, data: roomData.loanPools[id] });
                }
            }
            if (myPools.length === 0) return replier.reply(formatError(user, "내역 없음", "이 방에 올려둔 사채 풀이 없습니다."));

            var list = [];
            for(var i=0; i<myPools.length; i++) {
                var p = myPools[i].data;
                list.push((i+1) + ". 잔여: " + (p.remainingAmount) + "P (이율 " + p.rate + "%/3h)");
            }
            menuWaitState[targetUid] = { type: 'p2p_select_withdraw', time: Date.now(), extra: { pools: myPools.map(x => x.id) } };
            return replier.reply(formatCommand("📥 사채 풀 회수", user, list.join("\n"), "회수할 사채 풀 번호를 선택하세요."));
        }
        else if (choice === "5") {
            var myDebtors = [];
            if (roomData.loanContracts) {
                for(var id in roomData.loanContracts) {
                    if(roomData.loanContracts[id].lenderUid === targetUid) myDebtors.push({ id: id, data: roomData.loanContracts[id] });
                }
            }
            if (myDebtors.length === 0) return replier.reply(formatSimple("👥 내 채무자 현황", "현재 돈을 빌려 간 유저가 없습니다.", null));

            var list = [];
            var tempContracts = [];
            for(var i=0; i<myDebtors.length; i++) {
                var d = myDebtors[i].data;
                var status = (Date.now() - d.startTime > 24*60*60*1000) ? " (🚨연체)" : "";
                list.push((i+1) + ". [" + d.borrowerName + "] 빚: " + fp(d.currentDebt) + "P" + status);
                tempContracts.push(myDebtors[i].id);
            }
            menuWaitState[targetUid] = { type: 'p2p_select_collect', time: Date.now(), extra: { contracts: tempContracts } };
            replier.reply(formatCommand("👥 내 채무자 명단", user, list.join("\n"), "강제 수거를 원하시면 유저 번호를 입력하세요."));
            return;
        }
        delete menuWaitState[targetUid]; return;
    }
}

//==========섹터23-3==========

/* [3단계] 사채 목록 선택 처리 (독립형) */
if (menuWaitState && menuWaitState[targetUid]) {
    var state = menuWaitState[targetUid];
    var choice = msg.trim();

    if (state.type === 'p2p_select_pool') {
        var idx = parseInt(choice) - 1;
        var poolId = state.extra.pools[idx];
        if (!poolId) return replier.reply(formatError(user, "번호 오류"));
        
        bankProcessState[targetUid] = { type: 'p2p_borrow_amt', time: Date.now(), extra: { poolId: poolId } };
        replier.reply(formatCommand("💰 사채 금액 설정", user, "선택 매물: [" + roomData.loanPools[poolId].lenderName + "]\n잔여 금액: " + fp(roomData.loanPools[poolId].remainingAmount) + "P\n\n빌릴 금액을 입력하세요.", "취소: [취소]"));
        delete menuWaitState[targetUid]; return;
    }

    else if (state.type === 'p2p_select_repay') {
        var idx = parseInt(choice) - 1;
        var contractId = state.extra.contracts[idx];
        if (!contractId) return replier.reply(formatError(user, "번호 오류"));

        bankProcessState[targetUid] = { type: 'p2p_repay_amt', time: Date.now(), extra: { contractId: contractId } };
        
        /* [수정] 상환 입력창에 현재 보유 포인트 표시 추가 */
        var currentDebt = roomData.loanContracts[contractId].currentDebt;
        var lenderName = roomData.loanContracts[contractId].lenderName;
        
        replier.reply(formatCommand("📉 사채 상환액 입력", user, 
            "선택 계약: [" + lenderName + "]\n" +
            "갚아야 할 돈: " + fp(currentDebt) + "P\n" +
            "💰 보유 포인트: " + fp(user.point) + "P\n\n" +
            "갚을 금액을 입력하세요.", 
            "취소: [취소]"
        ));
        delete menuWaitState[targetUid]; return;
    }

    else if (state.type === 'p2p_select_withdraw') {
        var idx = parseInt(choice) - 1;
        var poolId = state.extra.pools[idx];
        if (!poolId) return replier.reply(formatError(user, "번호 오류"));

        bankProcessState[targetUid] = { type: 'p2p_withdraw_amt', time: Date.now(), extra: { poolId: poolId, max: roomData.loanPools[poolId].remainingAmount } };
        replier.reply(formatCommand("📥 회수 금액 입력", user, "현재 풀 잔액: " + fp(roomData.loanPools[poolId].remainingAmount) + "P\n\n회수할 금액을 입력하거나 [전액]을 입력하세요.", "취소: [취소]"));
        delete menuWaitState[targetUid]; return;
    }

    else if (state.type === 'p2p_select_collect') {
        var idx = parseInt(choice) - 1;
        var contractId = state.extra.contracts[idx];
        if (!contractId) return replier.reply(formatError(user, "번호 오류"));

        bankProcessState[targetUid] = { type: 'p2p_collect_manual', time: Date.now(), extra: { contractId: contractId } };
        replier.reply(formatCommand("🚬 사채 강제 수거 확인", user, "[" + roomData.loanContracts[contractId].borrowerName + "]님의 지갑에서 자산을 수거하시겠습니까?\n\n진행하시려면 아무 메시지나 입력해주세요.", "취소: [취소]"));
        delete menuWaitState[targetUid]; return;
    }
}

//==========섹터23-4==========

/* [4단계] 상점 및 도움말 처리 (독립형) */
if (menuWaitState && menuWaitState[targetUid]) {
    var state = menuWaitState[targetUid];
    var choice = msg.trim();

    if (state.type === 'shop_category') {
        var catId = parseInt(choice);
        if (isNaN(catId) || !SHOP_CATEGORIES[catId]) {
            return replier.reply(formatError(user, "번호 오류", "올바른 카테고리 번호를 선택해주세요."));
        }

        // 선택된 카테고리에 해당하는 아이템만 필터링
        var filteredItems = [];
        for (var i = 0; i < SHOP_ITEMS.length; i++) {
            if (SHOP_ITEMS[i].cat === catId) filteredItems.push(SHOP_ITEMS[i]);
        }

        if (filteredItems.length === 0) {
            return replier.reply(formatSimple("🛒 상점 알림", "해당 카테고리에 준비된 물품이 없습니다.", "다른 번호를 선택하세요."));
        }

        var list = [];
        for (var j = 0; j < filteredItems.length; j++) {
            var item = filteredItems[j];
            var currentPrice = getItemPrice(item, user, roomName); 
            list.push((j + 1) + ". " + item.icon + " " + item.name + " : " + fp(currentPrice) + "P");
        }

        // 구매 대기 상태로 전이 (필터링된 리스트 전달)
        bankProcessState[targetUid] = { 
            type: 'shop_buy', 
            time: Date.now(), 
            extra: { items: filteredItems } 
        };

        delete menuWaitState[targetUid];
        return replier.reply(formatCommand("🛒 " + SHOP_CATEGORIES[catId], user, list.join("\n"), "구매할 물품의 번호를 입력하세요."));
    }

    /* 도움말 메뉴 처리 */
    else if (state.type === 'help') {
        var helpBody = ""; var next = "";
        var targetCat = "";
        
        if (choice === "1") { targetCat = "조회"; next = "내 정보 확인: [/내정보]"; }
        else if (choice === "2") { targetCat = "게임"; next = "승급 도전: [/승급]"; }
        else if (choice === "3") { targetCat = "상점"; next = "상점 확인: [/상점]"; }
        else if (choice === "4") { targetCat = "경제"; next = "은행 및 사채 메뉴: [/은행]"; }
        else if (choice === "5") { targetCat = "주식"; next = "시세 확인: [/주식]"; }
        else if (choice === "6") { targetCat = "광산"; next = "채굴 시작: [/광산시작]"; }
        
        if (targetCat !== "") {
            var list = [];
            for(var i=0; i<CMD_LIST.user.length; i++) {
                var c = CMD_LIST.user[i];
                if(c.cat === targetCat) list.push("• " + c.cmd + ": " + c.desc);
            }
            helpBody = list.join("\n");
        } else if (choice === "7" && isAdmin(sender, data)) {
            var list = [];
            for(var i=0; i<CMD_LIST.admin.length; i++) {
                var c = CMD_LIST.admin[i];
                list.push((i+1) + ". " + c.cmd + " " + c.desc);
            }
            helpBody = "⚙️ [관리자 전용 명령어]\n" + list.join("\n"); 
            next = "관리자 권한으로 신중히 사용하세요.";
        }
        
        if (helpBody !== "") { 
            delete menuWaitState[targetUid]; 
            return replier.reply(formatCommand("📖 상세 도움말", null, helpBody, next)); 
        }
    }
}

/* [핵심] 도움말 명령어 (독립 실행 보장 위치) */
if (msg === "/도움말") {
    menuWaitState[targetUid] = { type: 'help', time: Date.now() };
    var menu = "1. 👤 조회 및 정보\n2. 🎮 게임 및 활동\n3. 🛒 상점 및 아이템\n4. 🏦 은행 및 사채\n5. 📈 주식 투자\n6. ⛏️ 광산 채굴 (방치형)\n";
    if (isAdmin(sender, data)) menu += "7. ⚙️ 관리자 기능\n";
    replier.reply(formatCommand("📖 내리다봇 도움말", null, "원하시는 메뉴 번호를 입력하세요.\n\n" + menu, "입력 대기: 30초"));
    return;
}

//==========섹터24==========

        /* [최적화] 게임 및 경제 활동 명령어 통합 처리 구간 */
        /* 메인 함수의 용량 초과(64KB) 방지를 위해 외부 함수로 위임 */
        /* 섹터 24~36에 있던 모든 로직을 _handleGameLogic 함수로 이관합니다. */
        
        // _handleGameLogic 함수가 존재하고, 해당 함수에서 명령어를 처리했다면(true 반환) 즉시 종료
        if (typeof _handleGameLogic === 'function') {
            if (_handleGameLogic(msg, user, data, replier, roomName, targetUid, sender)) return;
        }

//==========섹터25==========

        /* [최적화] 관리자 명령어 통합 처리 구간 */
        /* 메인 함수의 용량 초과(64KB) 방지를 위해 외부 함수로 위임 */
        if (isAdmin(sender, data)) {
            if (typeof _handleAdminLogic === 'function') {
                // 관리자 로직 함수가 true를 반환하면(명령어 처리됨) 함수 종료
                if (_handleAdminLogic(msg, user, data, replier, roomName, targetUid, sender)) return;
            }
        }

//==========섹터26==========

    } catch (e) {
        Log.error("Thread Runtime Error: " + e);
        if (lock.isLocked()) {
            try {
                lock.unlock();
            } catch(err) {
                Log.error("Lock Release Error: " + err);
            }
        }
    }
}
}));
}

//==========섹터27==========

/**
 * [독립형 함수 1] 인벤토리 로직
 * 기능: 보유 아이템 확인, 장착, 분해 처리
 * 수정: 카테고리 분리, ID 기반 오름차순 정렬, 상세 분해 결과 메시지 복구
 */
function _handleInventoryLogic(msg, user, data, replier, roomName, targetUid) {
    // 1. 가방 조회 (분류 및 자동 정렬 적용)
    if (msg === "/가방") {
        var inv = user.inventory || [];
        
        // ID 기준 오름차순 정렬 (ID가 없으면 9999로 처리)
        inv.sort(function(a, b) {
            var idA = Number(a.id) || 9999;
            var idB = Number(b.id) || 9999;
            if (idA !== idB) return idA - idB;
            return (a.name || "").localeCompare(b.name || "");
        });

        var iconEntries = [];
        var titleEntries = [];
        
        if (inv.length === 0) {
            iconEntries.push("(보유 중인 아이템이 없습니다)");
        } else {
            for (var i = 0; i < inv.length; i++) {
                var it = inv[i];
                var activeMark = "";
                
                if (it.effect === "icon" && user.icon === it.icon) activeMark = " (✅ 장착 중)";
                else if (it.effect === "title" && user.title === it.title) activeMark = " (✅ 장착 중)";
                
                var entry = (i + 1) + ". " + it.icon + " " + it.name + activeMark;

                if (it.effect === "icon") iconEntries.push(entry);
                else if (it.effect === "title") titleEntries.push(entry);
            }
        }

        var invDisplay = "[아이템 보관함]\n";
        invDisplay += "🖼️ 아이콘 목록 (등급순)\n";
        invDisplay += (iconEntries.length > 0 ? iconEntries.join("\n") : "- 없음") + "\n\n";
        
        invDisplay += "🎖️ 칭호 목록 (등급순)\n";
        invDisplay += (titleEntries.length > 0 ? titleEntries.join("\n") : "- 없음");

        var consumables = "\n\n[내 소모품 정보]\n" +
                          "🛡️ 강등 방어권: " + (user.tierGuard || 0) + "개\n" +
                          "🔂 추가 승급권: " + (user.purchasedPromotionAttempts || 0) + "회\n" +
                          "🧩 분해 조각: " + (user.boxFragments || 0) + " / 5 개\n" +
                          "🎫 랜덤박스 이용권: " + (user.boxTickets || 0) + "매";
        
        var content = invDisplay + consumables + "\n\n(장착: [/장착 번호]) (분해: [/분해 번호])";
        replier.reply(formatCommand("🎒 내 가방", user, content, "원하는 번호를 입력하여 장착하세요."));
        return true;
    }

    // 2. 아이템 장착 (신용불량자 제한 및 인덱스 정합성 유지)
    if (msg.indexOf("/장착 ") === 0) {
        if (Number(user.creditScore || 600) < 500) {
            replier.reply(formatError(user, "장착 불가", "현재 신용불량자 상태이므로 아이콘 및 칭호 변경이 불가능합니다. 신용을 먼저 회복하세요."));
            return true;
        }

        var parts = msg.trim().split(/\s+/);
        if (parts.length < 2) {
            replier.reply(formatError(user, "형식 오류", "/장착 [번호]"));
            return true;
        }

        var idx = parseInt(parts[1]);
        var inv = user.inventory || [];
        if (isNaN(idx) || idx < 1 || idx > inv.length) {
            replier.reply(formatError(user, "번호 오류", "가방에 표시된 번호를 입력해주세요."));
            return true;
        }

        var selected = inv[idx - 1];
        if (selected.effect === "icon") {
            user.icon = selected.icon;
            replier.reply(formatCommand("✨ 아이콘 장착", user, "[" + selected.icon + "] 아이콘으로 변경되었습니다.", "내 정보: [/내정보]"));
        } else if (selected.effect === "title") {
            user.title = selected.title || "";
            replier.reply(formatCommand("🎖️ 칭호 장착", user, "[" + (selected.title || selected.name) + "] 칭호로 변경되었습니다.", "내 정보: [/내정보]"));
        }
        safeSaveData(data);
        return true;
    }

    // 3. 아이콘 분해 로직 (상세 결과 메시지 복구 완료)
    if (msg.indexOf("/분해 ") === 0) {
        var inv = user.inventory || [];
        if (inv.length === 0) return replier.reply(formatError(user, "분해 불가", "분해할 아이템이 없습니다."));

        var numbers = msg.match(/\d+/g);
        if (!numbers) return replier.reply(formatError(user, "입력 오류", "/분해 [번호]"));

        var targetIndices = [];
        numbers.forEach(function(n) {
            var idx = parseInt(n) - 1;
            if (idx >= 0 && idx < inv.length && targetIndices.indexOf(idx) === -1) {
                targetIndices.push(idx);
            }
        });

        if (targetIndices.length === 0) return replier.reply(formatError(user, "번호 오류", "정확한 번호를 입력하세요."));

        var disassembledNames = [];
        var earnedFragments = targetIndices.length;
        
        targetIndices.sort(function(a, b) { return b - a; });

        targetIndices.forEach(function(idx) {
            var item = inv[idx];
            disassembledNames.push(item.icon + " " + item.name);
            if (item.effect === "icon" && user.icon === item.icon) user.icon = "";
            if (item.effect === "title" && user.title === item.title) user.title = "";
            inv.splice(idx, 1);
        });

        user.boxFragments = (user.boxFragments || 0) + earnedFragments;
        var earnedTickets = 0;
        
        while (user.boxFragments >= 5) {
            user.boxFragments -= 5;
            user.boxTickets = (user.boxTickets || 0) + 1;
            earnedTickets++;
        }

        // [복구] 상세 결과 메시지 로직
        var resultMsg = "아이템 " + targetIndices.length + "개를 분해했습니다.\n\n" +
                        "[분해 목록]\n" + disassembledNames.join(", ") + "\n\n" +
                        "🧩 획득 조각: +" + earnedFragments + " 개\n" +
                        "(현재 조각: " + user.boxFragments + " / 5 개)";

        if (earnedTickets > 0) {
            resultMsg += "\n🎫 랜덤박스 이용권: +" + earnedTickets + "매 획득! (조각 변환 완료)";
        }

        replier.reply(formatCommand("♻️ 아이콘 분해 완료", user, resultMsg, "이용권 확인: [/가방]"));
        safeSaveData(data);
        return true;
    }
}

//==========섹터28==========

/**
 * [독립형 함수 2] 로또 및 아이콘 로직
 */
function _handleLottoLogic(msg, user, data, replier, roomName, targetUid) {
    if (msg === "/아이콘초기화") {
        user.icon = "";
        replier.reply(formatCommand("✅ 아이콘 초기화", user, "설정된 아이콘이 제거되었습니다.", "상점 이용: [/상점]"));
        safeSaveData(data);
        return true;
    }

    if (msg === "/로또정보") {
        var currentHour = new Date().getHours();
        var isAfterDraw = (currentHour >= 22);
        var myLottos = (data.lotto.entries && data.lotto.entries[targetUid]) ? data.lotto.entries[targetUid] : [];
        var winNums = data.lotto.lastWinNums || [];

        var result = "🎫 로또 정보\n━━━━━━━━━━━━━━━\n" + getDisplayName(user) + "님\n[나의 구매 번호]\n";
        
        if (myLottos.length === 0) {
            result += "(구매한 내역이 없습니다)\n";
        } else {
            for (var i = 0; i < myLottos.length; i++) {
                var nums = myLottos[i];
                var line = (i + 1) + ") " + nums.join(", ");
                if (isAfterDraw && winNums.length > 0) {
                    var matchCount = 0;
                    for(var j=0; j < nums.length; j++) {
                        if (winNums.indexOf(nums[j]) !== -1) matchCount++;
                    }
                    if (matchCount === 3) line += " 🥇1등!";
                    else if (matchCount === 2) line += " 🥈2등!";
                    else if (matchCount === 1) line += " 🥉3등!";
                }
                result += line + "\n";
            }
        }

        result += "\n[당일 당첨 번호]\n";
        if (isAfterDraw) {
            if (winNums.length > 0) result += "🏆 " + winNums.join(", ");
            else result += "🏆 집계 중입니다.";
        } else {
            result += "🏆 아직 추첨 전입니다.";
        }
        result += "\n━━━━━━━━━━━━━━━\n💡 [가이드]: 구매: [/구매 5]";
        replier.reply(result);
        return true;
    }
}

//==========섹터29==========

/**
 * [독립형] 방치형 광산 시스템 로직 구현부 (누적 시간 및 성취 칭호 통합 버전)
 * 설명: 섹터 46(구 섹터 27 호출부)에서 호출되며, 광산 시작/정보/종료 및 보상 정산 로직을 수행합니다.
 * 수정 사항: 중앙은행 폐쇄형 경제 연동 및 누적 시간 칭호(두더지~채굴의신) 반영
 */
function _handleMiningLogic(msg, user, data, replier, roomName, targetUid) {
    var roomData = data.rooms[roomName]; 

    // 1. 광산 시작
    if (msg === "/광산시작") {
        if (user.jailReleaseTime && Date.now() < user.jailReleaseTime) {
            var diff = user.jailReleaseTime - Date.now();
            var remainMin = Math.ceil(diff / (1000 * 60));
            var timeMsg = remainMin >= 60 ? Math.ceil(remainMin / 60) + "시간" : remainMin + "분";
            replier.reply(formatError(user, "입장 불가", "현재 징역 중입니다. " + timeMsg + " 후 가능합니다."));
            return true;
        }
        
        if (user.mining && user.mining.active) {
            replier.reply(formatError(user, "활동 중", "이미 광산에서 채굴 중입니다."));
            return true;
        }
        
        if (isUserBusy(targetUid)) {
            replier.reply(formatError(user, "활동 중", "이미 다른 활동(도박/결투/도둑질) 중입니다."));
            return true;
        }

        user.mining = { active: true, startTime: Date.now(), room: roomName };
        replier.reply(formatCommand("⛏️ 광산 입성", user, "광산에서 채굴을 시작했습니다.\n채굴 중에는 도박, 주식, 도둑질 등 수익형 활동이 제한됩니다.", "종료: [/광산종료]"));
        safeSaveData(data);
        return true;
    }

    // 2. 광산 정보 (누적 채굴 시간 표시 추가)
    if (msg === "/광산정보") {
        if (!user.mining || !user.mining.active) {
            replier.reply(formatError(user, "상태 오류", "현재 광산에서 작업 중이 아닙니다."));
            return true;
        }

        var durationMin = Math.floor((Date.now() - user.mining.startTime) / 60000);
        var totalMin = (user.totalMiningTime || 0) + durationMin;
        
        var multiplier = 1.0;
        if (roomData.economyBase && roomData.economyBase > 0) {
            var eco = calculateEconomy(data, roomName);
            var rawRatio = eco.total / roomData.economyBase;
            var damping = (data.economyDamping !== undefined) ? data.economyDamping : 0.5;
            multiplier = 1 + (rawRatio - 1) * damping;
            if (multiplier < 0.5) multiplier = 0.5;
        }

        var hasDebt = (user.loan && Number(user.loan.debt) > 0);
        if (!hasDebt && roomData.loanContracts) {
            for (var cid in roomData.loanContracts) {
                if (roomData.loanContracts[cid].borrowerUid === targetUid) { hasDebt = true; break; }
            }
        }
        if (hasDebt) multiplier *= 1.5;

        var basePrice = SYSTEM_CONFIG.ECO.MINE.BASE_PER_MIN; 
        var estimatedEarn = Math.floor(durationMin * basePrice * multiplier);

        var infoBody = "\n채굴 진행: " + durationMin + "분째...\n" +
                       "📈 누적 채굴: " + fp(totalMin) + "분 경과\n" +
                       "예상 기본수익: +" + fp(estimatedEarn) + "P\n\n" +
                       "✨ 광물 발견 수익은 종료 시 합산됩니다.";

        replier.reply(formatCommand("⛏️ 광산 진행 현황", user, infoBody, "종료 및 정산은 [/광산종료]"));
        return true;
    }

    // 3. 광산 종료 (누적 시간 및 칭호 부여 로직 통합)
    if (msg === "/광산종료") {
        if (!user.mining || !user.mining.active) {
            replier.reply(formatError(user, "상태 오류", "현재 작업 중이지 않습니다."));
            return true;
        }

        if (user.jailReleaseTime && Date.now() < user.jailReleaseTime) {
            user.mining.active = false; 
            safeSaveData(data);
            replier.reply(formatError(user, "검거 확인", "징역형 선고로 인해 광산에서 강제 퇴거되었습니다.\n(누적 채굴 수익 소멸)"));
            return true;
        }

        var now = Date.now();
        var durationMin = Math.floor((now - user.mining.startTime) / 60000); 

        if (durationMin < 1) {
            user.mining.active = false; 
            safeSaveData(data);
            replier.reply(formatCommand("⛏️ 광산 퇴거", user, "채굴 시간이 너무 짧아 수익이 발생하지 않았습니다.\n(최소 1분 이상 유지 필요)", "다시 시작: [/광산시작]"));
            return true;
        }

        var multiplier = 1.0;
        if (roomData.economyBase && roomData.economyBase > 0) {
            var eco = calculateEconomy(data, roomName);
            var rawRatio = eco.total / roomData.economyBase;
            var damping = (data.economyDamping !== undefined) ? data.economyDamping : 0.5;
            multiplier = 1 + (rawRatio - 1) * damping;
            if (multiplier < 0.5) multiplier = 0.5;
        }

        var hasDebt = (user.loan && Number(user.loan.debt) > 0);
        if (!hasDebt && roomData.loanContracts) {
            for (var cid in roomData.loanContracts) {
                if (roomData.loanContracts[cid].borrowerUid === targetUid) { hasDebt = true; break; }
            }
        }
        if (hasDebt) multiplier *= 1.5;

        var basePrice = SYSTEM_CONFIG.ECO.MINE.BASE_PER_MIN;
        var conf = SYSTEM_CONFIG.ECO.MINE;
        var totalEarn = 0;
        var copperCount = 0, goldCount = 0, diaCount = 0;
        var artifactFound = 0;

        for (var i = 0; i < durationMin; i++) {
            var rand = Math.random();
            var minIncome = basePrice * multiplier;

            if (rand < conf.DIA_PROB) { 
                diaCount++; 
                totalEarn += (minIncome * conf.DIA_MULT); 
            } else if (rand < conf.GOLD_PROB) { 
                goldCount++; 
                totalEarn += (minIncome * conf.GOLD_MULT); 
            } else if (rand < conf.COPPER_PROB) { 
                copperCount++; 
                totalEarn += (minIncome * conf.COPPER_MULT); 
            } else { 
                totalEarn += minIncome; 
            }

            if (Math.random() < (conf.ARTIFACT_CHANCE || 0.0005)) {
                artifactFound++;
            }
        }

        totalEarn = Math.floor(totalEarn);
        var borrowerUid = targetUid || user.uid; 
        var res = processRepayment(user, totalEarn, borrowerUid, roomName); 
        
        util_updatePoint(user, roomData, Number(res.actualGain), "광산 채굴");

        // [신규] 누적 시간 업데이트
        if (user.totalMiningTime === undefined) user.totalMiningTime = 0;
        user.totalMiningTime += durationMin;

        // [신규] 광산 누적 시간 칭호 체크
        if (user.totalMiningTime >= 7000) {
            util_checkAndAwardTitle(user, replier, "채굴의신", 2903, "⛏️", "누적 채굴 7,000분", "유물 도감도 함께 확인해보세요! [/유물도감]");
        } else if (user.totalMiningTime >= 5000) {
            util_checkAndAwardTitle(user, replier, "석공", 2902, "⛏️", "누적 채굴 5,000분", "7,000분 달성 시 [채굴의신]을 획득합니다.");
        } else if (user.totalMiningTime >= 1000) {
            util_checkAndAwardTitle(user, replier, "두더지", 2901, "⛏️", "누적 채굴 1,000분", "5,000분 달성 시 [석공]에 도전하세요!");
        }

        user.artifactPieces = (user.artifactPieces || 0) + artifactFound;
        var goal = conf.ARTIFACT_GOAL || 10;
        var titleAwarded = false;

        if (user.artifactPieces >= goal) {
            if (!user.inventory) user.inventory = [];
            var hasTombTitle = false;
            for (var k = 0; k < user.inventory.length; k++) {
                if (user.inventory[k].title === "도굴왕") { hasTombTitle = true; break; }
            }
            if (!hasTombTitle) {
                user.inventory.push({ id: 888, name: "[도굴왕] 칭호", icon: "🏺", effect: "title", title: "도굴왕" });
                titleAwarded = true;
                user.title = "도굴왕"; // 도굴왕도 자동 장착 적용
            }
        }

        user.mining.active = false;
        
        var repayInfo = res.repayMsg ? "\n\n" + res.repayMsg : "";

        var resultBody = "\n⛏️ 채굴 시간: " + durationMin + "분\n" +
                         "🟫 구리 " + copperCount + "회 🗂️ 황금 " + goldCount + "회\n" +
                         "💎 다이아 " + diaCount + "회\n\n" +
                         "💰 채굴 수익: " + fp(totalEarn) + "P" + repayInfo;

        if (artifactFound > 0) {
            resultBody += "\n\n✨ [특별 발견] ✨\n━━━━━━━━━━━━━━━\n" +
                           "먼지 쌓인 흙더미 속에서 \n" +
                           "심상치 않은 기운의 조각을 발견했습니다!\n\n" +
                           "🧩 유물 조각 획득 (+" + artifactFound + ")\n" +
                           "(현재 보유: " + user.artifactPieces + " / " + goal + " 개)";
        }
                                 
        replier.reply(formatCommand("⛏️ 채굴 결과", user, resultBody, "내 잔액: " + fP(user.point) + "P"));

        if (titleAwarded) {
            var celebMsg = "드디어 " + goal + "개의 유물 조각을 모두 모았습니다.\n\n" +
                           "흩어져 있던 조각들이 하나로 합쳐지며 \n" +
                           "찬란한 빛과 함께 고대의 기운이 \n" +
                           "당신의 온몸을 감쌉니다...\n\n" +
                           "🎁 수집 보상 완료\n" +
                           "🎖️ 칭호 획득: [도굴왕]";
            replier.reply(formatCommand("🏺 [전설의 완성: 도굴왕]", user, celebMsg, "칭호가 자동 장착되었습니다."));
        }

        safeSaveData(data);
        return true;
    }
}

//==========섹터30==========

/**
 * [전역 독립 함수] 상점 아이템 효과 처리 엔진
 * 기능: 구매한 아이템의 효과 발동 및 중앙은행 재원 정산
 * 수정: 복수 구매 수량(quantity) 파라미터 추가 및 소모품 합산 로직 반영
 */
function _handleShopEffect(item, user, roomName, replier, data, targetUid, finalPrice, isUsingTicket, quantity) {
    var roomData = data.rooms[roomName];
    if (!roomData) return;
    
    // 수량이 전달되지 않은 경우 기본값 1 설정
    var qty = (quantity !== undefined && quantity !== null) ? quantity : 1;

    // 중앙은행 재원 초기화 (기본 10,000P)
    if (roomData.bankReserve === undefined || roomData.bankReserve === null) {
        roomData.bankReserve = 10000;
    }
    
    /* [1. 자산 정산] 이용권을 사용하지 않은 경우에만 구매 대금(총액)을 은행으로 귀속 */
    if (!isUsingTicket) {
        roomData.bankReserve += finalPrice;
    } else {
        // 이용권 사용 시 유저 데이터에서 이용권 1매 차감 (이용권은 단권 구매만 가능)
        user.boxTickets = Math.max(0, (user.boxTickets || 0) - 1);
    }

    /* [핵심] 아이템 효과별 실행 로직 */
    
    // 1. 랜덤 아이콘 박스 처리 (개편 버전 - 단권 처리)
    if (item.effect === "randomBox") {
        var rand = Math.random();
        var cumulative = 0;
        var resultIdx = 0; 

        var msgTable = {
            0: { title: "🎁 랜덤 아이콘 박스 개봉", desc: "\"에고... 먼지만 쌓인 창고에서 쓸모없는 물건을 발견했습니다.\"", guide: "가방에 저장되었습니다. [/가방]" },
            1: { title: "🎁 랜덤 아이콘 박스 개봉", desc: "\"나쁘지 않네요! 싱그러운 아이콘을 획득했습니다.\"", guide: "장착 시 [/장착 번호]를 입력하세요." },
            2: { title: "🎁 랜덤 아이콘 박스 개봉", desc: "\"오! 빛나는 아이템입니다. 희귀한 가치가 느껴지네요!\"", guide: "가방에서 확인 가능합니다. [/가방]" },
            3: { title: "🎊 에픽 아이템 획득! 🎊", desc: "\"와우! 대단한 운입니다. 화려한 에픽 아이콘을 손에 넣었습니다!\"", guide: "가방에 안전하게 보관되었습니다." },
            4: { title: "✨ [전설급] 유니크 등장! ✨", desc: "\"믿기지 않는 행운! 신화 속에서나 보던 유니크 아이템입니다!\"", guide: "즉시 장착하여 자랑해보세요! [/가방]" },
            5: { title: "🔥 [초비상] 레전더리 강림! 🔥", desc: "\"축하합니다! 서버 최상위 2%의 확률을 뚫고 전설을 획득했습니다!\"", guide: "이 아이콘은 상점에서 절대 구할 수 없습니다." }
        };

        for (var g = 0; g < RANDOM_BOX_CONFIG.PROBS.length; g++) {
            cumulative += RANDOM_BOX_CONFIG.PROBS[g].prob;
            if (rand < cumulative) { resultIdx = g; break; }
        }

        var resGrade = RANDOM_BOX_CONFIG.PROBS[resultIdx];
        var winIcon = resGrade.items[Math.floor(Math.random() * resGrade.items.length)];
        
        if (!user.collectedIcons) user.collectedIcons = [];
        var isDuplicate = (user.collectedIcons.indexOf(winIcon) !== -1);

        var mData = msgTable[resultIdx] || msgTable[0];
        var content = "등급: " + resGrade.icon + " " + resGrade.grade + "\n" +
                      "결과: [" + winIcon + "]\n\n" + mData.desc;

        if (isDuplicate) {
            user.boxFragments = (user.boxFragments || 0) + 1;
            var ticketConverted = false;
            if (user.boxFragments >= 5) {
                user.boxFragments -= 5;
                user.boxTickets = (user.boxTickets || 0) + 1;
                ticketConverted = true;
            }
            content += "\n\n⚠️ 중복 아이콘 당첨!\n(과거에 획득한 기록이 있습니다)\n\n🧩 보상: 분해 조각 +1개 지급\n📊 현재 조각: " + user.boxFragments + " / 5 개";
            if (ticketConverted) {
                content += "\n🎫 축하합니다! 조각이 모두 모여 랜덤박스 이용권 1매가 지급되었습니다!";
            }
        } else {
            user.inventory.push({ id: 900 + resultIdx, name: resGrade.grade.split(" ")[0] + " 아이콘", icon: winIcon, effect: "icon", title: "" });
            user.collectedIcons.push(winIcon);
        }
        
        var footer = isUsingTicket ? "🎫 랜덤박스 이용권 사용 완료" : "내 잔액: " + fp(user.point) + "P";
        replier.reply(formatCommand(mData.title, user, content, mData.guide + "\n" + footer));
    } 
    
    // 2. 게임 판수 인증권 처리 (단권 처리)
    else if (item.effect === "gameAuth") {
        user.gameAuthCount = (user.gameAuthCount || 0) + 1;
        user.purchasedAuthCount = (user.purchasedAuthCount || 0) + 1;
        replier.reply(formatCommand("🎫 인증권 사용 완료", user, "게임 판수 인증이 기록되었습니다.\n현재 인증 횟수: " + user.gameAuthCount + "/2", "시즌당 구매: " + user.purchasedAuthCount + "/2"));
    } 
    
    // 3. 로또 구매 대기 처리 (단권 처리)
    else if (item.effect === "lotto") {
        lottoPurchaseState[targetUid] = { time: Date.now(), price: finalPrice };
        replier.reply(formatCommand("🎫 로또 번호 입력", user, "1~15 사이의 숫자 3개를 입력해주세요.\n(예: 1 5 10)", "취소: [취소]"));
    } 
    
    // 4. 소모성 아이템 처리 (수량 qty 반영)
    else if (item.effect === "promotion") {
        // [수정] 승급 기회 구매 수량 합산
        user.purchasedPromotionAttempts = (user.purchasedPromotionAttempts || 0) + qty;
        replier.reply(formatCommand("🛒 구매 완료", user, item.name + " x" + qty + " 구매 성공!", "남은 승급 기회: " + (user.dailyPromotionAttempts + user.purchasedPromotionAttempts)));
    } else if (item.effect === "tierGuard") {
        // [수정] 강등 방어권 수량 합산
        user.tierGuard = (user.tierGuard || 0) + qty;
        replier.reply(formatCommand("🛒 구매 완료", user, item.name + " x" + qty + " 구매 성공!", "보유 방어권: " + user.tierGuard + "개"));
    } else if (item.effect === "icon" || item.effect === "title") {
        // 아이콘 및 칭호는 단권 처리
        user.inventory.push({ id: item.id, name: item.name, icon: item.icon, effect: item.effect, title: item.title || "" });
        if (item.effect === "icon") user.icon = item.icon;
        if (item.effect === "title") user.title = item.title;
        replier.reply(formatCommand("🛒 구매 완료", user, item.name + " 구매 및 장착 성공!", "장착 변경: [/가방]"));
    } else if (item.effect === "credit") {
        /* [수정] 수량은 항상 1로 고정되며 사용 카운트 증가 */
        var totalRestore = (item.value || 50);
        user.creditScore = Math.min(1000, (user.creditScore || 600) + totalRestore);
        user.dailyCreditRestoreCount = (user.dailyCreditRestoreCount || 0) + 1;
        if (typeof checkAndHandleDefaulter === 'function') checkAndHandleDefaulter(user, roomName);
        replier.reply(formatCommand("🛒 구매 완료", user, item.name + " 사용 성공! (신용 +50)", "현재 점수: " + user.creditScore));
    }

    safeSaveData(data);
}

//==========섹터31==========

/**
 * [관리자 명령어 분배기] (Admin Logic Dispatcher - Registry Refactored)
 * 설명: 관리자 명령어의 통합 진입점입니다. 
 * 섹터 1의 ADMIN_COMMANDS 레지스트리를 참조하여 등록된 로직을 자동으로 매핑 및 실행합니다.
 */
function _handleAdminLogic(msg, user, data, replier, roomName, targetUid, sender) {
    // 1. 명령어 첫 단어 추출 (예: "/재원수정 1000" -> "/재원수정")
    var cmd = msg.split(" ")[0]; 

    // 2. 관리자 명령어 레지스트리(ADMIN_COMMANDS)에서 해당 명령어 검색
    // 섹터 6에서 등록된 매핑 정보를 바탕으로 최적화된 O(1) 탐색을 수행합니다.
    if (ADMIN_COMMANDS[cmd] && typeof ADMIN_COMMANDS[cmd].execute === 'function') {
        
        // 3. 등록된 하위 로직 함수(섹터 35~38 등)를 즉시 실행 및 결과 반환
        // 실행 시 필요한 모든 컨텍스트 객체를 인자로 전달합니다.
        return ADMIN_COMMANDS[cmd].execute(msg, user, data, replier, roomName, targetUid);
    }

    // 4. 처리된 명령어가 없거나 등록되지 않은 경우 false 반환
    return false; 
}

//==========섹터32==========

/**
 * [관리자 하위 모듈 1] 시스템 기본 제어 및 권한 관리
 * 기능: 도움말, 봇구동, 강제재가동, 도박제한, 관리자 등록/해제
 */
function _adminSystemLogic(msg, user, data, replier, roomName) {

    /* 관리자 도움말 */
    if (msg === "/관리자") {
        var list = [];
        for(var i=0; i<ADMIN_CMD_LIST.length; i++) {
            list.push(ADMIN_CMD_LIST[i]);
        }
        replier.reply(formatAdmin("관리자 명령어 목록", list.join("\n")));
        return true;
    }

    /* 시스템 구동 제어 */
    if (msg.indexOf("/봇구동 ") === 0) {
        var state = msg.split(" ")[1];
        data.botActive = (state === "온");
        safeSaveData(data);
        replier.reply(formatAdmin("시스템 설정", "봇 구동 상태: [" + state + "]"));
        return true;
    }

    /* 시스템 강제 재가동 (락 해제) */
    if (msg === "/강제재가동") {
        if (lock.isLocked()) lock.unlock();
        replier.reply(formatAdmin("완료", "시스템 락 해제 및 동기화 완료"));
        return true;
    }

    /* 도박 제한 설정 */
    if (msg.indexOf("/도박제한 ") === 0) {
        var sw = msg.split(" ")[1]; 
        data.gambleLimit = (sw === "온");
        safeSaveData(data);
        replier.reply(formatAdmin("설정", "도박 제한 상태: [" + sw + "]"));
        return true;
    }

    /* 관리자 등록 */
    if (msg.indexOf("/관리자등록 ") === 0) {
        var target = msg.substring(7).trim();
        if (!data.admins) data.admins = ["관리자"];
        if (data.admins.indexOf(target) !== -1) { 
            replier.reply(formatAdmin("관리자 등록 알림", "이미 관리자로 등록되어 있는 닉네임입니다.")); 
            return true; 
        }
        data.admins.push(target);
        safeSaveData(data);
        replier.reply(formatAdmin("관리자 등록 완료", "[" + target + "]님을 부관리자로 등록했습니다."));
        return true;
    }

    /* 관리자 해제 */
    if (msg.indexOf("/관리자해제 ") === 0) {
        var target = msg.substring(7).trim();
        if (target === "95 남 광어") { 
            replier.reply(formatAdmin("오류", "최상위 관리자 권한은 해제할 수 없습니다.")); 
            return true; 
        }
        if (!data.admins) data.admins = ["관리자"];
        var idx = data.admins.indexOf(target);
        if (idx === -1) { 
            replier.reply(formatAdmin("오류", "해당 닉네임을 관리자 명단에서 찾을 수 없습니다.")); 
            return true; 
        }
        data.admins.splice(idx, 1);
        safeSaveData(data);
        replier.reply(formatAdmin("관리자 해제 완료", "[" + target + "]님을 관리자 권한에서 제외했습니다."));
        return true;
    }

    /* 관리자 목록 */
    if (msg === "/관리자목록") {
        var list = data.admins || ["관리자"];
        replier.reply(formatAdmin("현재 관리자 명단", "• " + list.join("\n• ")));
        return true;
    }

    return false; // 처리된 명령어가 없음
}

//==========섹터33==========

/**
 * [관리자 하위 모듈 2] 로그 및 제보 관리
 * 기능: 버그 제보 확인/삭제, 오류 로그 확인/삭제, 관리자 활동 로그 조회
 */
function _adminLogLogic(msg, user, data, replier) {

    /* 버그 제보 목록 확인 */
    if (msg === "/제보목록") {
        var list = FileStream.read(BUG_LOG_PATH);
        if (!list || list.trim() === "") replier.reply(formatAdmin("제보 내역", "접수된 버그 제보가 없습니다."));
        else replier.reply(formatAdmin("📂 버그 제보 목록", list.trim()));
        return true;
    }

    /* 버그 제보 초기화 */
    if (msg === "/제보초기화") {
        FileStream.remove(BUG_LOG_PATH);
        replier.reply(formatAdmin("완료", "버그 제보 내역을 모두 삭제했습니다."));
        return true;
    }

    /* 오류 로그 확인 */
    if (msg === "/오류로그") {
        var list = FileStream.read(ERROR_LOG_PATH);
        if (!list || list.trim() === "") replier.reply(formatAdmin("오류 로그", "기록된 시스템 오류가 없습니다."));
        else replier.reply(formatAdmin("⚠️ 시스템 오류 로그", list.trim()));
        return true;
    }

    /* 오류 로그 초기화 */
    if (msg === "/오류초기화") {
        FileStream.remove(ERROR_LOG_PATH);
        replier.reply(formatAdmin("완료", "오류 로그를 모두 삭제했습니다."));
        return true;
    }

    /* 관리자 활동 로그 */
    if (msg === "/관리자로그") {
        var logs = data.adminLogs || [];
        replier.reply(formatAdmin("활동 로그", logs.slice(-10).join("\n") || "기록 없음"));
        return true;
    }

    return false;
}

/**
 * [관리자 하위 모듈 3] 유저 데이터 관리
 * 기능: 유저 조회, 수정, 삭제, 복원, 데이터 이전, 닉네임 기록, 신용 조정
 * 수정 사항: 유저 삭제 시 출석일수 무관 사채 전액 보전 및 계약서 강제 삭제 로직 적용
 */
function _adminUserManageLogic(msg, user, data, replier, roomName, targetUid) {

    /* 상세 유저 데이터 조회 */
    if (msg.indexOf("/유저데이터 ") === 0) {
        var tn = msg.substring(7).trim();
        var roomData = data.rooms[roomName];
        var found = findUserByName(roomData, tn);
        if (!found.length) replier.reply(formatAdmin("오류", "유저를 찾을 수 없습니다."));
        else if (found.length > 1) handleUserSelection(replier, targetUid, found, "admin_userdata", null, user);
        else replier.reply(formatAdmin("유저 데이터 조회", JSON.stringify(found[0].data, null, 2)));
        return true;
    }

    /* 닉네임 변경 이력 */
    if (msg.indexOf("/닉네임기록 ") === 0) {
        var tn = msg.substring(7).trim();
        var roomData = data.rooms[roomName];
        var found = findUserByName(roomData, tn);
        if (!found.length) { replier.reply(formatAdmin("오류", "유저를 찾을 수 없습니다.")); return true; }
        if (found.length > 1) { handleUserSelection(replier, targetUid, found, "admin_nick_log", null, user); return true; }
        var targetId = found[0].id;
        var history = data.nickHistory[targetId] || [];
        if (history.length === 0) { replier.reply(formatAdmin("닉네임 기록", getDisplayName(found[0].data) + "님은 변경 이력이 없습니다.")); return true; }
        var logMsg = [];
        for(var i=0; i<history.length; i++) logMsg.push((i+1) + ". " + history[i].old + " (" + history[i].date + ")");
        replier.reply(formatAdmin("📋 닉네임 변경 이력", "현재: " + found[0].data.name + "\n\n[과거 기록]\n" + logMsg.join("\n")));
        return true;
    }

    /* [신규] 신용 점수 직접 조정 (v5.2) */
    if (msg.indexOf("/신용조정 ") === 0) {
        var ps = msg.split(" ");
        if (ps.length < 3) {
            replier.reply(formatAdmin("오류", "형식: /신용조정 [닉네임] [점수]\n예) /신용조정 홍길동 -50"));
            return true;
        }
        var scoreChange = parseInt(ps.pop());
        var targetName = ps.slice(1).join(" ").trim();
        var roomData = data.rooms[roomName];
        var found = findUserByName(roomData, targetName);

        if (isNaN(scoreChange)) { replier.reply(formatAdmin("오류", "조정할 점수를 숫자로 입력하세요.")); return true; }
        if (!found.length) { replier.reply(formatAdmin("오류", "유저를 찾을 수 없습니다.")); return true; }
        if (found.length > 1) { 
            handleUserSelection(replier, targetUid, found, "admin_credit_edit", { score: scoreChange }, user); 
            return true; 
        }

        var targetUser = found[0].data;
        var oldScore = Number(targetUser.creditScore || 600);
        targetUser.creditScore = Math.min(1000, Math.max(0, oldScore + scoreChange));
        
        if (typeof checkAndHandleDefaulter === 'function') {
            checkAndHandleDefaulter(targetUser, roomName);
        }

        safeSaveData(data);
        var crInfo = getCreditInfo(targetUser.creditScore);
        var resText = "대상: " + getDisplayName(targetUser) + "님\n" +
                      "변동: " + (scoreChange > 0 ? "+" : "") + scoreChange + "점\n" +
                      "현재: " + targetUser.creditScore + "점 (" + crInfo.label + ")";
        
        replier.reply(formatAdmin("⚙️ 신용 점수 조정 완료", resText));
        return true;
    }

    /* 출석 초기화 */
    if (msg.indexOf("/출석초기화 ") === 0) {
        var tn = msg.substring(7).trim();
        var roomData = data.rooms[roomName];
        var found = findUserByName(roomData, tn);
        if (!found.length) { replier.reply(formatAdmin("오류", "유저를 찾을 수 없습니다.")); return true; }
        if (found.length > 1) { handleUserSelection(replier, targetUid, found, "admin_attend_reset", null, user); return true; }
        found[0].data.lastDate = "";
        safeSaveData(data);
        replier.reply(formatAdmin("출석 초기화 완료", getDisplayName(found[0].data) + "님의 오늘 출석 기록을 삭제했습니다."));
        return true;
    }

    /* 출석 일수 수정 */
    if (msg.indexOf("/출석일수수정 ") === 0) {
        var ps = msg.split(" "), days = parseInt(ps.pop()), tn = ps.slice(1).join(" ");
        var roomData = data.rooms[roomName];
        var found = findUserByName(roomData, tn);
        if (!found.length) { replier.reply(formatAdmin("오류", "대상 없음")); return true; }
        if (found.length > 1) { handleUserSelection(replier, targetUid, found, "admin_attend_edit", { days: days }, user); return true; }
        found[0].data.totalAttendance = days; safeSaveData(data);
        replier.reply(formatAdmin("수정 완료", getDisplayName(found[0].data) + ": " + days + "일"));
        return true;
    }

    /* 전체 출석 수정 */
    if (msg.indexOf("/전체출석수정 ") === 0) {
        var days = parseInt(msg.split(" ")[1]);
        for (var r in data.rooms) {
            for (var id in data.rooms[r].users) { data.rooms[r].users[id].totalAttendance = days; }
        }
        safeSaveData(data);
        replier.reply(formatAdmin("완료", "전체 출석 " + days + "일로 고정"));
        return true;
    }

    /* 데이터 이전 */
    if (msg.indexOf("/데이터이전 ") === 0) {
        if (msg.indexOf(" > ") === -1) { replier.reply(formatAdmin("오류", "형식이 올바르지 않습니다.\n예) /데이터이전 구닉네임 > 신닉네임")); return true; }
        var names = msg.substring(7).split(" > ");
        var oldName = names[0].trim();
        var newName = names[1].trim();
        var roomData = data.rooms[roomName];
        
        var oldFound = findUserByName(roomData, oldName);
        var newFound = findUserByName(roomData, newName);

        if (oldFound.length === 0) { replier.reply(formatAdmin("오류", "구 닉네임을 찾을 수 없습니다.")); return true; }
        if (newFound.length === 0) { replier.reply(formatAdmin("오류", "신 닉네임을 찾을 수 없습니다.")); return true; }
        if (oldFound.length > 1 || newFound.length > 1) { replier.reply(formatAdmin("오류", "중복 닉네임이 존재합니다. 정확한 풀네임을 입력해주세요.")); return true; }

        var oldId = oldFound[0].id;
        var oldData = oldFound[0].data;
        var newData = newFound[0].data;

        newData.point = oldData.point;
        newData.bank = oldData.bank;
        newData.tier = oldData.tier;
        newData.creditScore = oldData.creditScore;
        newData.totalAttendance = oldData.totalAttendance;
        newData.loan = oldData.loan;
        newData.stockHoldings = oldData.stockHoldings;
        newData.stockAvg = oldData.stockAvg;
        newData.icon = oldData.icon;
        newData.title = oldData.title;

        if (typeof uidCache !== 'undefined') {
            for (var key in uidCache) {
                if (uidCache[key] === oldId) delete uidCache[key];
            }
        }
        delete roomData.users[oldId];
        safeSaveData(data);
        replier.reply(formatAdmin("데이터 이전 성공", oldName + " ➔ " + newName + "\n모든 자산 및 등급이 이전되었습니다."));
        return true;
    }

    /* 유저 삭제 (사채 전액 보전 및 계약 강제 삭제 적용) */
    if (msg.indexOf("/유저삭제 ") === 0) {
        var tn = msg.substring(6).trim();
        var roomData = data.rooms[roomName];
        var found = findUserByName(roomData, tn);
        if (!found.length) { replier.reply(formatAdmin("오류", "대상 없음")); return true; }
        if (found.length > 1) { handleUserSelection(replier, targetUid, found, "admin_delete", null, user); return true; }
        
        var targetId = found[0].id;
        var targetData = found[0].data;
        var refundLog = "";
        var refundCount = 0;
        var totalRefunded = 0;

        // [수정] 출석일수 관계없이 모든 사채 계약 강제 정산 및 삭제
        if (roomData.loanContracts) {
            for (var cid in roomData.loanContracts) {
                var c = roomData.loanContracts[cid];
                if (c.borrowerUid === targetId) {
                    var lender = roomData.users[c.lenderUid];
                    if (lender) {
                        var debtAmt = Number(c.currentDebt);
                        lender.point = Number(lender.point) + debtAmt;
                        totalRefunded += debtAmt;
                        refundCount++;
                        try { Api.replyRoom(roomName, "🚬 [사채 강제 정산]\n" + targetData.name + "님의 데이터 삭제로 인해 " + lender.name + "님께 미수금 " + fp(debtAmt) + "P가 전액 반환되었습니다."); } catch(e){}
                    }
                    delete roomData.loanContracts[cid]; // 계약서 강제 파기
                }
            }
        }

        // [신규] 은행 대출금 국고 회수 (폐쇄형 경제 안정화)
        if (targetData.loan && Number(targetData.loan.debt) > 0) {
            var bankDebt = Number(targetData.loan.debt);
            roomData.bankReserve = (Number(roomData.bankReserve) || 0) + bankDebt;
            refundLog += "\n🏦 은행 대출금 " + fp(bankDebt) + "P가 국고로 자동 회수되었습니다.";
        }

        if (refundCount > 0) refundLog += "\n⚠️ 사채 보전 완료: " + refundCount + "건 (" + fp(totalRefunded) + "P)";

        if (typeof uidCache !== 'undefined') {
            for (var key in uidCache) {
                if (uidCache[key] === targetId) delete uidCache[key];
            }
        }
        delete roomData.users[targetId];
        safeSaveData(data);
        replier.reply(formatAdmin("유저 삭제 완료", "[" + targetData.name + "]님의 데이터를 영구 삭제했습니다." + refundLog));
        return true;
    }

    /* 유저 부분 복원 */
    if (msg.indexOf("/유저복원 ") === 0) {
        var tn = msg.substring(6).trim();
        var roomData = data.rooms[roomName];
        var found = findUserByName(roomData, tn);
        if (found.length > 1) { handleUserSelection(replier, targetUid, found, "user_restore", null, user); return true; }
        if (found.length === 0) { replier.reply(formatAdmin("오류", "유저를 찾을 수 없습니다.")); return true; }

        var targetId = found[0].id;
        var stablePath = BACKUP_DIR + "last_stable_backup.json";
        var backupData = JSON.parse(FileStream.read(stablePath));
        var restored = false;
        
        for (var r in backupData.rooms) {
            if (backupData.rooms[r].users[targetId]) {
                roomData.users[targetId] = backupData.rooms[r].users[targetId];
                restored = true;
                if (typeof uidCache !== 'undefined') {
                    for (var key in uidCache) {
                        if (uidCache[key] === targetId) delete uidCache[key];
                    }
                }
                break;
            }
        }
        
        if(restored) { safeSaveData(data); replier.reply(formatAdmin("완료", "특정 유저 데이터 복구 완료")); }
        else replier.reply(formatAdmin("실패", "백업 본에 해당 유저가 없습니다."));
        return true;
    }

    return false;
}

//==========섹터35==========

/**
 * [관리자 하위 모듈 4] 경제 및 포인트 관리
 * 기능: 경제지표, 데이터교정, 물가조정, 포인트 지급/차감/뿌리기, 각종 초기화, 재원수정 및 충전, 자가복원
 */
function _adminEconomyLogic(msg, user, data, replier, roomName, targetUid) {

    /* [1] 은행 가용 재원 수동 수정 (강제 설정) */
    if (msg.indexOf("/재원수정 ") === 0) {
        var val = parseInt(msg.split(" ")[1].replace(/,/g, ""));
        if (isNaN(val)) {
            replier.reply(formatAdmin("오류", "수정할 금액을 숫자로 입력하세요.\n예) /재원수정 3000"));
            return true;
        }

        var roomData = data.rooms[roomName];
        if (!roomData) return true;
        
        roomData.bankReserve = val;
        safeSaveData(data);
        
        replier.reply(formatAdmin("🏦 은행 재원 수정 완료", 
            "현재 방의 가용 재원이 수정되었습니다.\n\n" +
            "💰 설정 금액: " + fp(val) + "P\n" +
            "📢 이제 유저들이 이 금액 내에서 대출 가능합니다."));
        return true;
    }

    /* [신규] 은행 긴급 재원 충전 (기존 잔액에 추가 합산) */
    if (msg.indexOf("/재원충전 ") === 0) {
        var val = parseInt(msg.split(" ")[1].replace(/,/g, ""));
        if (isNaN(val) || val <= 0) {
            replier.reply(formatAdmin("오류", "충전할 금액을 양의 숫자로 입력하세요.\n예) /재원충전 100000"));
            return true;
        }
        var roomData = data.rooms[roomName];
        if (!roomData) return true;

        if (roomData.bankReserve === undefined || roomData.bankReserve === null) roomData.bankReserve = 0;
        roomData.bankReserve += val;
        
        safeSaveData(data);
        
        var resMsg = "결과: 국고 보충 완료\n" +
                     "수혈 금액: +" + fp(val) + "P\n" +
                     "🏦 현재 금고 총액: " + fp(roomData.bankReserve) + "P";
        
        replier.reply(formatAdmin("⚙️ 중앙은행 긴급 재원 수혈", resMsg));
        return true;
    }

   /* [2] 특정 종목 신규 상장/부활 명령어 */
    if (msg.indexOf("/종목추가 ") === 0) {
        var parts = msg.split(" ");
        if (parts.length < 3) {
            replier.reply(formatAdmin("오류", "형식: /종목추가 [종목명] [가격]"));
            return true;
        }
        var name = parts[1];
        var price = parseInt(parts[2].replace(/,/g, ""));
        if (isNaN(price)) {
            replier.reply(formatAdmin("오류", "가격은 숫자로 입력해주세요."));
            return true;
        }

        data.stockMarket[name] = {
            price: price, lastPrice: price, type: assignStockType(), 
            delistTick: 0, delistLimit: 5, trend: "none", trendTick: 0
        };

        safeSaveData(data);
        replier.reply(formatAdmin("📈 종목 추가 완료", "[" + name + "] 종목이 " + fp(price) + "P로 상장되었습니다."));
        return true;
    }

    /* [관리자] 특정 종목 이름 및 가격 수정 */
    if (msg.indexOf("/종목수정 ") === 0) {
        var parts = msg.split(" ");
        if (parts.length < 4) {
            replier.reply(formatAdmin("오류", "형식: /종목수정 [기존이름] [새이름] [새가격]"));
            return true;
        }
        var oldName = parts[1];
        var newName = parts[2];
        var newPrice = parseInt(parts[3].replace(/,/g, ""));

        if (!data.stockMarket[oldName]) {
            replier.reply(formatAdmin("오류", "[" + oldName + "] 종목을 찾을 수 없습니다."));
            return true;
        }

        var stockData = data.stockMarket[oldName];
        stockData.price = newPrice;
        stockData.lastPrice = newPrice;
        
        if (oldName !== newName) {
            data.stockMarket[newName] = stockData;
            delete data.stockMarket[oldName];
            
            var fixCount = 0;
            for (var r in data.rooms) {
                var users = data.rooms[r].users;
                for (var uid in users) {
                    var u = users[uid];
                    if (u.stockHoldings && u.stockHoldings[oldName] !== undefined) {
                        u.stockHoldings[newName] = u.stockHoldings[oldName];
                        delete u.stockHoldings[oldName];
                        if (u.stockAvg && u.stockAvg[oldName] !== undefined) {
                            u.stockAvg[newName] = u.stockAvg[oldName];
                            delete u.stockAvg[oldName];
                        }
                        fixCount++;
                    }
                }
            }
        }

        safeSaveData(data);
        var res = "✅ 수정 완료: " + oldName + " ➔ " + newName + "\n💰 가격: " + fp(newPrice) + "P";
        if (oldName !== newName) res += "\n👥 유저 데이터 이전: " + fixCount + "명";
        
        replier.reply(formatAdmin("주식 시장 개입", res));
        return true;
    }

    /* [3] 유저 보유 자산 기반 시장 재건 */
    if (msg === "/시장자산복구") {
        var roomData = data.rooms[roomName];
        if (!roomData) return true;
        var recoveredCount = 0;
        
        for (var uid in roomData.users) {
            var u = roomData.users[uid];
            if (u.stockHoldings) {
                for (var sName in u.stockHoldings) {
                    if (!data.stockMarket[sName] || data.stockMarket[sName].price <= 10) {
                        var type = assignStockType();
                        var recoverPrice = Number(u.stockAvg ? u.stockAvg[sName] : 1000) || 1000;
                        
                        data.stockMarket[sName] = {
                            price: recoverPrice,
                            lastPrice: recoverPrice,
                            type: type,
                            delistTick: 0,
                            delistLimit: 5,
                            trend: "none",
                            trendTick: 0
                        };
                        recoveredCount++;
                    }
                }
            }
        }

        marketOpenPrice = 1000;
        data.marketOpenPrice = 1000;
        safeSaveData(data);
        
        var resMsg = "✅ [자산 기반 시장 복구 완료]\n" +
                     "- 부활시킨 종목 수: " + recoveredCount + "개\n" +
                     "- 복구 기준: 유저 보유 평단가 반영\n" +
                     "- 시가 정상화: 1,000P 설정";
        replier.reply(formatAdmin("시스템 복구 보고", resMsg));
        return true;
    }

    /* [4] 경제 지표 상세 조회 */
    if (msg === "/경제정보") {
        var eco = calculateEconomy(data, roomName);
        var rData = data.rooms[roomName];
        var base = rData.economyBase || 0;
        
        var multiplier = 1.0;
        if (base > 0) {
            var rawRatio = eco.total / base;
            var damping = (data.economyDamping !== undefined) ? data.economyDamping : 0.5;
            multiplier = 1 + (rawRatio - 1) * damping;
            if (multiplier < 0.5) multiplier = 0.5;
        }

        var ecoMsg = "💰 총 순자산: " + fp(eco.total) + "P\n" +
                     "🏦 은행 재고: " + fp(rData.bankReserve || 0) + "P\n" +
                     "⚖️ 물가 기준점: " + (base > 0 ? fp(base) + "P" : "설정 없음") + "\n" +
                     "📈 현재 물가 배율: x" + multiplier.toFixed(2) + "\n" +
                     "👥 활성 유저수: " + eco.count + "명\n" +
                     "💎 유저당 평균자산: " + fp(eco.average) + "P";

        replier.reply(formatAdmin("실시간 경제 리포트", ecoMsg));
        return true;
    }

    /* [5] 데이터 교정 및 무결성 검사 */
    if (msg.trim() === "/데이터교정") {
        var fixCount = 0;
        var refundCount = 0;
        var totalRefunded = 0;

        for (var r in data.rooms) {
            var currentRoom = data.rooms[r];
            if (!currentRoom.loanPools) currentRoom.loanPools = {};
            if (!currentRoom.loanContracts) currentRoom.loanContracts = {};

            for (var id in currentRoom.users) {
                var u = currentRoom.users[id];
                if (!u) continue;

                if (Number(u.totalAttendance || 0) <= 3) {
                    for (var cid in currentRoom.loanContracts) {
                        var c = currentRoom.loanContracts[cid];
                        if (c.borrowerUid === id) {
                            var lender = currentRoom.users[c.lenderUid];
                            if (lender) {
                                lender.point = Number(lender.point) + Number(c.currentDebt);
                                totalRefunded += Number(c.currentDebt);
                                refundCount++;
                            }
                            delete currentRoom.loanContracts[cid];
                        }
                    }
                }
                u.point = Math.floor(Number(u.point || 0));
                u.bank = Math.floor(Number(u.bank || 0));
                u.creditScore = Math.min(1000, Math.max(0, Number(u.creditScore || 600)));
                u.isDefaulter = (u.creditScore < 500);
                if (!u.loan) u.loan = { debt: 0, items: [] };
                if (!u.stockHoldings) u.stockHoldings = {};
                fixCount++;
            }
        }
        
        safeSaveData(data);
        var resMsg = "전체 유저 " + fixCount + "명 동기화 완료\n" +
                     "📉 사채 환수: " + refundCount + "건 (" + fp(totalRefunded) + "P 반환)";
        replier.reply(formatAdmin("데이터 교정 및 분리 완료", resMsg));
        return true;
    }

    /* [6] 물가 조정 */
    if (msg.indexOf("/물가조정") === 0) {
        var args = msg.split(" ");
        var currentEco = calculateEconomy(data, roomName); 
        if (args[1] === "초기화") { data.rooms[roomName].economyBase = 0; safeSaveData(data); replier.reply(formatAdmin("⚖️ 물가 초기화", "기본가로 고정됩니다.")); return true; }
        var oldBase = data.rooms[roomName].economyBase || currentEco.total;
        var newBase = (args.length > 1 && !isNaN(parseInt(args[1]))) ? parseInt(args[1]) : Math.floor(Math.sqrt(oldBase * currentEco.total));
        data.rooms[roomName].economyBase = newBase;
        safeSaveData(data);
        replier.reply(formatAdmin("⚖️ 물가 조정 완료", "새 기준: " + fp(newBase) + "P"));
        return true;
    }

    /* [7] 물가 완충 비율 설정 */
    if (msg.indexOf("/물가완충") === 0) {
        var val = parseFloat(msg.split(" ")[1]);
        if (isNaN(val) || val < 0.0 || val > 1.0) { replier.reply(formatAdmin("오류", "0.0 ~ 1.0 사이의 소수를 입력하세요.")); return true; }
        data.economyDamping = val;
        safeSaveData(data);
        replier.reply(formatAdmin("🛡️ 물가 완충 설정 완료", "적용 비율: " + (val*100) + "%"));
        return true;
    }

    /* [8] 포인트 지급 */
    if (msg.indexOf("/포인트지급 ") === 0) {
        var parts = msg.trim().split(/\s+/);
        if (parts.length < 3) { replier.reply(formatError(user, "형식 오류", "/포인트지급 [닉네임] [금액]")); return true; }
        var am = parseInt(parts.pop());
        var tn = parts.slice(1).join(" ").trim();
        var roomData = data.rooms[roomName];
        var found = findUserByName(roomData, tn);
        if (found.length === 0) { replier.reply(formatError(user, "대상 없음", "[" + tn + "]님을 찾을 수 없습니다.")); return true; }
        if (found.length > 1) { handleUserSelection(replier, targetUid, found, "admin_point_give", { amount: am }, user); return true; }
        
        var targetUser = found[0].data;
        util_updatePoint(targetUser, null, am, "관리자 직접 지급", roomName);
        replier.reply(formatAdmin("포인트 지급 완료", getDisplayName(targetUser) + "님: +" + fp(am) + "P"));
        safeSaveData(data);
        return true;
    }

    /* [9] 포인트 차감 */
    if (msg.indexOf("/포인트차감 ") === 0) {
        var parts = msg.trim().split(/\s+/);
        if (parts.length < 3) { replier.reply(formatError(user, "형식 오류", "/포인트차감 [닉네임] [금액]")); return true; }
        var am = parseInt(parts.pop());
        var tn = parts.slice(1).join(" ").trim();
        var roomData = data.rooms[roomName];
        var found = findUserByName(roomData, tn);
        if (found.length === 0) { replier.reply(formatError(user, "대상 없음", "[" + tn + "]님을 찾을 수 없습니다.")); return true; }
        if (found.length > 1) { handleUserSelection(replier, targetUid, found, "admin_point_take", { amount: am }, user); return true; }
        
        var targetUser = found[0].data;
        util_updatePoint(targetUser, null, -am, "관리자 직접 차감", roomName);
        replier.reply(formatAdmin("포인트 차감 완료", getDisplayName(targetUser) + "님: -" + fp(am) + "P"));
        safeSaveData(data);
        return true;
    }

    /* [10] 전체 포인트 지급 */
    if (msg.indexOf("/전체포인트지급 ") === 0) {
        var amt = parseInt(msg.split(" ")[1]);
        if (isNaN(amt)) return true;
        var count = 0;
        for (var r in data.rooms) {
            for (var id in data.rooms[r].users) {
                data.rooms[r].users[id].point = Number(data.rooms[r].users[id].point) + amt;
                count++;
            }
        }
        safeSaveData(data);
        replier.reply(formatAdmin("전체 지급 완료", "총 " + count + "명에게 " + fp(amt) + "P 지급 완료"));
        return true;
    }

    /* [11] 포인트 뿌리기 */
    if (msg === "/뿌리기") {
        if (sprinkleData.active) { replier.reply(formatAdmin("오류", "이미 뿌리기가 진행 중입니다.")); return true; }
        var roomData = data.rooms[roomName];
        var count = Math.floor(Math.random() * 3) + 2; 
        var multiplier = 1.0;
        if (roomData.economyBase && roomData.economyBase > 0) {
            var eco = calculateEconomy(data, roomName);
            multiplier = 1 + (eco.total / roomData.economyBase - 1) * (data.economyDamping || 0.5);
        }
        var portions = [];
        var totalSprinkle = 0;
        for(var i=0; i<count; i++) {
            var baseP = Math.floor(Math.random() * 501) + 500; 
            var finalP = Math.floor(baseP * multiplier);
            portions.push(finalP);
            totalSprinkle += finalP;
        }
        sprinkleData = { active: true, totalPoint: totalSprinkle, remainingPoint: totalSprinkle, limit: count, currentWinners: 0, winners: [], portions: portions };
        Api.replyRoom(roomName, formatAdmin("🎉 포인트 뿌리기 시작!", "선착순 " + count + "명!\n채팅창에 [줍기]를 입력하세요!\n💰 총 배정: " + fp(totalSprinkle) + "P"));
        setTimeout(function() { if (sprinkleData.active) { sprinkleData.active = false; Api.replyRoom(roomName, formatAdmin("🏁 뿌리기 시간 초과", "이벤트가 종료되었습니다.")); } }, 60000);
        return true;
    }

    /* [12] 시스템 초기화 세트 */
    if (msg === "/로또데이터초기화") {
        data.lotto = { round: (data.lotto.round || 0) + 1, entries: {}, dailyPool: 0, jackpot: 0, lastWinNums: [] };
        safeSaveData(data);
        replier.reply(formatAdmin("완료", "로또 시스템 리셋 완료"));
        return true;
    }
    if (msg === "/승급횟수초기화") {
        for (var r in data.rooms) {
            for (var id in data.rooms[r].users) {
                data.rooms[r].users[id].dailyPromotionAttempts = 1;
                data.rooms[r].users[id].purchasedPromotionAttempts = 0;
            }
        }
        safeSaveData(data);
        replier.reply(formatAdmin("완료", "전체 승급 기회 초기화"));
        return true;
    }
    if (msg === "/시즌강제종료") {
        for (var r in data.rooms) {
            for (var id in data.rooms[r].users) { data.rooms[r].users[id].tier = 0; }
        }
        safeSaveData(data);
        replier.reply(formatAdmin("완료", "모든 유저 티어 초기화"));
        return true;
    }

    /* [13] 시스템 자가 복원 (딥 옵티마이징 버전) */
    if (msg.trim() === "/시스템자가복원") {
        // 1. 휘발성 상태값 및 활동 락(Lock) 일괄 해제
        lottoPurchaseState = {}; 
        sprinkleData = { active: false, winners: [] };
        activeThefts = {}; 
        duelData = {}; 
        selectWaitState = {};
        bankProcessState = {}; 
        menuWaitState = {};
        miningState = {}; // 광산 활동 초기화
        feverData = { active: false, endTime: 0, scheduled: [] }; // 피버타임 상태 초기화

        // 2. UID 캐시 초기화 (메모리 정리)
        if (typeof uidCache !== 'undefined') uidCache = {};

        // 3. 시스템 핵심 경제 지표 복구
        if (!data.marketOpenPrice || data.marketOpenPrice <= 0) data.marketOpenPrice = 1000;
        marketOpenPrice = data.marketOpenPrice; // 전역 변수 동기화

        // 4. 전 유저 데이터 수치 정규화 및 필수 필드 복구
        var fixCount = 0;
        for (var r in data.rooms) {
            var roomObj = data.rooms[r];
            
            // 중앙은행 재원 누락 시 복구
            if (roomObj.bankReserve === undefined || roomObj.bankReserve === null) {
                roomObj.bankReserve = SYSTEM_CONFIG.ECO.BANK.INITIAL_RESERVE;
            }
            // 위기 알림 상태 리셋
            roomObj.lastBankAlert = "normal";

            for (var id in roomObj.users) {
                var u = roomObj.users[id];
                if (!u) continue;
                u.point = Math.floor(Number(u.point || 0));
                u.bank = Math.floor(Number(u.bank || 0));
                u.creditScore = Math.min(1000, Math.max(0, Number(u.creditScore || 600)));
                
                if (!u.loan) u.loan = { debt: 0, items: [] };
                if (!u.stockHoldings) u.stockHoldings = {};
                fixCount++;
            }
        }

        // 5. 파일 시스템 락(Lock) 강제 해제 시도
        if (lock.isLocked()) {
            try { lock.unlock(); } catch(e) {}
        }

        safeSaveData(data);
        replier.reply(formatAdmin("⚙️ 시스템 자가 복원 완료", 
            "1. 모든 입력 대기 및 활동 상태 초기화\n" +
            "2. 중앙은행 재원 및 주식 시세 지표 복구\n" +
            "3. 국가 위기 알림 엔진 리셋\n" +
            "4. 유저 " + fixCount + "명의 데이터 정수화 완료"));
        return true;
    }

    if (msg.trim() === "/전체복원") {
        var stablePath = BACKUP_DIR + "last_stable_backup.json";
        if (!new java.io.File(stablePath).exists()) { replier.reply(formatAdmin("오류", "백업 파일 유실")); return true; }
        var content = FileStream.read(stablePath);
        FileStream.write(FILE_PATH, content);
        globalData = JSON.parse(content);
        replier.reply(formatAdmin("성공", "데이터 전체 롤백 성공"));
        return true;
    }

    return false;
}

//==========섹터36==========

/**
 * [게임 명령어 분배기] (Game Logic Dispatcher - Registry Refactored)
 * 설명: 유저들의 게임/경제 활동 명령어를 각 전문 담당 함수로 연결합니다.
 * 섹터 1의 USER_COMMANDS 레지스트리를 참조하여 등록된 로직을 자동으로 매핑 및 실행합니다.
 */
function _handleGameLogic(msg, user, data, replier, roomName, targetUid, sender) {
    
    // 1. 명령어 첫 단어 추출 (예: "/홀짝 100" -> "/홀짝")
    var cmd = msg.split(" ")[0];

    // 2. 유저 명령어 레지스트리(USER_COMMANDS)에서 해당 명령어 검색
    // 섹터 6에서 등록된 정보를 바탕으로 최적화된 탐색을 수행합니다.
    if (USER_COMMANDS[cmd] && typeof USER_COMMANDS[cmd].execute === 'function') {
        
        // 3. 등록된 하위 로직 함수(섹터 40~44 및 로또/광산/가방 등)를 즉시 실행 및 결과 반환
        // 실행 시 필요한 모든 컨텍스트 객체를 인자로 전달하여 위임합니다.
        return USER_COMMANDS[cmd].execute(msg, user, data, replier, roomName, targetUid);
    }

    // 4. 등록되지 않은 명령어이거나 처리할 로직이 없는 경우 false 반환
    return false;
}

//==========섹터37==========

/**
 * [게임 하위 모듈 1] 은행 및 사채 관리
 * 기능: 은행 메뉴 호출, 대출금 직접 상환
 * 설명: 메뉴 UI에 기부 항목을 추가하고, 상환 시 중앙은행 재고로 환수되도록 연동함.
 */
function _gameBankLogic(msg, user, data, replier, roomName, targetUid) {
    var roomData = data.rooms[roomName];
    if (!roomData) return false;

    /* [기능 1] 은행 시스템 진입 (v5.2 기부 메뉴 추가) */
    if (msg === "/은행") {
        menuWaitState[targetUid] = { type: 'bank_menu', time: Date.now() };
        var bankMenu = "1. 💰 예금 (포인트 ➔ 은행)\n" +
                       "2. 🏧 출금 (은행 ➔ 포인트)\n" +
                       "3. 💸 송금 (타인에게 이체)\n" +
                       "4. 🏦 대출 (신용등급별)\n" +
                       "5. 📉 상환 (대출금 갚기)\n" +
                       "6. " + (SYSTEM_CONFIG.MSG.PREFIX.LOAN || "🚬") + " 사채 시장 (P2P 대출)\n" +
                       "7. 🎁 기부 (국고 후원)"; // [신규] 기부 항목 추가
        
        var myPoint = Number(user.point || 0);
        var myBank = Number(user.bank || 0);
        
        var content = bankMenu + "\n\n" +
               "🏦 은행 잔고 : " + fp(roomData.bankReserve) + "P\n\n" +
               "보유: " + fp(myPoint) + "P / 예금: " + fp(myBank) + "P\n" +
               "(번호를 선택해주세요)";

        // formatCommand를 호출하여 최종 메시지 조립
        replier.reply(formatCommand("🏦 은행 업무 선택", user, content, "입력 대기: 30초"));
        return true;
    }

    /* [기능 2] 대출금 상환 (직접 명령어) */
    if (msg.indexOf("/상환 ") === 0) {
        var myDebt = (user.loan && user.loan.debt) ? Number(user.loan.debt) : 0;
        if (myDebt <= 0) { 
            replier.reply(formatError(user, "상환 불가", "갚아야 할 은행 대출금이 존재하지 않습니다.")); 
            return true; 
        }

        var parts = msg.split(" ");
        // 쉼표가 포함된 입력도 처리 가능하도록 개선
        var amt = parseInt(parts[1].replace(/,/g, "")); 
        
        if (isNaN(amt) || amt <= 0) { 
            replier.reply(formatError(user, "금액 오류", "정확한 상환 금액을 입력하세요.")); 
            return true; 
        }
        
        var myPoint = Number(user.point || 0);
        if (myPoint < amt) { 
            replier.reply(formatError(user, "포인트 부족", "보유 포인트가 부족합니다.")); 
            return true; 
        }
        
        // 분산 상환 로직 호출 (섹터 13 정의)
        var res = distributeRepayment(user, amt);
        
        /* [중앙은행 연동] 통합 포인트 함수 사용 */
        // 유저 포인트 차감과 동시에 차감된 금액(res.actualRepay)이 bankReserve에 자동 입금됨.
        util_updatePoint(user, roomData, -Number(res.actualRepay), "대출 상환");
        
        var remainingDebt = (user.loan && user.loan.debt) ? Number(user.loan.debt) : 0;
        replier.reply(formatCommand("📉 상환 완료", user, fp(res.actualRepay) + "P 상환되었습니다.\n(신용 점수 +" + res.creditGain + ")", "남은 대출: " + fp(remainingDebt) + "P / 잔액: " + fp(user.point) + "P"));
        
        safeSaveData(data);
        return true;
    }

    return false;
}

//==========섹터38==========

/**
 * [게임 하위 모듈 2] 정보 및 랭킹 조회 (UI 최적화 및 출석 상태 추가)
 * 기능: 내정보, 유물도감, 신용등급, 대출한도, 명예의전당, 순위, 유저정보, 경마조회
 * 수정 사항: 주식자산 표시 제거, 오늘 출석 여부(✅/⏳) 표시 추가
 */
function _gameInfoLogic(msg, user, data, replier, roomName, targetUid) {
    var roomData = data.rooms[roomName];

    /* [Gemini 요청 사항] 경마 정보 실시간 브리핑 기능 통합 */
    if (msg === "/경마") {
        if (!racingData.isOperating) {
            replier.reply(formatSimple("🏇 경마장 휴장 안내", "현재 경마 운영 시간이 아닙니다.\n(운영시간: 09:00 ~ 23:59)", "오전 9시 정각에 개장합니다."));
            return true;
        }

        var hList = racingData.horses.map(function(h) {
            var horseBetSum = 0;
            for (var uid in racingData.bets) {
                if (racingData.bets[uid].horseId === h.id) horseBetSum += Number(racingData.bets[uid].amount);
            }
            return h.id + ". " + h.name + " [" + h.icon + "]\n    └ 현 배팅액: " + fp(horseBetSum) + "P";
        }).join("\n");

        var now = new Date();
        var remainMin = 49 - now.getMinutes();
        var remainSec = 59 - now.getSeconds();
        if (remainMin < 0) { remainMin = 0; remainSec = 0; }

        var totalPrizePool = racingData.totalPool + racingData.carryOver;
        var racingBody = "제 " + racingData.round + "회차 경기 배팅 진행 중\n\n" +
                         "[🏇 출전마 라인업]\n" + hList + "\n\n" +
                         "💰 현재 총 배당금: " + fp(totalPrizePool) + "P\n" +
                         (racingData.carryOver > 0 ? "✨ 이월 적립금: " + fp(racingData.carryOver) + "P 포함\n" : "") +
                         "🕒 배팅 마감: " + remainMin + "분 " + remainSec + "초 남음";

        replier.reply(formatCommand("🏇 내리다 중앙 경마장", user, racingBody, "배팅: [/배팅 번호 금액]"));
        return true;
    }

    /* [기능 3] 내 정보 조회 (주식자산 제거 및 출석 상태 반영 버전) */
    if (msg === "/내정보") {
        var cr = getCreditInfo(user.creditScore);
        var authInfo = "🎮 게임 인증: " + (user.gameAuthCount || 0) + "/2 (시즌)";
        
        // 1. 부채 및 채권 계산
        var bankDebt = (user.loan && user.loan.debt) ? Math.floor(Number(user.loan.debt)) : 0;
        var sacheDebt = 0;
        var sacheClaims = 0; 
        var overdueSache = 0;

        if (roomData && roomData.loanContracts) {
            for (var cid in roomData.loanContracts) {
                var c = roomData.loanContracts[cid];
                if (c.borrowerUid === targetUid) {
                    sacheDebt += Math.floor(c.currentDebt);
                    if (c.status === 'overdue') overdueSache += Math.floor(c.currentDebt);
                }
                if (c.lenderUid === targetUid) {
                    sacheClaims += Math.floor(c.currentDebt);
                }
            }
        }

        // 2. 오늘 출석 여부 및 승급 기회 계산 (오류 수정 지점)
        var todayStr = getSimpleDate();
        var attendMark = (user.lastDate === todayStr) ? " (✅)" : " (⏳)";
        // 승급 기회 합산 변수 선언
        var totalPromotion = (Number(user.dailyPromotionAttempts) || 0) + (Number(user.purchasedPromotionAttempts) || 0);

        // 3. 정보 텍스트 구성
        var infoBody = authInfo + "\n" +
                       "💰 보유 포인트: " + fp(user.point) + "P\n" +
                       "🏦 예금: " + fp(user.bank) + "P\n" +
                       (sClaims > 0 ? "🤝 미수 채권: " + fp(sacheClaims) + "P\n" : "") +
                       "💳 신용 등급: " + cr.label + " (" + user.creditScore + "점)\n" +
                       "🏅 현재 티어: " + (TIERS[user.tier] || "아이언") + "\n" +
                       "📅 누적 출석: " + (user.totalAttendance || 0) + "일" + attendMark + "\n" +
                       "🔂 승급 기회: " + totalPromotion + "회";
        
        // 채무 보유 시에만 하단에 조건부 노출
        if (bankDebt > 0) {
            var transferTag = user.isTransferred ? " (🚨대환 채무: 70% 강제상환)" : "";
            infoBody += "\n🏦 미상환 대출: " + fp(bankDebt) + "P" + transferTag;
        }

        if (sacheDebt > 0) {
            infoBody += "\n🚬 미상환 사채: " + fp(sacheDebt) + "P";
            if (overdueSache > 0) infoBody += "\n🚨 사채 연체: " + fp(overdueSache) + "P (50% 자동상환)";
        }
        
        replier.reply(formatCommand("📌 내 상세 정보", user, infoBody, "아이템 구매: [/상점]")); 
        return true;
    }

    /* [유물 도감 조회] */
    if (msg === "/유물도감") {
        var pieces = Number(user.artifactPieces || 0);
        var conf = SYSTEM_CONFIG.ECO.MINE;
        var goal = conf.ARTIFACT_GOAL || 10;
        var chancePercent = (conf.ARTIFACT_CHANCE * 100).toFixed(2).replace(/\.?0+$/, "") + "%";
        var rewardStatus = (pieces >= goal) ? "🎖️ 칭호: [도굴왕] (획득 완료!)" : "🎖️ 칭호: [도굴왕] (진행 중...)";
        var content = pieces >= goal ? "" : "\n"; 
        content += "✨ 유물 조각 (Fragment)\n" +
                   "🧩 보유: " + pieces + " / " + goal + " 개\n\n" +
                   "🎁 수집 달성 보상\n" +
                   rewardStatus;
        var guide = "광산에서 " + chancePercent + " 확률로 조각이 발견됩니다. " + goal + "개를 모으면 자동으로 칭호가 부여됩니다.";
        replier.reply(formatCommand("🏺 유물 도감 (Artifacts)", user, content, guide));
        return true;
    }

    /* [신용 등급 및 대출 한도 조회] */
    if (msg === "/신용등급" || msg === "/대출한도") {
        var cr = getCreditInfo(user.creditScore);
        var table = getCreditLimitTable(); 
        var myCredit = "\n[내 신용 상태]\n점수: " + user.creditScore + "점\n등급: " + cr.label + "\n대출 가능 한도: " + fp(cr.limit) + "P";
        replier.reply(formatCommand("💳 신용 등급 및 한도", user, table + "\n" + myCredit, "은행 이용: [/은행]"));
        return true;
    }

    /* [명예의 전당] */
    if (msg === "/명예의전당") {
        var challengers = [];
        var roomUsers = roomData.users;
        for (var id in roomUsers) {
            var u = roomUsers[id];
            if (u && u.tier === 9) {
                var count = Math.max(1, u.challengerCount || 0);
                  challengers.push("🏆 " + u.name + " (누적 " + count + "회)");
            }
        }
        var content = challengers.length > 0 ? challengers.join("\n") : "현재 이 방에 등록된 챌린저가 없습니다.";
        replier.reply(formatSimple("🏅 명예의 전당", content, "최고 티어 달성 시 등록됩니다."));
        return true;
    }

    /* [자산 순위] */
    if (msg === "/출석순위") {
        var users = [];
        var roomUsers = roomData.users;
        for (var id in roomUsers) {
            var u = roomUsers[id];
            var netWorth = util_calculateNetWorth(u, roomData);
            if (netWorth >= 1) users.push({ data: u, total: netWorth });
        }
        users.sort(function(a, b) { return b.total - a.total; });
        var rankList = [];
        for (var i = 0; i < Math.min(10, users.length); i++) {
            rankList.push((i + 1) + ". " + getDisplayName(users[i].data) + " (" + fp(users[i].total) + "P)");
        }
        var rankMsg = (rankList.length > 0 ? rankList.join("\n") : "순위 데이터가 없습니다.");
        replier.reply(formatSimple("자산 랭킹 (실질 순자산 기준)", rankMsg, "내 정보: [/내정보]"));
        return true;
    }

    /* [타 유저 정보 조회] */
    if (msg.indexOf("/유저정보") === 0) {
        var tn = msg.substring(5).trim(); 
        if (tn === "") {
            replier.reply(formatError(user, "입력 오류", "조회할 유저의 닉네임을 입력하세요.\n(예: /유저정보 홍길동)"));
            return true;
        }
        var found = findUserByName(roomData, tn);
        if (found.length === 0) { 
            replier.reply(formatError(user, "대상 없음", "[" + tn + "]님을 찾을 수 없습니다.")); 
            return true; 
        }
        if (found.length === 1) {
            var targetUser = found[0].data;
            var targetIdInside = found[0].id;
            var cr = getCreditInfo(targetUser.creditScore);
            
            var sDebt = 0;
            var sClaims = 0;
            if (roomData.loanContracts) {
                for (var cid in roomData.loanContracts) {
                    var c = roomData.loanContracts[cid];
                    if (c.borrowerUid === targetIdInside) sDebt += Math.floor(c.currentDebt);
                    if (c.lenderUid === targetIdInside) sClaims += Math.floor(c.currentDebt);
                }
            }

            var info = "💰 포인트: " + fp(targetUser.point) + "P\n" +
                       "🏦 예금: " + fp(targetUser.bank) + "P\n" +
                       (sClaims > 0 ? "🤝 미수 채권: " + fp(sClaims) + "P\n" : "") +
                       "💳 신용: " + cr.label + " (" + targetUser.creditScore + "점)\n" +
                       "🏅 티어: " + (TIERS[targetUser.tier] || "아이언") + "\n" +
                       "📅 출석: " + (targetUser.totalAttendance || 0) + "일";
            
            var bDebt = (targetUser.loan && targetUser.loan.debt) ? Math.floor(Number(targetUser.loan.debt)) : 0;
            if (bDebt > 0) info += "\n🏦 미상환 대출: " + fp(bDebt) + "P";
            if (sDebt > 0) info += "\n🚬 미상환 사채: " + fp(sDebt) + "P";

            replier.reply(formatCommand("🔍 유저 상세 정보", targetUser, info, null));
        } else {
            handleUserSelection(replier, targetUid, found, "info", null, user);
        }
        return true;
    }

    return false;
}

//==========섹터39==========

/**
 * [게임 하위 모듈 3] 액션 및 도박 통합 분배기
 * 설명: 섹터 39(전체 분배기)로부터 호출받아, 실제 세부 로직(42-1 ~ 42-3)으로 연결합니다.
 * 이 구조를 통해 각 기능별로 독립적인 수정 및 관리가 가능해집니다.
 */
function _gameActionLogic(msg, user, data, replier, roomName, targetUid) {
    
    // 1. 홀짝 및 승급 로직 (섹터 42-1 위임)
    if (msg.indexOf("/홀짝 ") === 0 || msg === "/승급") {
        return _gameActionLogic_Part1(msg, user, data, replier, roomName, targetUid);
    }
    
    // 2. 결투 로직 (섹터 42-2 위임)
    if (msg.indexOf("/결투 ") === 0 || msg === "수락" || msg === "거절" || msg === "취소") {
        return _gameActionLogic_Part2(msg, user, data, replier, roomName, targetUid);
    }
    
    // 3. 도둑질 및 줍기 로직 (섹터 42-3 위임)
    if (msg.indexOf("/도둑질 ") === 0 || msg === "잡았다요놈" || msg === "줍기") {
        return _gameActionLogic_Part3(msg, user, data, replier, roomName, targetUid);
    }
    
    return false; // 해당되는 명령어가 없음
}

//==========섹터40==========

/**
 * [게임 하위 모듈 3-1] 액션 및 도박 게임 (홀짝 & 승급 & 경마 액션)
 * 설명: 독립된 함수로 구성하여 컴파일 오류를 방지하고 유지보수성을 높였습니다.
 * 수정 사항: 중앙은행 폐쇄형 경제 연동, 경마 배팅(/배팅) 및 취소(배팅취소) 로직 통합
 */
function _gameActionLogic_Part1(msg, user, data, replier, roomName, targetUid) {
    var roomData = data.rooms[roomName];
    if (!roomData) return false;

    // 중앙은행 재원 시스템 초기화
    if (roomData.bankReserve === undefined || roomData.bankReserve === null) {
        roomData.bankReserve = SYSTEM_CONFIG.ECO.BANK.INITIAL_RESERVE;
    }

    var rConf = SYSTEM_CONFIG.ECO.RACING; // 경마 설정 참조

    /* [Gemini 요청 사항] 1. 경마 배팅 액션 (/배팅 [번호] [금액]) */
    if (msg.indexOf("/배팅 ") === 0) {
        if (!racingData.isOperating) {
            replier.reply(formatError(user, "경마장 휴장", "현재 운영 시간이 아닙니다. (09:00 ~ 23:59)"));
            return true;
        }

        var nowMin = new Date().getMinutes();
        if (nowMin >= 50) {
            replier.reply(formatError(user, "배팅 마감", "현재 경기 정산 중입니다. 정각(00분) 이후 배팅하세요."));
            return true;
        }

        if (user.mining && user.mining.active) {
            replier.reply(formatError(user, "작업 중", "광산 채굴 중에는 배팅이 불가능합니다."));
            return true;
        }

        var ps = msg.split(" ");
        if (ps.length < 3) { replier.reply(formatError(user, "형식 오류", "/배팅 [말번호] [금액]")); return true; }
        
        var hId = parseInt(ps[1]);
        var betAmt = parseInt(ps[2].replace(/,/g, ""));

        // 유효성 검사 (마리 수 가변 대응)
        if (isNaN(hId) || hId < 1 || hId > racingData.horses.length) {
            replier.reply(formatError(user, "번호 오류", "1~" + racingData.horses.length + "번 사이의 말을 선택하세요."));
            return true;
        }

        // [Gemini 요청 사항] Eco-base 기반 동적 한도 계산
        var multiplier = 1.0;
        if (roomData.economyBase && roomData.economyBase > 0) {
            var eco = calculateEconomy(data, roomName);
            var rawRatio = eco.total / roomData.economyBase;
            var damping = (data.economyDamping !== undefined) ? data.economyDamping : 0.5;
            multiplier = 1 + (rawRatio - 1) * damping;
            if (multiplier < 0.5) multiplier = 0.5;
        }

        var minLimit = Math.floor(rConf.MIN_BET * multiplier);
        var maxLimit = Math.floor(rConf.MAX_BET * multiplier);

        if (isNaN(betAmt) || betAmt < minLimit) {
            replier.reply(formatError(user, "금액 미달", "현재 최소 배팅금은 " + fp(minLimit) + "P 입니다."));
            return true;
        }
        if (betAmt > maxLimit) {
            replier.reply(formatError(user, "한도 초과", "현재 최대 배팅금은 " + fp(maxLimit) + "P 입니다."));
            return true;
        }
        if (Number(user.point) < betAmt) {
            replier.reply(formatError(user, "포인트 부족", "보유 포인트가 부족합니다."));
            return true;
        }

        if (racingData.bets[targetUid]) {
            replier.reply(formatError(user, "중복 배팅 불가", "이미 배팅하셨습니다. 수정을 원하시면 [배팅취소] 후 다시 시도하세요."));
            return true;
        }

        // 배팅 실행 및 중앙은행 금고 입고
        util_updatePoint(user, roomData, -betAmt, "경마 배팅", roomName);
        
        var selectedHorse = racingData.horses[hId - 1];
        racingData.bets[targetUid] = { 
            uid: targetUid, 
            horseId: hId, 
            amount: betAmt, 
            name: user.name 
        };
        racingData.totalPool += betAmt;

        replier.reply(formatCommand("✅ [경마 배팅 완료]", user, "🏇 선택: " + selectedHorse.id + "번 " + selectedHorse.name + "\n💰 금액: " + fp(betAmt) + "P 배팅 성공!", "내 잔액: " + fp(user.point) + "P"));
        safeSaveData(data);
        return true;
    }

    /* [Gemini 요청 사항] 2. 경마 배팅 취소 (배팅취소) */
    if (msg === "배팅취소") {
        if (!racingData.isOperating) return false;
        
        var nowMin = new Date().getMinutes();
        if (nowMin >= 50) {
            replier.reply(formatError(user, "취소 불가", "정산이 시작되어 배팅을 취소할 수 없습니다."));
            return true;
        }

        var myBet = racingData.bets[targetUid];
        if (!myBet) {
            replier.reply(formatError(user, "내역 없음", "이번 회차에 배팅한 기록이 없습니다."));
            return true;
        }

        // [Gemini 요청 사항] 취소 수수료 10% 적용
        var fee = Math.floor(myBet.amount * rConf.CANCEL_FEE);
        var refund = myBet.amount - fee;

        // 환불 처리 (수수료는 금고에 남음)
        util_updatePoint(user, roomData, refund, "경마 배팅 취소", roomName);
        
        racingData.totalPool -= myBet.amount;
        delete racingData.bets[targetUid];

        var cancelMsg = "경마 배팅을 철회했습니다.\n\n💰 원래 배팅금: " + fp(myBet.amount) + "P\n" +
                         "⚖️ 취소 수수료(10%): -" + fp(fee) + "P\n" +
                         "🎁 최종 환불액: " + fp(refund) + "P";
        
        replier.reply(formatCommand("🚫 배팅 취소 완료", user, cancelMsg, "내 잔액: " + fp(user.point) + "P"));
        safeSaveData(data);
        return true;
    }

    /* [기존 로직 유지] 홀짝 도박 */
    if (msg.indexOf("/홀짝 ") === 0) {
        startTracking(user, "홀짝 게임");
        try {
            if (user.mining && user.mining.active) {
                endTracking(user, false, "광산 채굴 중");
                replier.reply(formatError(user, "작업 중", "광산에서 채굴 중에는 홀짝을 할 수 없습니다."));
                return true;
            }
            if (data.gambleLimit) {
                endTracking(user, false, "도박 제한 상태");
                replier.reply(formatError(user, "시스템 제한", "현재 관리자에 의해 도박 시스템이 비활성화되었습니다."));
                return true;
            }
            var ps = msg.split(" ");
            if (ps.length < 3) { replier.reply(formatError(user, "형식 오류", "/홀짝 [홀|짝] [금액]")); return true; }
            var pick = ps[1];
            var bet = parseInt(ps[2].replace(/,/g, ""));
            
            if (pick !== "홀" && pick !== "짝") { 
                replier.reply(formatError(user, "입력 오류", "홀 또는 짝만 선택 가능합니다.")); 
                return true; 
            }
            
            var multiplier = 1.0;
            if (roomData.economyBase && roomData.economyBase > 0) {
                var eco = calculateEconomy(data, roomName);
                var rawRatio = eco.total / roomData.economyBase;
                var damping = (data.economyDamping !== undefined) ? data.economyDamping : 0.5;
                multiplier = 1 + (rawRatio - 1) * damping;
                if (multiplier < 0.5) multiplier = 0.5;
            }

            var minBet = Math.floor((SYSTEM_CONFIG.ECO.GAMBLE_MIN || 300) * multiplier);
            var maxBet = Math.floor((SYSTEM_CONFIG.ECO.GAMBLE_MAX || 2000) * multiplier);

            if (isNaN(bet) || bet < minBet) { replier.reply(formatError(user, "금액 오류", "최소 " + fp(minBet) + "P 이상 베팅해야 합니다.")); return true; }
            if (bet > maxBet) { replier.reply(formatError(user, "배팅 상한액 초과", "배팅 금액은 최대 " + fp(maxBet) + "P까지 가능합니다.")); return true; }
            if (Number(user.point) < bet) { replier.reply(formatError(user, "포인트 부족", "베팅할 포인트가 부족합니다.")); return true; }

            var expectedPayout = Math.floor(bet * 0.9);
            if (roomData.bankReserve < expectedPayout) {
                replier.reply(formatError(user, "은행 자금 부족", "죄송합니다. 현재 은행 금고의 현금 부족으로 도박판을 열 수 없습니다.\n🏦 현재 금고: " + fp(roomData.bankReserve) + "P"));
                return true;
            }
            
            var isFeverActive = (data.feverData && data.feverData.active === true);
            var winProb = isFeverActive ? SYSTEM_CONFIG.PROB.ODD_EVEN_FEVER : SYSTEM_CONFIG.PROB.ODD_EVEN_WIN;
            var isWin = Math.random() < winProb; 
            var result = isWin ? pick : (pick === "홀" ? "짝" : "홀");
            
            user.dailyGambleCount = (user.dailyGambleCount || 0) + 1;
            var creditPenalty = (user.dailyGambleCount > 10) ? 1 : 0;
            if (creditPenalty > 0) {
                user.creditScore = Math.max(0, Number(user.creditScore || 600) - creditPenalty);
                checkAndHandleDefaulter(user, roomName);
            }

            if (user.totalGambleCount === undefined) user.totalGambleCount = 0;
            if (user.totalGambleWins === undefined) user.totalGambleWins = 0;
            user.totalGambleCount++;

            if (isWin) {
                user.totalGambleWins++;
                var res = processRepayment(user, expectedPayout, targetUid, roomName);
                util_updatePoint(user, roomData, Number(res.actualGain), "홀짝 적중", roomName);
                var winPrefix = isFeverActive ? "🔥 [피버] " : "🎊 ";
                replier.reply(formatCommand(winPrefix + "홀짝 적중!", user, "결과: [" + result + "]\n축하합니다! " + fp(Number(res.actualGain)) + "P를 획득했습니다." + res.repayMsg, "현재 잔액: " + fP(user.point) + "P"));
            } else {
                util_updatePoint(user, roomData, -bet, "홀짝 미적중", roomName);
                var losePrefix = isFeverActive ? "🔥 [피버] " : "💀 ";
                replier.reply(formatCommand(losePrefix + "홀짝 미적중", user, "결과: [" + result + "]\n아쉽지만 " + fp(bet) + "P를 잃었습니다.", "현재 잔액: " + fP(user.point) + "P"));
            }

            var winRate = (user.totalGambleWins / user.totalGambleCount) * 100;
            var replierStub = { reply: function(m) { Api.replyRoom(roomName, m); } };

            if (user.totalGambleCount >= 500) {
                util_checkAndAwardTitle(user, replierStub, "도박의신", 4003, "🎲", "도박 횟수 500회", "운과 실력을 모두 겸비한 도박의 신이 되었습니다.");
            } else if (user.totalGambleCount >= 100 && winRate >= 60) {
                util_checkAndAwardTitle(user, replierStub, "타짜", 4002, "🎴", "총 승률 60% 이상", "도박판의 흐름을 지배하는 타짜로 인정받았습니다.");
            } else if (user.totalGambleCount >= 100) {
                util_checkAndAwardTitle(user, replierStub, "꾼", 4001, "🃏", "도박 횟수 100회", "승률 60% 달성 시 [타짜]에 도전하세요!");
            }

            safeSaveData(data);
            endTracking(user, true, "완료");
            return true;
        } catch(e) { endTracking(user, false, "CRASH: " + e); replier.reply("🚫 시스템 오류가 발생했습니다."); return true; }
    }

    /* [기존 로직 유지] 티어 승급 */
    if (msg === "/승급") {
        var totalAttempts = Number(user.dailyPromotionAttempts || 0) + Number(user.purchasedPromotionAttempts || 0);
        if (totalAttempts <= 0) { replier.reply(formatError(user, "기회 없음", "상점에서 승급권을 구매하세요.")); return true; }
        if (user.tier >= 9) { replier.reply(formatError(user, "최고 등급", "이미 챌린저 등급입니다.")); return true; }

        var usedDaily = false;
        if (Number(user.dailyPromotionAttempts) > 0) { user.dailyPromotionAttempts--; usedDaily = true; }
        else { user.purchasedPromotionAttempts--; }

        var prob = TIER_PROBS[user.tier] || { up: 50, stay: 40, down: 10 };
        var rand = Math.random() * 100;
        var isSundayFever = (new Date().getDay() === 0);
        if (isSundayFever) rand -= 5; 

        startTracking(user, "승급 도전");

        if (rand < prob.up) { 
            user.tier++;
            var successBody = "티어: [" + TIERS[user.tier] + "]\n\n";
            if (user.tier === 9) {
                user.challengerCount = (user.challengerCount || 0) + 1;
                user.challengerIconSeason = getSimpleSeason();
                successBody += "🎊 축하합니다! 전설적인 챌린저 등급에 도달하셨습니다!\n명예의 전당에 성함이 기록되었습니다.";
            } else {
                if (usedDaily) user.dailyPromotionAttempts++; else user.purchasedPromotionAttempts++;
                successBody += "🎉 승급 성공 보너스: 재도전 기회 유지!";
            }
            if (isSundayFever) successBody += "\n🔥 일요일 피버타임 보너스: 승률 +5% 적용!";
            replier.reply(formatCommand("🎊 승급 성공!", user, successBody, "남은 기회: " + (Number(user.dailyPromotionAttempts) + Number(user.purchasedPromotionAttempts)) + "회 / 방어권: " + (user.tierGuard || 0) + "개"));
            endTracking(user, true, "승급 성공");
        } else if (rand > (100 - prob.down)) {
            if (Number(user.tierGuard || 0) > 0) {
                user.tierGuard--;
                replier.reply(formatCommand("🛡️ 강등 방어", user, "티어: [" + TIERS[user.tier] + "] (유지)\n\n방어권을 사용하여 보호했습니다.", "남은 방어권: " + user.tierGuard + "개"));
                endTracking(user, true, "강등 방어");
            } else {
                user.tier = Math.max(0, user.tier - 1);
                replier.reply(formatCommand("📉 강등 발생", user, "티어: [" + TIERS[user.tier] + "]\n\n상태: 티어가 한 단계 하락했습니다.", "남은 기회: " + (Number(user.dailyPromotionAttempts) + Number(user.purchasedPromotionAttempts)) + "회 / 방어권: 0개"));
                endTracking(user, false, "강등 발생");
            }
        } else {
            replier.reply(formatCommand("😐 승급 실패", user, "티어: [" + TIERS[user.tier] + "] (유지)\n\n상태: 승급에 실패했습니다.", "남은 기회: " + (Number(user.dailyPromotionAttempts) + Number(user.purchasedPromotionAttempts)) + "회 / 방어권: " + (user.tierGuard || 0) + "개"));
            endTracking(user, false, "승급 실패");
        }
        safeSaveData(data);
        return true;
    }
    return false;
}

//==========섹터41==========

/**
 * [게임 하위 모듈 3-2] 액션 및 도박 게임 (결투 시스템)
 */
function _gameActionLogic_Part2(msg, user, data, replier, roomName, targetUid) {
    var roomData = data.rooms[roomName];
    if (!roomData) return false;

    /* [기능 11] 결투 신청 */
    if (msg.indexOf("/결투 ") === 0) {
        if (data.gambleLimit) { replier.reply(formatError(user, "도박 제한", "현재 도박 기능이 제한되어 있습니다.")); return true; }
        var parts = msg.trim().split(/\s+/);
        if (parts.length < 3) { replier.reply(formatError(user, "형식 오류", "/결투 [닉네임] [금액]")); return true; }
        var am = parseInt(parts.pop().replace(/,/g, ""));
        var tn = parts.slice(1).join(" ").trim();

        var multiplier = 1.0;
        if (roomData.economyBase && roomData.economyBase > 0) {
            var eco = calculateEconomy(data, roomName);
            var rawRatio = eco.total / roomData.economyBase;
            var damping = (data.economyDamping !== undefined) ? data.economyDamping : 0.5;
            multiplier = 1 + (rawRatio - 1) * damping;
            if (multiplier < 0.5) multiplier = 0.5;
        }
        var minBet = Math.floor(100 * multiplier);

        if (isNaN(am) || am < minBet) { replier.reply(formatError(user, "금액 오류", "최소 " + fp(minBet) + "P 이상 결투 가능합니다.")); return true; }
        if (Number(user.point) < am) { replier.reply(formatError(user, "포인트 부족", "베팅할 포인트가 부족합니다.")); return true; }
        
        var found = findUserByName(roomData, tn);
        if (found.length === 0) { replier.reply(formatError(user, "대상 없음", "[" + tn + "]님을 찾을 수 없습니다.")); return true; }
        if (found.length > 1) { handleUserSelection(replier, targetUid, found, "duel", { bet: am }, user); return true; }
        var target = found[0];
        if (target.id === targetUid) { replier.reply(formatError(user, "결투 불가", "자신과는 싸울 수 없습니다.")); return true; }
        if (isUserBusy(target.id)) { replier.reply(formatError(user, "대상 활동 중", "상대방이 현재 다른 활동을 하고 있습니다.")); return true; }

        util_updatePoint(user, null, -am, "결투 신청 베팅", roomName);

        duelData[target.id] = { challengerUid: targetUid, point: am, expire: Date.now() + 30000, room: roomName };
        replier.reply(formatCommand("⚔️ 결투 신청", target.data, getDisplayName(user) + "님이 " + fp(am) + "P 결투를 신청했습니다!\n\n승낙하시겠습니까? (수락/거절/취소)", "내 잔액: " + fP(user.point) + "P"));
        safeSaveData(data);
        return true;
    }

    /* [수정] 결투 취소 (신청자 본인이 철회) */
    if (msg === "취소") {
        var foundDuelId = null;
        // 내가 신청한 결투가 있는지 전체 duelData에서 탐색
        for (var tid in duelData) {
            if (duelData[tid].challengerUid === targetUid) {
                foundDuelId = tid;
                break;
            }
        }

        if (foundDuelId) {
            var d = duelData[foundDuelId];
            util_updatePoint(user, null, d.point, "결투 취소 환급");
            delete duelData[foundDuelId];
            replier.reply(formatCommand("🚫 결투 취소", user, "결투 신청을 철회하고 베팅금을 반환받았습니다.", "내 잔액: " + fp(user.point) + "P"));
            safeSaveData(data);
            return true;
        }
        return false; // 내가 신청한 결투가 없으면 일반 채팅으로 처리
    }

    /* [수정] 결투 수락 (상대방이 승낙) */
    if (msg === "수락" && duelData[targetUid]) {
        if (data.gambleLimit) { replier.reply(formatError(user, "도박 제한", "현재 도박 기능이 제한되어 있습니다.")); return true; }
        var d = duelData[targetUid];
        var challenger = roomData.users[d.challengerUid];
        
        if (!challenger) { 
            delete duelData[targetUid]; 
            replier.reply(formatError(user, "신청자 정보 없음")); 
            return true; 
        }

        if (Number(user.point) < d.point) {
            // 수락자 포인트 부족 시 신청자에게 포인트 돌려주고 결투 종료
            util_updatePoint(challenger, null, d.point, "상대 포인트 부족으로 인한 환급");
            delete duelData[targetUid];
            replier.reply(formatError(user, "포인트 부족", "수락하기 위한 포인트가 부족하여 결투가 무산되었습니다."));
            safeSaveData(data);
            return true;
        }

        // 수락자 포인트 차감
        util_updatePoint(user, null, -d.point, "결투 수락 베팅");

        // 승패 결정 (50:50)
        var isChallengerWin = Math.random() < 0.5;
        var winner = isChallengerWin ? challenger : user;
        var winnerId = isChallengerWin ? d.challengerUid : targetUid;
        var winPrize = d.point * 2;

        /* 통합 상환 엔진 호출 및 승리금 지급 */
        var res = processRepayment(winner, winPrize, winnerId, roomName);
        winner.point = Number(winner.point) + Number(res.actualGain);
        verifyPointTransaction(winner, winner.point - res.actualGain, Number(res.actualGain), "결투 승리 보상");

        var resBody = "⚔️ 결투 결과\n" + getDisplayName(challenger) + " VS " + getDisplayName(user) + "\n\n🏆 승자: " + getDisplayName(winner) + "\n💰 획득: " + fp(winPrize) + "P" + (res.repayMsg || "");
        replier.reply(formatCommand("⚔️ 결투 종료", winner, resBody, "내 잔액: " + fp(winner.point) + "P"));
        
        delete duelData[targetUid];
        safeSaveData(data);
        return true;
    }

    /* [수정] 결투 거절 (상대방이 거부) */
    if (msg === "거절" && duelData[targetUid]) {
        var d = duelData[targetUid];
        var challenger = roomData.users[d.challengerUid];
        if (challenger) {
            util_updatePoint(challenger, null, d.point, "결투 거절 환급");
        }
        delete duelData[targetUid];
        replier.reply(formatCommand("🚫 결투 거절", user, "결투 신청을 거절했습니다.", "신청자에게 베팅금이 반환되었습니다."));
        safeSaveData(data);
        return true;
    }
    return false;
}

//==========섹터42==========

/**
 * [게임 하위 모듈 3-3] 액션 및 도박 게임 (도둑질 & 줍기)
 * 설명: 도둑질의 쿨타임, 징역, 신용도 페널티 및 벌금의 은행 적립 로직을 원본 그대로 유지합니다.
 */
function _gameActionLogic_Part3(msg, user, data, replier, roomName, targetUid) {
    var roomData = data.rooms[roomName];
    if (!roomData) return false;

    /* [기능 12] 도둑질 시도 */
    if (msg.indexOf("/도둑질 ") === 0) {
        if (data.gambleLimit) { replier.reply(formatError(user, "도박 제한", "현재 도박 기능이 제한되어 있습니다.")); return true; }
        if (user.mining && user.mining.active) { replier.reply(formatError(user, "작업 중", "광산에서 일하는 중에는 도둑질을 할 수 없습니다.")); return true; }
        
        // [원본 유지] 징역 상태 확인
        if (user.jailReleaseTime && Date.now() < user.jailReleaseTime) {
            var diff = user.jailReleaseTime - Date.now();
            var remainMin = Math.ceil(diff / (1000 * 60));
            var timeMsg = remainMin >= 60 ? Math.ceil(remainMin / 60) + "시간" : remainMin + "분";
            replier.reply(formatError(user, "도둑질 금지", "현재 징역 중입니다. " + timeMsg + " 후 가능합니다."));
            return true;
        }

        // [원본 유지] 중복 도둑질 진행 여부 체크
        for (var v in activeThefts) { 
            if (activeThefts[v].thiefUid === targetUid) { replier.reply(formatError(user, "작업 중", "이미 도둑질을 진행 중입니다.")); return true; }
        }

        var tn = msg.substring(5).trim();
        var found = findUserByName(roomData, tn);
        if (found.length === 0) { replier.reply(formatError(user, "대상 없음", "[" + tn + "]님을 찾을 수 없습니다.")); return true; }
        if (found.length > 1) { handleUserSelection(replier, targetUid, found, "theft", null, user); return true; }
        
        var victim = found[0];

        // [원본 유지] 대상 상태 확인 (광산, 중복 강탈 등)
        if (victim.data.mining && victim.data.mining.active) {
            replier.reply(formatError(user, "접근 불가", "대상이 현재 광산 깊은 곳에서 작업 중이라 털 수 없습니다."));
            return true;
        }
        if (activeThefts[victim.id]) { replier.reply(formatError(user, "중복 강탈 불가", getDisplayName(victim.data) + "님은 현재 다른 도둑이 작업 중입니다!")); return true; }
        if (victim.id === targetUid) { replier.reply(formatError(user, "강탈 불가", "자신의 지갑은 털 수 없습니다.")); return true; }

        // [원본 유지] 쿨타임(1시간) 및 대상 포인트(300P 초과) 확인
        if (!user.theftCooldowns) user.theftCooldowns = {};
        var now = Date.now();
        var lastTheftTime = user.theftCooldowns[victim.id] || 0;
        if (now - lastTheftTime < 3600000) { 
            var remainMinCooldown = Math.ceil((3600000 - (now - lastTheftTime)) / 60000);
            replier.reply(formatError(user, "쿨타임 제한", getDisplayName(victim.data) + "님은 이미 털었습니다.\n" + remainMinCooldown + "분 후 다시 가능합니다."));
            return true;
        }
        if (Number(victim.data.point) <= 300) { replier.reply(formatError(user, "강탈 대상 부적합", fp(300) + "P를 초과하는 유저만 털 수 있습니다.")); return true; }

        // [원본 유지] 도둑질 프로세스 시작 (타이머 설정)
        var sT = setTimeout(function(){ processTheftResult(roomName, targetUid, victim.id); }, 60000);
        var pT = setTimeout(function(){ if (Math.random() < 0.5) { processPoliceResult(roomName, targetUid, victim.id); } }, 30000);
        activeThefts[victim.id] = { thiefUid: targetUid, successTimer: sT, policeTimer: pT };

        user.theftCooldowns[victim.id] = now;
        user.creditScore = Math.max(0, Number(user.creditScore || 600) - 10);

        replier.reply(formatCommand("🕵️ 도둑질 시도", user, getDisplayName(victim.data) + "님 강탈 시도 중 (1분 소요)\n\n🚓 30초 후 경찰 출동 확률 50%!", "방어: 1분 내 [잡았다요놈] 입력"));
        checkAndHandleDefaulter(user, roomName);
        safeSaveData(data);
        return true;
    }

    /* 도둑질 방어 (잡았다요놈) */
    if (msg === "잡았다요놈") {
        if (!activeThefts[targetUid]) return false;
        var theft = activeThefts[targetUid];
        if (theft.successTimer) clearTimeout(theft.successTimer);
        if (theft.policeTimer) clearTimeout(theft.policeTimer);
        var thief = roomData.users[theft.thiefUid];
        
        var multiplier = 1.0;
        if (roomData.economyBase && roomData.economyBase > 0) {
            var eco = calculateEconomy(data, roomName);
            var rawRatio = eco.total / roomData.economyBase;
            var damping = (data.economyDamping !== undefined) ? data.economyDamping : 0.5;
            multiplier = 1 + (rawRatio - 1) * damping;
            if (multiplier < 0.5) multiplier = 0.5;
        }

        var basePenalty = Math.floor(Math.random() * 101) + 200;
        var penalty = Math.floor(basePenalty * multiplier);
        var actualPenalty = Math.min(penalty, Number(thief.point));
        
        // [원본 복구] 포인트 차감 및 은행 재원 수동 적립
        util_updatePoint(thief, null, -actualPenalty, "도둑질 체포 벌금");
        roomData.bankReserve = (Number(roomData.bankReserve) || 0) + actualPenalty;
        
        thief.jailReleaseTime = Date.now() + (1 * 60 * 60 * 1000); // 1시간 징역
        delete activeThefts[targetUid];
        
        replier.reply(formatAdmin("🚓 체포 완료", "🚨 [현행범 체포]\n대상: " + getDisplayName(thief) + "\n결과: " + fp(actualPenalty) + "P 차감 / 징역 1시간"));
        safeSaveData(data);
        return true;
    }

    /* 뿌리기 줍기 */
    if (msg === "줍기") {
        if (!sprinkleData.active) return false;
        if (sprinkleData.winners.indexOf(targetUid) !== -1) { replier.reply(formatError(user, "중복 참여 불가")); return true; }
        if (sprinkleData.currentWinners >= sprinkleData.limit) { replier.reply(formatError(user, "선착순 마감")); return true; }
        
        var prize = sprinkleData.portions.pop();
        sprinkleData.winners.push(targetUid);
        sprinkleData.currentWinners++;
        
        /* [핵심 수정] 줍기 성공 시에도 방 정보와 UID를 포함한 통합 상환 엔진 호출 */
        var res = processRepayment(user, prize, targetUid, roomName);
        
        // 포인트 지급 (추심 후 남은 금액 반영)
        var prePoint = Number(user.point);
        user.point = prePoint + Number(res.actualGain);
        if (typeof verifyPointTransaction === 'function') {
            verifyPointTransaction(user, prePoint, Number(res.actualGain), "뿌리기 줍기");
        }
        
        replier.reply(formatCommand("🎉 줍기 성공!", user, fp(prize) + "P를 주웠습니다!" + res.repayMsg, "내 잔액: " + fP(user.point) + "P"));
        
        if (sprinkleData.currentWinners >= sprinkleData.limit) { 
            sprinkleData.active = false; 
            Api.replyRoom(roomName, formatAdmin("🏁 뿌리기 마감", "모든 포인트가 소진되었습니다.")); 
        }
        safeSaveData(data);
        return true;
    }

    return false;
}

//==========섹터43==========

/**
 * [게임 하위 모듈 4] 주식 투자 관리 (성취 기반 칭호 통합 버전)
 * 기능: 주식 시세 조회, 내 주식 확인, 매수, 매도
 * 설명: 폐쇄형 순환 경제 연동 - 매수금은 금고 입고, 매도금은 금고 지출
 */
function _gameStockLogic(msg, user, data, replier, roomName, targetUid) {
    var roomData = data.rooms[roomName];
    if (!roomData) return false;

    // 중앙은행 재원 초기화 (안전장치)
    if (roomData.bankReserve === undefined || roomData.bankReserve === null) {
        roomData.bankReserve = SYSTEM_CONFIG.ECO.BANK.INITIAL_RESERVE;
    }

    /* [기능 13] 주식 거래 */

    // 1. 실시간 시세 조회
    if (msg === "/주식") {
        var currentHour = new Date().getHours();
        var isMarketOpen = (currentHour >= 7 && currentHour <= 23);
        var statusText = isMarketOpen ? "🟢 장 운영 중 (07:00 ~ 23:59)" : "🔴 장 마감 (00:00~06:59)";
        var stockList = generateStockList(data); 
        
        replier.reply("📈 실시간 주식 시세\n━━━━━━━━━━━━━━━\n" + statusText + "\n\n" + (stockList || "상장된 종목이 없습니다.") + "\n━━━━━━━━━━━━━━━\n💡 [가이드]: 매수: [/매수 종목명 수량]");
        return true;
    }

    // 2. 내 보유 주식 확인
    if (msg === "/내주식") {
        var holdings = user.stockHoldings || {};
        var keys = Object.keys(holdings);
        var title = "📊 " + getDisplayName(user) + "의 주식 상황";

        if (keys.length === 0) {
            replier.reply(formatCommand(title, null, "보유 중인 주식이 없습니다.", "매수: [/매수 종목명 수량]"));
            return true;
        }

        var list = [];
        var totalEvaluation = 0;
        var totalPurchase = 0;

        for (var i = 0; i < keys.length; i++) {
            var sName = keys[i];
            var count = Number(holdings[sName]);
            if (count <= 0) continue;

            var stock = data.stockMarket[sName];
            var isDelisted = !stock; 
            var curPrice = isDelisted ? 0 : Math.floor(Number(stock.price));
            var avgPrice = Math.floor(Number(user.stockAvg[sName] || 0));
            
            var purchaseVal = Math.floor(avgPrice * count);
            var evaluationVal = Math.floor(curPrice * count);
            
            totalPurchase += purchaseVal;
            totalEvaluation += evaluationVal;
            
            var profit = evaluationVal - purchaseVal;
            var profitRate = avgPrice > 0 ? ((profit / purchaseVal) * 100).toFixed(1) : "0.0";
            var signIcon = profit > 0 ? "🔺" : (profit < 0 ? "🔹" : "➖");
            var nameDisplay = isDelisted ? "⚠️(상폐) " + sName : sName;
            
            list.push("• " + nameDisplay + " " + count + "주\n" +
                      "  수익: " + fp(Math.floor(profit)) + "P (" + signIcon + profitRate + "%)\n" +
                      "  평단: " + fp(avgPrice) + "P ➔ 현재: " + fp(curPrice) + "P");
        }

        var totalProfit = totalEvaluation - totalPurchase;
        var totalRate = totalPurchase > 0 ? ((totalProfit / totalPurchase) * 100).toFixed(1) : "0.0";
        var totalSignIcon = totalProfit > 0 ? "🔺" : (totalProfit < 0 ? "🔹" : "➖");

        var summary = "💎 총 평가금액: " + fp(Math.floor(totalEvaluation)) + "P\n" +
                      "📊 총 수익률: " + fp(Math.floor(totalProfit)) + "P (" + totalSignIcon + totalRate + "%)\n" +
                      "💰 보유 포인트: " + fp(Math.floor(user.point)) + "P";

        replier.reply(formatCommand(title, null, list.join("\n\n") + "\n\n" + summary, "매도: [/매도 종목명 수량]"));
        return true;
    }

    // 3. 주식 매수 (금고 입고 및 투자 칭호 연동)
    if (msg.indexOf("/매수 ") === 0) {
        if (user.mining && user.mining.active) { replier.reply(formatError(user, "작업 중", "광산에서 채굴 중에는 주식 거래를 할 수 없습니다.")); return true; }
        var currentHour = new Date().getHours();
        if (currentHour < 7) { replier.reply(formatError(user, "주식 시장 마감", "현재는 주식 장외 시간입니다.\n(운영시간: 07:00 ~ 23:59)")); return true; }

        var parts = msg.split(" ");
        if (parts.length < 3) { replier.reply(formatError(user, "형식 오류", "/매수 [종목명] [수량]")); return true; }
        var sName = parts[1], count = parseInt(parts[2]);
        var stock = data.stockMarket[sName];
        if (!stock) { replier.reply(formatError(user, "종목 없음", "[" + sName + "]을 찾을 수 없습니다.")); return true; }
        if (isNaN(count) || count <= 0) { replier.reply(formatError(user, "수량 오류", "수량을 정확히 입력하세요.")); return true; }
        
        var totalPrice = Math.floor(Number(stock.price) * count);
        if (Number(user.point) < totalPrice) { replier.reply(formatError(user, "포인트 부족", "필요: " + fp(totalPrice) + "P")); return true; }
        
        /* [핵심] 중앙은행 연동: 매수 대금을 금고에 입고 */
        util_updatePoint(user, roomData, -totalPrice, "주식 매수", roomName);

        if (!user.stockHoldings) user.stockHoldings = {};
        if (!user.stockAvg) user.stockAvg = {};
        var curCount = Number(user.stockHoldings[sName] || 0);
        var curAvg = Number(user.stockAvg[sName] || 0);
        
        user.stockAvg[sName] = Math.floor(((curAvg * curCount) + totalPrice) / (curCount + count));
        user.stockHoldings[sName] = curCount + count;

        /* [신규] 누적 투자 데이터 업데이트 및 칭호 체크 */
        if (user.totalInvestAmount === undefined) user.totalInvestAmount = 0;
        user.totalInvestAmount += totalPrice;

        var replierStub = { reply: function(m) { Api.replyRoom(roomName, m); } };
        if (user.totalInvestAmount >= 7000000) {
            util_checkAndAwardTitle(user, replierStub, "투자의신", 4303, "📈", "누적 투자액 7,000,000P", "차트를 지배하여 투자의신에 도달했습니다!");
        } else if (user.totalInvestAmount >= 3000000) {
            util_checkAndAwardTitle(user, replierStub, "큰손", 4302, "📉", "누적 투자액 3,000,000P", "차트를 지배하여 [투자의신]에 도달하세요!");
        } else if (user.totalInvestAmount >= 1000000) {
            util_checkAndAwardTitle(user, replierStub, "개미", 4301, "🐜", "누적 투자액 1,000,000P", "시장을 배우는 단계입니다. [큰손]을 향해 나아가세요!");
        }
        
        if (!data.stockTraffic) data.stockTraffic = {};
        if (!data.stockTraffic[sName]) data.stockTraffic[sName] = { buy: 0, sell: 0 };
        data.stockTraffic[sName].buy += count;
        
        replier.reply(formatCommand("📈 주식 매수 완료", user, "종목: " + sName + "\n수량: " + count + "주\n매수가: " + fp(stock.price) + "P (총 " + fp(totalPrice) + "P)", "내 잔액: " + fp(user.point) + "P"));
        safeSaveData(data);
        return true;
    }

    // 4. 주식 매도 (금고 지출 연동 및 뱅크런 방지)
    if (msg.indexOf("/매도 ") === 0) {
        if (user.mining && user.mining.active) { replier.reply(formatError(user, "작업 중", "광산에서 채굴 중에는 주식 거래를 할 수 없습니다.")); return true; }
        var currentHour = new Date().getHours();
        if (currentHour < 7) { replier.reply(formatError(user, "주식 시장 마감", "현재는 주식 장외 시간입니다.")); return true; }

        var parts = msg.split(" ");
        if (parts.length < 3) { replier.reply(formatError(user, "형식 오류", "/매도 [종목명] [수량]")); return true; }
        
        var sName = parts[1];
        var count = parseInt(parts[2]);
        var holdings = (user.stockHoldings && user.stockHoldings[sName]) ? Number(user.stockHoldings[sName]) : 0;

        if (holdings < count || count <= 0) { replier.reply(formatError(user, "수량 부족", "보유 수량을 확인해주세요.")); return true; }
        
        var stock = data.stockMarket[sName];
        var sellPrice = stock ? Math.floor(Number(stock.price)) : 0;
        var totalSell = sellPrice * count; 
        var fee = Math.floor(totalSell * 0.05); 
        var finalPrice = totalSell - fee; 

        /* [핵심] 은행 파산 보호 (뱅크런 방지) */
        if (roomData.bankReserve < finalPrice) {
            replier.reply(formatError(user, "거래 일시 중단", "죄송합니다. 현재 중앙은행의 현금 유동성 부족으로 주식 매도 대금 지급이 불가능합니다.\n\n🏦 현재 은행 금고: " + fp(roomData.bankReserve) + "P"));
            return true;
        }

        var avgPrice = (user.stockAvg && user.stockAvg[sName]) ? Number(user.stockAvg[sName]) : sellPrice; 
        var purchaseVal = Math.floor(avgPrice * count); 
        var profit = totalSell - purchaseVal; 
        var profitRate = purchaseVal > 0 ? ((profit / purchaseVal) * 100).toFixed(1) : "0.0";
        var signIcon = (profit > 0) ? "🔺" : (profit < 0 ? "🔹" : "➖");

        user.stockHoldings[sName] = holdings - count;
        if (user.stockHoldings[sName] <= 0) { 
            delete user.stockHoldings[sName]; 
            if (user.stockAvg) delete user.stockAvg[sName]; 
        }
        
        var res = processRepayment(user, finalPrice, targetUid, roomName); 
        
        /* [핵심] 중앙은행 연동: 매도 대금을 금고에서 차감 지급 */
        util_updatePoint(user, roomData, Number(res.actualGain), "주식 매도", roomName);
        
        if (!data.stockTraffic) data.stockTraffic = {};
        if (!data.stockTraffic[sName]) data.stockTraffic[sName] = { buy: 0, sell: 0 };
        data.stockTraffic[sName].sell += count;
        
        var sellMsg = "📉 주식 매도 완료\n" +
              "━━━━━━━━━━━━━━━\n" +
              getDisplayName(user) + "님\n" +
              "종목: " + sName + " " + count + "주\n" +
              "수익 : " + fp(Math.abs(profit)) + "P (" + signIcon + Math.abs(profitRate).toFixed(1) + "%)\n" +
              "실현손익 : " + fp(finalPrice) + "P (수수료 -5% 포함)" + (res.repayMsg || "") + "\n" +
              "━━━━━━━━━━━━━━━\n" +
              "💡 [가이드]: 내 잔액: " + fp(user.point) + "P";

        replier.reply(sellMsg);
        safeSaveData(data);
        return true;
    }

    return false;
}

//==========섹터44==========

/**
 * [게임 하위 모듈 5] 상점 및 기타 활동
 * 기능: 상점 메뉴 호출, 출석 체크
 * 설명: 폐쇄형 순환 경제 연동 - 출석 보상을 중앙은행 금고에서 지급합니다.
 */
function _gameShopLogic(msg, user, data, replier, roomName, targetUid) {
    var roomData = data.rooms[roomName];
    if (!roomData) return false;

    // 중앙은행 재원 초기화 (안전장치)
    if (roomData.bankReserve === undefined || roomData.bankReserve === null) {
        roomData.bankReserve = SYSTEM_CONFIG.ECO.BANK.INITIAL_RESERVE;
    }

    /* [기능 14] 상점 메뉴 호출 */
    if (msg === "/상점") {
        menuWaitState[targetUid] = { type: 'shop_category', time: Date.now() };
        var categoryList = [];
        for (var id in SHOP_CATEGORIES) {
            categoryList.push(id + ". " + SHOP_CATEGORIES[id]);
        }
        var shopMenu = "원하시는 카테고리 번호를 입력하세요.\n\n" + categoryList.join("\n");
        replier.reply(formatCommand("🛒 내리다봇 통합 상점", user, shopMenu, "취소: [취소] / 입력 대기: 30초"));
        return true;
    }

    /* [기능 2] 출석 체크 (중앙은행 연동) */
    if (msg === "/출석") {
        var today = getSimpleDate();
        // 1. 중복 출석 체크
        if (user.lastDate === today) { 
            replier.reply(formatError(user, "이미 출석 완료", "출석은 하루에 한 번만 가능합니다.")); 
            return true; 
        }
        
        // 2. 물가 연동 배율 계산
        var multiplier = 1.0;
        if (roomData.economyBase && roomData.economyBase > 0) {
            var eco = calculateEconomy(data, roomName);
            var rawRatio = eco.total / roomData.economyBase;
            var damping = (data.economyDamping !== undefined) ? data.economyDamping : 0.5;
            multiplier = 1 + (rawRatio - 1) * damping;
            if (multiplier < 0.5) multiplier = 0.5;
        }

        // 3. 랜덤 보상 계산 (200P ~ 300P 사이)
        var minR = SYSTEM_CONFIG.ECO.ATTEND_MIN || 200;
        var maxR = SYSTEM_CONFIG.ECO.ATTEND_MAX || 300;
        var baseReward = Math.floor(Math.random() * (maxR - minR + 1)) + minR; 
        var reward = Math.floor(baseReward * multiplier);

        /* [핵심 수정] 은행 파산 보호 로직 */
        // 은행 금고에 출석 보상을 지급할 수 있는 현금이 있는지 확인
        if (roomData.bankReserve < reward) {
            var errorMsg = "죄송합니다. 현재 중앙은행의 재고가 부족하여 출석 보상을 지급할 수 없습니다.\n" +
                           "경제 활동(주식 매수, 상점 이용 등)을 통해 국고가 충전될 때까지 기다려주세요.\n\n" +
                           "🏦 현재 금고: " + fp(roomData.bankReserve) + "P";
            replier.reply(formatError(user, "국고 고갈", errorMsg));
            return true;
        }

        /* [핵심 수정] 출석 보상 지급 전 통합 상환 엔진 호출 */
        var res = processRepayment(user, reward, targetUid, roomName);
        
        /* [핵심 수정] 중앙은행 연동: 보상금을 금고에서 차감 지급 */
        // util_updatePoint 호출 시 roomData를 전달하여 "출석 보상" 사유로 금고 잔액 차감
        util_updatePoint(user, roomData, Number(res.actualGain), "출석 보상", roomName);

        // 4. 유저 상태 데이터 업데이트
        user.lastDate = today; 
        user.totalAttendance = (user.totalAttendance || 0) + 1;
        user.creditScore = Math.min(1000, (user.creditScore || 600) + 2); 
        
        var content = fp(reward) + "P가 지급되었습니다! (신용 +2)" + (res.repayMsg || "") + "\n" +
                      "🏦 국고 재원에서 연금이 지급되었습니다.";

        replier.reply(formatCommand("✅ 일일 출석 완료", user, content, "내 잔액: " + fp(user.point) + "P"));
        
        safeSaveData(data); 
        return true;
    }

    return false;
}

//==========섹터45==========

/* [지연 실행] 명령어 레지스트리 초기화 (Initialization) */
// 모든 로직 함수(섹터 30~44)가 메모리에 적재된 후 실행되어야 하므로 파일 맨 끝에 배치합니다.
(function initializeRegistry() {
    try {
        // 1. 유저 명령어 등록
        // 섹터 6의 CMD_LIST.user에 추가된 경마 관련 명령어들을 자동으로 순회하며 등록합니다.
        for (var i = 0; i < CMD_LIST.user.length; i++) {
            var c = CMD_LIST.user[i];
            
            // eval을 사용하여 문자열 이름(예: "_gameActionLogic")을 실제 함수 객체로 변환합니다.
            var executor = null;
            try { executor = eval(c.func); } catch(e) {}

            if (typeof executor === 'function') {
                registerUserCmd(c.cmd, c.desc, c.cat, executor);
            } else {
                Log.error("❌ 명령어 등록 실패 (함수 미발견): " + c.cmd + " -> " + c.func);
            }
        }

        // 2. 관리자 명령어 등록
        for (var j = 0; j < CMD_LIST.admin.length; j++) {
            var a = CMD_LIST.admin[j];
            
            var adminExecutor = null;
            try { adminExecutor = eval(a.func); } catch(e) {}

            if (typeof adminExecutor === 'function') {
                registerAdminCmd(a.cmd, a.desc, adminExecutor);
            } else {
                Log.error("❌ 관리자 명령어 등록 실패: " + a.cmd);
            }
        }
        
        // [Gemini 알림] 경마 시스템 로드 확인 로그 (디버깅용)
        Log.info("🐎 [Racing System] 경마 엔진 및 관련 명령어 로드 완료.");
        
    } catch(e) {
        Log.error("Registry Init Critical Error: " + e);
    }
})();
