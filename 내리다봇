//==========섹터1==========

/* [신규] 명령어 자동 등록 시스템 (Command Registry) */
var USER_COMMANDS = {};
var ADMIN_COMMANDS = {};

function registerUserCmd(cmd, desc, cat, func) {
    USER_COMMANDS[cmd] = { desc: desc, cat: cat, execute: func };
}

function registerAdminCmd(cmd, desc, func) {
    ADMIN_COMMANDS[cmd] = { desc: desc, execute: func };
}

/**
 * [전역 표준 규격] USER_SCHEMA v1.0
 * 치유(Sector 19)와 신규가입(Sector 20-1)이 공통으로 참조하는 리스트입니다.
 * 덮어쓰기 사고를 방지하기 위해 point 등 핵심 자산의 기본값은 0으로 설정합니다.
 */
var USER_SCHEMA = [
    { key: 'point', default: 0, type: 'number' },
    { key: 'bank', default: 0, type: 'number' },
    { key: 'tier', default: 0, type: 'number' },
    { key: 'creditScore', default: 600, type: 'number' },
    { key: 'inventory', default: [], type: 'array' },
    { key: 'collectedIcons', default: [], type: 'array' },
    { key: 'stockHoldings', default: {}, type: 'object' },
    { key: 'stockAvg', default: {}, type: 'object' },
    { key: 'chatLog', default: [], type: 'array' },
    { key: 'timeoutEndTime', default: 0, type: 'number' },
    { key: 'totalMiningTime', default: 0, type: 'number' },
    { key: 'artifactPieces', default: 0, type: 'number' },
    { key: 'totalGambleCount', default: 0, type: 'number' },
    { key: 'totalGambleWins', default: 0, type: 'number' },
    { key: 'totalTheftSuccess', default: 0, type: 'number' },
    { key: 'totalInvestAmount', default: 0, type: 'number' },
    { key: 'dailyPromotionAttempts', default: 1, type: 'number' },
    { key: 'dailyGambleCount', default: 0, type: 'number' },
    { key: 'boughtWarningRemoval', default: false, type: 'boolean' },
    { key: 'hasVotedToday', default: false, type: 'boolean' },
    { key: 'lastFishingTime', default: 0, type: 'number' },    // 낚시 쿨타임 관리용 (Timestamp)
    { key: 'totalSpittoBought', default: 0, type: 'number' },  // 스피또 누적 구매량 (통계용)
    { key: 'horseParts', default: [], type: 'array' },       // 1) 경마 부품 (안장, 등자 등) 수집 목록
    { key: 'stockCertCount', default: 0, type: 'number' },   // 2) 주식 미발행확인서 보유 개수
    { key: 'lottoFailCount', default: 0, type: 'number' },   // 3) 로또/스피또 위로의편지 보유 개수
    { key: 'luckyCharmEnd', default: 0, type: 'number' },    // 3) 행운의부적 효과 종료 시간 (Timestamp)
    { key: 'accruedInterest', default: 0, type: 'number' },   // 적립된 이자 주머니
    { key: 'lastBankUpdateTime', default: 0, type: 'number' }, // 마지막 은행 잔액 변동 시간 (Timestamp)
    { key: 'totalFishingSuccess', default: 0, type: 'number' }, // 낚시 누적 성공 횟수 (칭호용)
    { key: 'totalDonation', default: 0, type: 'number' }        // 누적 기부 금액
];

/* [초고속 엔진] 전역 UID-닉네임 캐시 초기화 */
if (typeof globalData !== 'undefined' && !globalData.nameToIdCache) {
    globalData.nameToIdCache = {};
}

/* 파일 및 데이터 동기화 객체 */
var Lock = java.util.concurrent.locks.ReentrantLock; 
var lock = new Lock(); 
var logLock = new Lock(); // [v5.8] 저널링(블랙박스) 전용 독립 락 추가
var SD_PATH = android.os.Environment.getExternalStorageDirectory().getAbsolutePath(); 
var BASE_DIR = SD_PATH + "/msgbot/data/"; 
var FILE_PATH = BASE_DIR + "attendance.json"; 
var REGISTRY_PATH = BASE_DIR + "user_registry.json";
var JOURNAL_PATH = BASE_DIR + "transaction.log"; // [v5.8] 실시간 거래 기록용 블랙박스 경로
var BACKUP_DIR = BASE_DIR + "backup/"; 

/* [최적화] 전역 UID 캐시 시스템 */
var uidCache = uidCache || {}; 

/* [최적화] 병렬 처리 엔진 분리 */
// 1. 명령어 처리 엔진: 8개의 스레드가 유저와 소통 (응답 속도 담당)
var Executor = java.util.concurrent.Executors.newFixedThreadPool(6);
// 2. [신규] 저장 전담 엔진: 단 1개의 스레드가 순차적으로 파일 기록 (안전성 담당)
var SaveExecutor = java.util.concurrent.Executors.newSingleThreadExecutor();
// if (globalData) {
    // globalData.SaveExecutor = SaveExecutor;}

// globalData.Executor = Executor;
// globalData.SaveExecutor = SaveExecutor;

/* 로그 저장 경로 및 디렉토리 설정 */ 
var BUG_LOG_PATH = BASE_DIR + "logs/bug_report.txt"; 
var ERROR_LOG_PATH = BASE_DIR + "logs/error_log.txt"; 
var logDir = new java.io.File(BASE_DIR + "logs/"); 
if (!logDir.exists()) logDir.mkdirs(); 
var dir = new java.io.File(BACKUP_DIR); 
if (!dir.exists()) dir.mkdirs(); 

/* 전역 상태 변수 */ 
if (typeof globalData === 'undefined' || globalData === null) {
    var globalData = { rooms: {}, botActive: true }; 
}

/* [안정화] 핵심 게임 엔진 및 상태 참조 전역 선언 */
var racingData = null;      // 경마 실시간 데이터 참조용
var lotto = null;           // 로또 실시간 데이터 참조용
var marketOpenPrice = globalData.marketOpenPrice || 0;    // 주식 시가 참조용
var feverData = {};         // 피버타임 상태 참조용
var sprinkleData = {};      // 뿌리기 상태 참조용
var _msgReceiveTime = 0;    // [신규] 응답속도 측정을 위한 전역 타임스탬프

/* [안정화] 입력 대기 및 활동 상태 변수 초기 선언 */
var menuWaitState = {};
var bankProcessState = {};
var selectWaitState = {};
var lottoPurchaseState = {};
var activeThefts = {};
var duelData = {};
var miningState = {};
var loanRegisterState = {};
var loanContractWaitState = {};

/**
 * [Gemini 요청 사항] 방별 독립화를 위한 데이터 템플릿
 * 설명: 아래의 구조가 각 방(Room)이 생성될 때마다 독립적으로 복제되어 할당됩니다.
 */
var ROOM_FEATURE_TEMPLATE = function() {
    return {
        /* [Gemini 요청 사항] 경마 시스템 실시간 상태 및 상수 설명 통합 */
        racing: {
            round: 1,           // [회차]: 경마의 진행 차수를 기록 (봇 재시작 시 1로 초기화됨)
            horses: [           // [출전마 정보]: 각 말의 고유 ID, 이름, 우승 가중치(weight), 상태 아이콘 저장
                { id: 1, name: "어마어마", weight: 1.0, icon: "☁️ 보통" },
                { id: 2, name: "어서말을해", weight: 1.0, icon: "☁️ 보통" },
                { id: 3, name: "마의웨이", weight: 1.0, icon: "☁️ 보통" },
                { id: 4, name: "핵탄두", weight: 1.0, icon: "☁️ 보통" },
                { id: 5, name: "돌격앞으로", weight: 1.0, icon: "☁️ 보통" }
            ],
            bets: {},           // [배팅 기록]: { UID: {horseId, amount, name} } 형식으로 현재 회차 배팅 정보를 저장
            totalPool: 0,       // [당기 누적금]: 이번 회차에 유저들이 배팅한 순수 포인트 합계
            carryOver: 0,       // [이월금/Jackpot]: 이전 회차에서 당첨자가 없어 넘어온 포인트 (70% 비율 적용액)
            // [운영 플래그]: 봇 로드 시 현재 시간을 즉시 판별하여 09:00~23:59 사이면 자동으로 가동 상태(true)로 설정
            isOperating: (function() {
                var h = new Date().getHours();
                return h >= 9 && h <= 23; 
            })(),
            isDeadlineNotified: false, // [알림 제어]: 49분 59초 마감 공지가 중복 발송되는 것을 방지하는 스위치
            isResultProcessed: false   // [정산 제어]: 정각(00분) 결과 정산 로직이 중복 실행되는 것을 방지하는 스위치
        },
        /* 방별 주식 시장 및 기타 데이터 */
        stockMarket: {},
        stockTraffic: {},
        marketOpenPrice: 0,
        feverData: { active: false, endTime: 0, scheduled: [] },
        sprinkleData: { active: false, winners: [], portions: [] },
        lotto: { round: 1, entries: {}, dailyPool: 0, jackpot: 0, lastWinNums: [] },

        msgCount: 0,

        government: {
            activePolicy: { // 현재 시행 중인 정책 배율 (기본값)
                stockTax: 0.05,
                mineMult: 1.0,
                attendMult: 1.0,
                loanLimitMult: 1.0,
                bankInterest: 0.02,
                theftFineMult: 1.0,
                policeProbAdj: 0.0
            },
            pendingBill: null,   // 오늘 발의된 안건 데이터
            votes: { pro: 0, con: 0, voters: [] }, // 투표 가중치 합 및 참여자 명단
            lastBillDate: "",
            resultStatus: null,
            isClosing: false
        },

        /* 방별 독립 입력 대기 상태 */
        states: {
            menuWait: {}, bankProcess: {}, selectWait: {}, lottoPurchase: {},
            activeThefts: {}, duelData: {}, mining: {},
            loanRegister: {}, loanContractWait: {}
        }
    };
};

/* 관리자 UID 기반 인증 */ 
var adminUIDs = ["fixed-uuid-관리자1", "fixed-uuid-관리자2"]; 

/* 관리자 명령어 목록 */ 
var ADMIN_CMD_LIST = [ 
    "1. /봇구동 [온|오프]", "2. /유저데이터 [닉네임]", "3. /데이터교정 (로직동기화)", 
    "4. /데이터이전 [구닉 > 신닉]", "5. /닉네임기록 [닉네임]", "6. /출석초기화 [닉네임]", 
    "7. /전체포인트지급 [금액]", "8. /포인트차감 [닉] [금액]", "9. /뿌리기 (랜덤 포인트)", 
    "10. /관리자등록/해제/목록", "11. /관리자로그", "12. /승급횟수초기화", 
    "13. /시즌강제종료", "14. /출석일수수정 [닉] [일]", "15. /전체출석수정 [일수]", 
    "16. /로또데이터초기화", "17. /도박제한 [온|오프]", "18. /강제재가동", 
    "19. /유저삭제 [닉네임]", "20. /시스템자가복원 (최적화)", "21. /전체복원 (데이터 롤백)", 
    "22. /유저복원 [닉네임] (부분복구)", "23. /제보목록 (버그확인)", "24. /오류로그 (로직검증)", 
    "25. /제보초기화", "26. /오류초기화", "27. /포인트지급 [닉네임] [수량]", 
    "28. /물가조정 [기준값|초기화]", "29. /관리자해제 [닉네임]", "30. /관리자목록", 
    "31. /물가완충 [0.0~1.0]", "32. /재원수정 [금액] (은행금고수정)", "33. /경제정보(통합지표확인)",
    "34. /시장자산복구 (주가복구)", "35. /종목추가 [이름] [가격]", "36. /종목수정 [기존] [신규] [가격]",
    "37. /재원충전 [금액]", "38. /신용조정 [닉네임] [점수]", "39. /칭호회수 [닉네임] [칭호명]",
    "40. /명부확인", "41. /명부삭제", "42. /이월금수정 [금액]"
];

/* 시스템 핵심 상수 설정 */
var SYSTEM_CONFIG = {
    ECO: {
        /* [기초 경제 설정] */
        ATTEND_MIN: 8000, // [출석 최소 지급]: 출석 체크 시 무작위로 지급되는 포인트의 하한선
        ATTEND_MAX: 10000, // [출석 최대 지급]: 출석 체크 시 무작위로 지급되는 포인트의 상한선
        GAMBLE_MIN: 2000,  // [홀짝 최소 베팅]: 홀짝 게임 진행 시 입력 가능한 최소 포인트 단위
        GAMBLE_MAX: 50000, // [홀짝 최대 베팅]: 홀짝 게임의 1회당 최대 베팅 한도 (사행성 조절)

        /* [신규] 스피또 및 생산형 컨텐츠 설정 */
        SPITTO: {
            PRICE: 2000,           // 복권 가격
            RTP: 0.855,              // 기대 수익률 (85.5%)
            PROBS: {
                RANK1: 0.0008,     // 1등 확률 (0.08%)
                RANK2: 0.02,       // 2등 확률 (2%)
                RANK3: 0.15,       // 3등 확률 (15%)
                RANK4: 0.55         // 4등 확률 (55%)
            },
            PRIZES: {
                RANK1: 500000,     // 1등 상금
                RANK2: 25000,      // 2등 상금
                RANK3: 5000,       // 3등 상금
                RANK4: 1000         // 4등 상금
            }
        },
        FISHING: {
            COOLDOWN: 600000,      // 쿨타임 (10분 = 600,000ms)
            MIN_REWARD: 500,       // 최소 보상
            MAX_REWARD: 1500,       // 최대 보상
            FAIL_PROB: 0.15,         // 꽝 확률 (20%)
            ARTIFACT_CHANCE: 0.005  // [신규] 유물 조각 발견 확률 (0.5%)
        },
        
        /* [신규] 중앙은행 지급준비제도 설정 */
        BANK: {
            RESERVE_RATIO: 0.15, // [지급준비율]: 은행 총 예금액 중 대출해줄 수 없는 최소 현금 보유 비중 (20%)
            INITIAL_RESERVE: 10000, // [초기 재원]: 데이터 초기화 시 은행 금고에 기본으로 들어있는 포인트
            /* [지능형 탄력 금리 설정] */
            MIN_MULTIPLIER: 0.5,  // 금리 하한 승수 (0.5배)
            MAX_MULTIPLIER: 3.0,  // 금리 상한 승수 (3.0배)
            TARGET_RESERVE_RATIO: 0.1 // 적정 국고 유지 비율 (경제 기준점의 10%)
        },

        /* [신규] 경마 시스템 세부 설정 상술 */
        RACING: {
            MIN_BET: 10000,       // [최소 배팅액]: 경마 참여를 위한 최소 포인트
            MAX_BET: 30000,      // [최대 배팅액]: 한 회차에 걸 수 있는 최대 포인트 상한선
            TAX_RATE: 0.1,       // [기본 수수료]: 당첨금 정산 전 전체 판돈에서 국고로 환수되는 비율 (10%)
            CANCEL_FEE: 0.1,     // [취소 위약금]: 배팅 취소 시 원금에서 차감되어 국고로 귀속되는 수수료 (10%)
            WINLESS_BANK_RATE: 0.3,   // [무승자 국고행]: 우승자 없을 시 판돈의 30%를 은행 금고로 즉시 회수
            WINLESS_JACKPOT_RATE: 0.7, // [무승자 이월액]: 우승자 없을 시 판돈의 70%를 다음 회차 carryOver로 누적
            OPEN_HOUR: 9,        // 경마장 자동 개장 시각 (오전 9시)
            CLOSE_HOUR: 23,       // 경마장 마지막 배팅 마감 시각 (오후 11시 59분)
            MAX_PAYOUT_MULT: 7   // [신규: 배당 상한선]: 배팅 금액의 최대 10배까지만 당첨금 수령 가능 (독식 방지)
        },
        
        STOCK: {
            PREFIXES: ["롯데", "엘지", "한화", "나야", "삼성", "두바이쫀득", "현대", "카카오", "네이버", "애플", "테슬라", "도다리", "두유노" , "스페이스", "노력", "나무늘보"], 
            SUFFIXES: ["전자", "생명", "화학", "건설", "중공업", "바이오", "제약", "엔터", "식품", "모터스", "쿠키", "에너지", "보험", "통신", "투자증권", "그랩"], 
            TRAITS: { // [종목 특성]: 각 주식 타입별 변동성 및 생성 확률 정의
                "normal": { label: "일반", volatility: 1, prob: 44, icon: "🌱" }, 
                "bluechip": { label: "우량주", volatility: 0.5, prob: 28, icon: "🛡️" }, 
                "scam": { label: "작전주", volatility: 1.5, prob: 28, icon: "🔥" } 
            },
            MANIPULATION: { // [주가 조작 프리셋]: 관리자가 특정 종목의 시세를 강제로 제어할 때 참조
                TARGET: "현대바이오", // 조작 대상 종목명
                IS_UP: true,       // 상승(true) 또는 하락(false) 여부
                RATE: 0.25,        // 조작 시 변동률 (0.25 = 25%)
                ACTIVE: true      // 조작 시스템 활성화 상태 (평소엔 false)
            },
            SETTINGS: { // [주식 시장 세부 설정]
                MAX_COUNT: 10,     // 시장에 동시 상장 가능한 최대 종목 수
                OPEN_HOUR: 7,      // 주식 장 개장 시간
                CLOSE_HOUR: 23,    // 주식 장 마감 시간
                MANI_RATE: 0.15,   // 기본 특수 이벤트(폭등/폭락) 변동폭
                DELIST_LIMIT: 0.25, // [상폐 기준]: 시장 평균가 대비 20% 이하
                ABS_DELIST_LIMIT: 10000, // [절대적 기준]: 10,000P 미만 시 상폐 카운트
                CLOSING_LIMIT: 0.40, // [최대 슈팅]: 시가 대비 +40%까지 상승 허용
                RESISTANCE_START: 0.20, // [고무줄 시작]: +20% 지점부터 부드러운 저항 발생
                GRAVITY: 0.18      // [중력 계수]: 회귀 강도 (낮을수록 더 완만하게 복귀)
            }
        },
        MINE: { // [광산 채굴 설정]
            BASE_PER_MIN: 15, // 분당 획득하는 기본 채굴 포인트 (물가 배율 적용 전)
            COPPER_PROB: 0.05, // 구리 발견 확률 (5%)
            GOLD_PROB: 0.03,   // 금 발견 확률 (3%)
            DIA_PROB: 0.005,   // 다이아몬드 발견 확률 (0.5%)
            COPPER_MULT: 3.0,  // 구리 발견 시 수익 배율
            GOLD_MULT: 7.0,    // 금 발견 시 수익 배율
            DIA_MULT: 20.0,    // 다이아몬드 발견 시 수익 배율
            ARTIFACT_CHANCE: 0.002, // [유물 조각]: 매 분마다 유물을 찾을 확률 (0.1%)
            ARTIFACT_GOAL: 50  // [도굴왕 칭호]: 유물 조각을 이 갯수만큼 모으면 자동 부여
        },
        PRIVATE_LOAN: { // [사채(P2P) 시장 설정]
            MIN_AMOUNT: 10000,       // 사채 매물 등록 시 최소 단위
            MAX_RATE: 15,           // 법정 최고 이율 (3시간당 최대 15%)
            COLLECTION_LIMIT: 24,   // [추심 시작]: 대출 후 24시간 경과 시 수익 압류(50%) 시작
            INTEREST_PERIOD: 3,     // 이자가 복리로 계산되어 붙는 주기 (3시간)
            MIN_BORROW: 5000,       // 유저가 사채를 빌릴 때 최소 단위
            DAILY_LIMIT: 1          // 은행 대출 일일 이용 제한 횟수
        },
        CREDIT: { // [은행 신용 등급 체계]
            SCORES: [900, 800, 700, 600, 500], // 각 등급을 나누는 기준 점수
            LIMITS: [300000, 180000, 100000, 80000, 40000, 10000], // 등급별 대출 가능 한도
            RATES: [1.02, 1.04, 1.08, 1.12, 1.18, 1.30], // 등급별 기본 이율 (시장 승수와 연동되어 최종 산출됨)
            LABELS: ["1등급", "2등급", "3등급", "4등급", "5등급", "신용불량자"], 
            ICONS: ["👑", "💎", "🥇", "🥈", "🥉", "🚫"] 
        }
    },

BACKUP: {
        // 여기에 본인의 디스코드 웹후크 URL을 입력하세요. (따옴표 필수)
        DISCORD_WEBHOOK_URL: "https://discord.com/api/webhooks/1466005811594793000/LUVyScCaI88gKz4SxMUSOniTi890hRNVGvGn1SC_FoNhYU5Vy7bZD9PpjSF0mQHRUMUq"
    },

    SPAM: { // [도배 방지 엔진 설정]
        LIMIT_COUNT: 5,        // 제한 시간 내 허용되는 최대 메시지 수
        LIMIT_WINDOW: 3000,    // 도배 판정 시간 범위 (3000ms = 3초)
        TIMEOUT_MS: 300000     // 도배 적발 시 봇 이용이 제한되는 시간 (5분)
    },

    PROB: { // [핵심 게임 확률 엔진]
        ODD_EVEN_WIN: 0.45,        // 홀짝 기본 승률 (47%)
        ODD_EVEN_FEVER: 0.50,      // 피버타임 시 홀짝 승률 (52%)
        STOCK_NEW_LISTING: 0.8,    // 매 변동 타임마다 신규 종목이 상장될 확률 (50%)
        STOCK_SPECIAL: 0.5,        // 특정 종목에 특수 이벤트(폭등/폭락)가 발생할 확률 (50%)
        STOCK_UP_CHANCE: 0.45      // 특수 이벤트 발생 시 '상승'일 확률 (45%, 하락이 조금 더 높음)
    },
    
    MSG: { // [시스템 메시지 설정]
        PREFIX: {
            INFO: "ℹ️", ERROR: "🚫", ADMIN: "⚙️", SUCCESS: "✅", 
            WARN: "⚠️", GAMBLE_WIN: "🎊", GAMBLE_LOSE: "💀", LOAN: "🚬", MINE: "⛏️", TIMEOUT: "🔇"
        }, 
        ERR_FORM: "형식이 올바르지 않습니다.", 
        ERR_MONEY: "포인트가 부족합니다.", 
        ERR_USER: "대상을 찾을 수 없습니다.", 
        ERR_TIMEOUT: "도배로 인해 이용이 일시 제한되었습니다." 
    }
};

//==========섹터2==========

/**
 * [v8.1 개편] 블랙박스 복구 엔진 (Smart Replay Option 2)
 * 기능: 자본금 대비 수익 필터링 로직을 도입하여 보너스 레버리지를 이용한 부당 수익을 차단합니다.
 * [Gemini 요청 사항 반영]: 사유(Reason) 필터링 시스템 완벽 통합
 */
function recoverFromJournal(data) {
    try {
        var journalFile = new java.io.File(JOURNAL_PATH);
        if (!journalFile.exists() || journalFile.length() === 0) return;

        var logs = FileStream.read(JOURNAL_PATH).split("\n");
        var recoveryCount = 0;
        var skipCount = 0;
        var taintedUsers = {}; // 자본금 한도를 초과하여 베팅한 유저 태그 목록

        logs.forEach(function(line) {
            if (!line.trim()) return;
            var parts = line.split("|"); 
            // [교정]: 사유가 포함된 5개 항목이 모두 있는지 확인
            if (parts.length < 5) return;

            var uid = parts[0];
            var room = parts[1];
            var delta = Number(parts[2]);
            var brDelta = Number(parts[3] || 0);
            var reason = parts[4] || ""; 

            if (data.rooms[room] && data.rooms[room].users[uid] && !isNaN(delta)) {
                var user = data.rooms[room].users[uid];

                // [필터 1]: 입장 보너스 기록은 합산에서 제외 (중복 지급 방지)
                if (reason.indexOf("입장 축하") !== -1) {
                    skipCount++;
                    return;
                }

                // [필터 2]: 자본금 한도 초과 베팅 감지 (옵션 2 논리)
                if (delta < 0 && Math.abs(delta) > Number(user.point)) {
                    taintedUsers[uid] = true;
                    return;
                }

                // [필터 3]: 태그된 유저의 수익(+) 기록 무효화
                if (taintedUsers[uid] && delta > 0) {
                    skipCount++;
                    return;
                }

                // [최종 반영]: 필터를 통과한 정당한 데이터만 합산
                user.point = Number(user.point || 0) + delta;
                data.rooms[room].bankReserve = Number(data.rooms[room].bankReserve || 0) + brDelta;
                recoveryCount++;
            }
        });

        if (recoveryCount > 0 || skipCount > 0) {
            Log.info("[Recovery] 블랙박스 엔진: " + recoveryCount + "건 복구 완료 (부당 이득 및 보너스 " + skipCount + "건 필터링)");
        }
    } catch (e) {
        Log.error("Journal Recovery Error: " + e);
    }
}

/**
 * [Gemini 정밀 교정] 데이터베이스 로드 함수
 */
function getDatabase() {
    // 1. RAM 상주 데이터 우선 반환 (물리적 파일 읽기 생략으로 응답 속도 극대화)
    if (globalData && globalData.rooms && Object.keys(globalData.rooms).length > 0) {
        return globalData; 
    }

    try {
        var file = new java.io.File(FILE_PATH);
        var initialData;
        
        if (!file.exists()) {
            initialData = {
                rooms: {}, admins: ["관리자"], botActive: true,
                nickHistory: {}, adminLogs: [], economyDamping: 0.5,
                lastDailyReset: "", isRecovering: false, nameToIdCache: {}
            };
        } else {
            var content = FileStream.read(FILE_PATH);
            if (!content) throw new Error("Empty File");
            initialData = JSON.parse(content);
        }

        // 2. 블랙박스(Journal) 로그 즉시 복구 병합
        recoverFromJournal(initialData);
        
        // 3. [무결성 유지] 방별 독립성 및 Feature 템플릿 강제 이식 (기존 로직 보존)
        if (initialData.rooms) {
            for (var rName in initialData.rooms) {
                var targetRoom = initialData.rooms[rName];
                if (!targetRoom.features) {
                    if (typeof ROOM_FEATURE_TEMPLATE === 'function') {
                        targetRoom.features = ROOM_FEATURE_TEMPLATE();
                    }
                } else {
                    var template = ROOM_FEATURE_TEMPLATE();
                    if (!targetRoom.features.racing) targetRoom.features.racing = template.racing;
                    if (!targetRoom.features.lotto) targetRoom.features.lotto = template.lotto;
                    if (!targetRoom.features.stockMarket) targetRoom.features.stockMarket = template.stockMarket;
                    if (!targetRoom.features.states) {
                        targetRoom.features.states = template.states;
                    } else {
                        var s = targetRoom.features.states;
                        var ts = template.states;
                        for (var key in ts) {
                            if (!s[key] || typeof s[key] !== 'object') s[key] = {};
                        }
                    }
                }
                if (!targetRoom.loanPools) targetRoom.loanPools = {};
                if (!targetRoom.loanContracts) targetRoom.loanContracts = {};
                if (targetRoom.bankReserve === undefined) targetRoom.bankReserve = 10000;
            }
        }

        // 4. 시스템 엔진(Executor) 및 캐시 객체 바인딩
        if (initialData) {
            // initialData.SaveExecutor = SaveExecutor;
            // initialData.Executor = Executor;
            if (!initialData.nameToIdCache) initialData.nameToIdCache = {};
        }
        
        globalData = initialData;
        return globalData;
    } catch (e) {
        Log.error("DB Load Error: " + e);
        var stableFile = new java.io.File(BACKUP_DIR + "last_stable_backup.json");
        if (stableFile.exists()) {
            globalData = JSON.parse(FileStream.read(BACKUP_DIR + "last_stable_backup.json"));
            return globalData;
        }
        return null;
    }
}

/* 로직 추적 시작 */
function startTracking(user, commandName) {
    if (!user) return;
    user.lastAction = { cmd: commandName, status: "PENDING", time: Date.now(), msg: "수행 시작" };
}

/**
 * [v8.1 업그레이드] 포인트 변동 검증 및 사유 포함 블랙박스 기록
 * [교정]: 로그 한 줄에 reason을 반드시 포함하여 저장합니다.
 */
function verifyPointTransaction(user, prePoint, changeAmount, reason, roomName, brDelta) {
    try {
        var expected = Number(prePoint) + Number(changeAmount);
        var actual = Number(user.point);
        
        if (actual !== expected) {
            var errorMsg = "[" + new Date().toLocaleString() + "] [불일치] " + (user.name||"") + ": " + reason + " (예상:" + fp(expected) + "/실제:" + fp(actual) + ")\n";
            FileStream.append(ERROR_LOG_PATH, errorMsg);
            try { Api.replyRoom("내리다", "⚠️ 포인트 불일치 발생\n" + errorMsg); } catch(e){}
            user.lastAction = { cmd: reason, status: "FAIL", amount: changeAmount, time: Date.now(), msg: "데이터 불일치" };
        } else {
            if (roomName) {
                logLock.lock();
                try {
                    // [핵심 교정]: 로그 포맷에 reason 항목 추가 (5열 구조)
                    var journalEntry = user.uid + "|" + roomName + "|" + changeAmount + "|" + (brDelta || 0) + "|" + reason + "\n";
                    FileStream.append(JOURNAL_PATH, journalEntry);
                } finally {
                    logLock.unlock();
                }
            }
            if (user.lastAction && user.lastAction.status !== "FAIL") {
                user.lastAction = { cmd: reason, status: "SUCCESS", amount: changeAmount, time: Date.now(), msg: "정상 완료" };
            }
        }
    } catch(e) { 
        FileStream.append(ERROR_LOG_PATH, "검증오류: " + e + "\n"); 
    }
}

/* 로직 추적 종료 */
function endTracking(user, isSuccess, resultMsg) {
    if (!user || !user.lastAction) return;
    if (user.lastAction.status === "FAIL") return; 
    user.lastAction.status = isSuccess ? "SUCCESS" : "CRASH";
    user.lastAction.msg = resultMsg;
    user.lastAction.endTime = Date.now();
}

//==========섹터3==========

/* [최적화] 하이브리드 비동기 영속화(Asynchronous Persistence) 엔진 v6.0 (Defense + Performance) */
/**
 * @param {Object} data - 저장할 데이터 객체
 * @param {Boolean} isForceBackup - true일 경우 백업 파일까지 물리적으로 기록
 */
function safeSaveData(data, isForceBackup) {
    if (!data) return;

    var isHealed = false; // 치유 발생 여부
    var healReports = []; // 치유 내역 보고서

    /**
     * [1단계: 무결성 검역소] - 메인 스레드 수행
     * 사용자님의 핵심 방어 로직(포인트/은행/주식/가방 80% 급감, 유저 증발 등)을 그대로 유지합니다.
     */
    try {
        var roomCount = Object.keys(data.rooms || {}).length;
        if (roomCount === 0) throw new Error("저장 거부: 방(rooms) 객체가 비어있습니다.");

        // 비교용 기존 데이터 로드 (방어 로직 검증용)
        var DB_DATA = null;
        try {
            var dbFile = new java.io.File(FILE_PATH);
            if (dbFile.exists()) {
                var dbContent = FileStream.read(FILE_PATH);
                if (dbContent) DB_DATA = JSON.parse(dbContent);
            }
        } catch(e) { Log.error("DB Read for Healing Fail: " + e); }

        for (var rName in data.rooms) {
            var room = data.rooms[rName];
            var uKeys = Object.keys(room.users || {});
            
            // 1. 유저 대량 증발 체크 (핵심 방어)
            if (globalData.rooms[rName]) {
                var prevCount = Object.keys(globalData.rooms[rName].users || {}).length;
                var currentCount = uKeys.length;
                if (prevCount > 0 && currentCount === 0) {
                    throw new Error("[" + rName + "] 방의 유저 데이터 전량 누락 감지");
                }
                if (prevCount >= 10 && (currentCount / prevCount) < 0.65) {
                    throw new Error("[" + rName + "] 대량의 유저 데이터 증발 감지 (기존:" + prevCount + "/현재:" + currentCount + ")");
                }
            }

            for (var uid in room.users) {
                var u = room.users[uid];
                
                // 2. 변수 오염(NaN) 체크 및 복구
                var isPointBroken = isNaN(u.point) || u.point === null || typeof u.point !== 'number';
                var isBankBroken = isNaN(u.bank) || u.bank === null || typeof u.bank !== 'number';

                if (isPointBroken || isBankBroken) {
                    if (DB_DATA && DB_DATA.rooms[rName] && DB_DATA.rooms[rName].users[uid]) {
                        var safeU = DB_DATA.rooms[rName].users[uid];
                        if (isPointBroken) u.point = Number(safeU.point || 0);
                        if (isBankBroken) u.bank = Number(safeU.bank || 0);
                        isHealed = true;
                        healReports.push(u.name + " (자산 데이터 오염 수리)");
                    }
                    continue;
                }

                // 3. 정상 활동 플래그(skipHealing) 체크
                if (u.skipHealing === true) {
                    u.skipHealing = false; 
                    continue; 
                }
                
                // 4. 자산 80% 급감 방어 로직 (기존 로직 보존)
                if (DB_DATA && DB_DATA.rooms[rName] && DB_DATA.rooms[rName].users[uid]) {
                    var safeU = DB_DATA.rooms[rName].users[uid];
                    
                    // A. 포인트 급감 체크
                    var lastPoint = Number(safeU.point || 0);
                    if (lastPoint > 10000 && (lastPoint - u.point) / lastPoint >= 0.8) {
                        u.point = lastPoint; isHealed = true;
                        healReports.push(u.name + " (포인트 80%↑ 급감 복구)");
                    }
                    // B. 은행 잔고 급감 체크
                    var lastBank = Number(safeU.bank || 0);
                    if (lastBank > 10000 && (lastBank - u.bank) / lastBank >= 0.8) {
                        u.bank = lastBank; isHealed = true;
                        healReports.push(u.name + " (은행잔고 80%↑ 급감 복구)");
                    }
                    // C. 주식 보유량 증발 체크
                    if (safeU.stockHoldings) {
                        for (var sName in safeU.stockHoldings) {
                            if (!data.stockMarket || !data.stockMarket[sName]) continue; // 상폐 제외
                            var lastQty = Number(safeU.stockHoldings[sName] || 0);
                            var curQty = Number((u.stockHoldings || {})[sName] || 0);
                            if (lastQty >= 10 && (lastQty - curQty) / lastQty >= 0.8) {
                                if (!u.stockHoldings) u.stockHoldings = {};
                                u.stockHoldings[sName] = lastQty;
                                isHealed = true;
                                healReports.push(u.name + " (" + sName + " 주식 증발 복구)");
                            }
                        }
                    }
                    // D. 인벤토리 증발 체크
                    var lastInvCount = Array.isArray(safeU.inventory) ? safeU.inventory.length : 0;
                    var curInvCount = Array.isArray(u.inventory) ? u.inventory.length : 0;
                    if (lastInvCount >= 5 && (curInvCount / lastInvCount) <= 0.2) {
                        u.inventory = JSON.parse(JSON.stringify(safeU.inventory));
                        isHealed = true;
                        healReports.push(u.name + " (가방 아이템 유실 복구)");
                    }
                }
            }
        }

        if (isHealed && healReports.length > 0) {
            try {
                var reportMsg = "🚨 [데이터 자가 치유 작동]\n" +
                                "손상 의심 데이터를 제외하고 정상 저장되었습니다.\n\n" +
                                "[치유 내역]\n• " + healReports.join("\n• ") + "\n\n" +
                                "⚠️ 관리자는 해당 유저의 활동을 점검하십시오.";
                Api.replyRoom("내리다", reportMsg);
            } catch(e) {}
        }

    } catch (validationError) {
        // 검증 실패 시 로그 남기고 저장 중단 (파일 오염 방지)
        Log.error("!!! [데이터 오염 방지 작동] !!!");
        Log.error("사유: " + validationError.message);
        try {
            Api.replyRoom("내리다", "🚨 [데이터 보호 시스템 작동]\n심각한 데이터 오염이 감지되어 자동 저장을 차단했습니다.\n사유: " + validationError.message + "\n\n⚠️ 관리자는 즉시 시스템을 점검하십시오.");
        } catch (e) {}
        return; 
    }

    // [중요] 메모리 동기화 (즉시 반영하여 명령어 반응 속도 유지)
    globalData = data; 

    /**
     * [2단계: 비동기 영속화] - 배경 스레드 수행 (팅김 방지 핵심)
     * 무거운 '문자열 변환(Stringify)'과 '파일 쓰기'를 배경에서 몰래 처리하여
     * 메인 스레드(명령어 처리)가 멈추거나 팅기는 것을 방지합니다.
     */
    SaveExecutor.execute(new java.lang.Runnable({
        run: function() {
            lock.lock(); 
            try {
                // [크래시 방지] JSON 변환 시 Executor 등 자바 객체 자동 제거 (Replacer 적용)
                var content = JSON.stringify(data, function(key, value) {
                    if (key === "Executor" || key === "SaveExecutor" || (value && typeof value.getClass === 'function')) {
                        return undefined; // 자바 객체는 저장 대상에서 제외
                    }
                    return value;
                });
                
                // 2. 저장 전 데이터 구조 최종 확인
                var check = JSON.parse(content);
                if (!check || !check.rooms) throw new Error("데이터 구조 불완전 (rooms 누락)");

                var targetPath = FILE_PATH;
                var tempPath = FILE_PATH + ".tmp";
                
                // 3. 파일 기록 및 원자적 교체 (Atomic Rename)
                FileStream.write(tempPath, content);
                var tempFile = new java.io.File(tempPath);

                if (tempFile.exists() && tempFile.length() > 0) {
                    var orgFile = new java.io.File(targetPath);
                    if (orgFile.exists()) orgFile.delete();
                    tempFile.renameTo(orgFile);

                    /* [v9.0 블랙박스 로테이션] */
                    logLock.lock();
                    try {
                        var jFile = new java.io.File(JOURNAL_PATH);
                        if (jFile.exists()) jFile.delete();
                    } finally { logLock.unlock(); }
                }

                // 4. 물리 백업 처리
                if (isForceBackup) {
                    var backupPath = BACKUP_DIR + "last_stable_backup.json";
                    FileStream.write(backupPath + ".tmp", content);
                    var bTemp = new java.io.File(backupPath + ".tmp");
                    if (bTemp.exists() && bTemp.length() > 0) {
                        var oldB = new java.io.File(backupPath);
                        if (oldB.exists()) oldB.delete();
                        bTemp.renameTo(oldB);
                    }
                }
                
                content = null; // 메모리 해제
            } catch (e) {
                Log.error("Async Save Fail: " + e.message);
                try {
                    Api.replyRoom("내리다", "⚠️ 시스템 오류: 배경 저장 실패\n" + e.message);
                } catch (err) {}
            } finally {
                lock.unlock();
                // [노트9 최적화] 작업 완료 후 가비지 컬렉션(GC) 유도하여 팅김 방지
                java.lang.System.gc(); 
            }
        }
    }));
}

//==========섹터4==========

/* 관리자 및 시스템 설정 */
var FIXED_ADMINS = ["95 남 광어"]; // 여기에 본인의 정확한 닉네임을 입력하세요
var TIERS = ["아이언", "브론즈", "실버", "골드", "플레티넘", "에메랄드", "다이아몬드", "마스터", "그랜드마스터", "챌린저"];
var ALLOWED_ROOMS = ["내리다", "테스트"]; 

//==========섹터5==========

/* 고티어 승급 확률 설정 */
var TIER_PROBS = {
    0: { up: 95, stay: 5, down: 0 },
    1: { up: 85, stay: 15, down: 0 },
    2: { up: 70, stay: 25, down: 5 },
    3: { up: 50, stay: 40, down: 10 },
    4: { up: 35, stay: 50, down: 15 },
    5: { up: 20, stay: 60, down: 20 },
    6: { up: 12, stay: 68, down: 20 },
    7: { up: 8, stay: 67, down: 25 },  
    8: { up: 5, stay: 70, down: 25 }  
};

/* 상점 카테고리 정의 */
var SHOP_CATEGORIES = {
    1: "🎨 장착/꾸미기 (아이콘)",
    2: "🔂 성장/게임 (승급, 방어)",
    3: "💳 경제/지원 (신용, 인증, 기타)",
    4: "🎁 랜덤 뽑기 (아이콘 박스)",
    5: "🎫 특수/복권 (로또)"
};

/* [수정] 상점 아이템 데이터 (경고삭제권 추가) */
var SHOP_ITEMS = [
    { id: 1, name: "활동가 아이콘", icon: "🌱", price: 10000, effect: "icon", title: "", cat: 1 },
    { id: 2, name: "숙련자 아이콘", icon: "⚔️", price: 30000, effect: "icon", title: "", cat: 1 },
    { id: 3, name: "러블리 아이콘", icon: "❣️", price: 60000, effect: "icon", title: "", cat: 1 },
    { id: 4, name: "베테랑 아이콘", icon: "💎", price: 120000, effect: "icon", title: "", cat: 1 },
    { id: 5, name: "에이리언 아이콘", icon: "👾", price: 250000, effect: "icon", title: "", cat: 1 },
    { id: 6, name: "네임드 아이콘", icon: "👑", price: 500000, effect: "icon", title: "", cat: 1 },
    { id: 8, name: "승급 기회 구매", icon: "🔂", price: 1000, effect: "promotion", cat: 2 },  
    { id: 9, name: "강등 방어권", icon: "🛡️", price: 20000, effect: "tierGuard", cat: 2 },
    { id: 10, name: "신용 점수 회복", icon: "💊", price: 10000, effect: "credit", value: 50, cat: 3 },
    { id: 11, name: "[시즌] 롤 판수 인증권", icon: "🎫", price: 100000, effect: "gameAuth", cat: 3 },
    /* [신규] 경고삭제권: 기본가 500,000P 설정 */
    { id: 13, name: "경고삭제권", icon: "🎫", price: 2000000, effect: "warnClear", cat: 3 },
    { id: 12, name: "랜덤 아이콘 박스", icon: "🎁", price: 10000, effect: "randomBox", cat: 4 },
    { id: 7, name: "로또 구매", icon: "🎟️", price: 2000, effect: "lotto", cat: 5 },
    { id: 14, name: "스피또 복권", icon: "🧧", price: 2000, effect: "spitto", cat: 5 }
];

/* [신규] 랜덤 아이콘 박스 상세 구성 및 확률 설정 */
var RANDOM_BOX_CONFIG = {
    PROBS: [
        { grade: "꽝 (Trash)", icon: "💩", prob: 0.60, items: ["💩", "🤡", "🧤", "👞", "🌂", "🪠", "🚽", "🦴", "🧱", "🧹", "🧺", "🧻", "🧼", "🦶", "🦟"] },
        { grade: "노말 (Normal)", icon: "🌱", prob: 0.20, items: ["🌱", "⚔️", "❣️", "🍀", "🎀", "🎈", "🧸", "🪁", "🍭", "🍏", "🍄", "🌻", "🐱", "🐶", "🍎"] },
        { grade: "레어 (Rare)", icon: "💎", prob: 0.10, items: ["💎", "👾", "🛡️", "🎰", "🔱", "🧿", "🎭", "🎨", "🧪", "🔭", "🎸", "🏹", "🕯️", "⛓️", "🧬"] },
        { grade: "에픽 (Epic)", icon: "🔮", prob: 0.05, items: ["👑", "☄️", "🧨", "🔮", "⛩️", "🎡", "🚁", "🌋", "🐅", "🦅", "🏹", "🏰", "🛥️", "🧿"] },
        { grade: "유니크 (Unique)", icon: "🦄", prob: 0.03, items: ["🪐", "🏮", "🐲", "🦾", "🛰️", "🦄", "🧞", "🦁", "🐋", "🦜", "🕸️", "🎃", "🎅", "🧜"] },
        { grade: "레전더리 (Legendary)", icon: "🎰", prob: 0.02, items: ["🔥", "💫", "🌌", "⚡", "🛸", "🌈", "☀️", "❄️", "🌑", "🔱", "💮", "💠", "🎖️" ] }
    ],
    PAYBACK: 2000 // 중복 아이콘 당첨 시 환급금
};

//==========섹터6==========

/**
 * [시스템 모듈] 명령어 자동 등록 및 도움말 관리
 * 기능: CMD_LIST의 데이터를 USER_COMMANDS/ADMIN_COMMANDS 레지스트리에 매핑하고 도움말 생성
 */

/* [1] 도움말 생성 함수 (동적 렌더링) */
function generateHelpMenu(category) {
    var list = [];
    for (var cmd in USER_COMMANDS) {
        var item = USER_COMMANDS[cmd];
        if (item.cat === category) {
            list.push("• " + cmd + ": " + item.desc);
        }
    }
    return list.length > 0 ? list.join("\n") : "해당 카테고리에 준비된 명령어가 없습니다.";
}

function generateAdminHelp() {
    var list = [];
    var idx = 1;
    for (var cmd in ADMIN_COMMANDS) {
        list.push(idx + ". " + cmd + " (" + ADMIN_COMMANDS[cmd].desc + ")");
        idx++;
    }
    return "⚙️ [관리자 전용 명령어]\n" + list.join("\n");
}

/* [2] 명령어 리스트 데이터 (수정됨: 결투 응답 및 경마 명령어 통합 추가) */
var CMD_LIST = {
    user: [
        { cmd: "/출석", desc: "매일 포인트 획득", cat: "조회", func: "_gameShopLogic" },
        { cmd: "/내정보", desc: "내 스탯 확인", cat: "조회", func: "_gameInfoLogic" },
        { cmd: "/가이드", desc: "심화 시스템 가이드 확인", cat: "조회", func: "response" },
        { cmd: "/신용등급", desc: "신용 점수와 등급 확인", cat: "조회", func: "_gameInfoLogic" },
        { cmd: "/출석순위", desc: "포인트 랭킹 확인", cat: "조회", func: "_gameInfoLogic" },
        { cmd: "/유저정보", desc: "[닉네임] 상세정보 보기", cat: "조회", func: "_gameInfoLogic" },
        { cmd: "/명예의전당", desc: "챌린저 명단 확인", cat: "조회", func: "_gameInfoLogic" },
        { cmd: "/버그제보", desc: "[내용] 오류 및 버그 신고", cat: "조회", func: "response" }, 
        { cmd: "/핑", desc: "봇 응답 속도 측정", cat: "조회", func: "_gameInfoLogic" },
        { cmd: "/경마", desc: "현재 출전마 정보 및 배당 확인", cat: "조회", func: "_gameInfoLogic" }, // [신규 경마 조회]
        { cmd: "/코드확인", desc: "기기변경/전체변경 대비 복구코드 확인", cat: "조회", func: "_gameInfoLogic" },
        { cmd: "/계정연동", desc: "[코드] 입력하여 이전 데이터 복구", cat: "조회", func: "_gameInfoLogic" },
        { cmd: "/홀짝", desc: "[홀|짝] [포인트] 도박", cat: "게임", func: "_gameActionLogic" },
        { cmd: "/승급", desc: "티어 승급 도전", cat: "게임", func: "_gameActionLogic" },
        { cmd: "/배팅", desc: "[말번호] [포인트] 경마 참여", cat: "게임", func: "_gameActionLogic" }, // [신규 경마 배팅]
        { cmd: "배팅취소", desc: "현재 회차 배팅 철회 (수수료 10%)", cat: "게임", func: "_gameActionLogic" }, // [신규 경마 취소]
        { cmd: "/결투", desc: "[닉네임] [포인트] 신청", cat: "게임", func: "_gameActionLogic" },
        { cmd: "수락", desc: "결투 신청 승낙", cat: "게임", func: "_gameActionLogic" },
        { cmd: "거절", desc: "결투 신청 거절", cat: "게임", func: "_gameActionLogic" },
        { cmd: "취소", desc: "결투 신청 철회", cat: "게임", func: "_gameActionLogic" },
        { cmd: "/도둑질", desc: "[닉네임] 포인트 탈취 시도", cat: "게임", func: "_gameActionLogic" },
        { cmd: "잡았다요놈", desc: "도둑질 방어 (1분 이내)", cat: "게임", func: "_gameActionLogic" },
        { cmd: "줍기", desc: "바닥에 떨어진 포인트 획득", cat: "게임", func: "_gameActionLogic" },
        { cmd: "/상점", desc: "아이콘 및 방어권 구매", cat: "상점", func: "_gameShopLogic" },
        { cmd: "/구매", desc: "[번호] 상점 물품 구매", cat: "상점", func: "_gameShopLogic" },
        { cmd: "/가방", desc: "보유 중인 아이콘/칭호 확인", cat: "상점", func: "_handleInventoryLogic" },
        { cmd: "/장착", desc: "[번호] 보유 아이템 장착", cat: "상점", func: "_handleInventoryLogic" },
        { cmd: "/분해", desc: "[번호] 아이콘 분해 및 포인트 회수", cat: "상점", func: "_handleInventoryLogic" },
        { cmd: "/로또정보", desc: "내 로또 번구 및 결과 확인", cat: "상점", func: "_handleLottoLogic" },
        { cmd: "/아이콘초기화", desc: "설정한 아이콘 삭제", cat: "상점", func: "_handleLottoLogic" },
        { cmd: "/은행", desc: "예금/출금/송금/대출/사채 종합 관리", cat: "경제", func: "_gameBankLogic" },
        { cmd: "/대출한도", desc: "신용 등급별 한도 확인", cat: "경제", func: "_gameInfoLogic" },
        { cmd: "/상환", desc: "[금액] 대출금 직접 상환", cat: "경제", func: "_gameBankLogic" },
        { cmd: "/주식", desc: "실시간 주가 확인", cat: "주식", func: "_gameStockLogic" },
        { cmd: "/내주식", desc: "보유 주식 및 수익률 확인", cat: "주식", func: "_gameStockLogic" },
        { cmd: "/매수", desc: "[종목명] [수량] 주식 구매", cat: "주식", func: "_gameStockLogic" },
        { cmd: "/매도", desc: "[종목명] [수량] 주식 판매", cat: "주식", func: "_gameStockLogic" },
        { cmd: "/광산시작", desc: "방치형 포인트 채굴 시작", cat: "광산", func: "_handleMiningLogic" },
        { cmd: "/광산정보", desc: "현재 채굴 현황 및 예상 수익 확인", cat: "광산", func: "_handleMiningLogic" },
        { cmd: "/광산종료", desc: "채굴 완료 및 포인트 정산", cat: "광산", func: "_handleMiningLogic" },
        { cmd: "/유물도감", desc: "유물 조각 수집 현황 확인", cat: "광산", func: "_gameInfoLogic" },
        { cmd: "/의회", desc: "현재 정책 및 안건 조회", cat: "정부", func: "_gameGovernmentLogic" },
        { cmd: "/투표", desc: "[찬성|반대] 안건 투표 참여", cat: "정부", func: "_gameGovernmentLogic" },
        { cmd: "/스피또", desc: "즉석복권 구매 (1,000P)", cat: "상", func: "_gameLotteryLogic" },
        { cmd: "/낚시", desc: "강가에서 물고기 낚기 (10분 쿨타임)", cat: "게임", func: "_gameActivityLogic" }
    ],
    admin: [
        { cmd: "/봇구동", desc: "[온|오프] 시스템 제어", func: "_adminSystemLogic" },
        { cmd: "/진단", desc: "[닉네임] 유저 상태 정밀 분석", func: "_adminUserManageLogic" },
        { cmd: "/시장자산복구", desc: "유저 평단가 기반 주가 긴급 복구", func: "_adminEconomyLogic" },
        { cmd: "/종목추가", desc: "[이름] [가격] 신규 상장", func: "_adminEconomyLogic" },
        { cmd: "/종목수정", desc: "[기존] [새이름] [가격] 수정", func: "_adminEconomyLogic" },
        { cmd: "/경제정보", desc: "은행 재원 및 경제 지표 확인", func: "_adminEconomyLogic" },
        { cmd: "/재원수정", desc: "[금액] 은행 금고 자본 조정", func: "_adminEconomyLogic" },
        { cmd: "/데이터교정", desc: "은행 재원 및 유저 데이터 동기화", func: "_adminEconomyLogic" },
        { cmd: "/물가조정", desc: "[기준값] 인플레 반영 상점가 조절", func: "_adminEconomyLogic" },
        { cmd: "/물가완충", desc: "[0.0~1.0] 물가 변동폭 조절", func: "_adminEconomyLogic" },
        { cmd: "/강제재가동", desc: "시스템 락 해제 및 리셋", func: "_adminSystemLogic" },
        { cmd: "/유저삭제", desc: "[닉네임] 데이터 영구 삭제", func: "_adminUserManageLogic" },
        { cmd: "/유저데이터", desc: "상세 JSON 데이터 확인", func: "_adminUserManageLogic" },
        { cmd: "/데이터이전", desc: "[구닉] > [신닉] 자산 이전", func: "_adminUserManageLogic" },
        { cmd: "/닉네임기록", desc: "[닉네임] 변경 이력 조회", func: "_adminUserManageLogic" },
        { cmd: "/출석초기화", desc: "[닉네임] 오늘 기록 삭제", func: "_adminUserManageLogic" },
        { cmd: "/포인트지급", desc: "[닉네임] [수량] 직접 지급", func: "_adminEconomyLogic" },
        { cmd: "/전체포인트지급", desc: "[수량] 전원 지급", func: "_adminEconomyLogic" },
        { cmd: "/포인트차감", desc: "[닉네임] [수량] 차감", func: "_adminEconomyLogic" },
        { cmd: "/도박제한", desc: "[온|오프] 시스템 제어", func: "_adminSystemLogic" },
        { cmd: "/뿌리기", desc: "랜덤 포인트 선착순 이벤트", func: "_adminEconomyLogic" },
        { cmd: "/관리자등록", desc: "[닉네임] 부관리자 추가", func: "_adminSystemLogic" },
        { cmd: "/관리자해제", desc: "[닉네임] 관리자 권한 박탈", func: "_adminSystemLogic" },
        { cmd: "/관리자목록", desc: "권한 보유자 명단 조회", func: "_adminSystemLogic" },
        { cmd: "/관리자로그", desc: "최근 관리 활동 내역", func: "_adminLogLogic" },
        { cmd: "/제보목록", desc: "버그 제보 확인", func: "_adminLogLogic" },
        { cmd: "/제보초기화", desc: "제보 내역 전체 삭제", func: "_adminLogLogic" },
        { cmd: "/오류로그", desc: "시스템 에러 로그 확인", func: "_adminLogLogic" },
        { cmd: "/오류초기화", desc: "시스템 에러 로그 삭제", func: "_adminLogLogic" },
        { cmd: "/승급횟수초기화", desc: "전체 승급 기회 리셋", func: "_adminEconomyLogic" },
        { cmd: "/시즌강제종료", desc: "모든 티어 초기화", func: "_adminEconomyLogic" },
        { cmd: "/출석일수수정", desc: "[닉네임] [수치] 수정", func: "_adminUserManageLogic" },
        { cmd: "/전체출석수정", desc: "모든 유저 출석일 고정", func: "_adminUserManageLogic" },
        { cmd: "/로또데이터초기화", desc: "로또 시스템 리셋", func: "_adminEconomyLogic" },
        { cmd: "/전체복원", desc: "데이터 롤백 (안전 지점)", func: "_adminEconomyLogic" },
        { cmd: "/유저복원", desc: "[닉네임] 부분 복구", func: "_adminUserManageLogic" },
        { cmd: "/시스템자가복원", desc: "메모리 최적화 및 변수 초기화", func: "_adminEconomyLogic" },
        { cmd: "/이월금수정", desc: "[금액] 경마 잭팟 금액 강제 조정", func: "_adminEconomyLogic" },
        { cmd: "/재원충전", desc: "[금액] 은행 금고 자본 긴급 수혈", func: "_adminEconomyLogic" },
        { cmd: "/보안점검", desc: "데이터 보호 엔진 자가진단", func: "_adminEconomyLogic" },
        { cmd: "/명부확인", desc: "등록된 전체 유저 복구 코드 조회", func: "_adminEconomyLogic" },
        { cmd: "/명부삭제", desc: "[닉네임] 특정 유저 명부 강제 삭제", func: "_adminEconomyLogic" },
        { cmd: "/명부업데이트", desc: "등록된 전체 유저 복구 코드 업데이트", func: "_adminEconomyLogic" },
        { cmd: "/신용조정", desc: "[닉네임] [점수] 신용점수 직접 가감", func: "_adminUserManageLogic" },
        { cmd: "/칭호회수", desc: "[닉네임] [칭호명] 박탈", func: "_adminUserManageLogic" },
        { cmd: "/보안테스트", desc: "[1-3] 보안 엔진 4단계 스트레스 테스트", func: "_adminEconomyLogic" },
        { cmd: "/시장데이터교정", desc: "헬러 간섭으로 꼬인 주식 수량 강제 압축 및 교정", func: "_adminEconomyLogic" },
        { cmd: "/경제전체리셋", desc: "모든 유저 자산/부채 초기화 및 20만P 공평 지급", func: "_adminEconomyLogic" }
    ]
};

/* 전역 상태 변수들 (섹터1과 중복 방지 처리) */ 
var sprayData = { 
    totalPoint: 0, 
    remainingPoint: 0, 
    maxWinners: 0, 
    currentWinners: 0, 
    winnersList: [], 
    isActive: false, 
    timer: null 
};

/* 섹터1에 없는 변수만 신규 선언 */ 
// var selectWaitState = {}; 
// var bankProcessState = {};

//==========섹터7==========

/**
 * [신설: 가상 정부 정책 추출기] v1.0
 * 기능: 해당 방의 현재 시행 중인 정책 객체를 안전하게 반환
 */
function util_getActivePolicy(roomData) {
    if (roomData && roomData.features && roomData.features.government && roomData.features.government.activePolicy) {
        return roomData.features.government.activePolicy;
    }
    // 정책 데이터가 없을 경우 표준 기본값 반환 (시스템 중단 방지)
    return {
        stockTax: 0.05,
        mineMult: 1.0,
        attendMult: 1.0,
        loanLimitMult: 1.2,
        bankInterest: 0.01,
        theftFineMult: 1.0,
        policeProbAdj: 0.0
    };
}

/**
 * [신설: 범용 데이터 게이트웨이] v1.0
 * 기능: 티어, 신용점수, 통계 등 모든 일반 변수의 수정을 감시하고 오염을 차단
 */
function util_setData(user, key, value, reason, roomName) {
    if (!user || key === undefined) return;
    
    var preValue = user[key];
    
    // [감사] 기존 데이터와 새로운 데이터의 타입이 다르면 차단 (예: 숫자 자리에 문자열 주입)
    // 단, 기존 값이 null이나 undefined인 경우는 초기화로 간주하여 통과
    if (preValue !== undefined && preValue !== null) {
        if (typeof preValue !== typeof value || (typeof value === 'number' && isNaN(value))) {
            Log.error("[Universal Audit Fail] " + (user.name || "Unknown") + "의 " + key + " 데이터 오염 시도 차단");
            return; 
        }
    }

    user[key] = value; // 안전 검증 통과 시 값 변경

    // [확장성] 특정 핵심 변수 변경 시 로그 기록이나 부수 효과 연동
    if (key === 'tier' && preValue !== value) {
        Log.info("[Status Change] " + user.name + " 티어 변동: " + preValue + " -> " + value);
    }
}

/**
 * [신설: 중앙은행 국고 3중 방어막] v1.0
 * 기능: 국가 전체 재원의 NaN, 부분 증발, 비상식적 급감을 감시
 */
function util_updateReserve(roomData, delta, reason, roomName) {
    if (!roomData || isNaN(delta) || delta === 0) return;
    
    var preReserve = Number(roomData.bankReserve || 0);
    var expectedReserve = preReserve + Number(delta);
    roomData.bankReserve = expectedReserve;

    // [중요] 국고 급감 자가치유 예외 사유 (경마 당첨금, 대형 잭팟 등)
    var normalOutflow = ["경마 당첨금", "로또 1등", "주식 매도", "은행 출금", "재원 수정", "경마 보전금 지출", "민생지원금 지급", "의회 투표 거마비 지급"];
    var isNormal = normalOutflow.some(function(act) { return reason.indexOf(act) !== -1; });

    // [3중 감사]
    var isCorrupted = isNaN(roomData.bankReserve) || (roomData.bankReserve !== expectedReserve);
    var isAbnormalLoss = !isNormal && (preReserve > 100000 && expectedReserve / preReserve <= 0.2);

    if (isCorrupted || isAbnormalLoss) {
        var db = getDatabase();
        var rName = roomName || "내리다";
        var safeReserve = (db.rooms[rName]) ? Number(db.rooms[rName].bankReserve || 0) : 10000;

        roomData.bankReserve = safeReserve; // 파일 데이터로 즉시 복구
        var errType = isCorrupted ? "국고 연산 오차(Audit Fail)" : "국고 비상식적 급감(도난/버그 의심)";
        try { Api.replyRoom(rName, "🚨 [국가 재정 보안 엔진 작동]\n사유: " + errType + "\n상태: 국고 자산 안전 지점 복구 완료"); } catch(e){}
    }
}

/**
 * [신설: 주식 보유량 정밀 감사] v1.1 (Deep Healer 예외 처리 적용)
 * 기능: 종목별 수량 연산의 무결성 검증 및 매도 시 오탐지 방지
 */
function util_updateStock(user, stockName, delta, reason, roomName) {
    if (!user || !stockName || isNaN(delta)) return;
    if (!user.stockHoldings) user.stockHoldings = {};
    
    // [Healer 예외 처리] 정상적인 매도 활동인 경우 자가 치유 건너뛰기 플래그 활성화
    if (delta < 0) {
        var normalStockActs = ["매도", "판매", "청산", "상장폐지"];
        var isNormal = normalStockActs.some(function(act) { return reason.indexOf(act) !== -1; });
        if (isNormal) user.skipHealing = true;
    }
    
    var preCount = Number(user.stockHoldings[stockName] || 0);
    var expectedCount = preCount + Number(delta);
    user.stockHoldings[stockName] = expectedCount;

    // [감사] 1P(1주)라도 오차가 나거나 수량이 음수가 되면 즉시 복구
    if (isNaN(user.stockHoldings[stockName]) || user.stockHoldings[stockName] !== expectedCount || user.stockHoldings[stockName] < 0) {
        var db = getDatabase();
        var safeUser = null;
        for (var r in db.rooms) { if (db.rooms[r].users[user.uid]) { safeUser = db.rooms[r].users[user.uid]; break; } }
        
        if (safeUser && safeUser.stockHoldings) {
            user.stockHoldings[stockName] = Number(safeUser.stockHoldings[stockName] || 0);
            try { Api.replyRoom(roomName || "내리다", "🛡️ [주식 자산 자가치유]\n종목: " + stockName + "\n사유: 보유 수량 연산 오류\n상태: 안전 지점으로 롤백"); } catch(e){}
        }
    }
}

/**
 * [신설: 은행 잔고 게이트웨이] v1.1 (Deep Healer 예외 처리 적용)
 * 기능: 유저의 bank(예금) 변동을 감시하고 NaN 및 오염을 차단
 */
function util_updateBank(user, roomData, delta, reason, roomName) {
    if (!user || isNaN(delta) || delta === 0) return;

    // [Healer 예외 처리] 정상적인 출금/송금 활동인 경우 자가 치유 건너뛰기 플래그 활성화
    if (delta < 0) {
        var normalBankActs = ["출금", "송금", "이체", "결제", "지불", "기부", "수수료"];
        var isNormal = normalBankActs.some(function(act) { return reason.indexOf(act) !== -1; });
        if (isNormal) user.skipHealing = true;
    }

    var now = Date.now();
    var preBank = Number(user.bank || 0);

    // [이자 적립 엔진] 잔액이 변하기 전, 직전까지 머물렀던 금액에 대한 이자 계산
    if (user.lastBankUpdateTime > 0 && preBank > 0) {
        var timePassed = now - user.lastBankUpdateTime;
        var dayMs = 24 * 60 * 60 * 1000; // 하루 밀리초
        // 공식: 잔액 * 이율(5%) * (흐른시간 / 하루시간)
        var earned = preBank * 0.05 * (timePassed / dayMs);
        user.accruedInterest = (user.accruedInterest || 0) + earned;
    }
    user.lastBankUpdateTime = now; // 변동 시점 기록
    var expectedBank = preBank + Number(delta);
    if (expectedBank < 0) expectedBank = 0;
    user.bank = expectedBank;
    if (isNaN(user.bank) || user.bank !== expectedBank) {
        var db = getDatabase();
        var safeUser = null;
        for (var r in db.rooms) { if (db.rooms[r].users[user.uid]) { safeUser = db.rooms[r].users[user.uid]; break; } }
        if (safeUser && !isNaN(safeUser.bank)) {
            user.bank = Number(safeUser.bank);
            try { Api.replyRoom(roomName || "내리다", "🛡️ [은행 자산 자가치유]\n대상: " + user.name + "\n사유: 예금 연산 오류\n상태: 안전 지점 복구 완료"); } catch(e){}
        }
    }
}

/**
 * [시스템] 진단용 체크포인트 도장 함수
 * 설명: 스케줄러 로직의 완결성을 체크하기 위해 메모리에 타임스탬프를 기록합니다.
 */
function util_stamp(key) {
    if (typeof globalData !== 'undefined' && globalData !== null) {
        if (!globalData.statusCheck) globalData.statusCheck = {};
        globalData.statusCheck[key] = Date.now();
    }
}

/**
 * [수정] 통합 순자산 계산 엔진 (참조 오류 완벽 방지)
 */
function util_calculateNetWorth(user, roomData) {
    if (!user) return 0;
    try {
        var data = getDatabase(); 
        var liquidAssets = Number(user.point || 0) + Number(user.bank || 0);
        var stockAssets = 0;

        // [교정]: 주식 시장 데이터 경로 통합 탐색 (Crash 방지)
        var market = data.stockMarket || (roomData && roomData.features ? roomData.features.stockMarket : null);

        if (user.stockHoldings && market) {
            for (var sName in user.stockHoldings) {
                var stock = market[sName];
                if (stock) stockAssets += (Number(user.stockHoldings[sName] || 0) * Number(stock.price || 0));
            }
        }
        
        var bankDebt = (user.loan && user.loan.debt) ? Number(user.loan.debt) : 0;
        var sacheDebt = 0;
        var sacheClaims = 0; 

        if (roomData && roomData.loanContracts) {
            for (var cid in roomData.loanContracts) {
                var c = roomData.loanContracts[cid];
                if (c.borrowerUid === user.uid) sacheDebt += Number(c.currentDebt || 0);
                if (c.lenderUid === user.uid) sacheClaims += Number(c.currentDebt || 0);
            }
        }
        return Math.max(0, Math.floor(liquidAssets + stockAssets + sacheClaims - bankDebt - sacheDebt));
    } catch(e) {
        return Number(user.point || 0); // 에러 시 최소한의 값 반환으로 로직 중단 방지
    }
}

/**
 * [핵심: 포인트 게이트웨이 엔진] v6.0
 */
function util_updatePoint(user, roomData, delta, reason, roomName) {
    if (!user || isNaN(delta) || delta === 0) return;

    // 정상 활동 리스트 확장 (매도, 출금, 분해 등 추가)
    var normalActivities = [
        "매수", "매도", "상점", "구매", "예금", "출금", "송금", "배팅", 
        "사채", "기부", "차감", "홀짝", "결투", "벌금", "상환", "패널티", "분해", "줍기",
        "도둑질", "수수료", "수거", "정산", "환수", "징수", "벌금"
    ];
    
    // 정상 활동으로 인한 차감일 경우 자가치유 보호막 활성화
    if (delta < 0) {
        var isNormal = normalActivities.some(function(act) { return reason.indexOf(act) !== -1; });
        if (isNormal) user.skipHealing = true;
    }
    
    // 1. 데이터 형식 정규화 (NaN 및 0원 버그 방지)
    var prePoint = Number(user.point || 0);
    var numDelta = Number(delta);

    // 2. [전 구간 마이너스 방지 장치]
    var actualDelta = numDelta;
    if (numDelta < 0 && (prePoint + numDelta) < 0) {
        actualDelta = -prePoint; // 보유액보다 많이 뺄 경우 0원 고정
    }

    // 3. 중앙은행(국고) 재원 변동 로직 (안전장치 패치 적용)
    var bankOutputReasons = ["출석 보상", "민생지원금 지급", "홀짝 적중", "주식 매도", "광산 채굴", "로또 1등 당첨", "로또 2등 당첨", "로또 3등 당첨", "아이템 분해 회수", "랜덤박스 중복 환급", "결투 승리 보상", "뿌리기 줍기", "경마 당첨금", "은행 출금", "은행 대출 실행", "의회 투표 거마비 지급"];
    var bankInputReasons = ["주식 매수", "홀짝 미적중", "도둑질 체포 벌금", "대출 상환", "상점 구매", "경찰 체포 벌금", "경찰 벌금", "도둑질 성공", "은행 기부", "경마 배팅", "배팅 취소 수수료", "사채", "벌금", "상환", "로또 구매", "자산 보유세 징수", "장기 미접속 자산 환수"];

    var brDelta = 0; 
    
    // [Safety Guard] roomData가 유효할 때만 국고 연동 수행 (참조 오류로 인한 봇 멈춤 방지)
    if (roomData && typeof roomData === 'object') {
        if (roomData.bankReserve === undefined) roomData.bankReserve = (SYSTEM_CONFIG && SYSTEM_CONFIG.ECO.BANK.INITIAL_RESERVE) ? SYSTEM_CONFIG.ECO.BANK.INITIAL_RESERVE : 10000;
        
        if (actualDelta > 0) {
            if (bankOutputReasons.some(function(r){ return reason.indexOf(r) !== -1; })) brDelta = -actualDelta;
        } else {
            if (bankInputReasons.some(function(r){ return reason.indexOf(r) !== -1; })) brDelta = Math.abs(actualDelta);
        }
        util_updateReserve(roomData, brDelta, reason, roomName);
    }

    // 4. 최종 포인트 갱신 (안전 연산)
    var expectedPoint = prePoint + actualDelta; 
    user.point = expectedPoint; 

    // [레이어 1: 타입 및 연산 감사] NaN이거나, 1P라도 계산이 틀린 경우 (뒷자리 잘림 등)
    var isCorrupted = isNaN(user.point) || (user.point === null) || (user.point !== expectedPoint);
    
    // [레이어 2: 경제적 급감 감사] 정상 활동 예외가 아닌데 자산의 80%가 증발한 경우 (논리 버그)
    var lossRate = prePoint > 0 ? (prePoint - user.point) / prePoint : 0;
    var isAbnormalLoss = !user.skipHealing && (lossRate >= 0.8);

    if (isCorrupted || isAbnormalLoss) {
        var db = getDatabase();
        var safeUser = null;
        for (var r in db.rooms) { if (db.rooms[r].users[user.uid]) { safeUser = db.rooms[r].users[user.uid]; break; } }

        if (safeUser && !isNaN(safeUser.point)) {
            user.point = Number(safeUser.point); // 안전한 파일 데이터로 즉시 롤백
            
            var errorDetail = isCorrupted ? "데이터 오염 및 연산 불일치(NaN/Audit Fail)" : "비상식적 자산 급감(80%↑)";
            try { 
                Api.replyRoom(roomName || "내리다", "🛡️ [시스템 3중 방어막 작동]\n대상: " + (user.name||"유저") + "\n사유: " + errorDetail + "\n상태: 오염 데이터 차단 및 즉각 복구 완료"); 
            } catch(e){}
        }
    }

    // 5. 자산가 칭호 엔진 (에러 격리 보호막 적용)
    // 설명: 여기서 에러가 나더라도 로또 구매 응답 메시지는 반드시 출력되도록 try-catch로 감쌉니다.
    try {
        var totalNetWorth = util_calculateNetWorth(user, roomData);
        var assetTitles = [
            { name: "자산왕", limit: 5000000, id: 703, msg: "[장착 효과]: 매일 00시 은행 예금 이자 수령 시 이율 1.5배 보너스가 적용됩니다." },
            { name: "부호", limit: 2000000, id: 702, msg: "상류 사회의 일원이 되신 것을 환영합니다." },
            { name: "거상", limit: 1000000, id: 701, msg: "시장을 움직이는 거대한 손길이 느껴집니다." },
            { name: "재벌", limit: 500000, id: 700, msg: "성공적인 자산 축적의 첫 결실을 맺었습니다." }
        ];

       var rStub = { reply: function(m) { try { Api.replyRoom(roomName || "내리다", m); } catch(e){} } };

        for (var i = 0; i < assetTitles.length; i++) {
            var t = assetTitles[i];
            if (totalNetWorth >= t.limit) {
                // 공용 함수를 호출하여 작위 수여식 진행 (가방 체크 및 장착 로직 내장됨)
                var awarded = util_checkAndAwardTitle(
                    user, 
                    rStub, 
                    t.name, 
                    t.id, 
                    "💰", 
                    "내리다 경제 위원회", 
                    "순자산 " + fp(t.limit) + "P", 
                    t.msg, 
                    roomName
                );
                
                if (awarded) break; // 하나라도 수여했다면 중단 (중복 방지)
            }
        }
    } catch(titleError) {
        // 칭호 엔진에서 에러가 나면 무시하고 다음 로직(로또 응답)으로 넘깁니다.
    }

    // 6. 블랙박스 저널링 기록 (유실 방지)
    if (typeof verifyPointTransaction === 'function') {
        verifyPointTransaction(user, prePoint, actualDelta, reason, roomName, brDelta);
    }
}

/* 포인트 단위 쉼표 포맷팅 (0원 버그 방지형) */
function fp(val) {
    var num = Number(val);
    if (isNaN(num)) return "0";
    return String(Math.floor(num)).replace(/\B(?=(\d{3})+(?!\d))/g, ",");
}
var fP = fp;

/* UI 포맷터 함수군 */
function formatCommand(title, user, content, nextStep) { 
    var msg = title + "\n━━━━━━━━━━━━━━━\n"; 
    if (user !== null) { 
        var nameTag = (typeof user === "string") ? user : getDisplayName(user); 
        msg += nameTag + "님\n"; 
    } 
    msg += content + "\n━━━━━━━━━━━━━━━"; 
    if (nextStep) msg += "\n💡 [가이드]: " + nextStep; 
    return msg; 
}

function formatSimple(title, content, nextStep) {
    var msg = "ℹ️ " + title + "\n━━━━━━━━━━━━━━━\n" + content + "\n━━━━━━━━━━━━━━━";
    if (nextStep) msg += "\n💡 [가이드]: " + nextStep;
    return msg;
}

function formatAdmin(title, content) { 
    return "⚙️ " + title + "\n━━━━━━━━━━━━━━━\n" + content + "\n━━━━━━━━━━━━━━━"; 
}

function formatError(user, content, nextStep) { 
    var nameTag = (typeof user === "string") ? user : getDisplayName(user); 
    var msg = "🚫 오류 발생\n━━━━━━━━━━━━━━━\n" + nameTag + "님\n사유: " + content + "\n━━━━━━━━━━━━━━━"; 
    if (nextStep) msg += "\n💡 [가이드]: " + nextStep; 
    return msg; 
}

/**
 * [신규] 주식 가격 변동 엔진
 */
function stock_calculateNextPrice(currentPrice) {
    if (!marketOpenPrice || marketOpenPrice <= 0) return currentPrice;
    var cfg = SYSTEM_CONFIG.ECO.STOCK.SETTINGS;
    var growthRate = (currentPrice - marketOpenPrice) / marketOpenPrice;
    var change = (Math.random() * 2.4 - 1.2) / 100;

    if (growthRate > cfg.RESISTANCE_START) {
        // [최종 교정]: 삭제된 timeWeight 참조를 제거하여 수식 오류를 방지함
        var resistance = (growthRate - cfg.RESISTANCE_START) * cfg.GRAVITY;
        change -= resistance;
        
        if (growthRate >= (cfg.CLOSING_LIMIT - 0.01) && change > 0) {
            if (Math.random() < 0.8) change = -Math.abs(change) * 0.5;
        }
    }
    return Math.max(10, currentPrice + (currentPrice * change));
}

/**
 * [신설] 국고 비상태세 배율 산출 (지능형 방어)
 */
function util_getEmergencyMultiplier(roomName) {
    var data = getDatabase();
    var roomData = data.rooms[roomName];
    if (!roomData || !roomData.economyBase) return 1.0;
    
    var reserve = Number(roomData.bankReserve || 0);
    var base = Number(roomData.economyBase);
    
    // 재고가 기준점의 10% 미만이면 모든 보상 50% 삭감
    if (reserve < (base * 0.1)) return 0.5; 
    return 1.0;
}

/**
 * [신설] 국고 지급 가능 여부 체크 (부도 방어)
 */
function util_isBankSolvent(roomName, amount) {
    var data = getDatabase();
    var roomData = data.rooms[roomName];
    if (!roomData) return false;
    return (Number(roomData.bankReserve || 0) >= amount);
}

/**
 * [신설] 국가 부도 상태 확인 함수
 * 부도 선포(disaster) 상태인지 확인하여 리스크 컨텐츠 진행 여부 결정
 */
function util_isBankruptcy(roomName) {
    var data = getDatabase();
    var roomData = data.rooms[roomName];
    if (!roomData) return false;
    // lastBankAlert가 'disaster'인 경우에만 true(부도상태)를 반환
    return roomData.lastBankAlert === "disaster";
}

/**
 * [신설] 종목 약어 검색 엔진
 * @param {Object} market - 검색 대상 종목 객체 (전체 시장 혹은 보유 주식)
 * @param {String} input - 유저 입력 약어 (예: "나투증")
 */
function util_findStockByShorthand(market, input) {
    var stocks = Object.keys(market);
    var matched = [];
    var searchStr = input ? input.trim() : "";
    if (searchStr === "") return matched;

    for (var i = 0; i < stocks.length; i++) {
        var name = stocks[i];
        var searchIdx = 0;
        // 입력된 글자가 종목명에 순서대로 들어있는지 체크 (예: 나...투...증)
        for (var j = 0; j < name.length && searchIdx < searchStr.length; j++) {
            if (name[j] === searchStr[searchIdx]) searchIdx++;
        }
        if (searchIdx === searchStr.length) matched.push(name);
    }
    return matched;
}

//==========섹터8==========

/**
 * [Gemini 정밀 교정] 경제 지표 계산 함수 (시스템 판돈 완벽 통합 버전)
 * 반영: 주식, 경마 배팅액, 로또 잭팟, 은행 재원 등을 모두 합산하여 물가 왜곡 방지
 */
function calculateEconomy(data, roomName) {
    var totalAssets = 0;
    var userCount = 0;
    if (!data || !data.rooms) return { total: 0, count: 0, average: 0 };

    var roomsToScan = roomName ? [roomName] : Object.keys(data.rooms);
    
    // [전역 자산 합산] 로또 잭팟은 방과 상관없는 공통 자산이므로 1회만 합산
    totalAssets += Number(data.lotto_jackpot_pool || 0);

    for (var i = 0; i < roomsToScan.length; i++) {
        var r = roomsToScan[i];
        var roomData = data.rooms[r];
        if (!roomData) continue;

        // 1. 중앙은행 금고 자산 합산
        if (roomData.bankReserve !== undefined) {
            totalAssets += Number(roomData.bankReserve);
        }

        // 2. [신규 추가] 시스템 내 대기 중인 판돈 합산 (Deflation 방지)
        if (roomData.features) {
            // A. 경마: 아직 정산되지 않은 현재 회차 총 배팅액 + 이월금
            if (roomData.features.racing) {
                totalAssets += Number(roomData.features.racing.totalPool || 0);
                totalAssets += Number(roomData.features.racing.carryOver || 0);
            }
            // B. 로또: 오늘 판매된 로또 총액
            if (roomData.features.lotto) {
                totalAssets += Number(roomData.features.lotto.dailyPool || 0);
            }
        }

        // 3. 유저별 순자산 합산 (현금 + 예금 + 주식가치 + 채권 - 부채)
        for (var uid in roomData.users) {
            var u = roomData.users[uid];
            if (!u) continue;

            // util_calculateNetWorth 내부에 주식 가치 계산이 포함되어 있습니다.
            totalAssets += util_calculateNetWorth(u, roomData);
            userCount++;
        }
    }

    return {
        total: Math.max(0, totalAssets),
        count: userCount,
        average: userCount > 0 ? Math.floor(totalAssets / userCount) : 0
    };
}

//==========섹터9==========

/**
 * [공통 함수: 물가 배율 통합 엔진] v5.9
 * 기능: 특정 방의 경제 지표를 분석하여 현재의 최종 물가 배율(Multiplier)을 반환합니다.
 * 용도: 상점가 조절, 출석 보상 조절, 채굴 효율 조절 등
 */
function util_getEcoMultiplier(roomName) {
    var data = getDatabase();
    var roomData = data.rooms[roomName];
    if (!roomData || !roomData.economyBase || roomData.economyBase <= 0) return 1.0;

    // 섹터 8의 통합 경제 지표 호출 (채권/부채 반영 수치)
    var currentEco = calculateEconomy(data, roomName);
    var rawRatio = currentEco.total / roomData.economyBase;
    
    // 물가 완충 비율(Damping) 적용
    var damping = (data.economyDamping !== undefined) ? data.economyDamping : 0.5;
    var multiplier = 1 + (rawRatio - 1) * damping;
    
    // 최소 배율 제한 (하한선 0.5배)
    return Math.max(0.5, multiplier);
}

/**
 * [시스템] 아이템 가격 계산 함수
 * 기능: 통합 엔진 배율을 적용하여 실시간 상점가를 산출합니다.
 */
function getItemPrice(item, user, roomName) {
    var multiplier = util_getEcoMultiplier(roomName);
    var basePrice = Math.floor(Number(item.price) * multiplier);

    // [수집대마왕] 모든 상점 구매가 15% 할인
    if (user.title === "수집대마왕") {
        basePrice = Math.floor(basePrice * 0.85);
    }

    // 승급권(id:8)은 구매 횟수에 따른 할증 로직 유지
    if (item.id === 8) { 
        var boughtCount = Number(user.purchasedPromotionAttempts || 0);
        return basePrice + (boughtCount * 50);
    }
    return basePrice;
}

/**
 * [Gemini 정밀 교정] 경제 부양 지원금 체크 함수 (중복 선언 제거 및 통합)
 */
function checkEconomicStimulus(user, roomName, isManual) {
    if ((user.totalAttendance || 0) < 2) return;
    
    var currentCount = user.dailyStimulusCount || 0;
    if (currentCount >= 1) return;

    var data = getDatabase();
    if (!data) return;
    
    var eco = calculateEconomy(data, roomName);
    var avgAsset = eco.average;
    var roomData = data.rooms[roomName];
    var myNetWorth = util_calculateNetWorth(user, roomData);

    // 지급 기준선: 평균 순자산의 40% 미만
    var targetLine = Math.floor(avgAsset * 0.4);
    
    if (myNetWorth < targetLine) {
        var multiplier = util_getEcoMultiplier(roomName);
        var gap = targetLine - myNetWorth;
        var emergencyMult = util_getEmergencyMultiplier(roomName);
        var baseGive = Math.floor(10000 * multiplier * emergencyMult); 
        var giveAmount = Math.min(baseGive, gap); 
        
        if (giveAmount < 100 || !util_isBankSolvent(roomName, giveAmount)) return;

        util_updatePoint(user, roomData, giveAmount, "민생지원금 지급", roomName);
        user.dailyStimulusCount = currentCount + 1;

        var msg = "\n경제 위기 극복을 위한 긴급 민생지원금이 지급되었습니다.\n" +
                  "💰 지원금액: +" + fp(giveAmount) + "P";

        Api.replyRoom(roomName, formatCommand("🎁 민생지원금 안내", user, msg, "내 잔액: " + fp(user.point) + "P"));
        safeSaveData(data);
    }
}


//==========섹터10==========

/* 신용 정보 계산 함수 (상수 연동) */
function getCreditInfo(score) {
    var s = Number(score || 600);
    var conf = SYSTEM_CONFIG.ECO.CREDIT;
    
    for(var i=0; i<conf.SCORES.length; i++) {
        if(s >= conf.SCORES[i]) {
            return { grade: i+1, limit: conf.LIMITS[i], label: conf.LABELS[i], rate: conf.RATES[i], icon: conf.ICONS[i] };
        }
    }
    // 마지막 등급 (신용불량)
    var lastIdx = conf.SCORES.length;
    return { grade: lastIdx+1, limit: conf.LIMITS[lastIdx], label: conf.LABELS[lastIdx], rate: conf.RATES[lastIdx], icon: conf.ICONS[lastIdx] };
}

/* 신용 한도 표 생성 함수 (수정 완료) */
function getCreditLimitTable() {
    var conf = SYSTEM_CONFIG.ECO.CREDIT;
    var list = [];
    for(var i=0; i<conf.SCORES.length; i++) {
        var ratePct = Math.round((conf.RATES[i] - 1) * 100);
        // conf[i] -> i 로 수정
        list.push(conf.ICONS[i] + " " + conf.LABELS[i] + " (" + conf.SCORES[i] + "점~): " + fp(conf.LIMITS[i]) + "P (이율 " + ratePct + "%)");
    }
    var lastIdx = conf.SCORES.length;
    var lastRate = Math.round((conf.RATES[lastIdx] - 1) * 100);
    list.push(conf.ICONS[lastIdx] + " " + conf.LABELS[lastIdx] + " (<" + conf.SCORES[lastIdx-1] + "): " + fp(conf.LIMITS[lastIdx]) + "P (이율 " + lastRate + "%)");
    
    return list.join("\n");
}

/**
 * [수정] 닉네임 표시 생성 함수 (칭호 전용 아이콘 자동 노출 시스템)
 * [Gemini 요청 사항 반영]: 칭호 장착 시 인벤토리에서 해당 칭호의 아이콘을 찾아 자동으로 접두사에 붙입니다.
 */
function getDisplayName(user) {
    if (!user) return "알 수 없음";
    var userIcon = user.icon || "";
    var tierIcon = (user.tier === 9 ? "🏆" : ""); 
    var credit = getCreditInfo(user.creditScore || 600);
    
    var titleStr = "";
    
    // 1순위: 신용불량자일 경우 무조건 [신용불량자] 표시
    if (credit.label === "신용불량자") {
        titleStr = "[신용불량자] ";
    } 
    // 2순위: 일반 상태일 때 장착 중인 칭호 표시 (아이콘 제한 로직)
    else if (user.title && user.title.length > 0) {
        var titleIcon = "";
        
        // [Gemini 규칙]: 도굴왕, 수집대마왕만 인벤토리에서 아이콘을 찾아 합칩니다.
        if (user.title === "도굴왕" || user.title === "수집대마왕") {
            if (user.inventory && user.inventory.length > 0) {
                for (var i = 0; i < user.inventory.length; i++) {
                    var item = user.inventory[i];
                    if (item.effect === "title" && item.title === user.title) {
                        titleIcon = item.icon || ""; 
                        break;
                    }
                }
            }
        }
        
        // titleIcon이 비어있으면(그 외 칭호들) 자동으로 [칭호명]만 출력됩니다.
        titleStr = "[" + titleIcon + user.title + "] ";
    }
    
    return titleStr + tierIcon + userIcon + (user.name || "알 수 없음");
}

/* [수정] 관리자 여부 확인 함수 (FIXED_ADMINS 체크 추가) */
function isAdmin(sender, data, uid) {
    if (FIXED_ADMINS.indexOf(String(sender).trim()) !== -1) return true;
    if (adminUIDs.indexOf(uid) !== -1) return true;
    var name = String(sender).trim();
    if (data && data.admins && data.admins.indexOf(name) !== -1) return true;

    return false;
}

//==========섹터11==========

function util_checkUserState(user, uid, roomName) {
    var now = Date.now();
    var data = getDatabase();
    var roomData = data.rooms[roomName || "내리다"];
    
    // [교정]: 방별 독립 states 데이터 참조 (없을 경우 빈 객체 처리로 Crash 방지)
    var states = (roomData && roomData.features) ? roomData.features.states : {};
    var dData = states.duelData || {};
    var aThefts = states.activeThefts || {};

    // 1. 감옥(징역) 상태 체크
    if (user.jailReleaseTime && now < user.jailReleaseTime) {
        var diff = user.jailReleaseTime - now;
        var remainMin = Math.ceil(diff / (1000 * 60));
        var timeStr = remainMin >= 60 ? Math.ceil(remainMin / 60) + "시간" : remainMin + "분";
        return { canAction: false, reason: "현재 징역 중입니다. (" + timeStr + " 남음)" };
    }

    // 2. 광산 채굴 상태 체크
    if (user.mining && user.mining.active) {
        return { canAction: false, reason: "현재 광산에서 채굴 작업 중입니다." };
    }

    // 3. 결투 진행 상태 체크 (방별 데이터 참조형으로 교정)
    if (dData[uid]) return { canAction: false, reason: "현재 결투 신청을 받은 상태입니다." };
    for (var dKey in dData) {
        if (dData[dKey].challengerUid === uid) return { canAction: false, reason: "현재 타인에게 결투를 신청한 상태입니다." };
    }

    // 4. 도둑질 진행 상태 체크 (방별 데이터 참조형으로 교정)
    if (aThefts[uid]) return { canAction: false, reason: "현재 도둑질의 표적이 되어 방어 중입니다." };
    for (var vKey in aThefts) {
        if (aThefts[vKey].thiefUid === uid) return { canAction: false, reason: "현재 다른 유저를 털고 있는 중입니다." };
    }

    return { canAction: true, reason: "" };
}

/* 기존 호환성을 위한 단순 체크 함수 */
function isUserBusy(uid, roomName) {
    var data = getDatabase();
    var rName = roomName || "내리다";
    if (data.rooms[rName] && data.rooms[rName].users[uid]) {
        var res = util_checkUserState(data.rooms[rName].users[uid], uid, rName);
        return !res.canAction;
    }
    return false;
}

/* 유저 이름 검색 함수 */
function findUserByName(roomData, name) {
    var res = [];
    var searchName = name.trim();
    if (searchName === "") return res; 
    for (var id in roomData.users) {
        var u = roomData.users[id];
        if (u.name === searchName) {
            return [{ id: id, data: u }];
        }
        if (u.name.indexOf(searchName) !== -1) {
            res.push({ id: id, data: u });
        }
    }
    return res;
}

/* 중복 유저 선택 핸들러 함수 */
function handleUserSelection(replier, targetUid, found, type, extra, user, roomName) {
    var data = getDatabase();
    var roomData = data.rooms[roomName];
    if (!roomData || !roomData.features) return;

    // 방별 독립 저장소인 features.states.selectWait에 저장
    roomData.features.states.selectWait[targetUid] = { 
        timestamp: Date.now(), 
        results: found, 
        type: type, 
        extra: extra 
    };
    
    var list = [];
    for(var i=0; i<found.length; i++) {
        list.push((i + 1) + ". " + found[i].data.name);
    }

    replier.reply(formatCommand("🔍 중복 닉네임 선택", user, "여러 유저가 검색되었습니다.\n번호를 선택해주세요.\n\n" + list.join("\n") + "\n\n(취소: [취소])", "입력 대기: 30초"));
}

/**
 * [신설] 중복 종목 선택 핸들러
 */
function handleStockSelection(replier, targetUid, found, type, qty, user, roomName) {
    var data = getDatabase();
    var roomData = data.rooms[roomName];
    if (!roomData || !roomData.features) return;

    roomData.features.states.selectWait[targetUid] = { 
        timestamp: Date.now(), 
        results: found, 
        type: type,     
        extra: { amount: qty } 
    };
    var list = found.map(function(name, i) { return (i + 1) + ". " + name; });
    replier.reply(formatCommand("🔍 종목 선택", user, "여러 종목이 검색되었습니다.\n번호를 선택해주세요.\n\n" + list.join("\n") + "\n\n(취소: [취소])", "입력 대기: 30초"));
}

/* 날짜 및 시즌 유틸 함수 */
function getSimpleDate() { var d = new Date(); return d.getFullYear() + "-" + ("0" + (d.getMonth() + 1)).slice(-2) + "-" + ("0" + d.getDate()).slice(-2); }
function getSimpleSeason() { var d = new Date(); return d.getFullYear().toString().slice(-2) + "-" + (d.getMonth() + 1) + "시즌"; }
function generateUUID() { return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) { var r = Math.random() * 16 | 0, v = c == 'x' ? r : (r & 0x3 | 0x8); return v.toString(16); }); }

/**
 * [공통 함수: 칭호 자동 부여 시스템] v6.0 (표준 포맷 적용)
 */
function util_checkAndAwardTitle(user, replier, titleName, titleId, icon, committee, condition, guideText, roomName) {
    if (!user.inventory) user.inventory = [];
    
    var hasTitle = false;
    for (var i = 0; i < user.inventory.length; i++) {
        if (user.inventory[i].title === titleName) {
            hasTitle = true;
            break;
        }
    }
    if (hasTitle) return false;

    user.inventory.push({ 
        id: titleId, 
        name: "[" + titleName + "] 칭호", 
        icon: icon, 
        effect: "title", 
        title: titleName 
    });

    user.title = titleName;

    var winMsg = "🎊 [" + committee + ": 작위 수여]\n" +
                 "━━━━━━━━━━━━━━━\n" +
                 "축하합니다! " + (user.name || "유저") + "님\n\n" +
                 condition + "를 돌파하여\n" +
                 "국가 공인 [" + titleName + "] 칭호를 하사받았습니다.\n\n" +
                 "✨ 상태: [" + titleName + "] 자동 장착 완료\n" +
                 "💼 보관: 영구 자산으로 가방에 등록되었습니다.\n" +
                 "━━━━━━━━━━━━━━━\n" +
                 "💡 " + guideText;

    // [핵심 교정]: replier가 무효한 환경(문자열 전달 등)에서도 응답이 나가도록 예외 처리
    try {
        if (replier && typeof replier.reply === 'function') {
            replier.reply(winMsg);
        } else {
            Api.replyRoom(roomName || "내리다", winMsg);
        }
    } catch(e) {
        Log.error("Award Title Reply Error: " + e);
    }
    return true;
}

//==========섹터12==========

/* 경찰 출동 결과 처리 함수 (중앙은행 연동 및 방별 격리 보정) */
function processPoliceResult(roomName, thiefUid, victimUid) {
    var data = getDatabase();
    if (!data) return;
    var room = data.rooms[roomName];
    if (!room || !room.features || !room.features.states) return;

    // [핵심 수정] 전역 변수가 아닌 방별 독립 상태 저장소를 참조하도록 연결
    var activeThefts = room.features.states.activeThefts; 

    var theftData = activeThefts[victimUid];
    if (!theftData) return;
    
    var thief = room.users[thiefUid];
    
    if (activeThefts[victimUid].successTimer) clearTimeout(activeThefts[victimUid].successTimer);
    
    // [상태 해제] 올바른 참조 경로에서 삭제 수행
    delete activeThefts[victimUid]; 
    
    // 1. 벌금 계산: 현금 차감은 보유액의 10%
    var cashFine = Math.floor(Number(thief.point) * 0.1);
    // 2. 대납 계산: 1,000P 하한선 보장 (부족분 산출)
    var loanGap = Math.max(0, 1000 - cashFine);
    
    util_updatePoint(thief, room, -cashFine, "도둑질 체포 벌금", roomName);
    
    var loanMsg = "";
    if (loanGap > 0) {
        if (!thief.loan) thief.loan = { debt: 0, items: [] };
        thief.loan.debt = Number(thief.loan.debt || 0) + loanGap;
        if (!thief.loan.items) thief.loan.items = [];
        thief.loan.items.push(loanGap);
        loanMsg = "\n⚠️ 벌금 부족분 대납: " + fp(loanGap) + "P 대출 전환";
    }
    
    var jailTime = 1 * 60 * 60 * 1000;
    util_setData(thief, 'jailReleaseTime', Date.now() + jailTime, "도둑질 체포 징역", roomName);
    
    var msg = "🚨 [경찰 출동]\n대상: " + getDisplayName(thief) + "\n내용: 도둑질 현행범 체포\n벌금: -" + fp(cashFine) + "P / 징역 1시간" + loanMsg + "\n내 잔액: " + fp(thief.point) + "P";
    Api.replyRoom(roomName, formatAdmin("🚓 체포 완료", msg));
    safeSaveData(data);
}

/* 도둑질 성공 결과 처리 함수 (중앙은행 연동 및 방별 격리 보정) */
function processTheftResult(roomName, thiefUid, victimUid) {
    var data = getDatabase();
    if (!data) return;
    var room = data.rooms[roomName];
    if (!room || !room.features || !room.features.states) return;
    
    // [핵심 수정] 방별 독립 상태 저장소 참조 연결
    var activeThefts = room.features.states.activeThefts;

    if (!room.users[thiefUid] || !room.users[victimUid]) { 
        if (activeThefts[victimUid]) delete activeThefts[victimUid]; 
        Api.replyRoom(roomName, "⚠️ [시스템 알림]\n도둑질 진행 중 대상이 사라져 상황이 종료되었습니다.");
        return; 
    }
    
    if (activeThefts[victimUid] && activeThefts[victimUid].policeTimer) clearTimeout(activeThefts[victimUid].policeTimer);

    var thief = room.users[thiefUid];
    var victim = room.users[victimUid];
    
    // 1. 탈취액: 5% ~ 10% 사이 랜덤
    var minSteal = Math.floor(Number(victim.point) * 0.05);
    var maxSteal = Math.floor(Number(victim.point) * 0.10);
    var stealAmount = Math.floor(Math.random() * (maxSteal - minSteal + 1)) + minSteal;
    
    // 2. 피해자 보호: 6시간 동안 타겟 제외
    victim.lastTheftVictimTime = Date.now() + (6 * 60 * 60 * 1000);

    util_updatePoint(victim, room, -stealAmount, "도둑질 당함", roomName);

    var res = processRepayment(thief, stealAmount, thiefUid, roomName); 
    
    // 도둑의 포인트 증가 (이 돈은 피해자에게서 왔으므로 은행 재원 변동 0)
    util_updatePoint(thief, room, Number(res.actualGain), "도둑질 성공", roomName);
    
   // 2. [확정] 도둑질 성공 누적 통계 게이트웨이 보호
    var nextTheftSuccess = Number(thief.totalTheftSuccess || 0) + 1;
    util_setData(thief, 'totalTheftSuccess', nextTheftSuccess, "도둑질 성공 기록", roomName);

    // 3. 리플라이어 스텁 선언 (칭호 자동 부여 시스템 연동용)
    var replierStub = { reply: function(m) { Api.replyRoom(roomName, m); } };

    // 칭호 부여 로직 (게이트웨이로 갱신된 최신 값을 참조)
    if (thief.totalTheftSuccess >= 50) {
        util_checkAndAwardTitle(thief, replierStub, "약탈왕", 1203, "👤", "내리다 그림자 길드", "누적 도둑질 성공 50회", "[장착 효과]: 도둑질 시 경찰이 출동할 확률이 기존 50%에서 30%로 감소합니다.");
    } else if (thief.totalTheftSuccess >= 30) {
        util_checkAndAwardTitle(thief, replierStub, "대도", 1202, "👺", "내리다 그림자 길드", "누적 도둑질 성공 30회", "대담한 수법으로 세상을 놀라게 하고 있습니다.");
    } else if (thief.totalTheftSuccess >= 10) {
        util_checkAndAwardTitle(thief, replierStub, "좀도둑", 1201, "🧤", "내리다 그림자 길드", "누적 도둑질 성공 10회", "남의 지갑을 가볍게 만드는 기술을 익혔습니다.");
    }
    
    // [상태 해제] 올바른 참조 경로에서 삭제 수행
    if (activeThefts[victimUid]) delete activeThefts[victimUid]; 
    
    var content = "🕵️ 도둑질 성공!\n" + getDisplayName(victim) + "님의 지갑에서\n" + fp(stealAmount) + "P를 훔쳤습니다!" + res.repayMsg;
    // [수정] 도둑질 결과에 보유 포인트 표시 추가
    Api.replyRoom(roomName, formatCommand("💰 도둑질 결과", thief, content, "내 잔액: " + fp(thief.point) + "P"));
    safeSaveData(data);
}

//==========섹터13==========

/**
 * [경제 시스템 모듈] 통합 자동 상환 및 신용 관리 (수정된 차등 비율 버전)
 * 수정 내용: 
 * 1. 일반 은행 빚 상환: 30%
 * 2. 신용불량자/사채 강제추심: 50%
 * 3. 은행 대환 채무(대납건): 70%
 */

/* [기능 1] 신용불량자 상태 제어 */
function checkAndHandleDefaulter(user, roomName) {
    var currentScore = Number(user.creditScore || 600);
    if (currentScore < 500) {
        if (!user.isDefaulter) {
            util_setData(user, 'isDefaulter', true, "신용도 하락(500미만)", roomName);
            util_setData(user, 'icon', "", "신용불량 아이콘 몰수", roomName);
            var msg = "신용 점수 500점 미만 하락\n\n1. 보유 아이콘 몰수\n2. 획득 포인트 50% 자동 상환 적용";
            try { Api.replyRoom(roomName, formatCommand("📉 신용불량자 지정", user, msg, "대출 상환을 권장합니다.")); } catch(e){}
        }
    } else {
        if (user.isDefaulter) { user.isDefaulter = false; }
    }
}

/* [기능 2] 은행 대출금 분산 상환 엔진 */
function distributeRepayment(user, amount, roomName) {
    if (!user.loan || Number(user.loan.debt) < 1) {
        if (user.loan) { user.loan.debt = 0; user.loan.items = []; user.isTransferred = false; }
        return { actualRepay: 0, creditGain: 0, clearedCount: 0 };
    }
    
    var remainingRepay = Math.floor(Number(amount));
    var initialAmount = remainingRepay;
    var clearedCount = 0;
    
    if (!user.loan.items) user.loan.items = [];
    user.loan.items.sort(function(a, b) { return a - b; });
    
    var newItems = [];
    for (var i = 0; i < user.loan.items.length; i++) {
        var loanItem = Number(user.loan.items[i]);
        if (loanItem > 0 && remainingRepay >= loanItem) {
            remainingRepay -= loanItem;
            clearedCount++;
        } else {
            loanItem -= remainingRepay;
            remainingRepay = 0;
            if (loanItem > 0) newItems.push(loanItem);
        }
    }
    
    var actualRepayed = initialAmount - remainingRepay;
    user.loan.items = newItems;
    user.loan.debt = 0;
    var nextScore = Math.min(1000, Number(user.creditScore || 600) + (clearedCount * 15));
    util_setData(user, 'creditScore', nextScore, "대출 상환 가점", roomName);

    if (user.loan.debt <= 0) {
        user.loan.debt = 0; 
        user.loan.items = []; 
        util_setData(user, 'isTransferred', false, "채무 완납", roomName);
    }
    
    return { actualRepay: actualRepayed, creditGain: clearedCount * 15, clearedCount: clearedCount };
}

/* [기능 3] 사채(P2P) 자동 추심 처리 (수정: 추심 비율 50% 적용) */
function processPrivateCollection(user, userUid, amount, roomName) {
    var data = getDatabase();
    var roomData = data.rooms[roomName];
    if (!roomData) return { collected: 0, msg: "" };

    if (!user.loan || Number(user.loan.debt || 0) <= 0) {
        util_setData(user, 'isTransferred', false, "채무 부재 상태 동기화", roomName);
    }
    
    // [설정 수정] 직접 추심 한도를 수익의 50%로 변경
    var totalLimit = Math.floor(Number(amount) * 0.5); 
    var remainingAmount = totalLimit; 
    
    var totalCollected = 0;
    var collectionLog = "";

    if (roomData.loanContracts) {
        for (var cid in roomData.loanContracts) {
            var c = roomData.loanContracts[cid];
            if (c.borrowerUid === userUid && c.status === 'overdue' && remainingAmount > 0) {
                var collectTarget = Math.min(remainingAmount, c.currentDebt);
                
                var lender = roomData.users[c.lenderUid];
                if (lender) {
                    util_updatePoint(lender, roomData, collectTarget, "사채 추심 수익 (" + c.borrowerName + ")", roomName);
                }

                c.currentDebt -= collectTarget;
                totalCollected += collectTarget;
                remainingAmount -= collectTarget;
                collectionLog += "\n- " + c.lenderName + "님께 " + fp(collectTarget) + "P 송금";

                if (c.currentDebt <= 0) {
                    delete roomData.loanContracts[cid];
                    collectionLog += " (완납 종료)";
                }
            }
        }
    }

    if (totalCollected > 0) {
        var msg = "\n\n🚨 [사채 강제 추심 안내]\n사채 연체로 인해 수익의 50%가 채권자에게 자동 귀속되었습니다." + collectionLog;
        return { collected: totalCollected, msg: msg };
    }
    return { collected: 0, msg: "" };
}

/* [기능 4] 통합 자동 상환 프로세스 (수정: 비율 체계 전면 개편) */
function processRepayment(user, amount, userUid, roomName) {
    var amt = Number(amount) || 0;
    var currentGain = amt;
    var totalRepayMsg = "";
    var data = getDatabase();

    if (!user.loan || Number(user.loan.debt || 0) <= 0) {
        user.isTransferred = false;
    }

    // 1. 사채 직접 추심 (50% 비율 작동)
    var privateRes = processPrivateCollection(user, userUid, currentGain, roomName);
    if (privateRes.collected > 0) {
        currentGain -= privateRes.collected;
        totalRepayMsg += privateRes.msg;
    }

    // 2. 은행 대출 자동 상환
    if (currentGain > 0 && user.loan && Number(user.loan.debt) > 0) {
        // [기본값] 일반 유저 상환 비율 30%
        var repaymentRate = 0.3; 
        var typeLabel = "일반 상환";

        // [조건 1] 대환 채무(은행이 사채를 대신 갚아준 경우)는 70% 압류
        if (user.isTransferred === true || user.isTransferred === "true") {
            repaymentRate = 0.7; 
            typeLabel = "🚨 대환 채무 강제 추심";
        } 
        // [조건 2] 신용불량자(500점 미만)는 50% 압류
        else if (Number(user.creditScore || 600) < 500) {
            repaymentRate = 0.5; 
            typeLabel = "신용불량 제한 상환";
        }

        var intendedRepay = Math.floor(currentGain * repaymentRate);
        if (intendedRepay > Number(user.loan.debt)) intendedRepay = Number(user.loan.debt);
        
        var res = distributeRepayment(user, intendedRepay, roomName);
        currentGain -= res.actualRepay;

        totalRepayMsg += "\n\n🏦 [은행 " + typeLabel + "]\n💰 " + fp(res.actualRepay) + "P 상환됨 (" + Math.floor(repaymentRate * 100) + "%)\n(남은 대출: " + fp(user.loan.debt) + "P)";
        if (res.creditGain > 0) totalRepayMsg += "\n📈 신용 점수 +" + res.creditGain + " 상승";
    }
    
    return { actualGain: currentGain, repayMsg: totalRepayMsg };
}

//==========섹터14==========

/* 주식 이름 생성 함수 */
function generateStockName(data) {
    var conf = SYSTEM_CONFIG.ECO.STOCK; // [수정] 경로 참조 보정
    var name = "";
    for (var i = 0; i < 10; i++) {
        var pre = conf.PREFIXES[Math.floor(Math.random() * conf.PREFIXES.length)];
        var suf = conf.SUFFIXES[Math.floor(Math.random() * conf.SUFFIXES.length)];
        name = pre + suf;
        if (!data.stockMarket[name]) break;
    }
    return name;
}

/* 주식 타입 할당 함수 */
function assignStockType() {
    var conf = SYSTEM_CONFIG.ECO.STOCK; // [수정] 경로 참조 보정
    var rand = Math.random() * 100;
    var cumulative = 0;
    for (var type in conf.TRAITS) {
        cumulative += conf.TRAITS[type].prob;
        if (rand < cumulative) return type;
    }
    return "normal";
}

/* 주식 리스트 생성 함수 (아이콘 우측 배치 및 하단 경고 추가) */
function generateStockList(data) {
    var list = [];
    var dangerStocks = [];
    var keys = Object.keys(data.stockMarket || {});
    if (keys.length === 0) return null;

    // [수정] SYSTEM_CONFIG 참조로 경로 보정 (전역 변수 STOCK_TRAITS 제거 대응)
    var stockTraits = SYSTEM_CONFIG.ECO.STOCK.TRAITS;

    for (var i = 0; i < keys.length; i++) {
        var name = keys[i];
        var stock = data.stockMarket[name];
        var trait = stockTraits[stock.type] || stockTraits.normal;
        
        var diff = Number(stock.price) - Number(stock.lastPrice);
        var rate = stock.lastPrice > 0 ? ((diff / stock.lastPrice) * 100).toFixed(1) : "0.0";
        var sign = diff > 0 ? "🔺" : (diff < 0 ? "🔹" : "➖");
        
        // [수정] 정리매매 아이콘 로직 (우측 표시용)
        var warningMark = "";
        if (stock.delistTick && stock.delistTick > 0) {
            warningMark = " ⚠️";
            dangerStocks.push(name);
        }
        
        // [수정] 주가 포인트 수치에 .toLocaleString() 적용 및 아이콘 배치 유지
        list.push(trait.icon + " " + name + ": " + fp(stock.price) + "P (" + sign + " " + Math.abs(rate) + "%)" + warningMark);
    }

    var result = list.join("\n");

    // [수정] 하단 경고 섹션 생성
    if (dangerStocks.length > 0) {
        result += "\n\n⚠️ 주가 폭락으로 정리매매 단계 진입!\n해당 종목 : " + dangerStocks.join(", ");
    }
    
    return result;
}

//==========섹터15==========

/* 주식 이름 생성 함수 (상수 참조 경로 수정) */
function generateStockName(data) {
    var conf = SYSTEM_CONFIG.ECO.STOCK;
    var name = "";
    for (var i = 0; i < 20; i++) {
        var pre = conf.PREFIXES[Math.floor(Math.random() * conf.PREFIXES.length)];
        var suf = conf.SUFFIXES[Math.floor(Math.random() * conf.SUFFIXES.length)];
        name = pre + suf;
        if (!data.stockMarket || !data.stockMarket[name]) break;
    }
    return name;
}

/* 주식 타입 할당 함수 */
function assignStockType() {
    var conf = SYSTEM_CONFIG.ECO.STOCK;
    var rand = Math.random() * 100;
    var cumulative = 0;
    for (var type in conf.TRAITS) {
        cumulative += conf.TRAITS[type].prob;
        if (rand < cumulative) return type;
    }
    return "normal";
}

/* 주식 시세 변동 로직 함수 (정밀도 보정 및 정책 연동) */
function updateStockPrices(data) {
    var conf = SYSTEM_CONFIG.ECO.STOCK;
    if (!data.stockMarket) data.stockMarket = {};
    if (!data.stockTraffic) data.stockTraffic = {}; 

    // [Gemini 요청 사항] 메인 방의 정부 정책 데이터 로드
    var mainRoom = data.rooms["내리다"];
    var pol = util_getActivePolicy(mainRoom);

    var now = new Date();
    var currentHour = now.getHours();
    var isMarketOpen = (currentHour >= conf.SETTINGS.OPEN_HOUR && currentHour <= conf.SETTINGS.CLOSE_HOUR);
    
    var totalSum = 0;
    var count = 0;
    for (var k in data.stockMarket) { totalSum += Number(data.stockMarket[k].price); count++; }
    var marketAvg = count > 0 ? (totalSum / count) : 1000;

    /* [수정] 경제 지표 계산 시 '내리다' 방의 데이터만 독립적으로 참조 (방 격리) */
    var eco = calculateEconomy(data, "내리다");
    var activeUserCount = Math.max(1, eco.count); 

    /* [상폐 조건 개편] 경제 연동 제거 및 절대 하한선 고정 */
    var ecoBaseFloor = conf.SETTINGS.ABS_DELIST_LIMIT;

    var eventNews = [];

    /* [1] 신규 상장 처리 */
    if (data.pendingNewStock && isMarketOpen) {
        if (Object.keys(data.stockMarket).length < conf.SETTINGS.MAX_COUNT) {
            var newName = generateStockName(data);
            var newType = assignStockType();
            var startPrice = Math.floor(marketAvg * ((Math.random() * 0.3) + 0.8));
            var randomLimit = Math.floor(Math.random() * 4) + 2; 
            
            data.stockMarket[newName] = { 
                price: Number(startPrice), lastPrice: Number(startPrice), 
                type: newType, delistTick: 0, delistLimit: randomLimit,
                trend: "none", trendTick: 0, lastTrafficImpact: 0,
                isOverheated: false
            };
            eventNews.push("📢 신규 상장: " + conf.TRAITS[newType].icon + " " + newName + " (" + fp(startPrice) + "P)");
        }
        data.pendingNewStock = false;
    }

    /* [2] 조작 프리셋 설정 로드 */
    var mani = conf.MANIPULATION;
    var specStock = (mani && mani.ACTIVE) ? mani.TARGET : null;
    var specFactor = (mani && mani.ACTIVE) ? (mani.IS_UP ? Math.abs(mani.RATE) : -Math.abs(mani.RATE)) : 0;

    if (!specStock && data.pendingSpecialEffect && isMarketOpen) {
        specStock = data.pendingSpecialEffect.stock;
        specFactor = data.pendingSpecialEffect.factor;
    }

    /* [3] 시세 변동 계산 루프 진입 전 하이프 계수 선행 계산 */
    var msgCount = (mainRoom.features.msgCount || 0);
    // 500개 한도로 50개당 1단위 산출 (최대 10단위)
    var units = Math.floor(Math.min(msgCount, 500) / 50); 
    // $1 + (units \times 0.01)$ 공식 적용
    var hypeFactor = 1 + (units * 0.01); 

    for (var name in data.stockMarket) {
        var stock = data.stockMarket[name];
        if (stock.isOverheated === undefined) stock.isOverheated = false;
        var trait = conf.TRAITS[stock.type] || conf.TRAITS.normal;
        var changePercent = 0;
        
        stock.lastPrice = Number(stock.price);

        if (isMarketOpen) {
            if (name === specStock) { 
                // 이벤트 종목에 하이프 증폭 적용
                changePercent = specFactor * hypeFactor;
                eventNews.push("🚨 [변동성 알림]\n종목: " + name + "\n내용: " + (specFactor > 0 ? "🚀 폭등" : "📉 폭락") + " (" + (Math.abs(changePercent * 100)).toFixed(1) + "%)");
            } else {
                // 일반 종목의 기본 변동성에도 하이프 보너스 반영 (시장 활성화)
                if (stock.trendTick <= 0) {
                    stock.trendTick = Math.floor(Math.random() * 4) + 2;
                    var p = Math.random(); 
                    stock.trend = (p < 0.35) ? "up" : (p < 0.70 ? "down" : "volatile");
                }
                var baseRate = (stock.trend === "up" ? 0.025 : (stock.trend === "down" ? -0.025 : (Math.random()*0.08-0.04)));
                
                // 일반 변동성 * 종목특성 * 채팅하이프
                changePercent = baseRate * trait.volatility * hypeFactor;
                if (stock.trendTick > 0) stock.trendTick--;
            }
            
            var traffic = data.stockTraffic[name] || { buy: 0, sell: 0 };
            var trafficImpact = Math.max(-0.15, Math.min(0.15, ((traffic.buy - traffic.sell) / (activeUserCount * 5)) * 0.01));
            changePercent += trafficImpact;

            // [가상 정부] 정책에 따른 변동성(Volatility) 보정 적용
            // 예: 시장 안정화 정책 가결 시 변동폭 0.5배 축소 등
           if (pol.volatilityMult && pol.volatilityMult !== 1.0) {
                changePercent *= pol.volatilityMult;
            }

            /* [긴급 수정] 전역 시가(marketOpenPrice) 의존성 제거 및 개별 시가(openPrice) 도입 */
            // 사유: 종목별 가격 편차를 무시하고 단일 기준점을 쓰면 고가주가 폭락하는 버그 수정
            if (!stock.openPrice) stock.openPrice = stock.price; // 데이터 없으면 현재가를 시가로 초기화
            var refPrice = stock.openPrice;

            if (refPrice > 0) {
                var growthRate = (stock.price - refPrice) / refPrice;
                var sConf = conf.SETTINGS;

                // [유연한 탄성 저항 엔진]
                // 20%를 넘어서는 순간부터 고무줄 효과가 발생합니다.
                if (growthRate > sConf.RESISTANCE_START) {
                    var gap = growthRate - sConf.RESISTANCE_START;
                    
                    // 1. 점진적 압박: 20%에서 멀어질수록 당기는 힘이 강해짐
                    var pull = gap * sConf.GRAVITY;
                    changePercent -= pull;

                    // 2. 불규칙 진동(Jitter): 하락 중에도 50% 확률로 위로 튀어 오르는 노이즈 주입
                    // 이를 통해 일직선 하락이 아닌 '계단식/톱니형' 하락을 연출합니다.
                    var jitter = (Math.random() * 0.07 - 0.03); // -3% ~ +4% 사이의 무작위 흔들림
                    changePercent += jitter;

                    // 3. 40% 한계 돌파 방지: 최대 한계선에 근접할수록 급격한 저항 추가
                    if (growthRate >= sConf.CLOSING_LIMIT - 0.05) {
                        changePercent -= 0.05; // 강한 압박
                    }
                }
            }
         }
        
        // 최종 가격 반영 (중괄호 블록 밖, 루프 내부)
        var nextPrice = stock.price * (1 + changePercent);
        stock.price = Math.max(10, Math.round(nextPrice)); 

        /* [상폐 판정] 섹터 1에 정의된 상수(25%, 10,000P)를 사용하여 체크 */
        if (stock.price < (marketAvg * conf.SETTINGS.DELIST_LIMIT) || stock.price < ecoBaseFloor) { 
            stock.delistTick++; 
        } else { 
            stock.delistTick = 0; 
        }
    }

    /* 상장폐지 집행 */
    var delisted = [];
    for (var name in data.stockMarket) {
        if (data.stockMarket[name].delistTick >= data.stockMarket[name].delistLimit) delisted.push(name);
    }
    
    for (var i=0; i<delisted.length; i++) { 
        var delName = delisted[i];
        for (var r in data.rooms) {
            var users = data.rooms[r].users;
            for (var uid in users) {
                if (users[uid].stockHoldings) {
                    delete users[uid].stockHoldings[delName];
                    if (users[uid].stockAvg) delete users[uid].stockAvg[delName];
                }
            }
        }
        delete data.stockMarket[delName]; 
        eventNews.push("🚨 [상장폐지] " + delName + "\n사유: 주가 요건 미달 (하한선: " + fp(ecoBaseFloor) + "P)"); 
    }

    data.stockTraffic = {}; 
    data.pendingSpecialEffect = null; 
    
    return eventNews;
}

/* 주식 시장 수동 제어 엔진 */
function market_forceNewListing() {
    var data = getDatabase();
    data.pendingNewStock = true;
    return "✅ 다음 변동 타임에 신규 상장이 확정되었습니다.";
}

function market_setSpecialEffect(stockName, isUp, factor) {
    var data = getDatabase();
    var conf = SYSTEM_CONFIG.ECO.STOCK.SETTINGS;
    if (!data.stockMarket[stockName]) return "❌ 존재하지 않는 종목입니다.";
    var useFactor = (factor !== undefined) ? factor : conf.MANI_RATE;
    var finalFactor = isUp ? Math.abs(useFactor) : -Math.abs(useFactor);
    data.pendingSpecialEffect = { stock: stockName, factor: finalFactor };
    return "✅ [" + stockName + "] " + (Math.abs(useFactor*100)).toFixed(0) + "% " + (isUp ? "폭등" : "폭락") + " 예약 완료.";
}

function market_updateNow(roomName) {
    var data = getDatabase();
    var result = updateStockPrices(data);
    var body = "📉 주식 시세 변동\n━━━━━━━━━━━━━━━\n🟢 장 운영 중\n\n" + (generateStockList(data) || "시세 정보 없음");
    if (result.length > 0) body += "\n\n" + result.join("\n");
    body += "\n━━━━━━━━━━━━━━━"; 
    Api.replyRoom(roomName || "내리다", body);
    safeSaveData(data);
    return "✅ 시장 갱신 완료.";
}

//==========섹터16-1==========

/* 통합 스케줄러 실행 함수 (독립 모듈형 엔진 + 대시보드 연동) */
function runScheduler() {
    var SCHEDULER_KEY = "kakaobot_scheduler_v5";
    var oldTimer = java.lang.System.getProperty(SCHEDULER_KEY);
    if (oldTimer) try { clearInterval(parseInt(oldTimer)); } catch (e) {}
    
    var newTimer = setInterval(function() {
        try {
            var data = getDatabase(); 
            if (!data) return; 

            // 모든 섹터가 공유할 상태 객체 (Context)
            var ctx = {
                isUpdated: false,
                isForceBackup: false,
                now: new Date(),
                today: getSimpleDate(),
                season: getSimpleSeason(),
                /* [Gemini 요청 사항] 하드코딩 유지: 메인 운영 방 지정 */
                targetRoom: "내리다",
                // 아래 URL에 본인의 구글 웹 앱 URL을 입력하세요.
                dashboardUrl: "https://script.google.com/macros/s/AKfycbyoURblg3-nLNgSE57Pb9RmjqK3wXyMSRpm9WrkWe3z2kyE_q_wmoabNECLNXWQ2SBZ/exec"
            };

            // 1. 경제/경마 (섹터 16-2)
            try {
                if (typeof _runSector16Logic === 'function') _runSector16Logic(data, ctx);
            } catch (e) {
                Log.error("Sector 16 Logic Crash: " + e);
            }

            // 2. 일일 초기화 (섹터 17)
            try {
                if (typeof _runSector17Logic === 'function') _runSector17Logic(data, ctx);
            } catch (e) {
                Log.error("Sector 17 Logic Crash: " + e);
            }

            // 3. 로또 추첨 (섹터 18)
            try {
                if (typeof _runSector18Logic === 'function') _runSector18Logic(data, ctx);
            } catch (e) {
                Log.error("Sector 18 Logic Crash: " + e);
            }

            /* [신규] 10분 주기 구글 시트 대시보드 동기화 */
            var currentMin = ctx.now.getMinutes();
            if (currentMin % 10 === 0 && data.lastWebSyncMin !== currentMin && ctx.dashboardUrl.indexOf("http") === 0) {
                data.lastWebSyncMin = currentMin;
                _sendToDashboard(data, ctx);
            }

            /* [신규] 하이브리드 디스코드 원격 백업 (30분 전체 / 1분 로그) */
            var webhookUrl = SYSTEM_CONFIG.BACKUP ? SYSTEM_CONFIG.BACKUP.DISCORD_WEBHOOK_URL : "";
            
            if (webhookUrl && webhookUrl.indexOf("http") === 0) {
                
                // A. 전체 데이터 백업 (30분 주기: 매시 00분, 30분)
                if ((currentMin === 0 || currentMin === 30) && data.lastFullBackupMin !== currentMin) {
                    data.lastFullBackupMin = currentMin;
                    // 저장된 최신 파일(attendance.json) 전송
                    _sendDiscordFile(webhookUrl, FILE_PATH, "FULL_DATA_" + ctx.today + "_" + ctx.now.getHours() + "h" + currentMin + "m.json");
                }

                // B. 블랙박스 로그 백업 (1분 주기: 매분 00초)
                // transaction.log 파일이 존재하고 내용이 있을 때만 전송
                if (ctx.now.getSeconds() === 0) {
                    var logFile = new java.io.File(JOURNAL_PATH);
                    if (logFile.exists() && logFile.length() > 0) {
                        _sendDiscordFile(webhookUrl, JOURNAL_PATH, "LOG_" + ctx.now.getHours() + "h" + currentMin + "m.txt");
                    }
                }
            }

            /* [최종 저장] 하이브리드 비동기 저장 처리 */
            if (ctx.isUpdated) {
                SaveExecutor.execute(new java.lang.Runnable({
                    run: function() { safeSaveData(data, ctx.isForceBackup); }
                }));
            }

            util_stamp("mainLoop");

        } catch (e) { Log.error("Scheduler Error: " + e); }
    }, 1000);
    java.lang.System.setProperty(SCHEDULER_KEY, String(newTimer));
}

/**
 * [신규] 디스코드 파일 전송 헬퍼 함수
 */
function _sendDiscordFile(url, filePath, fileName) {
    Executor.execute(new java.lang.Runnable({
        run: function() {
            try {
                var file = new java.io.File(filePath);
                if (!file.exists()) return;

                org.jsoup.Jsoup.connect(url)
                    .data("file", fileName, new java.io.FileInputStream(file))
                    .ignoreContentType(true)
                    .ignoreHttpErrors(true)
                    .method(org.jsoup.Connection.Method.POST)
                    .execute();
                
                Log.info("[Remote Backup] " + fileName + " 전송 성공");
            } catch (e) {
                Log.error("Discord Backup Fail: " + e);
            }
        }
    }));
}

/** * [Gemini 요청 사항] 대시보드 데이터 전송 함수 (방별 데이터 분리 및 격리)
 * 수정 내용: 테스트 방의 자산이 대시보드 및 전체 경제 지표에 합산되지 않도록 
 * ctx.targetRoom("내리다")의 데이터만 필터링하여 집계합니다.
 */
function _sendToDashboard(data, ctx) {
    var totalPoints = 0;
    var userCount = 0;
    
    // [수정] 모든 방(data.rooms)을 순회하는 대신 지정된 메인 방만 참조하여 '지표 오염' 방지
    var mainRoomData = data.rooms[ctx.targetRoom];
    
    if (mainRoomData && mainRoomData.users) {
        for (var u in mainRoomData.users) {
            var userObj = mainRoomData.users[u];
            // 해당 방의 유저 포인트와 예금만 합산
            totalPoints += (Number(userObj.point || 0) + Number(userObj.bank || 0));
            userCount++;
        }
        
        // 해당 방의 중앙은행 재원(bankReserve)도 경제 지표에 포함
        if (mainRoomData.bankReserve !== undefined) {
            totalPoints += Number(mainRoomData.bankReserve);
        }
    }

    var payload = {
        total_money: totalPoints,
        user_count: userCount,
        stocks: data.stockMarket || {}
    };

    Executor.execute(new java.lang.Runnable({
        run: function() {
            try {
                org.jsoup.Jsoup.connect(ctx.dashboardUrl)
                    .header("Content-Type", "application/json")
                    .requestBody(JSON.stringify(payload))
                    .ignoreContentType(true)
                    .ignoreHttpErrors(true)
                    .method(org.jsoup.Connection.Method.POST)
                    .execute();
            } catch (e) { Log.error("Dashboard Sync Error: " + e); }
        }
    }));
}

//==========섹터16-2==========

/* 독립 로직 함수: 사채 및 시스템 관리 + 경마 스케줄러 통합 엔진 */
function _runSector16Logic(data, ctx) {
    var nowTs = ctx.now.getTime();
    var currentHour = ctx.now.getHours();
    var currentMin = ctx.now.getMinutes();
    var currentSec = ctx.now.getSeconds();
    var conf = SYSTEM_CONFIG.ECO.STOCK;
    var rConf = SYSTEM_CONFIG.ECO.RACING; 
    var mani = conf.MANIPULATION;

    // [안전장치] 스케줄러 가동 시 참조 오류 방지를 위한 독립 변수 할당
    var mainRoomData = data.rooms[ctx.targetRoom];
    if (!mainRoomData || !mainRoomData.features) return; 

    var racingData = mainRoomData.features.racing;
    var lotto = mainRoomData.features.lotto;

    var gov = mainRoomData.features.government;

    /* [가상 정부] 1. 안건 자동 발의 (20:00) */
    if (currentHour === 20 && currentMin === 0 && gov.lastBillDate !== ctx.today) {
        if (typeof gov_generateBill === 'function') {
            gov.pendingBill = gov_generateBill(); // 안건 생성 (섹터 46 로직)
            gov.votes = { pro: 0, con: 0, voters: [] };
            gov.lastBillDate = ctx.today;
            gov.isClosing = false;
            gov.resultStatus = null;

            var billMsg = "🏛️ [내리다 의회 안건 발의]\n" +
                          "━━━━━━━━━━━━━━━\n" +
                          "📜 안건: " + gov.pendingBill.name + "\n\n" +
                          "✅ 혜택: " + gov.pendingBill.buffDesc + "\n" +
                          "⚠️ 대가: " + gov.pendingBill.penaltyDesc + "\n" +
                          "━━━━━━━━━━━━━━━\n" +
                          "🕒 투표 시간: 20:00 ~ 23:50\n" +
                          "🎁 참여 보상: 2000P (즉시 지급)\n\n" +
                          "💡 참여: [/투표 찬성] 또는 [/투표 반대]\n" +
                          "(참여율 50% 미만 시 기각됩니다)";
            Api.replyRoom(ctx.targetRoom, billMsg);
            ctx.isUpdated = true;
        }
    }

    /* [가상 정부] 2. 투표 마감 및 정족수 검증 (23:50) */
    if (currentHour === 23 && currentMin === 50 && gov.pendingBill && !gov.isClosing) {
        gov.isClosing = true;
        
        // 정족수 계산: 오늘 출석한 유저 기준 50%
        var attendees = 0;
        for (var uid in mainRoomData.users) {
            if (mainRoomData.users[uid].lastDate === ctx.today) attendees++;
        }
        var quorum = Math.ceil(attendees * 0.5);
        var participantCount = gov.votes.voters.length;

        if (participantCount < quorum) {
            gov.resultStatus = "REJECTED_QUORUM";
            var failMsg = "📢 [의회 통보] 금일 안건이 기각되었습니다.\n" +
                          "사유: 투표 정족수 미달\n" +
                          "(참여: " + participantCount + "명 / 필요: " + quorum + "명)";
            Api.replyRoom(ctx.targetRoom, failMsg);
        } else {
            gov.resultStatus = (gov.votes.pro > gov.votes.con) ? "PASSED" : "REJECTED_VOTE";
            var resultText = (gov.resultStatus === "PASSED") ? "가결 (찬성 과반)" : "부결 (반대 과반)";
            var finalMsg = "🏛️ [의회 투표 종료]\n결과: " + resultText + "\n" +
                           "(찬성 " + gov.votes.pro + "표 / 반대 " + gov.votes.con + "표)\n\n" +
                           "💡 가결된 정책은 00시 05분에 발효됩니다.";
            Api.replyRoom(ctx.targetRoom, finalMsg);
        }
        ctx.isUpdated = true;
    }

    /* [가상 정부] 3. 정책 공식 적용 (00:05) */
    // 일일 초기화 로직보다 우선권을 갖도록 currentMin === 5 조건에서 정산 우선 실행
    if (currentHour === 0 && currentMin === 5 && gov.resultStatus !== null) {
        if (gov.resultStatus === "PASSED") {
            gov.activePolicy = JSON.parse(JSON.stringify(gov.pendingBill.effects));
            Api.replyRoom(ctx.targetRoom, "🏛️ [정부 공보] 새로운 정책 발효!\n━━━━━━━━━━━━━━━\n안건 '" + gov.pendingBill.name + "'이 가결되어 지금부터 모든 시스템에 공식 적용됩니다.");
        }
        
        // 정산 완료 후 상태 초기화 (데이터 휘발 방지)
        gov.pendingBill = null;
        gov.resultStatus = null;
        gov.isClosing = false;
        for (var userUid in mainRoomData.users) {
            mainRoomData.users[userUid].hasVotedToday = false;
        }
        ctx.isUpdated = true;
    }

    /* [시스템] 5분 주기 오토세이브 & 장 오픈 시가 기록 */
    try {
        if (currentMin % 5 === 0 && data.lastAutoSaveMin !== currentMin) {
            data.lastAutoSaveMin = currentMin;
            ctx.isUpdated = true;
            ctx.isForceBackup = true; 
        }
        if (currentHour === conf.SETTINGS.OPEN_HOUR && currentMin === 0 && data.lastMarketOpenMin !== currentMin) {
            data.lastMarketOpenMin = currentMin;
            if (data.stockMarket) {
                /* [긴급 수정] 개장 시 모든 종목의 시가(openPrice) 개별 동기화 */
                // 사유: 1개 종목의 가격이 전체 기준점이 되는 버그 수정
                for (var sKey in data.stockMarket) {
                    data.stockMarket[sKey].openPrice = data.stockMarket[sKey].price;
                }
                
                // (대시보드 호환성을 위해 전역 변수도 남겨두되 로직엔 영향 없음)
                var stocks = Object.keys(data.stockMarket);
                if (stocks.length > 0) {
                    marketOpenPrice = data.stockMarket[stocks[0]].price; 
                    data.marketOpenPrice = marketOpenPrice;
                }
                
                ctx.isUpdated = true;
            }
        }
    } catch(e) { Log.error("Sys/Save Logic Error: " + e); }

    /* [1. 사채 및 경제 감시 엔진] */
    try {
        for (var rName in data.rooms) {
            var roomData = data.rooms[rName];
            if (!roomData.loanContracts) roomData.loanContracts = {};

            // [국가 부도 관리 시스템 v2.0]
            if (roomData.bankReserve !== undefined) {
                var reserve = roomData.bankReserve;
                if (!roomData.lastBankAlert) roomData.lastBankAlert = "normal";

                var roomBase = roomData.economyBase || 3500000;
                var dangerLimit = Math.floor(roomBase * 0.3);  // 30% : 부도 위험
                var disasterLimit = Math.floor(roomBase * 0.1); // 10% : 부도 선포
                var normalLimit = Math.floor(roomBase * 0.5);   // 50% : 부도 해제

                // 1. 국가 부도 선포 (10% 미만)
                if (reserve < disasterLimit && roomData.lastBankAlert !== "disaster") {
                    roomData.lastBankAlert = "disaster";
                    var disasterMsg = "🚨 [국가 부도 선포] 🚨\n━━━━━━━━━━━━━━━\n중앙은행의 국고가 바닥났습니다(10% 미만).\n\n🚫 동결: 주식 매매, 홀짝, 경마 등 모든 투자 활동이 전면 금지됩니다.\n🏥 제한: 출석 및 복지 포인트가 50% 삭감됩니다.\n\n⚠️ 해제 조건: 국고가 기준점의 50%(" + fp(normalLimit) + "P) 이상 충전되어야 합니다.";
                    Api.replyRoom(rName, disasterMsg);
                    ctx.isUpdated = true;
                }
                // 2. 국가 부도 위험 (30% 미만) - 현재 상태가 '정상'일 때만 위험 알림
                else if (reserve < dangerLimit && reserve >= disasterLimit && roomData.lastBankAlert === "normal") {
                    roomData.lastBankAlert = "warning";
                    var warningMsg = "⚠️ [국가 부도 위험 알림]\n━━━━━━━━━━━━━━━\n중앙은행 재원이 위험 수준(30% 미만)에 도달했습니다.\n\n🏦 현재 금고: " + fp(reserve) + "P\n💡 지속적인 국고 유출 시 부도가 선포되어 모든 경제 활동이 동결될 수 있습니다.";
                    Api.replyRoom(rName, warningMsg);
                    ctx.isUpdated = true;
                }
                // 3. 국가 부도 해제 (50% 이상 복구 시) - 위험(warning)이나 선포(disaster) 상태일 때만 해제 알림
                else if (reserve >= normalLimit && (roomData.lastBankAlert === "warning" || roomData.lastBankAlert === "disaster")) {
                    roomData.lastBankAlert = "normal";
                    var normalMsg = "✅ [국가 부도 해제]\n━━━━━━━━━━━━━━━\n국고가 안정권(50% 이상)으로 복구되어 모든 경제 활동이 정상화되었습니다.\n\n🔓 해제: 주식, 도박, 경마 시스템 재가동\n💰 복지: 모든 보상이 정상 지급으로 전환됩니다.";
                    Api.replyRoom(rName, normalMsg);
                    ctx.isUpdated = true;
                }
            }

            // 사채 이자 및 추심 로직
            for (var cid in roomData.loanContracts) {
                var c = roomData.loanContracts[cid];
                var periodsPassed = Math.floor((nowTs - c.startTime) / 10800000); 
                
                if (c.appliedPeriods === undefined) c.appliedPeriods = 0;
                
                if (periodsPassed > c.appliedPeriods) {
                    var pendingPeriods = periodsPassed - c.appliedPeriods;
                    var totalNewInterest = 0;
                    for (var i = 0; i < pendingPeriods; i++) {
                        var currentDebt = Number(c.currentDebt || 0);
                        var interest = Math.floor(currentDebt * (Number(c.rate) / 100));
                        c.currentDebt = currentDebt + interest;
                        totalNewInterest += interest;
                    }
                    c.appliedPeriods = periodsPassed;
                    ctx.isUpdated = true;
                    
                    try {
                        var interestMsg = "🚬 [사채 이자 갱신]\n━━━━━━━━━━━━━━━\n" +
                                          "👤 대상: " + c.borrowerName + "님\n" +
                                          "🤝 채권자: " + c.lenderName + "\n" +
                                          "🕒 경과: " + (periodsPassed * 3) + "시간\n" +
                                          "💰 추가 이자: +" + fp(totalNewInterest) + "P\n" +
                                          "📉 현재 채무: " + fp(c.currentDebt) + "P\n" +
                                          "━━━━━━━━━━━━━━━";
                        Api.replyRoom(rName, interestMsg);
                    } catch(e) {}
                }

                var duration = nowTs - c.startTime;
                var overdueLimit = 24 * 60 * 60 * 1000;
                var bankTakeoverLimit = 36 * 60 * 60 * 1000;

                if (c.status === 'active' && duration > overdueLimit && duration <= bankTakeoverLimit) {
                    c.status = 'overdue'; 
                    ctx.isUpdated = true;
                    try { 
                        var collectionMsg = "🚨 [강제 추심 집행 알림]\n대상: " + c.borrowerName + "님\n사유: 상환 기한(24시간) 초과\n\n지금부터 수익의 50%가 채권자에게 자동 귀속됩니다.";
                        Api.replyRoom(rName, collectionMsg); 
                    } catch(e){}
                }
                else if (duration > bankTakeoverLimit) {
                    var amountToPay = Number(c.currentDebt);
                    var lender = roomData.users[c.lenderUid];
                    var borrower = roomData.users[c.borrowerUid];

                    if (lender && borrower) {
                        util_updatePoint(lender, roomData, amountToPay, "사채 은행 대납 회수 (" + c.borrowerName + ")", rName);
                        
                        if (!borrower.loan) borrower.loan = { debt: 0, items: [] };
                        borrower.loan.debt = Number(borrower.loan.debt) + amountToPay;
                        borrower.loan.items.push(amountToPay);
                        borrower.isTransferred = true; 
                        borrower.creditScore = Math.max(0, (borrower.creditScore || 600) - 50);
                        checkAndHandleDefaulter(borrower, rName);
                        
                        var takeoverMsg = "🏛️ [중앙은행 대환 집행]\n━━━━━━━━━━━━━━━\n👤 대상: " + c.borrowerName + "님\n\n내용: 사채 연체 36시간 경과로 인해 은행이 " + fp(amountToPay) + "P를 대납 처리하였습니다.\n\n⚠️ [페널티]: 신용점수 -50점 강등\n⚠️ 해당 채무는 [은행 대환 대출]로 전환되었으며, 완납 시까지 모든 수익의 70%가 강제 상환됩니다.\n━━━━━━━━━━━━━━━";
                        Api.replyRoom(rName, takeoverMsg);
                        delete roomData.loanContracts[cid];
                        ctx.isUpdated = true;
                    }
                }
            }
        }
    } catch (e) { Log.error("Loan/Bank Logic Error: " + e); }

    /* [2. 주식 주기적 변동 처리] */
    try {
        if (currentHour >= conf.SETTINGS.OPEN_HOUR && currentHour <= conf.SETTINGS.CLOSE_HOUR && currentMin % 10 === 0 && data.lastStockUpdateMin !== currentMin) {
            data.lastStockUpdateMin = currentMin; 
            var currentStockCount = Object.keys(data.stockMarket || {}).length;
            
            if (mani && mani.ACTIVE === true) {
                data.pendingSpecialEffect = { stock: mani.TARGET, factor: mani.IS_UP ? Math.abs(mani.RATE) : -Math.abs(mani.RATE), forceMani: true };
            } else {
                if (currentStockCount < 3 || (currentStockCount < 10 && Math.random() < SYSTEM_CONFIG.PROB.STOCK_NEW_LISTING)) { 
                    data.pendingNewStock = true;
                } else if (Math.random() < SYSTEM_CONFIG.PROB.STOCK_SPECIAL) {
                    var stocks = Object.keys(data.stockMarket || {});
                    if (stocks.length > 0) {
                        var target = stocks[Math.floor(Math.random() * stocks.length)];
                        var isUp = Math.random() < SYSTEM_CONFIG.PROB.STOCK_UP_CHANCE;
                        var randFactor = (Math.random() * 0.07) + 0.08;
                        data.pendingSpecialEffect = { stock: target, factor: isUp ? randFactor : -randFactor };
                    }
                }
            }
            try { java.lang.Thread.sleep(1000); } catch(e){}
            var stockResult = updateStockPrices(data);

            if (mainRoomData && mainRoomData.features) {
                mainRoomData.features.msgCount = 0;
            }

            var isMarketOpen = (currentHour >= conf.SETTINGS.OPEN_HOUR && currentHour <= conf.SETTINGS.CLOSE_HOUR);
            var statusText = isMarketOpen ? "🟢 장 운영 중 (07:00 ~ 23:59)" : "🔴 장 마감";
            var body = "📉 주식 시세 변동\n━━━━━━━━━━━━━━━\n" + statusText + "\n\n" + (generateStockList(data) || "시세 정보 없음"); 
            if (stockResult.length > 0) body += "\n\n" + stockResult.join("\n");
            body += "\n━━━━━━━━━━━━━━━";
            try { Api.replyRoom(ctx.targetRoom, body); } catch(err) {}
            ctx.isUpdated = true;
            util_stamp("stockLogic");
        }
    } catch (e) { Log.error("Stock Logic Error: " + e); }

    /* [3. 경마 시스템 통합 스케줄러] */
    try {
        // A. 개장 알림
        if (currentHour === rConf.OPEN_HOUR && currentMin === 0) {
            if (racingData.lastOpenDate !== ctx.today) {
                racingData.isOperating = true;
                racingData.isResultProcessed = false; 
                racingData.isDeadlineNotified = false;
                racingData.lastOpenDate = ctx.today;
                var startMsg = "🏇 [내리다 경마장 개장 알림]\n━━━━━━━━━━━━━━━\n지금부터 제 " + racingData.round + "회차 경마 배팅이 가능합니다!\n\n🕒 배팅 시간: 매시 00분 ~ 49분 59초\n🏁 결과 발표: 매시 00분 00초\n🚫 운영 종료: 23:59 (00:00 최종 결과)\n━━━━━━━━━━━━━━━\n💡 현황 확인: [/경마] 입력";
                Api.replyRoom(ctx.targetRoom, startMsg);
            }
        }

        // B. 배팅 마감 알림
        if (currentMin === 50 && !racingData.isDeadlineNotified) {
            if (currentHour >= rConf.OPEN_HOUR && currentHour <= rConf.CLOSE_HOUR) {
                racingData.isOperating = true; 
                racingData.isDeadlineNotified = true;
                var deadlineMsg = "📢 [경마 배팅 마감 알림]\n━━━━━━━━━━━━━━━\n제 " + racingData.round + "회차 배팅이 종료되었습니다!\n\n🏦 최종 집계 포인트: " + fp(racingData.totalPool) + "P\n🏁 우승마 판독 및 정산 진행 중...\n━━━━━━━━━━━━━━━\n🏇 잠시 후 정각(00분)에 결과가 발표됩니다!";
                Api.replyRoom(ctx.targetRoom, deadlineMsg);
                ctx.isUpdated = true;
            }
        }

        // C. 결과 발표 및 정산
        var isRaceTime = (currentHour >= rConf.OPEN_HOUR && currentHour <= 23) || currentHour === 0;
        if (isRaceTime && currentMin === 0 && currentHour !== rConf.OPEN_HOUR) {
            if (racingData.lastProcessedHour !== currentHour) {
                racingData.isOperating = (currentHour >= rConf.OPEN_HOUR && currentHour <= 23);
                racingData.lastProcessedHour = currentHour;

                // [신규] 배팅 밀집도에 따른 확률 역보정 (배팅이 몰릴수록 우승 확률 감소)
                if (racingData.totalPool > 0) {
                    racingData.horses.forEach(function(h) {
                        var horseBetAmt = 0;
                        for (var uid in racingData.bets) {
                            if (racingData.bets[uid].horseId === h.id) {
                                horseBetAmt += Number(racingData.bets[uid].amount);
                            }
                        }
                        var betRatio = horseBetAmt / racingData.totalPool;
                        
                        // 밀집도 보정 계수: 배팅 비율의 80%만큼 가중치 삭감 (역배 유도)
                        // 예: 한 말에 100% 몰리면 우승 확률이 기존의 20% 수준으로 급락
                        var penalty = 1 - (betRatio * 0.5);
                        h.weight = Math.max(0.1, h.weight * penalty); 
                    });
                }
                
                var totalW = 0; racingData.horses.forEach(function(h){ totalW += h.weight; });
                var rVal = Math.random() * totalW; var accum = 0; var winner = racingData.horses[0];
                for(var i=0; i<racingData.horses.length; i++){ accum += racingData.horses[i].weight; if(rVal < accum){ winner = racingData.horses[i]; break; } }

                var tax = Math.floor(racingData.totalPool * rConf.TAX_RATE);
                var basePool = racingData.totalPool - tax + racingData.carryOver;
                var winPool = 0; var winnerUids = [];
                for(var uid in racingData.bets){ if(racingData.bets[uid].horseId === winner.id){ winPool += racingData.bets[uid].amount; winnerUids.push(uid); } }

                var mainRoom = data.rooms[ctx.targetRoom];
                // [교체] 직접 연산 대신 보안 엔진 사용 (수수료 입고)
                if(mainRoom) util_updateReserve(mainRoom, tax, "경마 수수료 입고", ctx.targetRoom);

                var resultHeader = "🏁 [제 " + racingData.round + "회 경마 결과 및 새 경기 안내]\n━━━━━━━━━━━━━━━\n[🏆 지난 경기 결과]\n\"마지막 직선 주로에서 " + winner.id + "번 " + winner.name + "가 골인!\"\n\n🥇 우승마: [" + winner.id + "번 " + winner.name + "]\n";
                var resultBody = "";
                
                if(winnerUids.length > 0) {
                    var minDiv = 3.0; 
                    var totalRequiredFor3x = Math.floor(winPool * minDiv);
                    var subsidyNeeded = Math.max(0, totalRequiredFor3x - basePool);
                    var actualSubsidy = 0;
                    if (subsidyNeeded > 0 && mainRoom) {
                        actualSubsidy = Math.min(subsidyNeeded, mainRoom.bankReserve || 0);
                        util_updateReserve(mainRoom, -actualSubsidy, "경마 보전금 지출", ctx.targetRoom);
                    }
                    var finalDistributePool = basePool + actualSubsidy;
                    var totalActuallyPaid = 0;

                    resultBody += "🏛️ 국고 수수료(10%): " + fp(tax) + "P 입고\n";
                    if (actualSubsidy > 0) resultBody += "🛡️ 3배 배당 보전 지원: " + fp(actualSubsidy) + "P\n";
                    else if (racingData.carryOver > 0) resultBody += "💰 이월금 포함: " + fp(racingData.carryOver) + "P 방출!\n";
                    
                    resultBody += "\n[🎖️ 주요 당첨자]";
                    winnerUids.forEach(function(uId){
                        var b = racingData.bets[uId]; var u = null;
                        for(var r in data.rooms){ if(data.rooms[r].users[uId]){ u = data.rooms[r].users[uId]; break; } }
                        if(u){
                            var share = b.amount / winPool;
                            var prize = Math.floor(share * finalDistributePool);
                            var maxLimit = b.amount * (rConf.MAX_PAYOUT_MULT || 10);
                            if (prize > maxLimit) prize = maxLimit;

                            // [수정] 경마는 배팅금이 들어가는 투자형이므로 삭감(emergencyMult) 제거
                            var finalPrize = Math.floor(prize); 

                            if (!util_isBankSolvent(ctx.targetRoom, finalPrize)) {
                                try { Api.replyRoom(ctx.targetRoom, "🚨 [국고 부도] 경마 당첨금 지급이 정지되었습니다."); } catch(e){}
                                return;
                            }

                            var res = processRepayment(u, prize, uId, ctx.targetRoom);
                            // [교정] mainRoomData를 인자로 전달하여 게이트웨이 국고 연동 및 저널링 보장
                            util_updatePoint(u, mainRoomData, Number(res.actualGain), "경마 당첨금", ctx.targetRoom);
                            totalActuallyPaid += prize;
                            
                            var tag = (prize === maxLimit) ? " ⚠️최대배당" : (actualSubsidy > 0 ? " ✨3배보전" : "");
                            resultBody += "\n• " + b.name + " (+" + fp(res.actualGain) + "P)" + tag;
                        }
                    });
                    racingData.carryOver = Math.max(0, finalDistributePool - totalActuallyPaid);
                    if (racingData.carryOver > 10) {
                        resultBody += "\n\n💰 상한 초과분 " + fp(racingData.carryOver) + "P는\n다음 회차 배당으로 이월되었습니다!";
                    }
               } else {
                    var currentRoundNetPool = racingData.totalPool - tax; 
                    var toBank = Math.floor(currentRoundNetPool * rConf.WINLESS_BANK_RATE); 
                    racingData.carryOver = (currentRoundNetPool - toBank) + racingData.carryOver;
                    if(mainRoom) util_updateReserve(mainRoom, toBank, "경마 무승자 국고 환수", ctx.targetRoom);
                    resultBody += "💀 당첨 유저 없음\n💰 이월금 보전 완료: " + fp(racingData.carryOver) + "P\n" +
                                 "🏛️ 금기 판돈 국고 귀속(" + (rConf.WINLESS_BANK_RATE * 100).toFixed(0) + "%): " + fp(toBank) + "P";
                }

                var isClosing = (currentHour === 0);
                if (isClosing) {
                    racingData.isOperating = false;
                    resultBody += "\n━━━━━━━━━━━━━━━\n💤 금일 경마 운영이 종료되었습니다.\n다음 경기는 오전 09:00에 시작됩니다.";
                } else {
                    resultBody += "\n━━━━━━━━━━━━━━━\n✨ [제 " + (racingData.round + 1) + "회 경기 시작] ✨\n지금부터 다음 경기 배팅이 가능합니다.";
                }

                Api.replyRoom(ctx.targetRoom, resultHeader + resultBody);
                util_stamp("racingLogic");

                racingData.round++; 
                racingData.bets = {}; 
                racingData.totalPool = 0;
                racingData.isDeadlineNotified = false;
                
                var conds = [{l:"🚀 최상",w:1.5},{l:"☀️ 양호",w:1.2},{l:"☁️ 보통",w:1.0},{l:"💧 부진",w:0.7}];
                racingData.horses.forEach(function(h){ var c=conds[Math.floor(Math.random()*conds.length)]; h.icon=c.l; h.weight=c.w; });
                ctx.isUpdated = true;
            }
        }
    } catch (e) { Log.error("Racing Logic Error: " + e); }

    /* [4. 피버타임 및 결투 체크] */
    try {
        if (!data.feverData) data.feverData = { active: false, endTime: 0, scheduled: [] };
        var timeKey = (currentHour < 10 ? "0"+currentHour : currentHour) + ":" + (currentMin < 10 ? "0"+currentMin : currentMin);
        if (data.feverData.scheduled.indexOf(timeKey) !== -1 && !data.feverData.active) {
            data.feverData.active = true; data.feverData.endTime = nowTs + (5 * 60 * 1000);
            data.feverData.scheduled.splice(data.feverData.scheduled.indexOf(timeKey), 1);
            try { Api.replyRoom(ctx.targetRoom, "🔥 홀짝 피버타임 시작\n━━━━━━━━━━━━━━━\n지금부터 5분간 홀짝 승률이 상승합니다!"); } catch(e){}
            ctx.isUpdated = true;
        }
        if (data.feverData.active && data.feverData.endTime > 0 && nowTs > Number(data.feverData.endTime)) {
            data.feverData.active = false; data.feverData.endTime = 0;
            try { Api.replyRoom(ctx.targetRoom, "❄️ 홀짝 피버타임 종료\n━━━━━━━━━━━━━━━\n이벤트 시간이 마감되어 승률이 정상화되었습니다."); } catch(e){}
            ctx.isUpdated = true;
        }

        for (var dKey in duelData) {
            var d = duelData[dKey];
            if (nowTs > d.expire) {
                var room = data.rooms[d.room];
                if (room && room.users[d.challengerUid]) {
                    util_updatePoint(room.users[d.challengerUid], room, Number(d.point), "결투 만료 환급", d.room);
                    try { Api.replyRoom(d.room, "⏰ 결투 만료\n━━━━━━━━━━━━━━━\n상대방 응답 없음으로 " + fp(d.point) + "P 환급 완료\n내 잔액: " + fp(room.users[d.challengerUid].point) + "P"); } catch(err) {}
                }
                delete duelData[dKey]; ctx.isUpdated = true; 
            }
        }
    } catch (e) { Log.error("Fever/Duel Logic Error: " + e); }
}
// 엔진 가동
runScheduler();

//==========섹터17==========

/**
 * 섹터 17 로직 함수: 주식 장 마감, 일일 데이터 초기화 및 시즌 리셋 관리
 * [수정 완료] 날짜 갱신 순서 오류 수정 및 0시 제한 해제 (안전한 초기화 보장)
 */
function _runSector17Logic(data, ctx) {
    // 일일 데이터 초기화 (시간 제한 없이 날짜가 변경되었다면 즉시 실행)
    if (data.lastDailyReset !== ctx.today) {

    if (data.stockMarket) {
            for (var sName in data.stockMarket) {
                data.stockMarket[sName].isOverheated = false;
            }
            Log.info("[Stock Engine] 장 마감에 따른 과열 상태 초기화 완료.");
        }
        
        // [1] 자동 물가 기준점 보정 시스템
        for (var rName in data.rooms) {
            var rObj = data.rooms[rName];
            var eco = calculateEconomy(data, rName);
            
            if (eco.total > 0) {
                var oldBase = rObj.economyBase || eco.total;
                rObj.economyBase = Math.floor(Math.sqrt(oldBase * eco.total));
                Log.info("[" + rName + "] 경제 기준점 자동 조정 완료: " + fp(rObj.economyBase) + "P");
            }
        }

        // [2] 주식 시장 종료 처리 (전역 공지)
        try { 
            Api.replyRoom(ctx.targetRoom, formatAdmin("📉 장 마감 알림", "금일 주식 시장이 종료되었습니다.\n(일일 데이터가 초기화되었습니다.)")); 
        } catch(e) {}

        // [3] 전역 피버타임 스케줄 생성
        data.feverData.scheduled = [];
        while(data.feverData.scheduled.length < 5) {
            var h = Math.floor(Math.random() * 15) + 9; 
            var m = Math.floor(Math.random() * 60);
            var tStr = (h < 10 ? "0"+h : h) + ":" + (m < 10 ? "0"+m : m);
            if (data.feverData.scheduled.indexOf(tStr) === -1) data.feverData.scheduled.push(tStr);
        }
        data.feverData.active = false; 

        // [4] 피버타임 요일별 공지
        var dayOfWeek = ctx.now.getDay(); 
        if (dayOfWeek === 0) {
            try { Api.replyRoom(ctx.targetRoom, formatAdmin("🔥 피버타임 시작", "일요일 한정 이벤트!\n승급 확률 +5% 상승이 적용됩니다.")); } catch(e){}
        } else if (dayOfWeek === 1) {
            try { Api.replyRoom(ctx.targetRoom, formatAdmin("❄️ 피버타임 종료", "이벤트가 종료되어\n승급 확률이 정상화되었습니다.")); } catch(e){}
        }

        // [3, 4번 통합] 유령 유저 청소 및 강력한 누진세(보유세) 집행 로직
        for (var rName in data.rooms) {
            var roomObj = data.rooms[rName];
            var eco = calculateEconomy(data, rName);
            var wealthyThreshold = eco.average * 3; // 평균 자산의 3배 초과 시 부유층

            var reportTotalTax = 0;   // 총 징수액
            var reportTaxCount = 0;   // 납세 인원
            var reportPurgeCount = 0; // 청소 인원

            for (var id in roomObj.users) {
                var u = roomObj.users[id];
                
                // [3번] 30일 이상 미출석 유저 데이터 청소 및 자산 국고 귀속
                var lastDateTs = u.lastDate ? new Date(u.lastDate).getTime() : 0;
                var daysInActive = (Date.now() - lastDateTs) / (1000 * 60 * 60 * 24);
                
                if (u.lastDate !== "" && daysInActive > 30) {
                    if (Number(u.point) > 0) {
                        util_updatePoint(u, roomObj, -u.point, "장기 미접속 자산 환수", rName);
                    }
                    delete roomObj.users[id];
                    reportPurgeCount++;
                    continue;
                }

                // [4번 강화] 강력한 누진세(보유세) 집행 로직
                // 대상: 실질 순자산 기준 / 징수: 보유 현금에서 차감
                var netWorth = util_calculateNetWorth(u, roomObj);
                var taxRate = 0;
                
                // 자산 구간별 세율 설정 (누진제)
                if (netWorth > 1000000) taxRate = 0.02;      // 1,00만P 초과: 2%
                else if (netWorth > 500000) taxRate = 0.01;  // 50만P 초과: 1%
                else if (netWorth > 100000) taxRate = 0.005; // 10만P 초과: 0.5%

                // 최소 잔액 1,000P 이상인 유저에게만 징수 (서민 보호)
                if (taxRate > 0 && Number(u.point) > 100000) {
                    var tax = Math.floor(Number(u.point) * taxRate);
                    if (tax > 0) {
                        util_updatePoint(u, roomObj, -tax, "자산 보유세 징수", rName);
                        reportTotalTax += tax;
                        reportTaxCount++;
                    }
                }
            }

            // [자동 보고] 정산 내역이 있을 때만 결과 출력
            if (reportTaxCount > 0 || reportPurgeCount > 0) {
               var reportMsg = "🌙 [야간 경제 안정화 정산 보고]\n" +
                                "━━━━━━━━━━━━━━━\n" +
                                "✅ 보유세(누진제) 징수 완료\n" +
                                "• 납세 인원: " + reportTaxCount + "명\n" +
                                "• 총 세수: +" + fp(reportTotalTax) + "P (국고 입고)\n\n" +
                                "✅ 유령 유저 데이터 정리\n" +
                                "• 청소 인원: " + reportPurgeCount + "명\n" +
                                "━━━━━━━━━━━━━━━\n" +
                                "🏛️ 중앙은행 금고가 최신화되었습니다.";
                Api.replyRoom(rName, reportMsg);
            }

            // 하이프 카운트(채팅량) 초기화
            if (roomObj.features) roomObj.features.msgCount = 0;
        }

        // [5] 핵심: 모든 방 유저 스탯 초기화 (지능형 금리 엔진 적용)
        for (var rName in data.rooms) {
            var roomObj = data.rooms[rName];
            if (!roomObj.features) continue;

            // [연동] 섹터 49의 지능형 탄력 금리 승수 호출
            var dynMult = 1.0;
            if (typeof util_getDynamicRateMultiplier === 'function') {
                dynMult = util_getDynamicRateMultiplier(rName);
            }

            if (roomObj.features.lotto) {
                roomObj.features.lotto.entries = {}; 
                roomObj.features.lotto.dailyPool = 0;
            }

            for (var id in roomObj.users) {
                var u = roomObj.users[id];
                u.dailyLoanCount = 0; 
                u.dailyGambleCount = 0; 
                u.dailyPromotionAttempts = 1; 
                u.dailyStimulusCount = 0; 
                u.dailyCreditRestoreCount = 0; 
                
                // [보안강화] 시간 비례 적립 이자 정산 (0시 정각)
                var now = Date.now();
                // 0시 정각까지 남은 마지막 쪼가리 이자까지 합산
                if (u.lastBankUpdateTime > 0 && Number(u.bank) > 0) {
                    var timePassed = now - u.lastBankUpdateTime;
                    var dayMs = 24 * 60 * 60 * 1000;
                    var lastMinuteEarned = Number(u.bank) * 0.05 * (timePassed / dayMs);
                    u.accruedInterest = (u.accruedInterest || 0) + lastMinuteEarned;
                }

                // 긴급 경제 조치 배율 확인
                var emergencyMult = util_getEmergencyMultiplier(rName);

                // [자산왕] 칭호 효과: 이자 1.5배 보너스 적용
                var wealthBonus = (u.title === "자산왕") ? 1.5 : 1.0;
                // 지급할 최종 금액 (긴급 배율 및 칭호 보너스 통합 계산)
                var finalInterest = Math.floor((u.accruedInterest || 0) * emergencyMult * wealthBonus);

                if (finalInterest > 0) {
                    // 국고 지불 능력 확인 및 지급 로직 (이후 중괄호 닫힘 확인 필수)
                    if (util_isBankSolvent(rName, finalInterest)) {
                        util_updateBank(u, roomObj, finalInterest, "은행 예금 이자 지급", rName);
                        util_updateReserve(roomObj, -finalInterest, "은행 예금 이자 지급", rName);
                        
                        // [핵심] 지급에 성공했을 때만 이자 주머니를 0으로 초기화
                        u.accruedInterest = 0; 
                    } else {
                        // [핵심] 지급 실패 시 u.accruedInterest를 0으로 초기화하지 않음!
                        // 데이터는 보존되며 내일 정산 시 오늘치 이자가 다시 더해짐 (이월)
                        Log.info("[Bank Default] " + u.name + "님 국고 고갈로 이자 지급 보류 및 이월");
                    }
                }
                
                // 정산 후 초기화
                u.accruedInterest = 0;
                u.lastBankUpdateTime = now;
                
                // [보안강화] 지능형 차등 대출 이자 가산 (신용등급별 + 탄력 승수)
                if (u.loan && Number(u.loan.debt) > 0) { 
                    u.creditScore = Math.max(0, Number(u.creditScore) - 5); 
                    
                    // 신용등급 정보 호출 (섹터 10 연동)
                    var cr = getCreditInfo(u.creditScore);

                    // [기부왕] 채무 이자 감면 로직
                    var dailyRate = (cr.rate - 1) * dynMult;
                    if (u.title === "기부왕") dailyRate *= 0.7; // 30% 감면

                    var dailyInterest = Math.floor(Number(u.loan.debt) * dailyRate);
                    
                    var preDebt = Number(u.loan.debt);
                    var expectedDebt = preDebt + dailyInterest;
                    u.loan.debt = expectedDebt;
                    
                    if (isNaN(u.loan.debt) || u.loan.debt !== expectedDebt) {
                        u.loan.debt = preDebt;
                        Log.error("[System] " + u.name + " 대출 이자 연산 오류 차단 및 복구");
                    }

                    if (typeof checkAndHandleDefaulter === 'function') checkAndHandleDefaulter(u, rName); 
                }
            }

            try { 
                Api.replyRoom(rName, formatAdmin("🎫 로또 판매 시작", "새로운 로또 판매가 시작되었습니다.\n매일 밤 22시 추첨!")); 
            } catch(e) {}
        }

        // [6] 시즌 리셋 처리 (매월 1일)
        if (ctx.now.getDate() === 1 && data.lastSeasonReset !== ctx.season) {
            data.lastSeasonReset = ctx.season;
            for (var r in data.rooms) { 
                for (var id in data.rooms[r].users) { 
                    var u = data.rooms[r].users[id];
                    u.tier = 0;
                    u.gameAuthCount = 0; 
                    u.purchasedAuthCount = 0; 
                } 
            }
            try { 
                Api.replyRoom(ctx.targetRoom, formatAdmin("🏆 시즌 리셋", "새로운 시즌이 시작되어 모든 티어 및 게임 인증 기록이 초기화되었습니다.")); 
            } catch(e) {}
        }

        // [최종] 모든 로직 수행 후 날짜 갱신 (가장 마지막에 수행해야 함)
        data.lastDailyReset = ctx.today; 
        ctx.isUpdated = true;
        util_stamp("dailyReset");
    }
}

//==========섹터18==========

/**
 * 섹터 18 로직 함수: 로또 판매 마감 알림 및 당첨 추첨 프로세스
 * 수정 사항: 방별 격리된 로또 데이터(Features) 통합 추첨 및 상금 지급
 */
function _runSector18Logic(data, ctx) {
    var currentHour = ctx.now.getHours();
    var currentMin = ctx.now.getMinutes();
    
    // 중앙은행 재원 참조 (메인 운영 방 기준)
    var mainRoomData = data.rooms[ctx.targetRoom]; 

    /* 7. 로또 판매 마감 알림 (21:00) */
    if (currentHour === 21) {
        if (!data.lotto_flags) data.lotto_flags = {};
        if (data.lotto_flags.lastCloseNotify !== ctx.today) {
            data.lotto_flags.lastCloseNotify = ctx.today;

            // [핵심] 모든 방의 판매금(dailyPool)을 합산하여 총액 계산
            var totalDailyPool = 0;
            for (var r in data.rooms) {
                if (data.rooms[r].features && data.rooms[r].features.lotto) {
                    totalDailyPool += Number(data.rooms[r].features.lotto.dailyPool || 0);
                }
            }
            var totalJackpot = Number(data.lotto_jackpot_pool || 0); 
            var displayPool = totalDailyPool + totalJackpot;

            // 모든 방에 마감 알림 전송 (격리 발송)
            try { 
                Api.replyRoom(ctx.targetRoom, formatAdmin("🏁 로또 판매 마감", "잠시 후 22시 추첨!\n현재 누적 상금: " + fp(displayPool) + "P")); 
            } catch(e) {}
            
            ctx.isUpdated = true;
        }
    }

    /* 8. 로또 당첨 번호 추첨 및 상금 지급 (22:00) */
    if (currentHour === 22) {
        if (!data.lotto_flags) data.lotto_flags = {};
        if (data.lotto_flags.lastDrawNotify !== ctx.today) {
            data.lotto_flags.lastDrawNotify = ctx.today;
            
            // 당첨 번호 생성
            var win = []; 
            while(win.length < 3) { 
                var n = Math.floor(Math.random() * 15) + 1; 
                if(win.indexOf(n) === -1) win.push(n); 
            }
            win.sort(function(a,b){return a-b}); 
            data.last_win_nums = win; 

            var totalDailyPool = 0;
            var w1 = [], w2 = [], w3 = [];
            var fails = []; // 낙첨자 수집용 배열 선언

            // [핵심] 모든 방을 돌며 독립된 응모 내역(entries) 수집 및 당첨자 분류
            for (var rName in data.rooms) {
                var roomObj = data.rooms[rName];
                if (!roomObj.features || !roomObj.features.lotto) continue;
                
                var rLotto = roomObj.features.lotto;
                totalDailyPool += Number(rLotto.dailyPool || 0);

                for (var uid in rLotto.entries) {
                    var userFound = roomObj.users[uid];
                    if (!userFound) {
                        delete rLotto.entries[uid];
                        continue;
                    }
                    rLotto.entries[uid].forEach(function(tk) {
                        var match = 0; 
                        tk.forEach(function(n){ if(win.indexOf(n) !== -1) match++; });
                        if(match === 3) w1.push({u: userFound, id: uid, rm: rName}); 
                        else if(match === 2) w2.push({u: userFound, id: uid, rm: rName}); 
                        else if(match === 1) w3.push({u: userFound, id: uid, rm: rName});

                        else fails.push({u: userFound, id: uid, rm: rName}); // 낙첨자 수집 추가

                    });
                }
                // 정산 후 해당 방의 판돈 초기화
                rLotto.dailyPool = 0;
            }

            var baseJackpot = Number(data.lotto_jackpot_pool || 0);
            var totalPrizePool = totalDailyPool + baseJackpot;
            var totalPayout = 0;
            var resM = "당첨 번호: [" + win.join(", ") + "]\n";

            // 1등 지급 (전액 n빵)
            if(w1.length > 0) { 
                var p1 = Math.floor(totalPrizePool / w1.length); 
                w1.forEach(function(obj){
                // 로또는 잭팟 금액이므로 삭감(0.5)보다는 지급 능력 위주로 체크
                    if (!util_isBankSolvent(obj.rm, p1)) {
                        try { Api.replyRoom(obj.rm, "🚨 [국고 부도] 로또 당첨금이 부족하여 지급이 연기되었습니다."); } catch(e){}
                        return;
                    }
                    var res = processRepayment(obj.u, p1, obj.id, obj.rm);
                    util_updatePoint(obj.u, data.rooms[obj.rm], Number(res.actualGain), "로또 1등 당첨", obj.rm);
                    totalPayout += p1;
                }); 
                resM += "🥇 1등: " + w1.length + "명 (각 " + fp(p1) + "P)\n"; 
                data.lotto_jackpot_pool = 0; 
            } else { 
                resM += "🥇 1등 없음 (전액 이월)\n"; 
                data.lotto_jackpot_pool = totalPrizePool; 
            }

            // 2등/3등 지급 (고정 상금)
            w2.forEach(function(obj){ 
                var res = processRepayment(obj.u, 50000, obj.id, obj.rm);
                util_updatePoint(obj.u, data.rooms[obj.rm], Number(res.actualGain), "로또 2등 당첨", obj.rm);
                totalPayout += 5000;
            }); 
            if(w2.length > 0) resM += "🥈 2등: " + w2.length + "명 (각 5,0000P)\n";

            w3.forEach(function(obj){ 
                var res = processRepayment(obj.u, 10000, obj.id, obj.rm);
                util_updatePoint(obj.u, data.rooms[obj.rm], Number(res.actualGain), "로또 3등 당첨", obj.rm);
                totalPayout += 1000;
            }); 
            if(w3.length > 0) resM += "🥉 3등: " + w3.length + "명 (각 1,0000P)";

            // 국고(중앙은행) 재원 정산
                if (totalPayout > 0) {
                resM += "\n\n🏦 상금 총액 " + fp(totalPayout) + "P 국고 지급 완료";
            }

            fails.forEach(function(obj) {
                if (Math.random() < 0.2) { // 20% 확률
                    obj.u.lottoFailCount = (obj.u.lottoFailCount || 0) + 1;
                    var failMsg = "\n\n 📩 유저님 낙첨되었지만 '위로의편지'가 도착했습니다.\n";
                    
                    if (obj.u.lottoFailCount >= 15) {
                        obj.u.lottoFailCount = 0;
                        obj.u.luckyCharmEnd = Date.now() + (3600000); // 1시간
                        obj.u.inventory.push({ id: 888, name: "행운의부적", icon: "🔮", effect: "item", title: "행운의부적" });
                        failMsg += "✉️ 편지 15장이 모여 [행운의부적]으로 변했습니다! ✨\n⏳ 1시간 동안 홀짝 승률 +3%가 자동 적용됩니다.";
                    } else {
                        failMsg += "현재 수집: " + obj.u.lottoFailCount + " / 15";
                    }
                    try { Api.replyRoom(obj.rm, "💀 낙첨 알림\n━━━━━━━━━━━━━━━\n" + obj.u.name + "님" + failMsg); } catch(e) {}
                }
            });

            // 모든 방에 결과 발표
            try {
                java.lang.Thread.sleep(200); 
                Api.replyRoom(ctx.targetRoom, formatAdmin("🎰 로또 추첨 결과", resM));
            } catch(e) {}
            util_stamp("lottoLogic");
            ctx.isUpdated = true;
        }
    }
}

//==========섹터19==========

/* 메인 메시지 리스너 함수 */
action = function(room, msg, sender, isGroupChat, replier, imageDB) {
    _msgReceiveTime = Date.now();
    Executor.execute(new java.lang.Runnable({
        run: function() {
            lock.lock();
            try {
                var roomName = room ? room.trim() : "";
                var cleanSender = sender ? String(sender).trim() : ""; 
                
                if (ALLOWED_ROOMS.indexOf(roomName) === -1 || cleanSender === "오픈채팅봇") return;

                var data = getDatabase(); 
                if (!data) return;

                if (!data.rooms[roomName]) data.rooms[roomName] = { users: {} };
                var roomData = data.rooms[roomName];
                
                if (!roomData.features) {
                    if (typeof ROOM_FEATURE_TEMPLATE === 'function') {
                        roomData.features = ROOM_FEATURE_TEMPLATE();
                    }
                }

                // [2번] 실시간 하이프(채팅량) 기록
                roomData.features.msgCount = (roomData.features.msgCount || 0) + 1;

               /* [안전 패치] 템플릿 구조 변경 시 실시간 반영 (누락 데이터 자동 생성) */
                // 설명: 섹터 1의 템플릿에 새로운 기능이 추가되면, 기존 방에도 즉시 해당 공간을 만들어줍니다.
                if (typeof ROOM_FEATURE_TEMPLATE === 'function') {
                    var template = ROOM_FEATURE_TEMPLATE();
                    // 1. 메인 기능 키 누락 체크 (racing, lotto 등)
                    for (var key in template) {
                        if (!roomData.features[key]) {
                            roomData.features[key] = template[key];
                        }
                    }
                    // 2. States 내부 누락 체크 (menuWait, bankProcess 등)
                    if (!roomData.features.states) {
                        roomData.features.states = template.states;
                    } else {
                        for (var skey in template.states) {
                            if (!roomData.features.states[skey]) {
                                roomData.features.states[skey] = {};
                            }
                        }
                    }
                }
                
                var rFeatures = roomData.features;

                if (!rFeatures.states) rFeatures.states = { 
                    menuWait: {}, bankProcess: {}, selectWait: {}, lottoPurchase: {},
                    activeThefts: {}, duelData: {}, mining: {}, loanRegister: {}, loanContractWait: {} 
                };

                /* [마이그레이션] 기존 전역 데이터를 현재 방으로 이사 (최초 1회) */
                if (data.lotto && !rFeatures.lotto.round) {
                    rFeatures.lotto = data.lotto;
                }

                // [Gemini 요청 사항] 데이터 참조 지역화 (Thread-Safe)
                if (rFeatures && rFeatures.states) {
                    var racingData = rFeatures.racing;
                    var lotto = rFeatures.lotto;
                    var feverData = rFeatures.feverData;
                    var sprinkleData = rFeatures.sprinkleData;

                    var menuWaitState = rFeatures.states.menuWait; 
                    var bankProcessState = rFeatures.states.bankProcess;
                    var selectWaitState = rFeatures.states.selectWait;
                    var lottoPurchaseState = rFeatures.states.lottoPurchase;
                    var activeThefts = rFeatures.states.activeThefts;
                    var duelData = rFeatures.states.duelData;
                    var miningState = rFeatures.states.mining;
                    var loanRegisterState = rFeatures.states.loanRegister;
                    var loanContractWaitState = rFeatures.states.loanContractWait;
                }

                // [결투 로직 우선순위 가드]
                // 수락, 거절, 취소 키워드 입력 시 다른 대기 상태가 간섭하지 못하도록 결투 데이터를 최우선 탐색합니다.
                var SYSTEM_KEYWORDS = ["줍기", "수락", "거절", "취소", "잡았다요놈", "배팅취소"];
                var isSystemMsg = msg.startsWith("/") || SYSTEM_KEYWORDS.indexOf(msg) !== -1;

                /* [신규] 도배 방지 및 타임아웃 체크 엔진 */
                var user = null;
                var currentImgHash = null;
                try { if (imageDB) currentImgHash = imageDB.getProfileHash(); } catch(e) {}

                // [v6.7 통합] 유저 객체 및 UID 동시 탐색 엔진
                for (var id in roomData.users) {
                    var u = roomData.users[id];
                    // 해시값(프사) 또는 닉네임이 일치하는지 검사
                    if ((currentImgHash && u.imageHash === currentImgHash) || u.name === cleanSender) {
                        user = u;
                        targetUid = id; // 찾은 유저의 고유 코드(ID)를 즉시 바인딩
                        break;
                    }
                }

                /* [v6.6 딥 헬러] 타입 검증형 자가 치유 엔진 (Deep Healing & Memory Sync) */
                if (user && targetUid) {
                    var isDeepHealed = false;
                    
                    // [교정]: 게이트웨이 및 저널링 식별을 위한 UID 강제 바인딩
                    if (!user.uid || user.uid !== targetUid) {
                        user.uid = targetUid;
                        isDeepHealed = true;
                    }

                    // [교체] 전역 표준 규격 USER_SCHEMA를 호출하여 누락 데이터 수리
                    USER_SCHEMA.forEach(function(item) {
                        var val = user[item.key];
                        
                        // 타입이 맞다면 보존
                        if (val !== undefined && val !== null) {
                            if (typeof val === item.type || (item.type === 'array' && Array.isArray(val))) return;
                        }

                        // 수리: 숫자는 형변환 시도, 그 외는 기본값 주입
                        if (item.type === 'number' && val !== undefined && !isNaN(Number(val))) {
                            user[item.key] = Number(val);
                        } else {
                            user[item.key] = item.default;
                        }
                        isDeepHealed = true;
                    });

                    // 3. [Sync] 수리 발생 시 물리 저장 및 메모리(globalData) 즉시 갱신
                    if (isDeepHealed) {
                        Log.info("[Deep-Healer] " + user.name + "님 구조 최적화 및 동기화 완료.");
                        safeSaveData(data, false);
                        if (typeof globalData !== 'undefined') globalData = data; 
                    }

                    // 4. [Spam Guard] 도배 방지 로직 (수리 완료 후 안전하게 실행)
                    var now = Date.now();
                    var conf = SYSTEM_CONFIG.SPAM;
                    if (user.timeoutEndTime && now < user.timeoutEndTime) return;

                    user.chatLog.push(now);
                    user.chatLog = user.chatLog.filter(function(time) { return now - time < conf.LIMIT_WINDOW; });

                    if (user.chatLog.length > conf.LIMIT_COUNT) {
                        user.timeoutEndTime = now + conf.TIMEOUT_MS;
                        user.chatLog = [];
                        var expireTime = new Date(user.timeoutEndTime).toLocaleTimeString();
                        var timeoutMsg = "🔇 [도배 감지: 이용 제한]\n" +
                                         "━━━━━━━━━━━━━━━\n" +
                                         "대상: " + getDisplayName(user) + "님\n" +
                                         "사유: 단시간 과도한 채팅 발송\n" +
                                         "제한: " + Math.floor(conf.TIMEOUT_MS / 60000) + "분간 봇 이용 불가\n" +
                                         "━━━━━━━━━━━━━━━\n" +
                                         "💡 해제 시각: " + expireTime;
                        replier.reply(timeoutMsg);
                        safeSaveData(data);
                        return;
                    }
                }

                /* [핵심] 버그 제보 및 진실 판별 시스템 */
                if (msg.startsWith("/버그제보 ")) {
                    var content = msg.substring(6).trim();
                    if (content.length < 2) return replier.reply("내용을 상세히 적어주세요.");
                    
                    if(user) { 
                        var lastAct = user.lastAction;
                        var timeDiff = lastAct ? (Date.now() - lastAct.time) : 99999999;
                        var diagnosis = "";
                        var isConfirmed = false;

                        if (lastAct && timeDiff < 300000) { 
                            if (lastAct.status === "PENDING") { diagnosis = "⚠️ 로직 중단됨(응답없음)"; isConfirmed = true; }
                            else if (lastAct.status === "CRASH") { diagnosis = "🚫 시스템 에러(Crash)"; isConfirmed = true; }
                            else if (lastAct.status === "FAIL") { diagnosis = "📉 데이터 불일치(계산오류)"; isConfirmed = true; }
                            else if (lastAct.status === "SUCCESS") { 
                                replier.reply("🤖 [시스템 진단: 정상]\n직전 작업(" + lastAct.cmd + ")이 성공적으로 완료되었습니다.\n오류가 발견되지 않았습니다.");
                                return;
                            }
                        } else { 
                            diagnosis = "❓ 실행 기록 없음(로직 미진입/오타)"; isConfirmed = true; 
                        }

                        var logTime = new Date().toLocaleString();
                        var logTxt = "[" + logTime + "] " + cleanSender + ": " + content + "\n    ㄴ 판독: " + diagnosis + "\n";
                        FileStream.append(BUG_LOG_PATH, logTxt);
                        
                        if(isConfirmed) replier.reply("✅ [제보 접수]\n판독 결과: " + diagnosis + "\n분석 내용이 버그 리스트에 등록되었습니다.");
                        else replier.reply("📝 제보가 접수되었습니다.");
                    }
                    return;
                }

                /* 관리자용 시스템 제어 */
                if (isAdmin(sender, data)) {
                    if (msg === "/강제재가동") {
                        if (lock.isLocked()) lock.unlock(); 
                        globalData = getDatabase(); 
                        if (globalData) { globalData.botActive = true; safeSaveData(globalData); }
                        replier.reply(formatAdmin("🔄 시스템 재가동", "결과: 락 해제 및 메모리 동기화 완료"));
                        return;
                    }
                }

//==========섹터20-1==========

if (!data) return;
var roomData = data.rooms[roomName] || { users: {} };
data.rooms[roomName] = roomData;

/* [v9.5 초고속 엔진] 전역 통합 O(1) 식별 캐시 시스템 */
// 로더 리로드 시에도 유지되는 globalData 캐시 사용 (I/O 병목 제거 핵심)
var cacheKey = roomName + "_" + cleanSender;
var targetUid = globalData.nameToIdCache[cacheKey];

// 1. [캐시 검증] 캐시된 UID가 실제 유저 데이터와 일치하는지 확인 (닉변 감지)
// 불일치 시에만 정밀 루프(O(n))를 가동하여 성능 저하 방지
if (!targetUid || !roomData.users[targetUid] || roomData.users[targetUid].name !== cleanSender) {
    var nameMatchId = null;
    var hashMatchId = null;
    var currentImgHash = null;
    try { if (imageDB) currentImgHash = imageDB.getProfileHash(); } catch(e) {}

    // 정밀 교차 식별 루프 (캐시 미적중 시 1회만 실행)
    for (var id in roomData.users) {
        var u = roomData.users[id];
        var isNameEqual = (u.name === cleanSender);
        var isHashEqual = (currentImgHash && u.imageHash === currentImgHash);

        if (isNameEqual && isHashEqual) {
            targetUid = id;
            break; // 완벽 일치 시 즉시 종료
        }
        if (isNameEqual) nameMatchId = id;
        if (isHashEqual) hashMatchId = id;
    }

    // 완벽 일치가 없을 경우 교차 판별 (닉변/프변 대응)
    if (!targetUid) {
        if (nameMatchId) {
            targetUid = nameMatchId; // 프사만 바뀐 경우
            if (currentImgHash) roomData.users[targetUid].imageHash = currentImgHash;
        } else if (hashMatchId) {
            targetUid = hashMatchId; // 닉네임만 바뀐 경우 (닉변)
            var u = roomData.users[targetUid];
            if (!data.nickHistory[targetUid]) data.nickHistory[targetUid] = [];
            data.nickHistory[targetUid].push({ old: u.name, date: getSimpleDate() });
            u.name = cleanSender;
        }
    }

    // 찾은 결과가 있다면 캐시 최신화 (다음번엔 0ms 탐색)
    if (targetUid) {
        globalData.nameToIdCache[cacheKey] = targetUid;
    }
}

// 2. [신분 복구] 식별 실패 시 영구 명부(Registry) 대조 (데이터 부활)
// 캐시에도 없고 루프에서도 못 찾았을 때만 파일 I/O 수행
if (!targetUid) {
    var regKey = roomName + "_" + cleanSender;
    var registry = {};
    try {
        var regFile = new java.io.File(REGISTRY_PATH);
        if (regFile.exists()) registry = JSON.parse(FileStream.read(REGISTRY_PATH));
        
        if (registry[regKey]) {
            targetUid = registry[regKey]; // 과거 코드가 있다면 즉시 부활
            globalData.nameToIdCache[cacheKey] = targetUid; // 캐시 복구
            Log.info("[Identity Restore] " + cleanSender + "님 신분 복구 완료.");
        }
    } catch(e) { Log.error("Registry Read Error"); }
}

// 3. [신규 생성] 진짜 신규 유저일 경우
if (!targetUid) {
    targetUid = generateUUID();
    globalData.nameToIdCache[cacheKey] = targetUid; // 신규 유저도 캐시 등록
    
    // 명부 자동 등록
    try {
        var regKey = roomName + "_" + cleanSender;
        var regFile = new java.io.File(REGISTRY_PATH);
        var registry = regFile.exists() ? JSON.parse(FileStream.read(REGISTRY_PATH)) : {};
        registry[regKey] = targetUid;
        FileStream.write(REGISTRY_PATH, JSON.stringify(registry));
        Log.info("[Registry Auto-Sync] " + cleanSender + "님 신규 등록.");
    } catch(e) {}
}

// [C] UID는 확보되었으나 실제 게임 데이터(Object)가 없는 경우 초기화 실행
if (!roomData.users[targetUid]) {
// 1. 기초 유저 객체 생성 및 스키마 적용
    var newUser = { uid: targetUid, name: cleanSender, imageHash: currentImgHash, lastDate: "" };

    USER_SCHEMA.forEach(function(item) {
        newUser[item.key] = item.default;
    });

    roomData.users[targetUid] = newUser;

    // 2. 게이트웨이를 통한 공식 보너스 지급 (로그 기록 보장)
    if (typeof util_updatePoint === 'function') {
        util_updatePoint(roomData.users[targetUid], roomData, 100000, "입장 축하 보너스", roomName);
    }
    
    uidCache[cacheKey] = targetUid;
    
    var welcomeTitle = isIdentityRecovered ? "🎊 [" + cleanSender + "]님 신분 복구 완료!" : "🎊 [" + cleanSender + "]님 환영합니다!";
    var welcomeSub = isIdentityRecovered ? "🛡️ 영구 명부에서 과거 고유 코드를 찾아 연결했습니다." : "🎁 입장 축하 보너스: " + fP(100000) + "P 지급!";
    
    var welcomeMsg = welcomeTitle + "\n━━━━━━━━━━━━━━━\n" +
                     welcomeSub + "\n" +
                     "🕹️ 미니게임 및 출석체크 기능 제공\n" +
                     "💳 신용 등급: 4등급 (600점) 부여\n\n" + 
                     "📖 이용 전 반드시 '/도움말'을 확인해주세요!";
                     
    replier.reply(welcomeMsg); 
    safeSaveData(data);
}

//==========섹터20-2==========

user = roomData.users[targetUid];

if (msg === "줍기") {
    var rFeatures = roomData.features;
    if (rFeatures && rFeatures.sprinkleData && rFeatures.sprinkleData.active) {
        if (typeof _gameActionLogic_Part3 === 'function') {
            _gameActionLogic_Part3(msg, user, data, replier, roomName, targetUid);
            return; // 줍기 처리 시 로직 종료하여 가드 우회 및 하단 로직 중복 방지
        }
    }
}

/* [수정] 데이터 구조 보정 및 초기화 */
if (!user.inventory) user.inventory = [];
if (user.tierGuard === undefined) user.tierGuard = 0;
if (user.gameAuthCount === undefined) user.gameAuthCount = 0;
if (user.purchasedAuthCount === undefined) user.purchasedAuthCount = 0;

/* [신규: Gemini 요청 사항] 경고삭제권 구매 여부 필드 마이그레이션 */
if (user.boughtWarningRemoval === undefined) user.boughtWarningRemoval = false;

/* [개편] 랜덤박스 시스템 관련 변수 안전 초기화 및 자동 마이그레이션 */
if (user.boxFragments === undefined) user.boxFragments = 0;
if (user.boxTickets === undefined) user.boxTickets = 0;

// 1. 기록장(collectedIcons)이 없으면 생성
if (user.collectedIcons === undefined) {
    user.collectedIcons = [];
}

// 2. [Gemini 요청 사항] 기존 보유 아이콘 기록 자동 마이그레이션
// 가방에 있는 아이콘들을 전수 조사하여 한 번이라도 뽑은 기록에 자동 등록합니다.
if (user.inventory && user.inventory.length > 0) {
    user.inventory.forEach(function(it) {
        if (it.effect === "icon" && user.collectedIcons.indexOf(it.icon) === -1) {
            user.collectedIcons.push(it.icon);
        }
    });
}

/* [핵심] 강제 추심 플래그 초기화 및 보정 */
if (user.isTransferred === undefined) user.isTransferred = false;

/* [기능] 기존 아이콘 및 칭호 가방 자동 마이그레이션 */
if (user.inventory) {
    // 1. 아이콘 마이그레이션
    if (user.icon && user.icon !== "") {
        var hasIconInInv = false;
        for (var j = 0; j < user.inventory.length; j++) {
            if (user.inventory[j].icon === user.icon) { hasIconInInv = true; break; }
        }
        if (!hasIconInInv) {
            for (var k = 0; k < SHOP_ITEMS.length; k++) {
                if (SHOP_ITEMS[k].effect === "icon" && SHOP_ITEMS[k].icon === user.icon) {
                    user.inventory.push({
                        id: SHOP_ITEMS[k].id, name: SHOP_ITEMS[k].name, icon: SHOP_ITEMS[k].icon,
                        effect: "icon", title: ""
                    });
                    // 마이그레이션 시 기록장에도 동시 등록
                    if (user.collectedIcons.indexOf(user.icon) === -1) user.collectedIcons.push(user.icon);
                    break;
                }
            }
        }
    }
    
    // 2. 칭호 마이그레이션 (누락분 추가)
    if (user.title && user.title !== "") {
        var hasTitleInInv = false;
        for (var j = 0; j < user.inventory.length; j++) {
            if (user.inventory[j].title === user.title) { hasTitleInInv = true; break; }
        }
        if (!hasTitleInInv) {
            for (var k = 0; k < SHOP_ITEMS.length; k++) {
                if (SHOP_ITEMS[k].effect === "title" && SHOP_ITEMS[k].title === user.title) {
                    user.inventory.push({
                        id: SHOP_ITEMS[k].id, name: SHOP_ITEMS[k].name, icon: SHOP_ITEMS[k].icon || "",
                        effect: "title", title: SHOP_ITEMS[k].title
                    });
                    break;
                }
            }
        }
    }
}

var today = getSimpleDate();
user.point = Number(user.point || 0);

/* 민생지원금 즉시 체크 */
if (user && user.lastDate !== today) {
    checkEconomicStimulus(user, roomName, false);
}

/* [신규] 기존 예금자 이자 엔진 강제 활성화 */
// 예금은 있는데 기준 시간이 0인 경우, 지금 이 순간부터 이자가 쌓이도록 기준점 설정
if (user.bank > 0 && (!user.lastBankUpdateTime || user.lastBankUpdateTime === 0)) {
    user.lastBankUpdateTime = Date.now();
}

/**
 * [독립형 함수] 중복 유저 선택 처리 엔진
 * 설명: 닉네임 검색 시 중복 발생 건에 대한 유저의 숫자 선택을 처리합니다.
 */
function _handleSelectionLogic(msg, user, data, replier, roomName, targetUid) {
    var roomData = data.rooms[roomName];
    if (!roomData || !roomData.features || !roomData.features.states.selectWait) return false;

    var selectWaitState = roomData.features.states.selectWait;
    if (!selectWaitState[targetUid]) return false;

    // 1. 시간 초과 체크 (30초)
    if (Date.now() - selectWaitState[targetUid].timestamp > 30000) {
        delete selectWaitState[targetUid];
        return false;
    } 

    // 2. 취소 처리
    if (msg === "취소") {
        delete selectWaitState[targetUid];
        replier.reply(formatCommand("🚫 선택 취소", user, "작업이 취소되었습니다."));
        return true;
    }

    // 3. 숫자 선택 및 로직 실행
    var choice = parseInt(msg.replace(/[^0-9]/g, ""));
    if (!isNaN(choice) && choice >= 1 && choice <= selectWaitState[targetUid].results.length) {
        var state = selectWaitState[targetUid];
        var selected = state.results[choice - 1];
        var type = state.type;
        var extra = state.extra;
        var targetUser = selected.data;
        
        delete selectWaitState[targetUid]; // 선택 완료 시 세션 삭제

        // 주식 중복 선택 처리 분기
        if (type === "stock_buy" || type === "stock_sell") {
            var stockName = selected; // 주식은 selected 자체가 종목명(String)
            var cmdPrefix = (type === "stock_buy") ? "/매수 " : "/매도 ";
            // 기존 주식 로직으로 리다이렉트하여 거래 집행
            _gameStockLogic(cmdPrefix + stockName + " " + extra.amount, user, data, replier, roomName, targetUid);
            return true;
        }

        if (type === "info") {
            var cr = getCreditInfo(targetUser.creditScore);
            var info = "💰 포인트: " + fp(targetUser.point) + "P\n🏦 예금: " + fp(targetUser.bank) + "P\n💳 신용: " + cr.label + " (" + targetUser.creditScore + "점)\n🏅 티어: " + TIERS[targetUser.tier];
            replier.reply(formatCommand("🔍 유저 상세 정보", targetUser, info, null));
        }
        else if (type === "transfer") {
            if (selected.id === targetUid) return replier.reply(formatError(user, "송금 불가", "자기 자신에게는 송금할 수 없습니다."));
            util_updatePoint(user, roomData, -extra.amount, "송금 보냄", roomName);
            var res = processRepayment(targetUser, extra.amount, selected.id, roomName);
            util_updatePoint(targetUser, roomData, Number(res.actualGain), "송금 받음", roomName);
            replier.reply(formatCommand("💸 송금 완료", user, getDisplayName(targetUser) + "님께 " + fp(extra.amount) + "P 보냈습니다.", "내 잔액: " + fp(user.point) + "P"));
        }
        else if (type === "admin_userdata") { 
            replier.reply(formatAdmin("유저 데이터 조회", JSON.stringify(targetUser, null, 2))); 
        }
        else if (type === "admin_point_give") {
            util_updatePoint(targetUser, roomData, extra.amount, "관리자 지급", roomName);
            replier.reply(formatAdmin("포인트 지급 완료", getDisplayName(targetUser) + "님: +" + fp(extra.amount) + "P\n(현재: " + fp(targetUser.point) + "P)"));
        }
        else if (type === "admin_point_take") {
            util_updatePoint(targetUser, roomData, -extra.amount, "관리자 차감", roomName);
            replier.reply(formatAdmin("포인트 차감 완료", getDisplayName(targetUser) + "님 차감 처리됨"));
        }
        else if (type === "admin_attend_edit") {
            targetUser.totalAttendance = extra.days;
            replier.reply(formatAdmin("출석 수정 완료", getDisplayName(targetUser) + "님: " + extra.days + "일"));
        }
        else if (type === "admin_credit_edit") {
            var oldScore = Number(targetUser.creditScore || 600);
            targetUser.creditScore = Math.min(1000, Math.max(0, oldScore + extra.score));
            if (typeof checkAndHandleDefaulter === 'function') checkAndHandleDefaulter(targetUser, roomName);
            var crInfo = getCreditInfo(targetUser.creditScore);
            replier.reply(formatAdmin("⚙️ 신용 점수 조정 완료", "대상: " + getDisplayName(targetUser) + "\n변동: " + extra.score + "점\n현재: " + targetUser.creditScore + "점 (" + crInfo.label + ")"));
        }
        else if (type === "admin_title_take") {
            var titleToTake = extra.title;
            var inv = targetUser.inventory || [];
            var removed = false;
            targetUser.inventory = inv.filter(function(it) {
                if (it.effect === "title" && (it.title === titleToTake || it.name.indexOf(titleToTake) !== -1)) {
                    removed = true; return false;
                }
                return true;
            });
            if (targetUser.title === titleToTake) { targetUser.title = ""; removed = true; }
            if (removed) {
                replier.reply(formatAdmin("🎖️ 칭호 회수 완료", getDisplayName(targetUser) + "님에게서 [" + titleToTake + "] 칭호를 박탈했습니다."));
            } else {
                replier.reply(formatAdmin("회수 실패", getDisplayName(targetUser) + "님은 해당 칭호를 보유하고 있지 않습니다."));
            }
        }
        else if (type === "admin_delete") {
            var tName = targetUser.name;
            var targetId = selected.id;
            var refundLog = "";
            var refundCount = 0;
            var totalRefunded = 0;
            if (roomData.loanContracts) {
                for (var cid in roomData.loanContracts) {
                    var c = roomData.loanContracts[cid];
                    if (c.borrowerUid === targetId) {
                        var lender = roomData.users[c.lenderUid];
                        if (lender) {
                            var debtAmt = Number(c.currentDebt);
                            util_updatePoint(lender, roomData, debtAmt, "사채 강제 정산", roomName);
                            totalRefunded += debtAmt;
                            refundCount++;
                            try { Api.replyRoom(roomName, "🚬 [사채 강제 정산]\n" + tName + "님의 데이터 삭제로 인해 " + lender.name + "님께 미수금 " + fp(debtAmt) + "P가 전액 반환되었습니다."); } catch(e){}
                        }
                        delete roomData.loanContracts[cid];
                    }
                }
            }
            if (targetUser.loan && Number(targetUser.loan.debt) > 0) {
                var bankDebt = Number(targetUser.loan.debt);
                util_updateReserve(roomData, bankDebt, "대출금 국고 회수", roomName);
                refundLog += "\n\n🏦 은행 대출금 " + fp(bankDebt) + "P가 국고로 자동 회수되었습니다.";
            }
            if (refundCount > 0) refundLog += "\n⚠️ 사채 보전 완료: " + refundCount + "건 (" + fp(totalRefunded) + "P)";
            if (typeof uidCache !== 'undefined') {
                for (var key in uidCache) { if (uidCache[key] === targetId) delete uidCache[key]; }
            }
            delete roomData.users[targetId];
            try {
                var regFile = new java.io.File(REGISTRY_PATH);
                if (regFile.exists()) {
                    var regData = JSON.parse(FileStream.read(REGISTRY_PATH));
                    delete regData[roomName + "_" + tName];
                    FileStream.write(REGISTRY_PATH, JSON.stringify(regData));
                }
            } catch (e) { Log.error("Registry Delete Error: " + e); }
            replier.reply(formatAdmin("유저 삭제 완료", "[" + tName + "]님의 데이터를 영구 삭제했습니다." + refundLog));
        }
        else if (type === "admin_attend_reset") {
            targetUser.lastDate = "";
            replier.reply(formatAdmin("출석 초기화", getDisplayName(targetUser) + "님의 오늘 출석 기록을 삭제했습니다."));
        }
        else if (type === "user_restore") {
            // [Gemini 수정] 중복 선택 시에도 스마트 복구 로직(v5.9.1) 적용
            var stablePath = BASE_DIR + "backup/last_stable_backup.json";
            var stableFile = new java.io.File(stablePath);

            if (!stableFile.exists() || stableFile.length() === 0) {
                replier.reply(formatAdmin("🚫 복구 실패", "안전 백업 파일(last_stable_backup.json)을 찾을 수 없습니다."));
                return true;
            }

            try {
                // 1. 소스 코드 결정 (입력된 UUID가 있으면 그것을, 없으면 선택된 유저의 ID를 사용)
                var sourceCode = (extra && extra.sourceCode) ? extra.sourceCode : selected.id;
                var targetId = selected.id;
                var fullNick = selected.data.name; // 현재 방에 존재하는 정확한 풀네임

                var backupContent = FileStream.read(stablePath);
                var backupData = JSON.parse(backupContent);
                var rawBackupUser = null;

                // 2. 백업본에서 소스 데이터 탐색
                for (var r in backupData.rooms) {
                    if (backupData.rooms[r].users[sourceCode]) {
                        rawBackupUser = backupData.rooms[r].users[sourceCode];
                        break;
                    }
                }

                if (!rawBackupUser) throw new Error("백업본에 해당 데이터(ID:" + sourceCode + ")가 없습니다.");

                // 3. 데이터 이식 및 동기화
                var backupUser = JSON.parse(JSON.stringify(rawBackupUser));
                var schema = { chatLog: [], inventory: [], stockHoldings: {}, stockAvg: {}, point: 50000 };
                for (var key in schema) { if (backupUser[key] === undefined) backupUser[key] = schema[key]; }

                // [동기화] 이름은 현재 방의 풀네임으로 유지
                backupUser.name = fullNick;
                roomData.users[targetId] = backupUser;

                safeSaveData(data, false);
                if (typeof globalData !== 'undefined') globalData = data;

                // 4. 결과 출력 (신형 포맷)
                replier.reply(formatAdmin("✅ 데이터 정밀 이관 완료",
                    "현재 대상: " + fullNick + "\n" +
                    "식별 모드: 간략화 검색 지원\n" +
                    "━━━━━━━━━━━━━━━\n" +
                    "💰 최종 복구 잔액: " + fp(backupUser.point) + "P\n\n" +
                    "💡 전체 닉네임과의 동기화가 완료되어 즉시 사용 가능합니다."));

            } catch (e) {
                replier.reply(formatAdmin("🚫 복구 중단", "복구 처리 중 오류가 발생했습니다.\n사유: " + e.message));
                Log.error("Select Restore Error: " + e);
            }
        }
        else if (type === "admin_nick_log") {
            var hist = data.nickHistory[selected.id] || [];
            if (hist.length === 0) {
                replier.reply(formatAdmin("닉네임 기록", getDisplayName(targetUser) + "님은 변경 이력이 없습니다."));
            } else {
                var logMsg = [];
                for(var i=0; i<hist.length; i++) logMsg.push((i+1) + ". " + hist[i].old + " (" + hist[i].date + ")");
                replier.reply(formatAdmin("📋 닉네임 변경 이력", "현재: " + targetUser.name + "\n\n[과거 기록]\n" + logMsg.join("\n")));
            }
        }

else if (type === "admin_reg_delete") {
            // 명부 강제 삭제 타입 처리 로직 추가
            var targetKey = selected.id; // handleUserSelection에서 넘겨준 regKey
            var targetFullNick = selected.data.name;
            
            try {
                var regFile = new java.io.File(REGISTRY_PATH);
                if (regFile.exists()) {
                    var regData = JSON.parse(FileStream.read(REGISTRY_PATH));
                    delete regData[targetKey];
                    FileStream.write(REGISTRY_PATH, JSON.stringify(regData));
                    replier.reply(formatAdmin("명부 삭제 완료", "찾은 유저: [" + targetFullNick + "]\n관련 식별 코드를 명부에서 파기했습니다."));
                }
            } catch (e) { Log.error("Registry Delete Error: " + e); }
        }

        safeSaveData(data);
        return true; // 로직 처리 완료
    }
    return false;
}

//==========섹터21==========

/**
 * [독립형 함수] 로또 번호 입력 처리 엔진
 */
function _handleLottoInput(msg, user, data, replier, roomName, targetUid) {
    var roomData = data.rooms[roomName];
    if (!roomData || !roomData.features) return false;

    // 방별 독립 상태 저장소 참조
    var lottoPurchaseState = roomData.features.states.lottoPurchase;
    
    // 현재 유저가 로또 구매 대기 중인지 확인
    if (!lottoPurchaseState || !lottoPurchaseState[targetUid]) return false;

    // 1. 시간 초과 및 취소 가드
    if (Date.now() - lottoPurchaseState[targetUid].time > 30000) {
        delete lottoPurchaseState[targetUid];
        replier.reply(formatError(user, "시간 초과", "30초가 지나 구매가 자동 취소되었습니다."));
        return true;
    }
    if (msg === "취소") {
        delete lottoPurchaseState[targetUid];
        replier.reply(formatCommand("🚫 구매 취소", user, "로또 구매가 취소되었습니다."));
        return true;
    }

    // 2. 활동 상태 검증
    var stateRes = util_checkUserState(user, targetUid, roomName);
    if (!stateRes.canAction) {
        delete lottoPurchaseState[targetUid];
        replier.reply(formatError(user, "구매 불가", stateRes.reason));
        return true;
    }

    // 3. 번호 파싱
    var rawNums = msg.match(/\d+/g);
    if (!rawNums || rawNums.length !== 3) {
        replier.reply(formatError(user, "입력 오류", "숫자 3개를 입력해주세요.\n예) 1 5 10"));
        return true;
    }
    
    var nums = rawNums.map(Number).sort(function(a, b) { return a - b; });
    var isInvalid = (nums[0] === nums[1] || nums[1] === nums[2] || nums[0] === nums[2]);
    for (var i = 0; i < 3; i++) { if (nums[i] < 1 || nums[i] > 15) isInvalid = true; }
    
    if (isInvalid) {
        replier.reply(formatError(user, "번호 오류", "1~15 사이의 중복 없는 숫자 3개를 입력하세요."));
        return true;
    }

    // 4. 가격 확인 및 잔액 체크
    var lottoPrice = (lottoPurchaseState[targetUid].price !== undefined) ? lottoPurchaseState[targetUid].price : 2000;
    if (Number(user.point) < lottoPrice) {
         delete lottoPurchaseState[targetUid];
         replier.reply(formatError(user, "잔액 부족", fp(lottoPrice) + "P가 필요합니다."));
         return true;
    }

    // 5. 로또 데이터 등록
    var lotto = roomData.features.lotto;
    if (!lotto.entries) lotto.entries = {};
    if (!lotto.entries[targetUid]) lotto.entries[targetUid] = [];

    lotto.entries[targetUid].push(nums);
    lotto.dailyPool = (Number(lotto.dailyPool) || 0) + lottoPrice;

    // 6. 결제 및 완료
    var prePoint = Number(user.point);
    util_updatePoint(user, roomData, -lottoPrice, "로또 구매", roomName);
    var actualDeducted = prePoint - Number(user.point);

    delete lottoPurchaseState[targetUid];
    
    replier.reply(formatCommand("🎫 로또 구매 완료", user, 
        "선택 번호: [" + nums.join(", ") + "]\n" +
        "차감 금액: " + fp(actualDeducted) + "P\n" +
        "추첨 시간: 매일 밤 22:00", 
        "내 잔액: " + fP(user.point) + "P"
    ));

    safeSaveData(data);
    return true; 
}

/* [채팅 보너스 로직 분리] - 섹터 21 하단에 추가 */
function _runChatBonusLogic(msg, user, data, replier, roomName, targetUid) {
    if (msg.indexOf("/") !== 0) {
        user.chatCount = (user.chatCount || 0) + 1;
        user.chatCycleCount = (user.chatCycleCount || 0) + 1;
        
        if (user.chatCycleCount > 13 || !user.chatBonusTarget) {
            user.chatCycleCount = 1; 
            user.chatBonusTarget = Math.floor(Math.random() * 12) + 1;
            user.chatBonusGiven = false; 
        }
        
        if (user.chatCycleCount >= user.chatBonusTarget && !user.chatBonusGiven) {
            // [v5.9] 통합 상태 가드
            var stateRes = util_checkUserState(user, targetUid, roomName);
            if (!stateRes.canAction && stateRes.reason.indexOf("징역") !== -1) return;

            var multiplier = util_getEcoMultiplier(roomName);
            var basePrize = Math.floor(Math.random() * 201) + 300;
            var prize = Math.floor(basePrize * multiplier);
            
            var res = processRepayment(user, prize, targetUid, roomName);
            util_updatePoint(user, data.rooms[roomName], Number(res.actualGain), "채팅 보너스", roomName);

            user.creditScore = Math.min(1000, Number(user.creditScore || 600) + 1);
            
            var output = "🎁 채팅 보너스\n━━━━━━━━━━━━━━━\n" + getDisplayName(user) + "님\n" + fp(prize) + "P를 획득했습니다!" + (res.repayMsg ? res.repayMsg : "") + "\n━━━━━━━━━━━━━━━";
            replier.reply(output + "\n내 잔액: " + fP(user.point) + "P");
            
            user.chatBonusGiven = true; 
        }
    }
}

//==========섹터22-1==========

/* [독립형 함수] 통합 업무 처리 핸들러 1단계: 송금, 예금 및 기부 */
function _handleBankStep1(msg, user, data, replier, roomName, targetUid) {
    var bankProcessState = data.rooms[roomName].features.states.bankProcess;
    if (!bankProcessState || !bankProcessState[targetUid]) return false;

    var state = bankProcessState[targetUid];
    var types = ['transfer', 'deposit', 'donate'];
    if (types.indexOf(state.type) === -1) return false; // 내 담당 업무가 아니면 패스

    // 1. 공통 가드 (시간 초과 및 취소)
    if (Date.now() - state.time > 30000) {
        delete bankProcessState[targetUid];
        replier.reply(formatError(user, "시간 초과", "입력 시간이 30초를 초과하여 업무가 자동 취소되었습니다."));
        return true;
    }
    if (msg === "취소") {
        delete bankProcessState[targetUid];
        replier.reply(formatCommand("🚫 업무 취소", user, "요청하신 업무가 취소되었습니다."));
        return true;
    }
    if (msg.startsWith("/")) return false; // 명령어는 흘려보냄

    // 2. 스마트 가드 (징역)
    if (user.jailReleaseTime && Date.now() < user.jailReleaseTime) {
        delete bankProcessState[targetUid];
        var diff = user.jailReleaseTime - Date.now();
        var remainMin = Math.ceil(diff / (1000 * 60));
        replier.reply(formatError(user, "업무 불가", "현재 징역 중입니다. (" + remainMin + "분 남음)"));
        return true;
    }

    var roomData = data.rooms[roomName];
    if (roomData.bankReserve === undefined) roomData.bankReserve = SYSTEM_CONFIG.ECO.BANK.INITIAL_RESERVE;

    /* [기능 1] 송금 처리 */
    if (state.type === 'transfer') {
        var ps = msg.split(" ");
        if (ps.length < 2) {
            replier.reply(formatError(user, "입력 오류", "형식: [닉네임] [금액]"));
            return true;
        }
        var am = parseInt(ps.pop().replace(/,/g, ""));
        var tn = ps.join(" ").trim();
        var found = findUserByName(roomData, tn);

        if (found.length === 0) {
            replier.reply(formatError(user, "대상 없음", "[" + tn + "]님을 찾을 수 없습니다."));
        } else if (found.length > 1) {
            handleUserSelection(replier, targetUid, found, "transfer", { amount: am }, user, roomName);
            delete bankProcessState[targetUid];
        } else if (found[0].id === targetUid) {
            replier.reply(formatError(user, "본인 송금 불가", "자신에게는 보낼 수 없습니다."));
        } else if (isNaN(am) || am <= 0) {
            replier.reply(formatError(user, "금액 오류", "정확한 숫자를 입력하세요."));
        } else if (user.point < am) {
            replier.reply(formatError(user, "잔액 부족", "보유 포인트가 부족합니다."));
        } else {
            var rc = found[0].data;
            util_updatePoint(user, roomData, -am, "송금 보냄", roomName);
            var res = processRepayment(rc, am, found[0].id, roomName);
            util_updatePoint(rc, roomData, Number(res.actualGain), "송금 받음", roomName);
            replier.reply(formatCommand("💸 송금 완료", user, getDisplayName(rc) + "님께 " + fp(am) + "P를 보냈습니다." + res.repayMsg, "내 잔액: " + fp(user.point) + "P"));
            delete bankProcessState[targetUid];
            safeSaveData(data);
        }
        return true;
    }

        /* [기능 2] 예금 처리 */
    else if (state.type === 'deposit') {
        var amt = parseInt(msg.replace(/,/g, ""));
        if (isNaN(amt) || amt <= 0) {
            replier.reply(formatError(user, "금액 오류", "예금할 숫자를 입력하세요."));
        } else if (user.point < amt) {
            replier.reply(formatError(user, "포인트 부족", "보유하신 포인트보다 많습니다."));
        } else {
            util_updateBank(user, roomData, amt, "은행 예금", roomName);
            util_updatePoint(user, roomData, -amt, "은행 예금", roomName);
            replier.reply(formatCommand("💰 예금 완료", user, fp(amt) + "P를 통장에 입금했습니다.\n(중앙은행 가용 재원으로 편입됨)", "내 잔액: " + fp(user.point) + "P"));
            delete bankProcessState[targetUid];
            safeSaveData(data);
        }
        return true;
    }

        /* [기능 3] 기부 처리 */
    else if (state.type === 'donate') {
        var amt = parseInt(msg.replace(/,/g, ""));
        if (isNaN(amt) || amt <= 0) {
            replier.reply(formatError(user, "금액 오류", "기부할 금액을 숫자로 정확히 입력하세요."));
        } else if (user.point < amt) {
            replier.reply(formatError(user, "잔액 부족", "보유하신 포인트보다 많은 금액은 기부할 수 없습니다."));
        } else {
            var replierStub = { reply: function(m) { Api.replyRoom(roomName, m); } };
            util_updatePoint(user, roomData, -amt, "은행 기부", roomName);
            var nextDonation = (user.totalDonation || 0) + amt;
            util_setData(user, 'totalDonation', nextDonation, "기부금 누적", roomName);
            
            // 기부 칭호 체크
            var donation = user.totalDonation;
            
          if (donation >= 2000000) {
                util_checkAndAwardTitle(user, replierStub, "기부왕", 5004, "👑", "내리다 사회복지 협의회", "누적 기부 금액 " + fp(2000000) + "P", "[장착 효과]: 은행 대출 이용 시 매일 발생하는 채무 이자가 30% 감면됩니다.", roomName);
            } else if (donation >= 1000000) {
                util_checkAndAwardTitle(user, replierStub, "자선가", 5003, "✨", "내리다 사회복지 협의회", "누적 기부 금액 " + fp(1000000) + "P", "사회 전반에 걸쳐 선한 영향력을 널리 퍼뜨리고 있습니다.", roomName);
            } else if (donation >= 700000) {
                util_checkAndAwardTitle(user, replierStub, "기부천사", 5002, "👼", "내리다 사회복지 협의회", "누적 기부 금액 " + fp(700000) + "P", "어려운 이들에게 희망의 빛을 선사했습니다.", roomName);
            } else if (donation >= 300000) {
                util_checkAndAwardTitle(user, replierStub, "선한손길", 5001, "🌱", "내리다 사회복지 협의회", "누적 기부 금액 " + fp(300000) + "P", "당신의 따뜻한 마음이 사회의 소중한 밀알이 됩니다.", roomName);
            }

                var thanksMsg = "중앙은행에 " + fp(amt) + "P를 기부하셨습니다.\n" +
                                "보내주신 소중한 자산은 국가 경제 위기 극복과 \n" +
                                "전체 유저 복지 향상을 위해 귀하게 사용됩니다.\n" +
                                "따뜻한 마음에 진심으로 감사드립니다!\n\n" +
                                "🏦 [국고 입고]: 기부금이 중앙은행 재원으로 귀속됨\n" +
                                "📊 누적 기부액: " + fp(donation) + "P";

                replier.reply(formatCommand("🎁 기부 완료", user, thanksMsg, "(현재 잔액: " + fp(user.point) + "P)"));
                delete bankProcessState[targetUid];
                safeSaveData(data)
            }
        return true;
    }
    return false;
}
            
//==========섹터22-2==========

/* [독립형 함수] 통합 업무 처리 핸들러 2단계: 출금, 대출, 상환 */
function _handleBankStep2(msg, user, data, replier, roomName, targetUid) {
    var bankProcessState = data.rooms[roomName].features.states.bankProcess;
    if (!bankProcessState || !bankProcessState[targetUid]) return false;

    var state = bankProcessState[targetUid];
    var types = ['withdraw', 'loan', 'repay'];
    if (types.indexOf(state.type) === -1) return false;

    // 공통 가드
    if (Date.now() - state.time > 30000) {
        delete bankProcessState[targetUid];
        replier.reply(formatError(user, "시간 초과", "입력 시간이 30초를 초과하여 은행 업무가 자동 취소되었습니다."));
        return true;
    }
    if (msg === "취소") {
        delete bankProcessState[targetUid];
        replier.reply(formatCommand("🚫 업무 취소", user, "요청하신 은행 업무가 취소되었습니다."));
        return true;
    }
    if (msg.startsWith("/")) return false;

    var roomData = data.rooms[roomName];
    if (roomData.bankReserve === undefined) roomData.bankReserve = SYSTEM_CONFIG.ECO.BANK.INITIAL_RESERVE;

    /* [기능 1] 출금 처리 */
    if (state.type === 'withdraw') {
        var amt = parseInt(msg.replace(/,/g, ""));
        if (isNaN(amt) || amt <= 0) {
            replier.reply(formatError(user, "금액 오류", "출금할 숫자를 정확히 입력하세요."));
        } else if (user.bank < amt) {
            replier.reply(formatError(user, "잔고 부족", "통장 잔고보다 많은 금액은 출금할 수 없습니다."));
        } else if (roomData.bankReserve < amt) {
            replier.reply(formatError(user, "은행 지급 불능", "죄송합니다. 현재 은행의 현금 유동성(실재고)이 부족하여 출금이 일시 제한됩니다.\n대출금 회수 및 수수료 적립 시까지 기다려주세요.\n\n🏦 현재 은행 금고: " + fp(roomData.bankReserve) + "P"));
        } else {
           // 1. 은행 잔고 감사 엔진 가동 (- 차감)
            util_updateBank(user, roomData, -amt, "은행 출금", roomName);
            
            // 2. 포인트 게이트웨이 가동 (+ 지급 및 국고 차감 연동)
            util_updatePoint(user, roomData, amt, "은행 출금", roomName);
            
            replier.reply(formatCommand("🏧 출금 완료", user, fp(amt) + "P를 현금으로 출금했습니다.", "보유 포인트: " + fp(user.point) + "P"));
            
            delete bankProcessState[targetUid]; // 상태 해제
            safeSaveData(data); // 즉시 저장
        }
        return true;
    }

        /* [기능 2] 대출 실행 */
    else if (state.type === 'loan') {
        var amt = parseInt(msg.replace(/,/g, ""));
        var cr = getCreditInfo(user.creditScore);
        var bConf = SYSTEM_CONFIG.ECO.BANK;
        var lConf = SYSTEM_CONFIG.ECO.PRIVATE_LOAN;

        var totalDeposits = 0;
        for (var id in roomData.users) { totalDeposits += (roomData.users[id].bank || 0); }
        var requiredReserve = Math.floor(totalDeposits * bConf.RESERVE_RATIO);
        var lendableAmount = roomData.bankReserve - requiredReserve;

        if (isNaN(amt) || amt <= 0) {
            replier.reply(formatError(user, "금액 오류", "대출받을 숫자를 입력하세요."));
        } else if (amt > lendableAmount) {
            var reserveInfo = "현재 은행의 대출 가능 한도를 초과했습니다.\n(지급준비율 " + (bConf.RESERVE_RATIO * 100) + "% 준수 중)\n\n" + "🏦 현재 금고: " + fp(roomData.bankReserve) + "P\n" + "🛡️ 법정 준비금: " + fp(requiredReserve) + "P\n" + "💰 실제 대출 가능액: " + fp(Math.max(0, lendableAmount)) + "P";
            replier.reply(formatError(user, "은행 자금 동결", reserveInfo));
        } else if ((user.dailyLoanCount || 0) >= lConf.DAILY_LIMIT) {
            delete bankProcessState[targetUid];
            replier.reply(formatError(user, "대출 제한", "대출은 하루에 최대 " + lConf.DAILY_LIMIT + "회까지만 가능합니다."));
        } else if (amt > cr.limit) {
            replier.reply(formatError(user, "한도 초과", cr.label + "의 최대 한도는 " + fp(cr.limit) + "P입니다."));
        } else {
            user.dailyLoanCount = (user.dailyLoanCount || 0) + 1;
            if (user.dailyLoanCount >= 2) {
                user.creditScore = Math.max(0, Number(user.creditScore || 600) - 20);
                checkAndHandleDefaulter(user, roomName);
            }
            /* [Gemini 요청 사항] 지능형 금리 엔진 연동 */
            var dynMult = 1.0;
            if (typeof util_getDynamicRateMultiplier === 'function') {
                dynMult = util_getDynamicRateMultiplier(roomName);
            }

            // [기부왕] 실행 시 선이자 30% 감면
            var rateGap = (cr.rate - 1) * dynMult;
            if (user.title === "기부왕") rateGap *= 0.7;
            var finalRate = 1 + rateGap;

            var total = Math.floor(amt * finalRate);
            if (!user.loan || typeof user.loan !== 'object') user.loan = { debt: 0, items: [] };
            if (!user.loan.items) user.loan.items = [];
            user.loan.debt = Number(user.loan.debt || 0) + Number(total);
            user.loan.items.push(Number(total));
            util_updatePoint(user, roomData, amt, "은행 대출 실행", roomName);
            replier.reply(formatCommand("🏦 대출 승인", user, fp(amt) + "P 입금 완료\n(상환 예정액: " + fp(total) + "P)\n\n🏛️ 남은 가용 재원: " + fp(roomData.bankReserve - requiredReserve) + "P", "보유 포인트: " + fp(user.point) + "P"));
            delete bankProcessState[targetUid];
            safeSaveData(data);
        }
        return true;
    }

        /* [기능 3] 상환 처리 */
    else if (state.type === 'repay') {
        var amt = parseInt(msg.replace(/,/g, ""));
        if (isNaN(amt) || amt <= 0) {
            replier.reply(formatError(user, "금액 오류", "상환할 숫자를 입력하세요."));
        } else if (user.point < amt) {
            replier.reply(formatError(user, "포인트 부족", "보유하신 포인트가 상환액보다 적습니다."));
        } else {
            var res = distributeRepayment(user, amt, roomName);
            util_updatePoint(user, roomData, -Number(res.actualRepay), "대출 상환", roomName);
            var currentDebt = (user.loan && user.loan.debt) ? Number(user.loan.debt) : 0;
            replier.reply(formatCommand("📉 상환 완료", user, fp(res.actualRepay) + "P 상환되었습니다.\n\n🏦 은행 재원 충전: +" + fp(res.actualRepay) + "P", "남은 대출금: " + fp(currentDebt) + "P"));
            delete bankProcessState[targetUid];
            safeSaveData(data);
        }
        return true;
    }
    return false;
}
            
//==========섹터22-3==========

/* [독립형 함수] 통합 업무 처리 핸들러 3단계: 사채 등록 및 빌리기 */
function _handleBankStep3(msg, user, data, replier, roomName, targetUid) {
    var bankProcessState = data.rooms[roomName].features.states.bankProcess;
    if (!bankProcessState || !bankProcessState[targetUid]) return false;

    var state = bankProcessState[targetUid];
    var types = ['p2p_reg_input', 'p2p_borrow_amt'];
    if (types.indexOf(state.type) === -1) return false;

    if (Date.now() - state.time > 30000) {
        delete bankProcessState[targetUid];
        replier.reply(formatError(user, "시간 초과", "입력 시간이 30초를 초과했습니다."));
        return true;
    }
    if (msg === "취소") {
        delete bankProcessState[targetUid];
        replier.reply(formatCommand("🚫 업무 취소", user, "업무가 취소되었습니다."));
        return true;
    }

    var roomData = data.rooms[roomName];

    /* [기능 1] 사채 등록 */
    if (state.type === 'p2p_reg_input') {
        var parts = msg.split(" ");
        if (parts.length < 2) {
            replier.reply(formatError(user, "입력 오류", "형식: [금액] [이율]\n예) 10000 5"));
        } else {
            var amt = parseInt(parts[0]);
            var rate = parseInt(parts[1]);
            var conf = SYSTEM_CONFIG.ECO.PRIVATE_LOAN;

            if (isNaN(amt) || amt < conf.MIN_AMOUNT) {
                replier.reply(formatError(user, "금액 오류", "최소 " + fp(conf.MIN_AMOUNT) + "P 이상 등록 가능합니다."));
            } else if (isNaN(rate) || rate < 5 || rate > conf.MAX_RATE) {
                replier.reply(formatError(user, "이율 오류", "이율은 5% ~ " + conf.MAX_RATE + "% 사이로 설정하세요."));
            } else if (user.point < amt) {
                replier.reply(formatError(user, "포인트 부족", "보유 포인트가 부족합니다."));
            } else {
                util_updatePoint(user, roomData, -amt, "사채 풀 등록", roomName);
                var poolId = generateUUID();
                if (!roomData.loanPools) roomData.loanPools = {};
                roomData.loanPools[poolId] = {
                    lenderUid: targetUid, lenderName: user.name, totalAmount: amt,
                    remainingAmount: amt, rate: rate, time: Date.now()
                };
                replier.reply(formatCommand("💰 사채 등록 완료", user, fp(amt) + "P (이자 " + rate + "%/3h) 매물을 올렸습니다.", "남은 잔액: " + fp(user.point) + "P"));
                delete bankProcessState[targetUid];
                safeSaveData(data);
            }
        }
        return true;
    }

        /* [기능 2] 사채 빌리기 */
    else if (state.type === 'p2p_borrow_amt') {
        var amt = parseInt(msg);
        var pool = roomData.loanPools[state.extra.poolId];
        var conf = SYSTEM_CONFIG.ECO.PRIVATE_LOAN;

        if (!pool) {
            replier.reply(formatError(user, "매물 정보 없음", "유효하지 않은 매물입니다."));
        } else if (isNaN(amt) || amt < conf.MIN_BORROW) {
            replier.reply(formatError(user, "금액 오류", "최소 " + fp(conf.MIN_BORROW) + "P 이상 빌려야 합니다."));
        } else if (amt > pool.remainingAmount) {
            replier.reply(formatError(user, "금액 초과", "잔여 금액(" + fp(pool.remainingAmount) + "P)까지만 가능합니다."));
        } else if (pool.lenderUid === targetUid) {
            replier.reply(formatError(user, "계약 불가", "본인 사채는 빌릴 수 없습니다."));
        } else {
            pool.remainingAmount -= amt;
            if (pool.remainingAmount <= 0) delete roomData.loanPools[state.extra.poolId];
            var initialDebt = Math.floor(amt * 1.1);
            var contractId = generateUUID();
            if (!roomData.loanContracts) roomData.loanContracts = {};
            roomData.loanContracts[contractId] = {
                lenderUid: pool.lenderUid, lenderName: pool.lenderName,
                borrowerUid: targetUid, borrowerName: user.name,
                principal: amt, currentDebt: initialDebt, rate: pool.rate,
                startTime: Date.now(), status: 'active'
            };
            util_updatePoint(user, roomData, amt, "사채 빌림 회수 승인", roomName);
            replier.reply(formatCommand("📝 사채 계약 체결", user, pool.lenderName + "님으로부터 " + fp(amt) + "P를 빌렸습니다.\n(선이자 10% 포함 채무: " + fp(initialDebt) + "P)", "내 잔액: " + fp(user.point) + "P"));
            delete bankProcessState[targetUid];
            safeSaveData(data);
        }
        return true;
    }
    return false;
}

//==========섹터22-4==========

/* [독립형 함수] 통합 업무 처리 핸들러 4단계: 사채 상환/회수/수거 */
function _handleBankStep4(msg, user, data, replier, roomName, targetUid) {
    var bankProcessState = data.rooms[roomName].features.states.bankProcess;
    if (!bankProcessState || !bankProcessState[targetUid]) return false;

    var state = bankProcessState[targetUid];
    var types = ['p2p_repay_amt', 'p2p_withdraw_amt', 'p2p_collect_manual'];
    if (types.indexOf(state.type) === -1) return false;

    if (Date.now() - state.time > 30000 || msg === "취소") {
        delete bankProcessState[targetUid];
        if (msg === "취소") replier.reply(formatCommand("🚫 업무 취소", user, "업무가 취소되었습니다."));
        else replier.reply(formatError(user, "시간 초과", "입력 시간이 초과되었습니다."));
        return true;
    }

    var roomData = data.rooms[roomName];

    /* [기능 1] 사채 상환 */
    if (state.type === 'p2p_repay_amt') {
        var amt = parseInt(msg);
        var contract = roomData.loanContracts[state.extra.contractId];
        if (!contract) {
            replier.reply(formatError(user, "계약 정보 없음"));
        } else if (isNaN(amt) || amt <= 0 || user.point < amt) {
            replier.reply(formatError(user, "금액/포인트 오류"));
        } else {
            var actualRepay = Math.min(amt, contract.currentDebt);
            util_updatePoint(user, roomData, -actualRepay, "사채 상환 지불", roomName);
            var lender = roomData.users[contract.lenderUid];
            if (lender) util_updatePoint(lender, roomData, actualRepay, "사채 이자 수입", roomName);
            
            contract.currentDebt -= actualRepay;
            var footerMsg = "남은 빚: " + fp(contract.currentDebt) + "P";
            if (contract.currentDebt <= 0) {
                delete roomData.loanContracts[state.extra.contractId];
                footerMsg = "모든 채무가 변제되었습니다.";
            }
            replier.reply(formatCommand("📉 사채 상환 완료", user, contract.lenderName + "님께 " + fp(actualRepay) + "P를 갚았습니다.\n" + footerMsg, "내 잔액: " + fp(user.point) + "P"));
            delete bankProcessState[targetUid];
            safeSaveData(data);
        }
        return true;
    }

        /* [기능 2] 사채 매물 회수 */
    else if (state.type === 'p2p_withdraw_amt') {
        var amt = (msg === "전액") ? state.extra.max : parseInt(msg);
        var pool = roomData.loanPools[state.extra.poolId];
        if (!pool) {
            replier.reply(formatError(user, "매물 정보 없음"));
        } else if (isNaN(amt) || amt <= 0 || amt > pool.remainingAmount) {
            replier.reply(formatError(user, "금액 오류"));
        } else {
            pool.remainingAmount -= amt;
            util_updatePoint(user, roomData, amt, "사채 풀 직접 수거", roomName);
            if (pool.remainingAmount <= 0) delete roomData.loanPools[state.extra.poolId];
            replier.reply(formatCommand("✅ 사채 회수 완료", user, fp(amt) + "P를 회수했습니다.", "내 잔액: " + fp(user.point) + "P"));
            delete bankProcessState[targetUid];
            safeSaveData(data);
        }
        return true;
    }

        /* [기능 3] 채무자 강제 수거 */
    else if (state.type === 'p2p_collect_manual') {
        var contract = roomData.loanContracts[state.extra.contractId];
        if (!contract) {
            replier.reply(formatError(user, "계약 정보 없음"));
        } else {
            var debtor = roomData.users[contract.borrowerUid];
            if (!debtor) {
                replier.reply(formatError(user, "채무자 정보 없음"));
            } else {
                var collectAmt = Math.min(Number(debtor.point), contract.currentDebt);
                if (collectAmt <= 0) {
                    replier.reply(formatError(user, "수거 실패", "채무자의 지갑이 비어있습니다."));
                } else {
                    util_updatePoint(debtor, roomData, -collectAmt, "사채 강제 수거 당함", roomName);
                    util_updatePoint(user, roomData, collectAmt, "사채 직접 수거 수익", roomName);
                    contract.currentDebt -= collectAmt;
                    var footer = "남은 빚: " + fp(contract.currentDebt) + "P";
                    if (contract.currentDebt <= 0) {
                        delete roomData.loanContracts[state.extra.contractId];
                        footer = "모든 채무가 변제되었습니다.";
                    }
                    replier.reply(formatCommand("🚬 강제 수거 완료", user, debtor.name + "님에게서 " + fp(collectAmt) + "P를 수거했습니다.\n" + footer, "내 잔액: " + fp(user.point) + "P"));
                    safeSaveData(data);
                }
            }
        }
        delete bankProcessState[targetUid];
        return true;
    }
    return false;
}

//==========섹터22-5==========

/* [독립형 함수] 통합 업무 처리 핸들러 5단계: 상점 아이템 구매 및 수량 처리 */
function _handleBankStep5(msg, user, data, replier, roomName, targetUid) {
    var bankProcessState = data.rooms[roomName].features.states.bankProcess;
    if (!bankProcessState || !bankProcessState[targetUid]) return false;

    var state = bankProcessState[targetUid];
    var types = ['shop_buy', 'shop_quantity'];
    if (types.indexOf(state.type) === -1) return false;

    // 1. 공통 가드 (시간 초과 및 취소)
    if (Date.now() - state.time > 30000 || msg === "취소") {
        delete bankProcessState[targetUid];
        if (msg === "취소") replier.reply(formatCommand("🚫 업무 취소", user, "업무가 취소되었습니다."));
        else replier.reply(formatError(user, "시간 초과", "입력 시간이 초과되었습니다."));
        return true;
    }
    if (msg.startsWith("/")) {
        delete bankProcessState[targetUid];
        return false;
    }

    var roomData = data.rooms[roomName];

    /* [기능 1] 상점 아이템 번호 선택 처리 */
    if (state.type === 'shop_buy') {
        var idx = parseInt(msg.replace(/[^0-9]/g, "")) - 1;
        var filteredItems = (state.extra && state.extra.items) ? state.extra.items : [];

        if (isNaN(idx) || idx < 0 || idx >= filteredItems.length) {
            replier.reply(formatError(user, "번호 오류", "목록에 있는 번호를 입력해주세요."));
        } else {
            var item = filteredItems[idx];

            /* 예외 처리 1: 신용 점수 회복제 일일 제한 */
            if (item.effect === "credit" && (user.dailyCreditRestoreCount || 0) >= 1) {
                delete bankProcessState[targetUid];
                replier.reply(formatError(user, "구매 제한", "신용 점수 회복제는 하루에 1개만 사용 가능합니다."));
                return true;
            }

            /* 예외 처리 2: 경고삭제권 제한 로직 (평생 1회 + 사채 보유 시 불가) */
            if (item.effect === "warnClear") {
                if (user.boughtWarningRemoval === true) {
                    delete bankProcessState[targetUid];
                    replier.reply(formatError(user, "구매 불가", "경고삭제권은 평생 단 1회만 구매 가능합니다."));
                    return true;
                }
                var hasSache = false;
                if (roomData.loanContracts) {
                    for (var cid in roomData.loanContracts) {
                        if (roomData.loanContracts[cid].borrowerUid === targetUid) { hasSache = true; break; }
                    }
                }
                if (hasSache) {
                    delete bankProcessState[targetUid];
                    replier.reply(formatError(user, "구매 제한", "사채를 모두 상환한 후에만 구매가 가능합니다."));
                    return true;
                }
            }

            /* 예외 처리 3: 게임 인증권 시즌 2회 제한 */
            if (item.effect === "gameAuth" && (user.purchasedAuthCount || 0) >= 2) {
                delete bankProcessState[targetUid];
                replier.reply(formatError(user, "구매 한도 초과", "인증권은 시즌당 최대 2회까지만 구매 가능합니다."));
                return true;
            }

            // 수량 입력이 필요한 아이템인지 확인 (중복 구매 가능 여부)
            var stackableEffects = ["promotion", "tierGuard", "randomBox", "spitto"];
            if (stackableEffects.indexOf(item.effect) !== -1) {
                bankProcessState[targetUid] = { type: 'shop_quantity', time: Date.now(), extra: { item: item } };
                replier.reply(formatCommand("🔢 수량 입력", user, "구매하실 [" + item.name + "]의 수량을 입력해주세요.", "취소: [취소]"));
            } else {
                /* 단권 구매 로직 */
                var finalPrice = getItemPrice(item, user, roomName);
                var isUsingTicket = (item.effect === "randomBox" && (user.boxTickets || 0) > 0);

                if (!isUsingTicket && Number(user.point) < finalPrice) {
                    delete bankProcessState[targetUid];
                    replier.reply(formatError(user, "포인트 부족", fp(finalPrice) + "P가 필요합니다."));
                } else {
                    var hasItem = false;
                    if (item.effect === "icon" || item.effect === "title") {
                        var inv = user.inventory || [];
                        for (var i = 0; i < inv.length; i++) { if (inv[i].id === item.id) { hasItem = true; break; } }
                    }

                    if (hasItem) {
                        delete bankProcessState[targetUid];
                        replier.reply(formatError(user, "중복 소유", "이미 보유 중인 아이템입니다."));
                    } else {
                        if (!isUsingTicket) util_updatePoint(user, roomData, -finalPrice, "상점 구매: " + item.name, roomName);
                        delete bankProcessState[targetUid];
                        if (typeof _handleShopEffect === 'function') _handleShopEffect(item, user, roomName, replier, data, targetUid, finalPrice, isUsingTicket, 1);
                        safeSaveData(data);
                    }
                }
            }
        }
        return true;
    }

    /* [기능 2] 수량 입력 처리 */
    else if (state.type === 'shop_quantity') {
        var item = (state.extra && state.extra.item) ? state.extra.item : null;
        if (!item) { delete bankProcessState[targetUid]; return true; }

        var qty = parseInt(msg.replace(/[^0-9]/g, ""));
        if (isNaN(qty) || qty <= 0) {
            replier.reply(formatError(user, "입력 오류", "숫자로 수량을 입력해주세요."));
        } else {
            var unitPrice = getItemPrice(item, user, roomName);
            var totalPrice = 0;

            var paidQty = qty; 

            // [랜덤박스 전용] 보유 중인 이용권 개수만큼 결제 대상 수량(paidQty)에서 제외
            if (item.effect === "randomBox") {
                var currentTickets = Number(user.boxTickets || 0);
                paidQty = Math.max(0, qty - currentTickets); // 이용권으로 충당 안 되는 수량만 유료 결제
            }

            if (item.id === 8) { 
                // [변경] 승급 기회 구매(ID: 8)일 경우, 5% 복리 누적 합산 적용
                var ratio = 1.05;
                totalPrice = Math.round(unitPrice * (Math.pow(ratio, qty) - 1) / (ratio - 1));
            } else {
                totalPrice = unitPrice * paidQty; // 보정된 paidQty로 가격 계산
            }

            if (Number(user.point) < totalPrice) {
                replier.reply(formatError(user, "포인트 부족", "총 " + fp(totalPrice) + "P가 필요합니다."));
            } else {
                // 이용권이 1개라도 있으면 true를 전달하여 섹터 30이 차감 로직을 타게 합니다.
                var isUsingTicket = (item.effect === "randomBox" && (user.boxTickets || 0) > 0);
                
                util_updatePoint(user, roomData, -totalPrice, "상점 구매: " + item.name + " x" + qty, roomName);
                delete bankProcessState[targetUid];
                
                // 기존 'false'로 고정되어 있던 8번째 인자를 'isUsingTicket' 변수로 교체
                if (typeof _handleShopEffect === 'function') {
                    _handleShopEffect(item, user, roomName, replier, data, targetUid, totalPrice, isUsingTicket, qty);
                }
                safeSaveData(data);
            }
        }
        return true;
    }
    return false;
}

//==========섹터23-1==========

/* [독립형 함수] 메뉴 선택 대기 처리 1단계 (메인 메뉴 분기) */
function _handleMenuStep1(msg, user, data, replier, roomName, targetUid) {
    var menuWaitState = data.rooms[roomName].features.states.menuWait;
    if (!menuWaitState || !menuWaitState[targetUid]) return false;

    var state = menuWaitState[targetUid];
    var now = Date.now();

    // 1. [시간 초과 체크] 30초 통일
    if (now - state.time > 30000) {
        delete menuWaitState[targetUid];
        replier.reply(formatError(user, "선택 시간 초과", "30초 이내에 번호를 선택하지 않아 메뉴가 닫혔습니다."));
        return true;
    }

    // 2. 취소 입력 시 처리
    if (msg === "취소") {
        delete menuWaitState[targetUid];
        replier.reply(formatCommand("🚫 메뉴 선택 취소", user, "작업이 취소되었습니다."));
        return true;
    }

    // 3. [명령어 가드] 명령어(/) 입력 시 대기 상태를 유지하되, 처리는 하위 로직에 위임
    if (msg.startsWith("/")) {
        return false;
    }

    var roomData = data.rooms[roomName];
    // 중앙은행 재원 초기화 (UI 출력용)
    if (roomData.bankReserve === undefined) roomData.bankReserve = SYSTEM_CONFIG.ECO.BANK.INITIAL_RESERVE;

    var choice = msg.trim();
    var bankProcessState = roomData.features.states.bankProcess; // 상태값 할당을 위해 참조

    /* [1단계] 은행 메인 메뉴 선택 처리 (v5.2 기부 선택 추가) */
    if (state.type === 'bank_menu') {
        delete menuWaitState[targetUid]; // 메뉴 선택 완료 시 대기 상태 해제

        if (choice === "1") {
            bankProcessState[targetUid] = { type: 'deposit', time: Date.now() };
            replier.reply(formatCommand("💰 예금 진행", user, "예금할 금액을 입력해주세요.\n(보유: " + fp(user.point) + "P)", "취소: [취소]"));
        } else if (choice === "2") {
            bankProcessState[targetUid] = { type: 'withdraw', time: Date.now() };
            replier.reply(formatCommand("🏧 출금 진행", user, "출금할 금액을 입력해주세요.\n(잔고: " + fp(user.bank) + "P)", "취소: [취소]"));
        } else if (choice === "3") {
            bankProcessState[targetUid] = { type: 'transfer', time: Date.now() };
            replier.reply(formatCommand("💸 송금 진행", user, "받을 사람의 [닉네임]과 [금액]을 띄어쓰기로 입력하세요.\n(예: 홍길동 5000)", "취소: [취소]"));
        } else if (choice === "4") {
            var cr = getCreditInfo(user.creditScore);
            if (cr.limit <= 0) {
                replier.reply(formatError(user, "대출 불가", "신용등급이 너무 낮습니다."));
            } else {
                bankProcessState[targetUid] = { type: 'loan', time: Date.now() };
                var loanMsg = "희망 대출금을 입력해주세요.\n" +
                              "내 한도: " + fp(cr.limit) + "P (이율: " + ((cr.rate - 1) * 100).toFixed(0) + "%)\n" +
                              "🏦 은행 가용 재원: " + fp(roomData.bankReserve) + "P";
                replier.reply(formatCommand("🏦 대출 진행", user, loanMsg, "취소: [취소]"));
            }
        } else if (choice === "5") {
            if (!user.loan || user.loan.debt <= 0) {
                replier.reply(formatError(user, "상환 불가", "갚을 대출금이 없습니다."));
            } else {
                bankProcessState[targetUid] = { type: 'repay', time: Date.now() };
                replier.reply(formatCommand("📉 상환 진행", user, "상환할 금액을 입력해주세요.\n(대출 잔액: " + fp(user.loan.debt) + "P)\n보유 포인트: " + fp(user.point) + "P", "취소: [취소]"));
            }
        } else if (choice === "6") {
            // [중요] 사채 메뉴 선택 시에는 bankProcess가 아닌 menuWaitState를 갱신해야 함 (서브 메뉴 이동)
            menuWaitState[targetUid] = { type: 'p2p_loan_menu', time: Date.now() };
            var p2pMenu = "1. 💰 사채 등록 (매물 올리기)\n" +
                          "2. 📋 사채 목록 (분할 대출 받기)\n" +
                          "3. 📉 사채 상환 (빌린 돈 갚기)\n" +
                          "4. 📥 사채 회수 (등록 매물 회수)\n" +
                          "5. 👥 내 채무자 현황 (직접 수거 가능)";
            replier.reply(formatCommand("🚬 사채 시장 업무 선택", user, p2pMenu, "원하시는 번호를 입력하세요."));
            return true; // 여기서 true 반환하여 종료 (다음 로직 수행 X)
        } else if (choice === "7") {
            bankProcessState[targetUid] = { type: 'donate', time: Date.now() };
            replier.reply(formatCommand("🎁 기부 진행", user, "기부할 금액을 입력해주세요.\n(보유: " + fp(user.point) + "P)", "취소: [취소]"));
        } else {
            // 잘못된 번호 입력 시 다시 메뉴 대기 상태로 복구? 
            // 기획 의도상 메뉴가 닫히는 게 일반적이므로 에러 메시지 후 종료 처리
            replier.reply(formatError(user, "번호 오류", "올바른 메뉴 번호를 선택해주세요."));
        }
        return true;
    }
    return false; // 이 함수에서 처리하지 않은 state.type인 경우 (예: p2p_loan_menu 등)
}

//==========섹터23-2==========

/* [독립형 함수] 메뉴 선택 대기 처리 2단계 (사채 시장 서브 메뉴) */
function _handleMenuStep2(msg, user, data, replier, roomName, targetUid) {
    var menuWaitState = data.rooms[roomName].features.states.menuWait;
    if (!menuWaitState || !menuWaitState[targetUid]) return false;

    var state = menuWaitState[targetUid];
    // 이 함수는 'p2p_loan_menu' 타입만 처리합니다.
    if (state.type !== 'p2p_loan_menu') return false;

    // 1. [시간 초과 및 취소 가드]
    if (Date.now() - state.time > 30000 || msg === "취소") {
        delete menuWaitState[targetUid];
        if (msg === "취소") replier.reply(formatCommand("🚫 사채 업무 취소", user, "작업이 취소되었습니다."));
        else replier.reply(formatError(user, "선택 시간 초과", "30초 이내에 번호를 선택하지 않아 메뉴가 닫혔습니다."));
        
        // 명령어 입력 시에는 false를 반환하여 하위 로직으로 전달
        if (msg.startsWith("/")) return false;
        return true;
    }

    // 2. [명령어 통로]
    if (msg.startsWith("/")) {
        delete menuWaitState[targetUid];
        return false;
    }

    var choice = msg.trim();
    var roomData = data.rooms[roomName];
    var bankProcessState = roomData.features.states.bankProcess;

    // 선택지 처리 시작 (일단 현재 대기 상태 해제)
    delete menuWaitState[targetUid];

    if (choice === "1") {
        bankProcessState[targetUid] = { type: 'p2p_reg_input', time: Date.now() };
        replier.reply(formatCommand("💰 사채 매물 등록", user, "등록할 [금액]과 [이율]을 입력하세요.\n(예: 10000 5)", "취소: [취소]"));
    }
    else if (choice === "2") {
        var pools = Object.keys(roomData.loanPools || {});
        if (pools.length === 0) {
            replier.reply(formatSimple("📋 사채 시장", "현재 등록된 매물이 없습니다.", null));
        } else {
            var list = []; 
            var tempPools = [];
            for(var i=0; i<pools.length; i++) {
                var p = roomData.loanPools[pools[i]];
                list.push((i+1) + ". [" + p.lenderName + "] 잔여: " + fp(p.remainingAmount) + "P (" + p.rate + "%)");
                tempPools.push(pools[i]);
            }
            menuWaitState[targetUid] = { type: 'p2p_select_pool', time: Date.now(), extra: { pools: tempPools } };
            replier.reply(formatCommand("📋 사채 매물 목록", user, list.join("\n"), "빌리고 싶은 매물 번호를 입력하세요."));
        }
    }
    else if (choice === "3") {
        var myContracts = [];
        if (roomData.loanContracts) {
            for(var id in roomData.loanContracts) {
                if(roomData.loanContracts[id].borrowerUid === targetUid) myContracts.push({ id: id, data: roomData.loanContracts[id] });
            }
        }
        if (myContracts.length === 0) {
            replier.reply(formatError(user, "내역 없음", "현재 이 방에서 빌려 쓰고 있는 사채가 없습니다."));
        } else {
            var list = [];
            for(var i=0; i<myContracts.length; i++) {
                var c = myContracts[i].data;
                list.push((i+1) + ". [" + c.lenderName + "] 채무액: " + fp(c.currentDebt) + "P (이율 " + c.rate + "%)");
            }
            menuWaitState[targetUid] = { type: 'p2p_select_repay', time: Date.now(), extra: { contracts: myContracts.map(function(x){return x.id;}) } };
            replier.reply(formatCommand("📉 사채 상환 선택", user, list.join("\n"), "갚을 사채의 번호를 선택하세요."));
        }
    }
    else if (choice === "4") {
        var myPools = [];
        if (roomData.loanPools) {
            for(var id in roomData.loanPools) {
                if(roomData.loanPools[id].lenderUid === targetUid) myPools.push({ id: id, data: roomData.loanPools[id] });
            }
        }
        if (myPools.length === 0) {
            replier.reply(formatError(user, "내역 없음", "이 방에 올려둔 사채 풀이 없습니다."));
        } else {
            var list = [];
            for(var i=0; i<myPools.length; i++) {
                var p = myPools[i].data;
                list.push((i+1) + ". 잔여: " + (p.remainingAmount) + "P (이율 " + p.rate + "%/3h)");
            }
            menuWaitState[targetUid] = { type: 'p2p_select_withdraw', time: Date.now(), extra: { pools: myPools.map(function(x){return x.id;}) } };
            replier.reply(formatCommand("📥 사채 풀 회수", user, list.join("\n"), "회수할 사채 풀 번호를 선택하세요."));
        }
    }
    else if (choice === "5") {
        var myDebtors = [];
        if (roomData.loanContracts) {
            for(var id in roomData.loanContracts) {
                if(roomData.loanContracts[id].lenderUid === targetUid) myDebtors.push({ id: id, data: roomData.loanContracts[id] });
            }
        }
        if (myDebtors.length === 0) {
            replier.reply(formatSimple("👥 내 채무자 현황", "현재 돈을 빌려 간 유저가 없습니다.", null));
        } else {
            var list = [];
            var tempContracts = [];
            for(var i=0; i<myDebtors.length; i++) {
                var d = myDebtors[i].data;
                var status = (Date.now() - d.startTime > 24*60*60*1000) ? " (🚨연체)" : "";
                list.push((i+1) + ". [" + d.borrowerName + "] 빚: " + fp(d.currentDebt) + "P" + status);
                tempContracts.push(myDebtors[i].id);
            }
            menuWaitState[targetUid] = { type: 'p2p_select_collect', time: Date.now(), extra: { contracts: tempContracts } };
            replier.reply(formatCommand("👥 내 채무자 명단", user, list.join("\n"), "강제 수거를 원하시면 유저 번호를 입력하세요."));
        }
    }
    else {
        // 잘못된 번호 입력 처리
        replier.reply(formatError(user, "번호 오류", "올바른 메뉴 번호를 선택해주세요."));
    }

    return true;
}

//==========섹터23-3==========

/* [독립형 함수] 메뉴 선택 대기 처리 3단계 (사채 목록 선택) */
function _handleMenuStep3(msg, user, data, replier, roomName, targetUid) {
    var menuWaitState = data.rooms[roomName].features.states.menuWait;
    if (!menuWaitState || !menuWaitState[targetUid]) return false;

    var state = menuWaitState[targetUid];
    // 이 함수가 처리할 타입 목록 정의 (사채 관련 선택지들)
    var types = ['p2p_select_pool', 'p2p_select_repay', 'p2p_select_withdraw', 'p2p_select_collect'];
    if (types.indexOf(state.type) === -1) return false;

    // 1. [시간 초과 및 취소 가드]
    if (Date.now() - state.time > 30000 || msg === "취소") {
        delete menuWaitState[targetUid];
        if (msg === "취소") replier.reply(formatCommand("🚫 사채 업무 취소", user, "작업이 취소되었습니다."));
        else replier.reply(formatError(user, "선택 시간 초과", "30초 이내에 번호를 선택하지 않아 메뉴가 닫혔습니다."));
        
        if (msg.startsWith("/")) return false;
        return true;
    }

    // 2. [명령어 통로]
    if (msg.startsWith("/")) {
        delete menuWaitState[targetUid];
        return false;
    }

    var choice = msg.trim();
    var roomData = data.rooms[roomName];
    var bankProcessState = roomData.features.states.bankProcess;

    /* [선택 분기 1] 사채 빌리기 매물 선택 */
    if (state.type === 'p2p_select_pool') {
        delete menuWaitState[targetUid];
        var idx = parseInt(choice) - 1;
        var poolId = (state.extra && state.extra.pools) ? state.extra.pools[idx] : null;
        
        if (!poolId || !roomData.loanPools[poolId]) {
            replier.reply(formatError(user, "번호 오류", "목록에 있는 번호를 정확히 입력해주세요."));
        } else {
            bankProcessState[targetUid] = { type: 'p2p_borrow_amt', time: Date.now(), extra: { poolId: poolId } };
            replier.reply(formatCommand("💰 사채 금액 설정", user, "선택 매물: [" + roomData.loanPools[poolId].lenderName + "]\n잔여 금액: " + fp(roomData.loanPools[poolId].remainingAmount) + "P\n\n빌릴 금액을 입력하세요.", "취소: [취소]"));
        }
        return true;
    }

    /* [선택 분기 2] 사채 상환 대상 선택 */
    else if (state.type === 'p2p_select_repay') {
        delete menuWaitState[targetUid];
        var idx = parseInt(choice) - 1;
        var contractId = (state.extra && state.extra.contracts) ? state.extra.contracts[idx] : null;
        
        if (!contractId || !roomData.loanContracts[contractId]) {
            replier.reply(formatError(user, "번호 오류", "상환할 계약 번호를 확인해주세요."));
        } else {
            bankProcessState[targetUid] = { type: 'p2p_repay_amt', time: Date.now(), extra: { contractId: contractId } };
            var contract = roomData.loanContracts[contractId];
            replier.reply(formatCommand("📉 사채 상환액 입력", user, "채권자: [" + contract.lenderName + "]\n남은 빚: " + fp(contract.currentDebt) + "P\n💰 내 잔액: " + fp(user.point) + "P\n\n갚을 금액을 입력하세요.", "취소: [취소]"));
        }
        return true;
    }

    /* [선택 분기 3] 사채 매물 회수 대상 선택 */
    else if (state.type === 'p2p_select_withdraw') {
        delete menuWaitState[targetUid];
        var idx = parseInt(choice) - 1;
        var poolId = (state.extra && state.extra.pools) ? state.extra.pools[idx] : null;
        
        if (!poolId || !roomData.loanPools[poolId]) {
            replier.reply(formatError(user, "번호 오류"));
        } else {
            bankProcessState[targetUid] = { type: 'p2p_withdraw_amt', time: Date.now(), extra: { poolId: poolId, max: roomData.loanPools[poolId].remainingAmount } };
            replier.reply(formatCommand("📥 회수 금액 입력", user, "현재 풀 잔액: " + fp(roomData.loanPools[poolId].remainingAmount) + "P\n\n회수할 금액을 입력하거나 [전액]을 입력하세요.", "취소: [취소]"));
        }
        return true;
    }

    /* [선택 분기 4] 채무자 강제 수거 대상 선택 */
    else if (state.type === 'p2p_select_collect') {
        delete menuWaitState[targetUid];
        var idx = parseInt(choice) - 1;
        var contractId = (state.extra && state.extra.contracts) ? state.extra.contracts[idx] : null;
        
        if (!contractId || !roomData.loanContracts[contractId]) {
            replier.reply(formatError(user, "번호 오류"));
        } else {
            bankProcessState[targetUid] = { type: 'p2p_collect_manual', time: Date.now(), extra: { contractId: contractId } };
            replier.reply(formatCommand("🚬 사채 강제 수거 확인", user, "[" + roomData.loanContracts[contractId].borrowerName + "]님의 지갑에서 자산을 수거하시겠습니까?\n\n진행하시려면 아무 메시지나 입력해주세요.", "취소: [취소]"));
        }
        return true;
    }

    return false;
}

//==========섹터23-4==========

/* [독립형 함수] 메뉴 선택 대기 처리 4단계 (상점/도움말/가이드) */
function _handleMenuStep4(msg, user, data, replier, roomName, targetUid) {
    var menuWaitState = data.rooms[roomName].features.states.menuWait;
    if (!menuWaitState || !menuWaitState[targetUid]) return false;

    var state = menuWaitState[targetUid];
    // 처리 가능 타입에 'shop_detail' 추가
    var types = ['shop_category', 'shop_detail', 'help', 'guide_menu'];
    if (types.indexOf(state.type) === -1) return false;

    // 1. [시간 초과 및 취소 가드]
    if (Date.now() - state.time > 30000 || msg === "취소") {
        delete menuWaitState[targetUid];
        if (msg === "취소") replier.reply(formatCommand("🚫 메뉴 선택 취소", user, "작업이 취소되었습니다."));
        else replier.reply(formatError(user, "선택 시간 초과", "30초 이내에 번호를 선택하지 않아 메뉴가 닫혔습니다."));
        
        if (msg.startsWith("/")) return false;
        return true;
    }

    // 2. [명령어 통로]
    if (msg.startsWith("/")) {
        delete menuWaitState[targetUid];
        return false;
    }

    var choice = msg.replace(/[^0-9]/g, "").trim();
    var bankProcessState = data.rooms[roomName].features.states.bankProcess;

    /* [기능 1] 상점 카테고리 선택 */
    if (state.type === 'shop_category') {
        var catId = parseInt(choice);
        if (isNaN(catId) || !SHOP_CATEGORIES[catId]) {
            delete menuWaitState[targetUid];
            replier.reply(formatError(user, "번호 오류", "올바른 카테고리 번호를 선택해주세요."));
        } 
        // 5번(특수/복권) 카테고리 선택 시 서브 메뉴로 분기
        else if (catId === 5) {
            menuWaitState[targetUid] = { type: 'shop_detail', category: '5', time: Date.now() };
            
            // [수정] 스피또 가격 자동 계산 (설정값 * 물가배율)
            var spittoBase = SYSTEM_CONFIG.ECO.SPITTO.PRICE;
            var spittoPrice = Math.floor(spittoBase * util_getEcoMultiplier(roomName));

            var lotteryMenu = "원하시는 복권 번호를 입력하세요.\n\n" +
                              "1. 로또 (추첨식: 22:00 발표)\n" +
                              "2. 스피또 (즉석식: " + fp(spittoPrice) + "P)";
            
            replier.reply(formatCommand("🎫 특수/복권 상점", user, lotteryMenu, "취소: [취소] / 입력 대기: 30초"));
        }
        else {
            var filteredItems = [];
            for (var i = 0; i < SHOP_ITEMS.length; i++) {
                if (SHOP_ITEMS[i].cat === catId) filteredItems.push(SHOP_ITEMS[i]);
            }

            if (filteredItems.length === 0) {
                delete menuWaitState[targetUid];
                replier.reply(formatSimple("🛒 상점 알림", "해당 카테고리에 물품이 없습니다.", "다른 번호를 선택하세요."));
            } else {
                var list = [];
                for (var j = 0; j < filteredItems.length; j++) {
                    var item = filteredItems[j];
                    list.push((j + 1) + ". " + item.icon + " " + item.name + " : " + fp(getItemPrice(item, user, roomName)) + "P");
                }
                bankProcessState[targetUid] = { type: 'shop_buy', time: Date.now(), extra: { items: filteredItems } };
                delete menuWaitState[targetUid]; // 메뉴 대기 해제 -> 상점 구매 대기 진입
                replier.reply(formatCommand("🛒 " + SHOP_CATEGORIES[catId], user, list.join("\n"), "구매할 물품의 번호를 입력하세요."));
            }
        }
        return true;
    }

/* [기능 1-1] 상점 상세 선택 (복권 카테고리 내 번호 선택 처리) */
    else if (state.type === 'shop_detail') {
        delete menuWaitState[targetUid]; // 상세 선택 진입 시 메뉴 대기 해제
        
        if (state.category === '5') { // 복권 카테고리인 경우
            if (choice === "1") { // 로또 선택 시
                var lottoItem = null;
                for(var i=0; i<SHOP_ITEMS.length; i++) { 
                    if(SHOP_ITEMS[i].effect === "lotto") { lottoItem = SHOP_ITEMS[i]; break; } 
                }
                // 로또는 단권 구매이므로 바로 구매 확인 단계로 이동
                bankProcessState[targetUid] = { type: 'shop_buy', time: Date.now(), extra: { items: [lottoItem] } };
                _handleBankStep5("1", user, data, replier, roomName, targetUid);
            } 
            else if (choice === "2") { // 스피또 선택 시
                var spittoItem = null;
                for(var i=0; i<SHOP_ITEMS.length; i++) { 
                    if(SHOP_ITEMS[i].effect === "spitto") { spittoItem = SHOP_ITEMS[i]; break; } 
                }
                // 스피또는 여러 개 구매가 가능하므로 수량 입력 단계로 이동
                bankProcessState[targetUid] = { type: 'shop_quantity', time: Date.now(), extra: { item: spittoItem } };
                replier.reply(formatCommand("🔢 스피또 수량 입력", user, "구매하실 [스피또 복권]의 수량을 입력해주세요.", "취소: [취소]"));
            } 
            else {
                replier.reply(formatError(user, "번호 오류", "1번(로또) 또는 2번(스피또)을 선택해주세요."));
            }
        }
        return true;
    }

    /* [기능 2] 도움말 메뉴 선택 */
    else if (state.type === 'help') {
        delete menuWaitState[targetUid];
        var helpBody = ""; var next = "";
        var targetCat = "";
        
        if (choice === "1") { targetCat = "조회"; next = "내 정보 확인: [/내정보]"; }
        else if (choice === "2") { targetCat = "게임"; next = "미니게임 참여: [/홀짝], [/낚시]"; }
        else if (choice === "3") { targetCat = "상점"; next = "상점 확인: [/상점]"; }
        else if (choice === "4") { targetCat = "경제"; next = "은행 및 사채 메뉴: [/은행]"; }
        else if (choice === "5") { targetCat = "주식"; next = "시세 확인: [/주식]"; }
        else if (choice === "6") { targetCat = "광산"; next = "채굴 시작: [/광산시작]"; }
        else if (choice === "7") { targetCat = "정부"; next = "정책 확인: [/의회]"; }
        
        if (targetCat !== "") {
            var list = [];
            for(var i=0; i<CMD_LIST.user.length; i++) {
                var c = CMD_LIST.user[i];
                if(c.cat === targetCat) list.push("• " + c.cmd + ": " + c.desc);
            }
            helpBody = list.join("\n");
        } else if (choice === "8" && isAdmin(user.name, data, targetUid)) { // 관리자 번호 7 -> 8 이동
            var list = [];
            for(var i=0; i<CMD_LIST.admin.length; i++) {
                var a = CMD_LIST.admin[i];
                list.push((i+1) + ". " + a.cmd + " " + a.desc);
            }
            helpBody = "⚙️ [관리자 전용 명령어]\n" + list.join("\n"); 
            next = "관리자 권한으로 신중히 사용하세요.";
        }
        
        if (helpBody !== "") { 
            replier.reply(formatCommand("📖 상세 도움말", null, helpBody, next)); 
        } else {
            replier.reply(formatError(user, "번호 오류", "올바른 번호를 선택해주세요."));
        }
        return true;
    }

    /* [기능 3] 가이드 메뉴 선택 */
    else if (state.type === 'guide_menu') {
        delete menuWaitState[targetUid];
        var guideBody = "";
        var guideTitle = "";

        if (choice === "1") {
            guideTitle = "🏛️ 중앙은행 및 신용 경제";
            guideBody = "• 중앙은행 재원: 상점 수익, 도박 패배금 등이 금고로 적립됩니다.\n" + "• 지급준비제도: 총 예금의 20%는 대출 불가한 준비금입니다. 금고 고갈 시 출금이 제한됩니다.\n" + "• 자동 상환: 빚 보유 시 수익의 일부가 강제 상환됩니다.\n" + "  (은행대출 30% / 신불·사채 50% / 대환 70%)";
        }
        else if (choice === "2") {
            guideTitle = "🏇 중앙 경마 시스템";
            guideBody = "• 배팅: 매시 00~49분 참여, 정각에 결과 발표 및 정산.\n" + "• 당첨금: 10% 국고 수수료 제외 후 지분만큼 분할 지급.\n" + "• 하한 보장: 당첨 시 배팅액의 최소 3배 배당을 은행이 보전해드립니다.\n" + "• 상한 제한: 독점 방지를 위해 배팅액의 최대 10배까지만 수령 가능합니다.\n" + "• 이월: 무승자 발생 시 판돈의 70%가 잭팟으로 합산 이월됩니다.";
        }
        else if (choice === "3") {
            guideTitle = "📈 주식 및 투자";
            guideBody = "• 운영: 07:00 ~ 23:59 (10분마다 변동)\n" + "• 세금: 매도 시 판매 금액의 5%가 국세로 자동 차감됩니다.\n" + "• 상폐: 주가가 기준가 이하로 폭락 시 ⚠️ 표시가 뜨며, 지속될 경우 상장 폐지(0P) 됩니다.";
        }
        else if (choice === "4") {
            guideTitle = "🎰 로또 및 도박";
            guideBody = "• 로또: 1~15 중 3개 숫자. 22시 추첨. 1등 당첨금은 당첨자 없을 시 매일 무제한 이월됩니다.\n" + "• 홀짝: 기본 배당 1.9배. [피버타임] 발동 시 5분간 승률 보너스가 적용됩니다.";
        }
        else if (choice === "5") {
            guideTitle = "⛏️ 활동 및 수익";
            guideBody = "• 광산: 방치형 수익형 활동. 채무 보유 시 근로 의욕 고취로 효율이 1.5배 상승합니다.\n" + "• 유물: 채굴 중 0.1% 확률로 발견. 조각 수집량에 따라 [도굴왕] 등 5단계 칭호가 부여됩니다.\n" + "• 도둑질: 타인 자산 10% 강탈. [잡았다요놈] 대응 시 벌금 및 감옥 1시간이 부과됩니다.";
        }
        else if (choice === "6") {
            guideTitle = "🎁 민생 지원 및 복지";
            guideBody = "• 지원금: 실질 순자산이 평균의 40% 미만인 서민 유저에게 하루 한 번 지급됩니다.\n" + "• 자산가 칭호: 총 자산(가용+주식+채권-부채) 돌파 시 재벌, 거상 등 영구 소장 칭호를 획득합니다.";
        }

        else if (choice === "7") {
            guideTitle = "🏛️ 정부 및 투표 가이드";
            guideBody = "• 발의: 매일 20:00 새로운 안건이 자동 상정됩니다.\n" +
                        "• 투표: 20:00 ~ 23:50 사이 참여 가능 ([/투표 찬성|반대])\n" +
                        "• 가중: 아이언~실버(1표) / 골드~에메(2표) / 다이아~(3표)\n" +
                        "• 보상: 투표 즉시 거마비 500P가 국고에서 지급됩니다.\n" +
                        "• 의결: 당일 출석 인원의 50% 미만 참여 시 무조건 기각됩니다.\n" +
                        "• 발효: 가결된 안건은 다음 날 00:05부터 시스템에 반영됩니다.";
        }

        if (guideBody !== "") {
            replier.reply(formatCommand("📔 " + guideTitle, null, guideBody, "닫기: [취소]"));
        } else {
            replier.reply(formatError(user, "번호 오류", "올바른 번호를 선택해주세요."));
        }
        return true;
    }

    return false;
}

/* [명령어 진입점] 도움말 및 가이드 (함수 밖 독립 실행 보장) */
if (msg === "/도움말") {
    var menuWaitState = data.rooms[roomName].features.states.menuWait; // 안전 참조
    menuWaitState[targetUid] = { type: 'help', time: Date.now() };
    var menu = "1. 👤 조회 및 정보\n" +
               "2. 🎮 게임 및 활동\n" +
               "3. 🛒 상점 및 아이템\n" +
               "4. 🏦 은행 및 사채\n" +
               "5. 📈 주식 투자\n" +
               "6. ⛏️ 광산 채굴 (방치형)\n" +
               "7. 🏛️ 정부 및 투표\n"; // 신규 카테고리 추가
    
    if (isAdmin(user.name, data, targetUid)) menu += "8. ⚙️ 관리자 기능\n";
    replier.reply(formatCommand("📖 내리다봇 도움말", null, "원하시는 메뉴 번호를 입력하세요.\n\n" + menu, "입력 대기: 30초"));
    return;
}

if (msg === "/가이드") {
    var menuWaitState = data.rooms[roomName].features.states.menuWait; // 안전 참조
    menuWaitState[targetUid] = { type: 'guide_menu', time: Date.now() };
    var menu = "1. 🏛️ 중앙은행 및 신용 경제\n" +
               "2. 🏇 중앙 경마 시스템\n" +
               "3. 📈 주식 및 투자\n" +
               "4. 🎰 로또 및 도박\n" +
               "5. ⛏️ 활동 및 수익\n" +
               "6. 🎁 민생 지원 및 복지\n" +
               "7. 🏛️ 정부 및 투표 가이드";
    replier.reply(formatCommand("📔 내리다봇 마스터 가이드", null, "상세 내용을 보고 싶은 항목을 선택하세요.\n\n" + menu, "입력 대기: 30초"));
    return;
}

//==========섹터24==========

/* [최적화] 모든 숫자 입력 및 상태 기반 명령어 통합 처리 구간 */
        
        if (rFeatures && rFeatures.states) {
            // 0. 중복 유저 선택
            if (typeof _handleSelectionLogic === 'function' && _handleSelectionLogic(msg, user, data, replier, roomName, targetUid)) return;
            // 1. 로또 번호 입력 (섹터21 연결)
            if (typeof _handleLottoInput === 'function' && _handleLottoInput(msg, user, data, replier, roomName, targetUid)) return;
            // A. 은행 업무
            if (typeof _handleBankStep1 === 'function' && _handleBankStep1(msg, user, data, replier, roomName, targetUid)) return;
            if (typeof _handleBankStep2 === 'function' && _handleBankStep2(msg, user, data, replier, roomName, targetUid)) return;
            if (typeof _handleBankStep3 === 'function' && _handleBankStep3(msg, user, data, replier, roomName, targetUid)) return;
            if (typeof _handleBankStep4 === 'function' && _handleBankStep4(msg, user, data, replier, roomName, targetUid)) return;
            if (typeof _handleBankStep5 === 'function' && _handleBankStep5(msg, user, data, replier, roomName, targetUid)) return;
            // B. 메뉴 대기
            if (typeof _handleMenuStep1 === 'function' && _handleMenuStep1(msg, user, data, replier, roomName, targetUid)) return;
            if (typeof _handleMenuStep2 === 'function' && _handleMenuStep2(msg, user, data, replier, roomName, targetUid)) return;
            if (typeof _handleMenuStep3 === 'function' && _handleMenuStep3(msg, user, data, replier, roomName, targetUid)) return;
            if (typeof _handleMenuStep4 === 'function' && _handleMenuStep4(msg, user, data, replier, roomName, targetUid)) return;
        }

        // 2. 일반 게임 명령어 처리
        if (typeof _handleGameLogic === 'function') {
            if (_handleGameLogic(msg, user, data, replier, roomName, targetUid, cleanSender)) return;
        }

        /* [3. 채팅 보너스 로직 (함수 연결)] */
        if (typeof _runChatBonusLogic === 'function') {
            _runChatBonusLogic(msg, user, data, replier, roomName, targetUid);
        }

//==========섹터25==========

/* [최적화] 관리자 명령어 통합 처리 구간 */
        if (isAdmin(sender, data)) {
            if (typeof _handleAdminLogic === 'function') {
                if (_handleAdminLogic(msg, user, data, replier, roomName, targetUid, sender)) return;
            }
        }

        /* [명령어 실행 및 예외 처리] */
        var cmdKey = msg.split(" ")[0];

        if (msg.startsWith("/")) {
            // 1. 사용자 명령어 실행 로직
            if (USER_COMMANDS && USER_COMMANDS[cmdKey]) {
                USER_COMMANDS[cmdKey].execute(msg, user, data, replier, roomName, targetUid, sender);
                return;
            }

            // 2. 관리자/사용자 명령어 모두 없는 경우
            if (!ADMIN_COMMANDS[cmdKey]) {
                var unknownCmdMsg = "'" + cmdKey + "'은(는) 등록되지 않은 명령어입니다.";
                replier.reply(formatError(user, "알 수 없는 명령어", unknownCmdMsg + "\n'/도움말'을 입력하여 전체 명령어 목록을 확인하세요."));
                return;
            }
        }

//==========섹터26==========

    } catch (e) {
        Log.error("Thread Runtime Error: " + e);
        if (lock.isLocked()) {
            try {
                lock.unlock();
            } catch(err) {
                Log.error("Lock Release Error: " + err);
            } finally {
            // [스레드 보호] 로직 종료/에러 발생 시 무조건 락 해제 (다음 사람을 위해)
            lock.unlock(); 
        }
}
}));
};

//==========섹터27==========

/**
 * [독립형 함수 1] 인벤토리 로직 (자산가 영구 칭호 통합본)
 * 기능: 보유 아이템 확인, 장착, 분해 처리
 * 수정: 영구 칭호(700번대) 카테고리 분류 및 보호 로직 추가
 */
function _handleInventoryLogic(msg, user, data, replier, roomName, targetUid) {
    // 1. 가방 조회 (분류 및 자동 정렬 적용)
    if (msg === "/가방") {
        var inv = user.inventory || [];
        
        // ID 기준 오름차순 정렬 (자산가 칭호 700~703번이 칭호 상단에 오도록 정렬)
        inv.sort(function(a, b) {
            var idA = Number(a.id) || 9999;
            var idB = Number(b.id) || 9999;
            if (idA !== idB) return idA - idB;
            return (a.name || "").localeCompare(b.name || "");
        });

        var iconEntries = [];
        var titleEntries = [];
        
        if (inv.length === 0) {
            iconEntries.push("(보유 중인 아이템이 없습니다)");
        } else {
            for (var i = 0; i < inv.length; i++) {
                var it = inv[i];
                var activeMark = "";
                
                // 현재 장착 상태 확인 (✅ 표시)
                if (it.effect === "icon" && user.icon === it.icon) activeMark = " (✅ 장착 중)";
                else if (it.effect === "title" && user.title === it.title) activeMark = " (✅ 장착 중)";
                
                var displayIcon = it.icon || "";
                var entry = "";

                if (it.effect === "icon") {
                    // 아이콘 카테고리: [아이콘] 이름 포맷
                    entry = (i + 1) + ". " + (displayIcon || "📦") + " " + it.name + activeMark;
                    iconEntries.push(entry);
                } else if (it.effect === "title") {

                    // 1. 모든 칭호가 보이도록 필터(continue) 제거
                    // 2. 수집대마왕, 도굴왕을 제외한 칭호의 아이콘 숨김 처리
                    var finalDisplayIcon = "";
                    if (it.title === "수집대마왕" || it.title === "도굴왕") {
                        finalDisplayIcon = it.icon || "";
                    }

                    var entry = "";
                    if (finalDisplayIcon) {
                        // 아이콘이 허용된 칭호: [아이콘+이름] 포맷
                        entry = (i + 1) + ". [" + finalDisplayIcon + it.title + "] 칭호" + activeMark;
                    } else {
                        // 그 외 모든 칭호: 아이콘 없이 [이름] 포맷
                        entry = (i + 1) + ". [" + it.title + "] 칭호" + activeMark;
                    }
                    titleEntries.push(entry);
                }
            }
        }

        var horseInfo = "🐎 경마 장비: [" + (user.horseParts.length > 0 ? user.horseParts.join(", ") : "없음") + "] " + (user.horseParts.length) + " / 4 개";
        var stockInfo = "📈 미발행확인서: " + (user.stockCertCount || 0) + " / 10 개";
        var letterInfo = "📩 위로의 편지: " + (user.lottoFailCount || 0) + " / 15 개";
        
        // 행운의부적 남은 시간 계산
        var charmStatus = "";
        if (user.luckyCharmEnd && Date.now() < user.luckyCharmEnd) {
            var remainMin = Math.ceil((user.luckyCharmEnd - Date.now()) / 60000);
            charmStatus = "\n🔮 행운의부적: 활성 중 (" + remainMin + "분 남음)";
        }

        var invDisplay = "[아이템 보관함]\n";
        invDisplay += "🖼️ 아이콘 목록 (등급순)\n";
        invDisplay += (iconEntries.length > 0 ? iconEntries.join("\n") : "- 없음") + "\n\n";
        
        invDisplay += "🎖️ 칭호 목록 (등급순)\n";
        invDisplay += (titleEntries.length > 0 ? titleEntries.join("\n") : "- 없음");

        var consumables = "\n\n[내 소모품 정보]\n" +
                          "🛡️ 강등 방어권: " + (user.tierGuard || 0) + "개\n" +
                          "🔂 추가 승급권: " + (user.purchasedPromotionAttempts || 0) + "회\n" +
                          "🧩 분해 조각: " + (user.boxFragments || 0) + " / 5 개\n" +
                          "🎫 랜덤박스 이용권: " + (user.boxTickets || 0) + "매" + charmStatus;

        // 2. 수집 진행도 섹션 별도 조립
        var progress = "\n\n[📊 수집 및 칭호 진행도]\n" +
                       horseInfo + "\n" +
                       stockInfo + "\n" +
                       letterInfo;
        
        // 3. 최종 content에 progress 추가 연결
        var content = invDisplay + consumables + progress + "\n\n(장착: [/장착 번호]) (분해: [/분해 번호])";
        
        replier.reply(formatCommand("🎒 내 가방", user, content, "원하는 번호를 입력하여 장착하세요."));
        return true;
    }

    // 2. 아이템 장착 (신용불량자 제한 및 인덱스 정합성 유지)
    if (msg.indexOf("/장착 ") === 0) {
        if (Number(user.creditScore || 600) < 500) {
            replier.reply(formatError(user, "장착 불가", "현재 신용불량자 상태이므로 아이콘 및 칭호 변경이 불가능합니다. 신용을 먼저 회복하세요."));
            return true;
        }

        var parts = msg.trim().split(/\s+/);
        if (parts.length < 2) {
            replier.reply(formatError(user, "형식 오류", "/장착 [번호]"));
            return true;
        }

        var idx = parseInt(parts[1]);
        var inv = user.inventory || [];
        if (isNaN(idx) || idx < 1 || idx > inv.length) {
            replier.reply(formatError(user, "번호 오류", "가방에 표시된 번호를 입력해주세요."));
            return true;
        }

        var selected = inv[idx - 1];
        if (selected.effect === "icon") {
            user.icon = selected.icon;
            replier.reply(formatCommand("✨ 아이콘 장착", user, "[" + selected.icon + "] 아이콘으로 변경되었습니다.", "내 정보: [/내정보]"));
        } else if (selected.effect === "title") {
            user.title = selected.title || "";
            replier.reply(formatCommand("🎖️ 칭호 장착", user, "[" + (selected.title || selected.name) + "] 칭호로 변경되었습니다.", "내 정보: [/내정보]"));
        }
        safeSaveData(data);
        return true;
    }

    // 3. 아이콘 분해 로직 (영구 칭호 보호 로직 추가)
    if (msg.indexOf("/분해 ") === 0) {
        var inv = user.inventory || [];
        if (inv.length === 0) return replier.reply(formatError(user, "분해 불가", "분해할 아이템이 없습니다."));

        user.skipHealing = true;

        var numbers = msg.match(/\d+/g);
        if (!numbers) return replier.reply(formatError(user, "입력 오류", "/분해 [번호]"));

        var targetIndices = [];
        var protectedCount = 0;

        numbers.forEach(function(n) {
            var idx = parseInt(n) - 1;
            if (idx >= 0 && idx < inv.length && targetIndices.indexOf(idx) === -1) {
                var item = inv[idx];
                // [안전 장치] ID 700~799번대(자산가/업적 영구 칭호)는 분해 대상에서 제외
                if (item.effect === "title" && item.id >= 700 && item.id < 800) {
                    protectedCount++;
                } else {
                    targetIndices.push(idx);
                }
            }
        });

        if (protectedCount > 0 && targetIndices.length === 0) {
            return replier.reply(formatError(user, "분해 불가", "영구 업적 칭호는 분해할 수 없습니다."));
        }
        if (targetIndices.length === 0) return replier.reply(formatError(user, "번호 오류", "정확한 번호를 입력하세요."));

        var disassembledNames = [];
        var earnedFragments = targetIndices.length;
        
        // 역순 정렬하여 splice 시 인덱스 밀림 방지
        targetIndices.sort(function(a, b) { return b - a; });

        targetIndices.forEach(function(idx) {
            var item = inv[idx];
            disassembledNames.push((item.icon || "📦") + " " + item.name);
            if (item.effect === "icon" && user.icon === item.icon) user.icon = "";
            if (item.effect === "title" && user.title === item.title) user.title = "";
            inv.splice(idx, 1);
        });

        user.boxFragments = (user.boxFragments || 0) + earnedFragments;
        var earnedTickets = 0;
        
        while (user.boxFragments >= 5) {
            user.boxFragments -= 5;
            user.boxTickets = (user.boxTickets || 0) + 1;
            earnedTickets++;
        }

        var resultMsg = "아이템 " + targetIndices.length + "개를 분해했습니다.\n\n" +
                        "[분해 목록]\n" + disassembledNames.join(", ") + "\n\n" +
                        "🧩 획득 조각: +" + earnedFragments + " 개\n" +
                        "(현재 조각: " + user.boxFragments + " / 5 개)";

        if (protectedCount > 0) resultMsg += "\n\n⚠️ 알림: 선택하신 영구 칭호 " + protectedCount + "개는 분해 대상에서 제외되었습니다.";
        if (earnedTickets > 0) resultMsg += "\n🎫 랜덤박스 이용권: +" + earnedTickets + "매 획득! (조각 변환 완료)";

        replier.reply(formatCommand("♻️ 아이콘 분해 완료", user, resultMsg, "이용권 확인: [/가방]"));
        safeSaveData(data);
        return true;
    }
}

//==========섹터28==========

/**
 * [독립형 함수 2] 로또 및 아이콘 로직
 */
function _handleLottoLogic(msg, user, data, replier, roomName, targetUid) {
    var roomData = data.rooms[roomName];

    // 1. 방 데이터 및 기능 템플릿 존재 여부 체크 (안전 가드)
    if (!roomData || !roomData.features) return false;

    // 2. [핵심] 이 함수 전용 지역 변수로 로또 데이터 연결 (먹통 방지)
    var lotto = roomData.features.lotto;

    if (msg === "/아이콘초기화") {
        user.icon = "";
        replier.reply(formatCommand("✅ 아이콘 초기화", user, "설정된 아이콘이 제거되었습니다.", "상점 이용: [/상점]"));
        safeSaveData(data);
        return true;
    }

    if (msg === "/로또정보") {
        var currentHour = new Date().getHours();
        var isAfterDraw = (currentHour >= 22);
        var myLottos = (lotto.entries && lotto.entries[targetUid]) ? lotto.entries[targetUid] : [];
        var winNums = lotto.lastWinNums || [];

        var result = "🎫 로또 정보\n━━━━━━━━━━━━━━━\n" + getDisplayName(user) + "님\n[나의 구매 번호]\n";
        
        if (myLottos.length === 0) {
            result += "(구매한 내역이 없습니다)\n";
        } else {
            for (var i = 0; i < myLottos.length; i++) {
                var nums = myLottos[i];
                var line = (i + 1) + ") " + nums.join(", ");
                if (isAfterDraw && winNums.length > 0) {
                    var matchCount = 0;
                    for(var j=0; j < nums.length; j++) {
                        if (winNums.indexOf(nums[j]) !== -1) matchCount++;
                    }
                    if (matchCount === 3) line += " 🥇1등!";
                    else if (matchCount === 2) line += " 🥈2등!";
                    else if (matchCount === 1) line += " 🥉3등!";
                }
                result += line + "\n";
            }
        }

        result += "\n[당일 당첨 번호]\n";
        if (isAfterDraw) {
            if (winNums.length > 0) result += "🏆 " + winNums.join(", ");
            else result += "🏆 집계 중입니다.";
        } else {
            result += "🏆 아직 추첨 전입니다.";
        }
        result += "\n━━━━━━━━━━━━━━━\n💡 [가이드]: 구매: [/구매 5]";
        replier.reply(result);
        return true;
    }
}

//==========섹터29==========

/**
 * [독립형] 방치형 광산 시스템 로직 구현부 (누적 시간 및 성취 칭호 통합 버전)
 * 설명: 섹터 46(구 섹터 27 호출부)에서 호출되며, 광산 시작/정보/종료 및 보상 정산 로직을 수행합니다.
 * 반영 사항: 유물 조각 5단계 칭호 체계 적용 (도굴왕만 전용 아이콘 [⚜️] 부여)
 */
function _handleMiningLogic(msg, user, data, replier, roomName, targetUid) {
    var roomData = data.rooms[roomName]; 

    // 1. 광산 시작
    if (msg === "/광산시작") {
        var stateRes = util_checkUserState(user, targetUid);
        if (!stateRes.canAction) {
            replier.reply(formatError(user, "입장 불가", stateRes.reason));
            return true; // [수정] true를 명시적으로 반환하여 중복 출력 차단
        }

        user.mining = { active: true, startTime: Date.now(), room: roomName };
        replier.reply(formatCommand("⛏️ 광산 입성", user, "광산에서 채굴을 시작했습니다.\n채굴 중에는 도박, 주식, 도둑질 등 수익형 활동이 제한됩니다.", "종료: [/광산종료]"));
        safeSaveData(data);
        return true;
    }

    // 2. 광산 정보 (누적 채굴 시간 표시 추가)
    if (msg === "/광산정보") {
        if (!user.mining || !user.mining.active) {
            replier.reply(formatError(user, "상태 오류", "현재 광산에서 작업 중이 아닙니다."));
            return true;
        }

        var durationMin = Math.floor((Date.now() - user.mining.startTime) / 60000);
        var totalMin = (user.totalMiningTime || 0) + durationMin;
        
        // [가상 정부] 현재 정책 배율 로드
        var pol = util_getActivePolicy(roomData);
        var multiplier = util_getEcoMultiplier(roomName) * (pol.mineMult || 1.0);

        var hasDebt = (user.loan && Number(user.loan.debt) > 0);
        if (!hasDebt && roomData.loanContracts) {
            for (var cid in roomData.loanContracts) {
                if (roomData.loanContracts[cid].borrowerUid === targetUid) { hasDebt = true; break; }
            }
        }
        if (hasDebt) multiplier *= 1.5;

        var basePrice = SYSTEM_CONFIG.ECO.MINE.BASE_PER_MIN; 
        var estimatedEarn = Math.floor(durationMin * basePrice * multiplier);

        var infoBody = "\n채굴 진행: " + durationMin + "분째...\n" +
                       "📈 누적 채굴: " + fp(totalMin) + "분 경과\n" +
                       "💰 예상 기본수익: +" + fp(estimatedEarn) + "P\n" +
                       "⚖️ 정책 효과: x" + (pol.mineMult || 1.0).toFixed(1) + " (적용 중)\n\n" +
                       "✨ 광물 발견 수익은 종료 시 합산됩니다.";

        replier.reply(formatCommand("⛏️ 광산 진행 현황", user, infoBody, "종료 및 정산은 [/광산종료]"));
        return true;
    }

    // 3. 광산 종료 (유물 5단계 칭호 정산 및 누적 시간 반영)
    if (msg === "/광산종료") {
        if (!user.mining || !user.mining.active) {
            replier.reply(formatError(user, "상태 오류", "현재 작업 중이지 않습니다."));
            return true;
        }

        // [v5.9] 통합 상태 가드: 징역형 선고 시 즉시 퇴거 처리
        var stateRes = util_checkUserState(user, targetUid);
        if (!stateRes.canAction && stateRes.reason.indexOf("징역") !== -1) {
            user.mining.active = false; 
            safeSaveData(data);
            return replier.reply(formatError(user, "검거 확인", "징역형 선고로 인해 광산에서 강제 퇴거되었습니다."));
        }

        var now = Date.now();
        var durationMin = Math.floor((now - user.mining.startTime) / 60000); 

        if (durationMin < 1) {
            user.mining.active = false; 
            safeSaveData(data);
            replier.reply(formatCommand("⛏️ 광산 퇴거", user, "채굴 시간이 너무 짧아 수익이 발생하지 않았습니다.\n(최소 1분 이상 유지 필요)", "다시 시작: [/광산시작]"));
            return true;
        }

        // [가상 정부] 현재 정책 배율 로드 및 적용
        var pol = util_getActivePolicy(roomData);
        var multiplier = util_getEcoMultiplier(roomName) * (pol.mineMult || 1.0);

        var hasDebt = (user.loan && Number(user.loan.debt) > 0);
        if (!hasDebt && roomData.loanContracts) {
            for (var cid in roomData.loanContracts) {
                if (roomData.loanContracts[cid].borrowerUid === targetUid) { hasDebt = true; break; }
            }
        }
        if (hasDebt) multiplier *= 1.5;

        var basePrice = SYSTEM_CONFIG.ECO.MINE.BASE_PER_MIN;
        var conf = SYSTEM_CONFIG.ECO.MINE;
        var totalEarn = 0;
        var copperCount = 0, goldCount = 0, diaCount = 0;
        var artifactFound = 0;

        for (var i = 0; i < durationMin; i++) {
            var rand = Math.random();
            // [채굴왕] 기본 포인트 20% 상승
            var miningBonus = (user.title === "채굴왕") ? 1.2 : 1.0;
            var minIncome = basePrice * multiplier * miningBonus;

            // [도굴왕] 발견 확률 20% 상승 (상대적 상승)
            var luck = (user.title === "도굴왕") ? 1.2 : 1.0;
            
            if (rand < (conf.DIA_PROB * luck)) { 
                diaCount++; 
                totalEarn += (minIncome * conf.DIA_MULT); 
            } 
            else if (rand < ((conf.DIA_PROB + conf.GOLD_PROB) * luck)) { 
                goldCount++; 
                totalEarn += (minIncome * conf.GOLD_MULT); 
            } 
            else if (rand < ((conf.DIA_PROB + conf.GOLD_PROB + conf.COPPER_PROB) * luck)) { 
                copperCount++; 
                totalEarn += (minIncome * conf.COPPER_MULT); 
            }
            else { 
                // 4. 일반 돌덩이 판정 (나머지 91.5%)
                totalEarn += minIncome; 
            }

            if (Math.random() < (conf.ARTIFACT_CHANCE || 0.0005)) {
                artifactFound++;
            }
        }

        totalEarn = Math.floor(totalEarn);
        var borrowerUid = targetUid || user.uid; 
        var res = processRepayment(user, totalEarn, borrowerUid, roomName); 
        
        // [v5.9] 게이트웨이 통합: "채굴" 키워드로 국고(bankReserve)에서 수익금 방출 및 기록
        util_updatePoint(user, roomData, Number(res.actualGain), "광산 채굴 정산", roomName);

        var nextMiningTime = Number(user.totalMiningTime || 0) + durationMin;
        util_setData(user, 'totalMiningTime', nextMiningTime, "광산 채굴 시간 합산", roomName);

        var nextArtifacts = Number(user.artifactPieces || 0) + artifactFound;
        util_setData(user, 'artifactPieces', nextArtifacts, "유물 조각 획득", roomName);

        var replierStub = { reply: function(m) { Api.replyRoom(roomName, m); } };

        // 3. 채굴 시간 칭호 체크
        if (user.totalMiningTime >= 10000) {
            util_checkAndAwardTitle(user, replierStub, "채굴왕", 2903, "⛏️", "내리다 광업 관리청", "누적 채굴 10,000분", "[장착 효과]: 광산 채굴 시 분당 획득하는 기본 포인트가 20% 상승합니다.");
        } else if (user.totalMiningTime >= 7000) {
            util_checkAndAwardTitle(user, replierStub, "석공", 2902, "⛏️", "내리다 광업 관리청", "누적 채굴 7,000분", "바위조차 당신의 곡괭이 앞에서는 길을 내어줍니다.");
        } else if (user.totalMiningTime >= 3000) {
            util_checkAndAwardTitle(user, replierStub, "두더지", 2901, "⛏️", "내리다 광업 관리청", "누적 채굴 3,000분", "땅속의 기운과 하나가 되어 묵묵히 길을 뚫고 있습니다.");
        }

        // 4. 유물 조각 칭호 체크
        if (user.artifactPieces >= 50) {
            util_checkAndAwardTitle(user, replierStub, "도굴왕", 2915, "⚜️", "내리다 고고학 연구소", "유물 조각 50개 달성", "[장착 효과]: 광산 채굴 시 희귀 광물(구리/금/다이아) 발견 확률이 20% 상승합니다.", roomName);
        } 
        if (user.artifactPieces >= 40) {
            util_checkAndAwardTitle(user, replierStub, "트레저헌터", 2914, "💎", "내리다 고고학 연구소", "유물 조각 40개 달성", "전설의 보물을 찾아 전 세계를 누비는 탐험가입니다.", roomName);
        } 
        if (user.artifactPieces >= 30) {
            util_checkAndAwardTitle(user, replierStub, "발굴가", 2913, "🏺", "내리다 고고학 연구소", "유물 조각 30개 달성", "역사의 파편을 맞춰나가며 신비를 밝히고 있습니다.", roomName);
        } 
        if (user.artifactPieces >= 20) {
            util_checkAndAwardTitle(user, replierStub, "탐사원", 2912, "🔍", "내리다 고고학 연구소", "유물 조각 20개 달성", "유적의 흔적들이 보이기 시작합니다.", roomName);
        } 
        if (user.artifactPieces >= 10) {
            // [복구 대상] 10개 획득 시 도굴꾼 칭호 부여
            util_checkAndAwardTitle(user, replierStub, "도굴꾼", 2911, "🧤", "내리다 고고학 연구소", "유물 조각 10개 달성", "드디어 첫 번째 유물 칭호를 획득하셨습니다.", roomName);
        }

        user.mining.active = false;
        // [통합 메시지 조립 시작]
        var repayInfo = res.repayMsg ? "\n\n" + res.repayMsg : "";
        var finalOutput = "⛏️ 채굴 결과\n━━━━━━━━━━━━━━━\n" + getDisplayName(user) + "님\n\n";
        
        finalOutput += "⛏️ 채굴 시간: " + durationMin + "분\n" +
                       "🟫 구리 " + copperCount + "회 🗂️ 황금 " + goldCount + "회\n" +
                       "💎 다이아 " + diaCount + "회\n\n" +
                       "💰 채굴 수익: " + fp(totalEarn) + "P" + repayInfo;

        if (artifactFound > 0) {
            // 다음 칭호 목표치 계산 로직
            var pieces = Number(user.artifactPieces || 0);
            var targetGoal = 10;
            if (pieces >= 50) targetGoal = 50;
            else if (pieces >= 40) targetGoal = 50;
            else if (pieces >= 30) targetGoal = 40;
            else if (pieces >= 20) targetGoal = 30;
            else if (pieces >= 10) targetGoal = 20;
            else targetGoal = 10;

            finalOutput += "\n\n✨ [내리다 고고학 연구소: 유물 발견] ✨\n" +
                           "━━━━━━━━━━━━━━━\n" +
                           "심상치 않은 기운의 조각을 발견했습니다!\n\n" +
                           "🧩 유물 조각 획득 (+" + artifactFound + ")\n" +
                           "현재 보유 " + pieces + " / " + targetGoal + " 개";
        }

        finalOutput += "\n━━━━━━━━━━━━━━━\n💡 [가이드]: 내 잔액: " + fP(user.point) + "P";
                                          
        replier.reply(finalOutput);
        safeSaveData(data);
        return true;
    }
}

//==========섹터30==========

/**
 * [전역 독립 함수] 상점 아이템 효과 처리 엔진
 * 기능: 구매한 아이템의 효과 발동 및 중앙은행 재원 정산
 * 수정 사항: [Gemini 요청 사항] 수집대마왕 판정 로직을 "보유+분해 누적" 및 "전종 수집" 기준으로 정밀화
 */
function _handleShopEffect(item, user, roomName, replier, data, targetUid, finalPrice, isUsingTicket, quantity) {
    var roomData = data.rooms[roomName];
    if (!roomData) return;
    
    // 수량이 전달되지 않은 경우 기본값 1 설정
    var qty = (quantity !== undefined && quantity !== null) ? quantity : 1;

    // 중앙은행 재원 초기화 (기본 10,000P)
    if (roomData.bankReserve === undefined || roomData.bankReserve === null) {
        roomData.bankReserve = 10000;
    }
    
    /* [1. 자산 정산] 이용권 차감 로직 (유저님의 기존 사유 문구 보존) */
    if (isUsingTicket && item.effect === "randomBox") {
        var currentTickets = Number(user.boxTickets || 0);
        // 구매 수량(qty)만큼 차감하되, 보유량보다 많이 뺄 수 없도록 제한
        var ticketsToUse = Math.min(qty, currentTickets); 
        util_setData(user, 'boxTickets', currentTickets - ticketsToUse, "랜덤박스 이용권 사용", roomName);
    }

    /* [Gemini 요청 사항] 수집대마왕 판정 함수 - 전종 수집(보유+분해) 체크 */
    var checkCollectionMaster = function() {
        // 1. 상점 판매 아이콘 추출
        var shopIcons = SHOP_ITEMS.filter(function(it) { return it.effect === "icon"; }).map(function(it) { return it.icon; });
        
        // 2. 랜덤 박스 모든 아이콘 추출
        var boxIcons = [];
        if (RANDOM_BOX_CONFIG && RANDOM_BOX_CONFIG.PROBS) {
            RANDOM_BOX_CONFIG.PROBS.forEach(function(grade) {
                if (grade.items) boxIcons = boxIcons.concat(grade.items);
            });
        }
        
        // 3. 중복 제거된 전체 고유 아이콘 목록 생성
        var allUniqueIcons = {};
        shopIcons.concat(boxIcons).forEach(function(icon) {
            if (icon) allUniqueIcons[icon] = true;
        });
        
        var totalTargetCount = Object.keys(allUniqueIcons).length;
        
        // 4. 유저의 누적 수집 기록(collectedIcons)과 비교 판정
        if (user.collectedIcons && user.collectedIcons.length >= totalTargetCount) {
            
            var replierStub = { reply: function(m) { Api.replyRoom(roomName, m); } };
            util_checkAndAwardTitle(user, replierStub, "수집대마왕", 3001, "🏵️", "내리다 만물 상업 연합", "모든 아이콘 수집 완료", "[장착 효과]: 모든 상점 물품 구매 시 15% 상시 할인이 적용됩니다.");
        }
    };

    /* [2. 아이템 효과별 실행 로직] */

    // 0. 스피또 복권 처리 로직
    if (item.effect === "spitto") {
        var conf = SYSTEM_CONFIG.ECO.SPITTO;
        var totalPrize = 0;
        var results = { rank1: 0, rank2: 0, rank3: 0, rank4: 0, fail: 0 };

        var earnedLetters = 0; // 이번 구매에서 획득한 편지 총수

        for (var i = 0; i < qty; i++) {
            var rand = Math.random();
            if (rand < conf.PROBS.RANK1) { results.rank1++; totalPrize += conf.PRIZES.RANK1; }
            else if (rand < conf.PROBS.RANK2) { results.rank2++; totalPrize += conf.PRIZES.RANK2; }
            else if (rand < conf.PROBS.RANK3) { results.rank3++; totalPrize += conf.PRIZES.RANK3; }
            else if (rand < conf.PROBS.RANK4) { results.rank4++; totalPrize += conf.PRIZES.RANK4; }
            else { 
                results.fail++; 
                // [개별 확률 적용] 낙첨된 복권 한 장당 20% 확률로 편지 카운트
                if (Math.random() < 0.2) earnedLetters++; 
            }
        }

        // 편지 데이터 반영 및 부적 변환 체크
        var letterMsg = "";
        if (earnedLetters > 0) {
            user.lottoFailCount = (user.lottoFailCount || 0) + earnedLetters;
            letterMsg = "\n\n📩 낙첨 위로의 편지 " + earnedLetters + "장 획득!";
            
            // 15장 마다 부적으로 변환 (while문으로 다량 획득 대응)
            while (user.lottoFailCount >= 15) {
                user.lottoFailCount -= 15;
                user.luckyCharmEnd = Date.now() + 3600000; // 1시간
                user.inventory.push({ id: 888, name: "행운의부적", icon: "🔮", effect: "item", title: "행운의부적" });
                letterMsg += "\n✨ 편지 15장이 모여 [행운의부적]이 완성되었습니다! (현재 잔여: " + user.lottoFailCount + "장)";
            }
            if (user.lottoFailCount > 0 && user.lottoFailCount < 15) {
                letterMsg += "\n(현재 수집 현황: " + user.lottoFailCount + "/15)";
            }
        }

        var res = processRepayment(user, totalPrize, targetUid, roomName);
        util_updatePoint(user, roomData, Number(res.actualGain), "스피또 당첨금", roomName);

        var body = "🧧 스피또 " + qty + "매 개봉 결과\n\n";
        if (totalPrize > 0) {
            body += "🎊 총 당첨금: " + fp(totalPrize) + "P\n";
            if (results.rank1 > 0) body += "⭐ 1등: " + fp(conf.PRIZES.RANK1) + "회\n";
            if (results.rank2 > 0) body += "🥈 2등: " + fp(conf.PRIZES.RANK2) + "회\n";
            body += "🥉 기타 등수: " + (results.rank3 + results.rank4) + "회 당첨";
        } else {
            body += "💀 아쉽게도 모두 꽝입니다...";
        }
        
        replier.reply(formatCommand("🎰 스피또 결과", user, body + letterMsg + (res.repayMsg || ""), "내 잔액: " + fp(user.point) + "P"));
    }
    
    // 1. 랜덤 아이콘 박스 처리 (메시지 테이블 및 중복 조각 지급 포함)
    if (item.effect === "randomBox") {
        var resSummary = {
            newIcons: [],
            duplicates: 0,
            earnedFrags: 0,
            earnedTickets: 0,
            highestIdx: -1,
            counts: {}
        };

        var msgTable = {
            0: { title: "🎁 랜덤 아이콘 박스 개봉", desc: "먼지만 쌓인 창고에서 잡동사니를 발견했습니다." },
            1: { title: "🎁 랜덤 아이콘 박스 개봉", desc: "나쁘지 않네요! 싱그러운 아이콘들이 보입니다." },
            2: { title: "🎁 랜덤 아이콘 박스 개봉", desc: "오! 빛나는 아이템입니다. 희귀한 가치가 느껴지네요!" },
            3: { title: "🎊 에픽 아이템 획득! 🎊", desc: "와우! 대단한 운입니다. 화려한 에픽 아이콘이 포함되었습니다!" },
            4: { title: "✨ [전설급] 유니크 등장! ✨", desc: "믿기지 않는 행운! 신화 속에서나 보던 유니크가 등장했습니다!" },
            5: { title: "🔥 [초비상] 레전더리 강림! 🔥", desc: "축하합니다! 서버 최상위 확률을 뚫고 레전더리를 획득했습니다!" }
        };

        for (var i = 0; i < qty; i++) {
            var rand = Math.random();
            var cumulative = 0;
            var resultIdx = 0;
            for (var g = 0; g < RANDOM_BOX_CONFIG.PROBS.length; g++) {
                cumulative += RANDOM_BOX_CONFIG.PROBS[g].prob;
                if (rand < cumulative) { resultIdx = g; break; }
            }
            if (resultIdx > resSummary.highestIdx) resSummary.highestIdx = resultIdx;
            var resGrade = RANDOM_BOX_CONFIG.PROBS[resultIdx];
            resSummary.counts[resGrade.grade] = (resSummary.counts[resGrade.grade] || 0) + 1;
            var winIcon = resGrade.items[Math.floor(Math.random() * resGrade.items.length)];
            if (!user.collectedIcons) user.collectedIcons = [];
            var isDuplicate = (user.collectedIcons.indexOf(winIcon) !== -1);
            if (isDuplicate) {
                resSummary.duplicates++;
                util_setData(user, 'boxFragments', (user.boxFragments || 0) + 1, "박스 조각 획득", roomName);
                resSummary.earnedFrags++;
                if (user.boxFragments >= 5) {
                    util_setData(user, 'boxFragments', user.boxFragments - 5, "조각 변환 차감", roomName);
                    util_setData(user, 'boxTickets', (user.boxTickets || 0) + 1, "랜덤박스 이용권 획득", roomName);
                    resSummary.earnedTickets++;
                }
            } else {
                user.inventory.push({ id: 900 + resultIdx, name: resGrade.grade.split(" ")[0] + " 아이콘", icon: winIcon, effect: "icon", title: "" });
                user.collectedIcons.push(winIcon);
                resSummary.newIcons.push("[" + winIcon + "]");
            }
        }

        var mData = msgTable[Math.max(0, resSummary.highestIdx)];
        var body = (qty > 1) ? "📦 랜덤박스 " + qty + "개 일괄 개봉 결과\n" : "등급: " + RANDOM_BOX_CONFIG.PROBS[resSummary.highestIdx].icon + " " + RANDOM_BOX_CONFIG.PROBS[resSummary.highestIdx].grade + "\n";
        
        if (resSummary.newIcons.length > 0) body += "\n✨ [신규 획득]\n" + resSummary.newIcons.join(", ") + "\n";
        if (resSummary.duplicates > 0) {
            body += "\n♻️ [중복 당첨]: " + resSummary.duplicates + "회\n" + "🧩 조각 획득: +" + resSummary.earnedFrags + "개\n";
            if (resSummary.earnedTickets > 0) body += "🎫 이용권 변환: +" + resSummary.earnedTickets + "매\n";
            body += "📊 현재 조각: " + user.boxFragments + " / 5 개\n";
        }
        if (qty > 1) {
            body += "\n[등급별 상세 내역]";
            for (var gName in resSummary.counts) { body += "\n• " + gName + ": " + resSummary.counts[gName] + "회"; }
        } else if (resSummary.newIcons.length > 0) {
            body += "\n결과: " + resSummary.newIcons[0];
        }

        replier.reply(formatCommand(mData.title, user, body + "\n\n\"" + mData.desc + "\"", "내 잔액: " + fp(user.point) + "P"));
        checkCollectionMaster();
    } 
    
    // 2. [복구] 게임 판수 인증권 처리 (단권 처리)
    else if (item.effect === "gameAuth") {
        user.gameAuthCount = (user.gameAuthCount || 0) + 1;
        user.purchasedAuthCount = (user.purchasedAuthCount || 0) + 1;
        replier.reply(formatCommand("🎫 인증권 사용 완료", user, "게임 판수 인증이 기록되었습니다.\n현재 인증 횟수: " + user.gameAuthCount + "/2", "시즌당 구매: " + user.purchasedAuthCount + "/2"));
    } 
    
    // 3. [핵심 수정] 로또 구매 (방별 독립 상태 저장소 사용)
    else if (item.effect === "lotto") {
        var currentHour = new Date().getHours();
        if (currentHour >= 21) {
            util_updatePoint(user, roomData, finalPrice, "로또 구매 불가 환불", roomName);
            replier.reply(formatError(user, "구매 불가", "로또 판매가 마감되었습니다.\n(판매 시간: 00:00 ~ 20:59)\n\n💰 결제 금액이 환불되었습니다."));
            return;
        }

        // [수정] 전역 변수가 아닌 roomData 내의 states에 접근하여 할당
        if (roomData.features && roomData.features.states) {
            roomData.features.states.lottoPurchase[targetUid] = { time: Date.now(), price: finalPrice };
            replier.reply(formatCommand("🎫 로또 번호 입력", user, "1~15 사이의 숫자 3개를 입력해주세요.\n(예: 1 5 10)", "취소: [취소]"));
        } else {
            replier.reply(formatError(user, "시스템 오류", "로또 상태 저장소를 찾을 수 없습니다."));
        }
    }
    
    // 4. 상점 일반 아이콘 구매 처리
    else if (item.effect === "icon") {
        user.inventory.push({ id: item.id, name: item.name, icon: item.icon, effect: item.effect, title: "" });
        
        var isNewIcon = false;
        if (!user.collectedIcons) user.collectedIcons = [];
        if (user.collectedIcons.indexOf(item.icon) === -1) {
            user.collectedIcons.push(item.icon);
            isNewIcon = true;
        }
        user.icon = item.icon;
        replier.reply(formatCommand("🛒 구매 완료", user, item.name + " 구매 및 장착 성공!", "장착 변경: [/가방]"));

        /* [신규 수집 발생] 칭호 판정 호출 (Gemini 요청 사항 반영) */
        if (isNewIcon) checkCollectionMaster();
    }
    
    // 5. 기타 소모성 아이템 처리 (수량 qty 반영)
    else if (item.effect === "promotion") {
        user.purchasedPromotionAttempts = (user.purchasedPromotionAttempts || 0) + qty;
        replier.reply(formatCommand("🛒 구매 완료", user, item.name + " x" + qty + " 구매 성공!", "남은 승급 기회: " + (user.dailyPromotionAttempts + user.purchasedPromotionAttempts)));
    } else if (item.effect === "tierGuard") {
        user.tierGuard = (user.tierGuard || 0) + qty;
        replier.reply(formatCommand("🛒 구매 완료", user, item.name + " x" + qty + " 구매 성공!", "보유 방어권: " + user.tierGuard + "개"));
    } else if (item.effect === "credit") {
        var totalRestore = (item.value || 50);
        user.creditScore = Math.min(1000, (user.creditScore || 600) + totalRestore);
        user.dailyCreditRestoreCount = (user.dailyCreditRestoreCount || 0) + 1;
        if (typeof checkAndHandleDefaulter === 'function') checkAndHandleDefaulter(user, roomName);
        replier.reply(formatCommand("🛒 구매 완료", user, item.name + " 사용 성공! (신용 +50)", "현재 점수: " + user.creditScore));
    }

    /* [신규: Gemini 요청 사항] 경고삭제권(warnClear) 구매 완료 처리 */
    else if (item.effect === "warnClear") {
        user.boughtWarningRemoval = true;
        // 실제 경고(경고 카운트 등)가 존재한다면 여기서 초기화 로직을 수행합니다.
        if (user.warningCount !== undefined) user.warningCount = 0; 
        
        replier.reply(formatCommand("🎫 경고삭제권 사용 완료", user, "경고삭제권 구매 및 사용이 성공적으로 완료되었습니다.\n(평생 1회 사용 기록 완료)", "내 잔액: " + fp(user.point) + "P"));
    }

    safeSaveData(data);
}

//==========섹터31==========

/**
 * [관리자 명령어 분배기] (Admin Logic Dispatcher - Registry Refactored)
 * 설명: 관리자 명령어의 통합 진입점입니다. 
 * 섹터 1의 ADMIN_COMMANDS 레지스트리를 참조하여 등록된 로직을 자동으로 매핑 및 실행합니다.
 */
function _handleAdminLogic(msg, user, data, replier, roomName, targetUid, sender) {
    // 1. 명령어 첫 단어 추출 (예: "/재원수정 1000" -> "/재원수정")
    var cmd = msg.split(" ")[0]; 

    // 2. 관리자 명령어 레지스트리(ADMIN_COMMANDS)에서 해당 명령어 검색
    // 섹터 6에서 등록된 매핑 정보를 바탕으로 최적화된 O(1) 탐색을 수행합니다.
    if (ADMIN_COMMANDS[cmd] && typeof ADMIN_COMMANDS[cmd].execute === 'function') {
        
        // 3. 등록된 하위 로직 함수(섹터 35~38 등)를 즉시 실행 및 결과 반환
        // 실행 시 필요한 모든 컨텍스트 객체를 인자로 전달합니다.
        return ADMIN_COMMANDS[cmd].execute(msg, user, data, replier, roomName, targetUid);
    }

    // 4. 처리된 명령어가 없거나 등록되지 않은 경우 false 반환
    return false; 
}

//==========섹터32==========

/**
 * [관리자 하위 모듈 1] 시스템 기본 제어 및 권한 관리
 * 기능: 도움말, 봇구동, 강제재가동, 도박제한, 관리자 등록/해제
 */
function _adminSystemLogic(msg, user, data, replier, roomName) {

    /* 관리자 도움말 */
    if (msg === "/관리자") {
        var list = [];
        for(var i=0; i<ADMIN_CMD_LIST.length; i++) {
            list.push(ADMIN_CMD_LIST[i]);
        }
        replier.reply(formatAdmin("관리자 명령어 목록", list.join("\n")));
        return true;
    }

    /* 시스템 구동 제어 */
    if (msg.indexOf("/봇구동 ") === 0) {
        var state = msg.split(" ")[1];
        data.botActive = (state === "온");
        safeSaveData(data);
        replier.reply(formatAdmin("시스템 설정", "봇 구동 상태: [" + state + "]"));
        return true;
    }

    /* 시스템 강제 재가동 (락 해제) */
    if (msg === "/강제재가동") {
        if (lock.isLocked()) lock.unlock();
        replier.reply(formatAdmin("완료", "시스템 락 해제 및 동기화 완료"));
        return true;
    }

    /* 도박 제한 설정 */
    if (msg.indexOf("/도박제한 ") === 0) {
        var sw = msg.split(" ")[1]; 
        data.gambleLimit = (sw === "온");
        safeSaveData(data);
        replier.reply(formatAdmin("설정", "도박 제한 상태: [" + sw + "]"));
        return true;
    }

    /* 관리자 등록 */
    if (msg.indexOf("/관리자등록 ") === 0) {
        var target = msg.substring(7).trim();
        if (!data.admins) data.admins = ["관리자"];
        if (data.admins.indexOf(target) !== -1) { 
            replier.reply(formatAdmin("관리자 등록 알림", "이미 관리자로 등록되어 있는 닉네임입니다.")); 
            return true; 
        }
        data.admins.push(target);
        safeSaveData(data);
        replier.reply(formatAdmin("관리자 등록 완료", "[" + target + "]님을 부관리자로 등록했습니다."));
        return true;
    }

    /* 관리자 해제 */
    if (msg.indexOf("/관리자해제 ") === 0) {
        var target = msg.substring(7).trim();
        if (target === "95 남 광어") { 
            replier.reply(formatAdmin("오류", "최상위 관리자 권한은 해제할 수 없습니다.")); 
            return true; 
        }
        if (!data.admins) data.admins = ["관리자"];
        var idx = data.admins.indexOf(target);
        if (idx === -1) { 
            replier.reply(formatAdmin("오류", "해당 닉네임을 관리자 명단에서 찾을 수 없습니다.")); 
            return true; 
        }
        data.admins.splice(idx, 1);
        safeSaveData(data);
        replier.reply(formatAdmin("관리자 해제 완료", "[" + target + "]님을 관리자 권한에서 제외했습니다."));
        return true;
    }

    /* 관리자 목록 */
    if (msg === "/관리자목록") {
        var list = data.admins || ["관리자"];
        replier.reply(formatAdmin("현재 관리자 명단", "• " + list.join("\n• ")));
        return true;
    }

    return false; // 처리된 명령어가 없음
}

//==========섹터33==========

/**
 * [관리자 하위 모듈 2] 로그 및 제보 관리
 * 기능: 버그 제보 확인/삭제, 오류 로그 확인/삭제, 관리자 활동 로그 조회
 */
function _adminLogLogic(msg, user, data, replier) {

    /* 버그 제보 목록 확인 */
    if (msg === "/제보목록") {
        var list = FileStream.read(BUG_LOG_PATH);
        if (!list || list.trim() === "") replier.reply(formatAdmin("제보 내역", "접수된 버그 제보가 없습니다."));
        else replier.reply(formatAdmin("📂 버그 제보 목록", list.trim()));
        return true;
    }

    /* 버그 제보 초기화 */
    if (msg === "/제보초기화") {
        FileStream.remove(BUG_LOG_PATH);
        replier.reply(formatAdmin("완료", "버그 제보 내역을 모두 삭제했습니다."));
        return true;
    }

    /* 오류 로그 확인 */
    if (msg === "/오류로그") {
        var list = FileStream.read(ERROR_LOG_PATH);
        if (!list || list.trim() === "") replier.reply(formatAdmin("오류 로그", "기록된 시스템 오류가 없습니다."));
        else replier.reply(formatAdmin("⚠️ 시스템 오류 로그", list.trim()));
        return true;
    }

    /* 오류 로그 초기화 */
    if (msg === "/오류초기화") {
        FileStream.remove(ERROR_LOG_PATH);
        replier.reply(formatAdmin("완료", "오류 로그를 모두 삭제했습니다."));
        return true;
    }

    /* 관리자 활동 로그 */
    if (msg === "/관리자로그") {
        var logs = data.adminLogs || [];
        replier.reply(formatAdmin("활동 로그", logs.slice(-10).join("\n") || "기록 없음"));
        return true;
    }

    return false;
}

//==========섹터34==========

/**
 * [관리자 하위 모듈 3] 유저 데이터 관리
 * 기능: 유저 조회, 수정, 삭제, 복원, 데이터 이전, 닉네임 기록, 신용 조정, 칭호 회수
 * 수정 사항: [Gemini 요청 사항] 오류 지급 칭호 박탈을 위한 /칭호회수 명령어 추가
 */
function _adminUserManageLogic(msg, user, data, replier, roomName, targetUid) {

    if (msg.indexOf("/진단 ") === 0) {
        var tn = msg.substring(4).trim();
        var roomData = data.rooms[roomName];
        var found = findUserByName(roomData, tn);

        if (found.length === 0) {
            replier.reply("❌ [" + tn + "] 유저를 찾을 수 없습니다.");
            return true;
        }

        // [식별 개선] 검색된 유저가 여러 명일 경우 목록과 ID를 먼저 출력
        if (found.length > 1) {
            var multiList = found.map(function(f, i) { 
                return (i+1) + ". " + f.data.name + " (" + fp(f.data.point) + "P)\n   └ ID: " + f.id; 
            }).join("\n\n");
            replier.reply(formatAdmin("🔍 중복 유저 식별", "방 안에 동일 닉네임 데이터가 " + found.length + "개 발견되었습니다.\n상세 진단은 정확한 풀네임을 입력하세요.\n\n" + multiList));
            return true;
        }

        var t = found[0].data;
        var tId = found[0].id;
        var rFeatures = roomData.features;
        var st = rFeatures.states;
        var now = Date.now();

        var report = "🔍 [" + tn + "] 유저 정밀 진단 보고서\n" +
                     "📌 고유 ID: " + tId + "\n" + // ID 상단 배치
                     "━━━━━━━━━━━━━━━\n\n";
        
        // 1. 스팸 분석
        var isSpam = (t.timeoutEndTime && now < t.timeoutEndTime);
        report += "[🚫 스팸 및 시스템 제한]\n" +
                  "• 필터: " + (isSpam ? "차단됨 (제한 중)" : "정상") + " (Timeout: " + (isSpam ? Math.ceil((t.timeoutEndTime - now)/1000) : 0) + ")\n\n";

        // 2. 활동 분석
        report += "[⛓️ 구속 및 강제 활동]\n" +
                  "• 징역: " + (t.jailReleaseTime && now < t.jailReleaseTime ? "수감 중 (" + Math.ceil((t.jailReleaseTime - now)/60000) + "분)" : "정상 (잔여: 0분)") + "\n\n";

        // 3. 논리적 대기 상태 (모든 State 주머니 스캔)
        report += "[⏳ 논리적 대기 상태]\n";
        report += "• 메뉴: " + (st.menuWait[tId] ? "선택 대기 중" : "없음") + "\n";
        report += "• 은행/상점: " + (st.bankProcess[tId] ? "수량 입력 대기 중 (꼬임 발생 가능!)" : "없음") + "\n";
        report += "• 로또: " + (st.lottoPurchase[tId] ? "번호 입력 중" : "없음") + "\n";
        report += "• 중복선택: " + (st.selectWait[tId] ? "유저 선택 대기 중 (확인 필요)" : "없음") + "\n";
        report += "• 사채등록: " + (st.loanRegister[tId] ? "등록 절차 진행 중" : "없음") + "\n\n";

        // 4. 데이터 무결성 점검
        report += "[🛠️ 데이터 무결성 점검]\n";
        var isInvOk = Array.isArray(t.inventory);
        var isLoanOk = (t.loan && typeof t.loan === 'object');
        var lastStat = t.lastAction ? t.lastAction.status : "NONE";
        
        // NaN/Infinite 연산 결함 체크 (추가 꼬임 방지)
        var isCalcOk = (!isNaN(t.point) && isFinite(t.point) && !isNaN(t.bank));

        report += "• 인벤토리: " + (isInvOk ? "정상 (Array 확인)" : "❗파손") + "\n";
        report += "• 대출객체: " + (isLoanOk ? "정상 (Object 확인)" : "❗누락") + "\n";
        report += "• 직전작업: " + lastStat + " (" + (t.lastAction ? t.lastAction.cmd : "로직 중단 의심") + ")\n";
        report += "• 연산결함: " + (isCalcOk ? "정상 (NaN/Infinite 없음)" : "❗결함발견") + "\n";

        report += "━━━━━━━━━━━━━━━\n" +
                  "💡 진단: ";
        
        if (isSpam) report += "스팸 필터 작동 중.";
        else if (st.menuWait[tId] || st.bankProcess[tId] || st.selectWait[tId]) report += "입력 대기 로직에 갇혀 있습니다. [취소]를 입력하게 하세요.";
        else if (lastStat === "PENDING") report += "로직이 수행 중 멈췄습니다. 시스템 재가동을 권장합니다.";
        else if (!isCalcOk) report += "포인트 변수가 오염되었습니다. 관리자 수정이 필요합니다.";
        else report += "데이터상 정상입니다. 특정 유저만 안 된다면 식별 캐시를 확인하세요.";

        replier.reply(report);
        return true;
    }

    /* 상세 유저 데이터 조회 */
    if (msg.indexOf("/유저데이터 ") === 0) {
        var tn = msg.substring(7).trim();
        var roomData = data.rooms[roomName];
        var found = findUserByName(roomData, tn);
        if (!found.length) replier.reply(formatAdmin("오류", "유저를 찾을 수 없습니다."));
        else if (found.length > 1) handleUserSelection(replier, targetUid, found, "admin_userdata", null, user, roomName);
        else replier.reply(formatAdmin("유저 데이터 조회", JSON.stringify(found[0].data, null, 2)));
        return true;
    }

    /* 닉네임 변경 이력 */
    if (msg.indexOf("/닉네임기록 ") === 0) {
        var tn = msg.substring(7).trim();
        var roomData = data.rooms[roomName];
        var found = findUserByName(roomData, tn);
        if (!found.length) { replier.reply(formatAdmin("오류", "유저를 찾을 수 없습니다.")); return true; }
        if (found.length > 1) { handleUserSelection(replier, targetUid, found, "admin_nick_log", null, user, roomName); return true; }
        var targetId = found[0].id;
        var history = data.nickHistory[targetId] || [];
        if (history.length === 0) { replier.reply(formatAdmin("닉네임 기록", getDisplayName(found[0].data) + "님은 변경 이력이 없습니다.")); return true; }
        var logMsg = [];
        for(var i=0; i<history.length; i++) logMsg.push((i+1) + ". " + history[i].old + " (" + history[i].date + ")");
        replier.reply(formatAdmin("📋 닉네임 변경 이력", "현재: " + found[0].data.name + "\n\n[과거 기록]\n" + logMsg.join("\n")));
        return true;
    }

    /* [신규] 신용 점수 직접 조정 (v5.2) */
    if (msg.indexOf("/신용조정 ") === 0) {
        var ps = msg.split(" ");
        if (ps.length < 3) {
            replier.reply(formatAdmin("오류", "형식: /신용조정 [닉네임] [점수]\n예) /신용조정 홍길동 -50"));
            return true;
        }
        var scoreChange = parseInt(ps.pop());
        var targetName = ps.slice(1).join(" ").trim();
        var roomData = data.rooms[roomName];
        var found = findUserByName(roomData, targetName);

        if (isNaN(scoreChange)) { replier.reply(formatAdmin("오류", "조정할 점수를 숫자로 입력하세요.")); return true; }
        if (!found.length) { replier.reply(formatAdmin("오류", "유저를 찾을 수 없습니다.")); return true; }
        if (found.length > 1) { 
            handleUserSelection(replier, targetUid, found, "admin_credit_edit", { score: scoreChange }, user, roomName);
        return true; 
    }

        var targetUser = found[0].data;
        var oldScore = Number(targetUser.creditScore || 600);
        targetUser.creditScore = Math.min(1000, Math.max(0, oldScore + scoreChange));
        
        if (typeof checkAndHandleDefaulter === 'function') {
            checkAndHandleDefaulter(targetUser, roomName);
        }

        safeSaveData(data);
        var crInfo = getCreditInfo(targetUser.creditScore);
        var resText = "대상: " + getDisplayName(targetUser) + "님\n" +
                      "변동: " + (scoreChange > 0 ? "+" : "") + scoreChange + "점\n" +
                      "현재: " + targetUser.creditScore + "점 (" + crInfo.label + ")";
        
        replier.reply(formatAdmin("⚙️ 신용 점수 조정 완료", resText));
        return true;
    }

    /* [Gemini 요청 사항] 관리자 전용 칭호 회수 로직 (오류 지급분 박탈용) */
    if (msg.indexOf("/칭호회수 ") === 0) {
        var ps = msg.split(" ");
        if (ps.length < 3) {
            replier.reply(formatAdmin("오류", "형식: /칭호회수 [닉네임] [칭호명]"));
            return true;
        }
        var titleToTake = ps.pop().trim();
        var targetName = ps.slice(1).join(" ").trim();
        var roomData = data.rooms[roomName];
        var found = findUserByName(roomData, targetName);

        if (!found.length) { replier.reply(formatAdmin("오류", "유저를 찾을 수 없습니다.")); return true; }
    if (found.length > 1) {
        handleUserSelection(replier, targetUid, found, "admin_title_take", { title: titleToTake }, user, roomName);
        return true;
    }

        var targetUser = found[0].data;
        var inv = targetUser.inventory || [];
        var removed = false;

        // 1. 인벤토리(가방)에서 해당 칭호 삭제
        targetUser.inventory = inv.filter(function(it) {
            if (it.effect === "title" && (it.title === titleToTake || it.name.indexOf(titleToTake) !== -1)) {
                removed = true;
                return false;
            }
            return true;
        });

        // 2. 현재 장착 중인 경우 해제
        if (targetUser.title === titleToTake) {
            targetUser.title = "";
            removed = true;
        }

        if (removed) {
            safeSaveData(data);
            replier.reply(formatAdmin("🎖️ 칭호 회수 완료", getDisplayName(targetUser) + "님에게서 [" + titleToTake + "] 칭호를 박탈했습니다."));
        } else {
            replier.reply(formatAdmin("회수 실패", getDisplayName(targetUser) + "님은 해당 칭호를 보유하고 있지 않습니다."));
        }
        return true;
    }

    /* 출석 초기화 */
    if (msg.indexOf("/출석초기화 ") === 0) {
        var tn = msg.substring(7).trim();
        var roomData = data.rooms[roomName];
        var found = findUserByName(roomData, tn);
        if (!found.length) { replier.reply(formatAdmin("오류", "유저를 찾을 수 없습니다.")); return true; }
        if (found.length > 1) { handleUserSelection(replier, targetUid, found, "admin_attend_reset", null, user, roomName); return true; }
        found[0].data.lastDate = "";
        safeSaveData(data);
        replier.reply(formatAdmin("출석 초기화 완료", getDisplayName(found[0].data) + "님의 오늘 출석 기록을 삭제했습니다."));
        return true;
    }

    /* 출석 일수 수정 */
    if (msg.indexOf("/출석일수수정 ") === 0) {
        var ps = msg.split(" "), days = parseInt(ps.pop()), tn = ps.slice(1).join(" ");
        var roomData = data.rooms[roomName];
        var found = findUserByName(roomData, tn);
        if (!found.length) { replier.reply(formatAdmin("오류", "대상 없음")); return true; }
        if (found.length > 1) { handleUserSelection(replier, targetUid, found, "admin_attend_edit", { days: days }, user, roomName); return true; }
        found[0].data.totalAttendance = days; safeSaveData(data);
        replier.reply(formatAdmin("수정 완료", getDisplayName(found[0].data) + ": " + days + "일"));
        return true;
    }

    /* 전체 출석 수정 */
    if (msg.indexOf("/전체출석수정 ") === 0) {
        var days = parseInt(msg.split(" ")[1]);
        for (var r in data.rooms) {
            for (var id in data.rooms[r].users) { data.rooms[r].users[id].totalAttendance = days; }
        }
        safeSaveData(data);
        replier.reply(formatAdmin("완료", "전체 출석 " + days + "일로 고정"));
        return true;
    }

    /* 데이터 이전 */
    if (msg.indexOf("/데이터이전 ") === 0) {
        if (msg.indexOf(" > ") === -1) { replier.reply(formatAdmin("오류", "형식이 올바르지 않습니다.\n예) /데이터이전 구닉네임 > 신닉네임")); return true; }
        var names = msg.substring(7).split(" > ");
        var oldName = names[0].trim();
        var newName = names[1].trim();
        var roomData = data.rooms[roomName];
        
        var oldFound = findUserByName(roomData, oldName);
        var newFound = findUserByName(roomData, newName);

        if (oldFound.length === 0) { replier.reply(formatAdmin("오류", "구 닉네임을 찾을 수 없습니다.")); return true; }
        if (newFound.length === 0) { replier.reply(formatAdmin("오류", "신 닉네임을 찾을 수 없습니다.")); return true; }
        if (oldFound.length > 1 || newFound.length > 1) { replier.reply(formatAdmin("오류", "중복 닉네임이 존재합니다. 정확한 풀네임을 입력해주세요.")); return true; }

        var oldId = oldFound[0].id;
        var oldData = oldFound[0].data;
        var newData = newFound[0].data;

        newData.point = oldData.point;
        newData.bank = oldData.bank;
        newData.tier = oldData.tier;
        newData.creditScore = oldData.creditScore;
        newData.totalAttendance = oldData.totalAttendance;
        newData.loan = oldData.loan;
        newData.stockHoldings = oldData.stockHoldings;
        newData.stockAvg = oldData.stockAvg;
        newData.icon = oldData.icon;
        newData.title = oldData.title;

        if (typeof uidCache !== 'undefined') {
            for (var key in uidCache) {
                if (uidCache[key] === oldId) delete uidCache[key];
            }
        }
        delete roomData.users[oldId];
        safeSaveData(data);
        replier.reply(formatAdmin("데이터 이전 성공", oldName + " ➔ " + newName + "\n모든 자산 및 등급이 이전되었습니다."));
        return true;
    }

    /* 유저 삭제 (사채 전액 보전 및 계약 강제 삭제 적용) */
    if (msg.indexOf("/유저삭제 ") === 0) {
        var tn = msg.substring(6).trim();
        var roomData = data.rooms[roomName];
        var found = findUserByName(roomData, tn);
        if (!found.length) { replier.reply(formatAdmin("오류", "대상 없음")); return true; }
        if (found.length > 1) { handleUserSelection(replier, targetUid, found, "admin_delete", null, user, roomName); return true; }
        
        var targetId = found[0].id;
        var targetData = found[0].data;
        var refundLog = "";
        var refundCount = 0;
        var totalRefunded = 0;

        // [수정] 출석일수 관계없이 모든 사채 계약 강제 정산 및 삭제
        if (roomData.loanContracts) {
            for (var cid in roomData.loanContracts) {
                var c = roomData.loanContracts[cid];
                if (c.borrowerUid === targetId) {
                    var lender = roomData.users[c.lenderUid];
                    if (lender) {
                        var debtAmt = Number(c.currentDebt);
                        util_updatePoint(lender, roomData, debtAmt, "사채 강제 정산", roomName);
                        totalRefunded += debtAmt;
                        refundCount++;
                        try { Api.replyRoom(roomName, "🚬 [사채 강제 정산]\n" + targetData.name + "님의 데이터 삭제로 인해 " + lender.name + "님께 미수금 " + fp(debtAmt) + "P가 전액 반환되었습니다."); } catch(e){}
                    }
                    delete roomData.loanContracts[cid]; // 계약서 강제 파기
                }
            }
        }

        // [신규] 은행 대출금 국고 회수 (폐쇄형 경제 안정화)
        if (targetData.loan && Number(targetData.loan.debt) > 0) {
            var bankDebt = Number(targetData.loan.debt);
            util_updateReserve(roomData, bankDebt, "대출금 국고 회수", roomName);
            refundLog += "\n🏦 은행 대출금 " + fp(bankDebt) + "P가 국고로 자동 회수되었습니다.";
        }

        if (refundCount > 0) refundLog += "\n⚠️ 사채 보전 완료: " + refundCount + "건 (" + fp(totalRefunded) + "P)";

        if (typeof uidCache !== 'undefined') {
            for (var key in uidCache) {
                if (uidCache[key] === targetId) delete uidCache[key];
            }
        }
        delete roomData.users[targetId];
            try {
                var regFile = new java.io.File(REGISTRY_PATH);
                if (regFile.exists()) {
                    var regData = JSON.parse(FileStream.read(REGISTRY_PATH));
                    delete regData[roomName + "_" + targetData.name];
                    FileStream.write(REGISTRY_PATH, JSON.stringify(regData));
                }
            } catch (e) { Log.error("Registry Delete Error: " + e); }
            safeSaveData(data);
            replier.reply(formatAdmin("유저 삭제 완료", "[" + targetData.name + "]님의 데이터를 영구 삭제했습니다." + refundLog));
        return true;
    }

    /* [개인 복구] 4대 보안 가드가 적용된 지능형 유저 복구 (Smart User Restore v5.9.1) */
    if (msg.indexOf("/유저복원 ") === 0) {
    var fullInput = msg.substring(6).trim();
    var roomData = data.rooms[roomName];

    var words = fullInput.split(/\s+/);
    var lastWord = words[words.length - 1];
    var isUUID = (lastWord.split("-").length >= 5 && lastWord.length >= 36);

    var targetNick = "";
    var sourceCode = "";

    if (isUUID) {
        sourceCode = lastWord;
        targetNick = fullInput.substring(0, fullInput.lastIndexOf(lastWord)).trim();
    } else {
        targetNick = fullInput;
        sourceCode = ""; 
    }

    var currentFound = findUserByName(roomData, targetNick);
    if (currentFound.length > 1) { 
        handleUserSelection(replier, targetUid, currentFound, "user_restore", { sourceCode: sourceCode }, user, roomName);
        return true; 
    }
    if (currentFound.length === 0) { 
        replier.reply(formatAdmin("🚫 대상 없음", "[" + targetNick + "] 유저를 찾을 수 없습니다.")); 
        return true; 
    }
    
    // [핵심 수정] 입력값(inputNick)이 아닌, 실제 찾은 유저의 '전체 이름'을 가져옵니다.
    var targetId = currentFound[0].id; 
    var fullNick = currentFound[0].data.name; // "95 남 광어" 전체 이름을 확보
    var backupSourceId = (sourceCode !== "") ? sourceCode : targetId;

    try {
        var backupContent = FileStream.read(BACKUP_DIR + "last_stable_backup.json");
        var backupData = JSON.parse(backupContent);
        var rawBackupUser = null;

        for (var r in backupData.rooms) {
            if (backupData.rooms[r].users[backupSourceId]) {
                rawBackupUser = backupData.rooms[r].users[backupSourceId];
                break;
            }
        }

        if (!rawBackupUser) throw new Error("백업본에 해당 데이터가 없습니다.");

        var backupUser = JSON.parse(JSON.stringify(rawBackupUser));

        // [구조 동기화] (이전 섹터와 동일)
        var schema = { chatLog: [], inventory: [], stockHoldings: {}, stockAvg: {}, point: 50000 };
        for (var key in schema) { if (backupUser[key] === undefined) backupUser[key] = schema[key]; }

        // [v7.0 핵심] 가져온 데이터의 이름을 '전체 닉네임'으로 고정
        backupUser.name = fullNick; 
        roomData.users[targetId] = backupUser; 

        safeSaveData(data, false);
        if (typeof globalData !== 'undefined') globalData = data; 

        replier.reply(formatAdmin("✅ 데이터 정밀 이관 완료", 
            "현재 대상: " + fullNick + "\n" + // 전체 이름 출력
            "식별 모드: 간략화 검색 지원\n" +
            "━━━━━━━━━━━━━━━\n" +
            "💰 최종 복구 잔액: " + fp(backupUser.point) + "P\n\n" +
            "💡 전체 닉네임과의 동기화가 완료되어 즉시 사용 가능합니다."));

    } catch (e) {
        replier.reply(formatAdmin("🚫 복구 중단", "사유: " + e.message));
        Log.error("Restore Error: " + e);
    }
        return true;
    }

    return false;
}

//==========섹터35==========

/**
 * [관리자 하위 모듈 4] 경제 및 포인트 관리
 * 기능: 경제지표, 데이터교정, 물가조정, 포인트 지급/차감/뿌리기, 각종 초기화, 재원수정 및 충전, 자가복원
 */
function _adminEconomyLogic(msg, user, data, replier, roomName, targetUid) {

    /* [1] 은행 가용 재원 수동 수정 (강제 설정) */
    if (msg.indexOf("/재원수정 ") === 0) {
        var val = parseInt(msg.split(" ")[1].replace(/,/g, ""));
        if (isNaN(val)) {
            replier.reply(formatAdmin("오류", "수정할 금액을 숫자로 입력하세요.\n예) /재원수정 3000"));
            return true;
        }

        var roomData = data.rooms[roomName];
        if (!roomData) return true;

        // [보안 교체] 직접 할당 대신 보안 엔진을 통한 차액(delta) 계산 및 적용
        var currentRes = Number(roomData.bankReserve || 0);
        var delta = val - currentRes;
        util_updateReserve(roomData, delta, "재원 수정", roomName);
        
        roomData.bankReserve = val;
        safeSaveData(data);
        
        replier.reply(formatAdmin("🏦 은행 재원 수정 완료", 
            "현재 방의 가용 재원이 수정되었습니다.\n\n" +
            "💰 설정 금액: " + fp(val) + "P\n" +
            "📢 이제 유저들이 이 금액 내에서 대출 가능합니다."));
        return true;
    }

    /* [신규] 은행 긴급 재원 충전 (기존 잔액에 추가 합산) */
    if (msg.indexOf("/재원충전 ") === 0) {
        var val = parseInt(msg.split(" ")[1].replace(/,/g, ""));
        if (isNaN(val) || val <= 0) {
            replier.reply(formatAdmin("오류", "충전할 금액을 양의 숫자로 입력하세요.\n예) /재원충전 100000"));
            return true;
        }
        var roomData = data.rooms[roomName];
        if (!roomData) return true;

        // [보안 교체] 직접 합산(+=) 대신 보안 엔진 호출
        util_updateReserve(roomData, val, "재원 충전", roomName);
        
        safeSaveData(data);
        
        var resMsg = "결과: 국고 보충 완료\n" +
                     "수혈 금액: +" + fp(val) + "P\n" +
                     "🏦 현재 금고 총액: " + fp(roomData.bankReserve) + "P";
        
        replier.reply(formatAdmin("⚙️ 중앙은행 긴급 재원 수혈", resMsg));
        return true;
    }

   /* [2] 특정 종목 신규 상장/부활 명령어 */
    if (msg.indexOf("/종목추가 ") === 0) {
        var parts = msg.split(" ");
        if (parts.length < 3) {
            replier.reply(formatAdmin("오류", "형식: /종목추가 [종목명] [가격]"));
            return true;
        }
        var name = parts[1];
        var price = parseInt(parts[2].replace(/,/g, ""));
        if (isNaN(price)) {
            replier.reply(formatAdmin("오류", "가격은 숫자로 입력해주세요."));
            return true;
        }

        data.stockMarket[name] = {
            price: price, lastPrice: price, type: assignStockType(), 
            delistTick: 0, delistLimit: 5, trend: "none", trendTick: 0
        };

        safeSaveData(data);
        replier.reply(formatAdmin("📈 종목 추가 완료", "[" + name + "] 종목이 " + fp(price) + "P로 상장되었습니다."));
        return true;
    }

    /* [관리자] 특정 종목 이름 및 가격 수정 */
    if (msg.indexOf("/종목수정 ") === 0) {
        var parts = msg.split(" ");
        if (parts.length < 4) {
            replier.reply(formatAdmin("오류", "형식: /종목수정 [기존이름] [새이름] [새가격]"));
            return true;
        }
        var oldName = parts[1];
        var newName = parts[2];
        var newPrice = parseInt(parts[3].replace(/,/g, ""));

        if (!data.stockMarket[oldName]) {
            replier.reply(formatAdmin("오류", "[" + oldName + "] 종목을 찾을 수 없습니다."));
            return true;
        }

        var stockData = data.stockMarket[oldName];
        var oldPrice = Number(stockData.price);
        
        // 자산 보존 비율 계산 (기존가 / 신규가)
        var ratio = oldPrice / newPrice;

        // 1. 시장 데이터 업데이트
        stockData.price = newPrice;
        stockData.lastPrice = newPrice;
        stockData.openPrice = newPrice; // 시가 동기화로 급락 방지

        var fixCount = 0;
        for (var r in data.rooms) {
            var users = data.rooms[r].users;
            for (var uid in users) {
                var u = users[uid];
                if (u.stockHoldings && u.stockHoldings[oldName] !== undefined) {
                    // 2. 보안 가드: 수량 급변으로 인한 자가치유 엔진 차단
                    u.skipHealing = true;

                    var oldQty = Number(u.stockHoldings[oldName]);
                    var oldAvg = Number(u.stockAvg[oldName] || oldPrice);

                    // 3. 보유 수량 및 평단가 비율 조정 (가치 보존)
                    var newQty = Math.max(1, Math.floor(oldQty * ratio));
                    var newAvg = Math.floor(oldAvg / ratio);

                    // 4. 데이터 이식 (이름 변경 대응 포함)
                    u.stockHoldings[newName] = newQty;
                    u.stockAvg[newName] = newAvg;

                    if (oldName !== newName) {
                        delete u.stockHoldings[oldName];
                        if (u.stockAvg[oldName]) delete u.stockAvg[oldName];
                    }
                    fixCount++;
                }
            }
        }

        if (oldName !== newName) {
            data.stockMarket[newName] = stockData;
            delete data.stockMarket[oldName];
        }

        safeSaveData(data);
        var res = "✅ 시장 데이터 정밀 교정 완료\n" +
                  "━━━━━━━━━━━━━━━\n" +
                  "• 종목: " + oldName + " ➔ " + newName + "\n" +
                  "• 가격: " + fp(oldPrice) + "P ➔ " + fp(newPrice) + "P\n" +
                  "• 대상: 유저 " + fixCount + "명의 자산 가치 보존 완료\n" +
                  "━━━━━━━━━━━━━━━\n" +
                  "💡 가격 변동 비율에 맞춰 수량과 평단가가 자동 조정되었습니다.";

         replier.reply(formatAdmin("주식 시장 개입", res));
        return true;
    }

    /* [3] 유저 보유 자산 기반 시장 재건 */
    if (msg === "/시장자산복구") {
        var roomData = data.rooms[roomName];
        if (!roomData) return true;
        var pumpCount = 0;
        var healthyPrice = 175000; // 목표 주가 (기준점 5%)
        var floorPrice = 52500;    // 상패 기준선 (기준점 1.5%)

        for (var sName in data.stockMarket) {
            var oldPrice = data.stockMarket[sName].price;
            if (oldPrice < floorPrice) {
                var ratio = oldPrice / healthyPrice; // 병합 비율 계산
                
                // 모든 방의 모든 유저를 탐색하여 수량 조절 및 헬러 방어막 가동
                for (var r in data.rooms) {
                    for (var uid in data.rooms[r].users) {
                        var u = data.rooms[r].users[uid];
                        if (u.stockHoldings && u.stockHoldings[sName]) {
                            u.skipHealing = true; 
                            var oldQty = u.stockHoldings[sName];
                            u.stockHoldings[sName] = Math.max(1, Math.floor(oldQty * ratio));
                            u.stockAvg[sName] = healthyPrice; 
                        }
                    }
                }
                data.stockMarket[sName].price = healthyPrice;
                data.stockMarket[sName].lastPrice = healthyPrice;
                data.stockMarket[sName].delistTick = 0;
                pumpCount++;
            }
        }
        
        data.marketOpenPrice = healthyPrice;
        marketOpenPrice = healthyPrice;
        safeSaveData(data);

        var resMsg = "✅ [시장 중립 복구 완료]\n" +
                     "━━━━━━━━━━━━━━━\n" +
                     "• 보정 종목: " + pumpCount + "개\n" +
                     "• 시가 재설정: " + fp(healthyPrice) + "P\n" +
                     "• 결과: 주가 정상화 및 유저 자산 비율 조정 완료";
        replier.reply(formatAdmin("경제 정상화 보고", resMsg));
        return true;
    }

    /* [4] 경제 지표 상세 조회 */
    if (msg === "/경제정보") {
        var eco = calculateEconomy(data, roomName);
        var rData = data.rooms[roomName];
        var base = rData.economyBase || 0;
        
        var multiplier = 1.0;
        if (base > 0) {
            var rawRatio = eco.total / base;
            var damping = (data.economyDamping !== undefined) ? data.economyDamping : 0.5;
            multiplier = 1 + (rawRatio - 1) * damping;
            if (multiplier < 0.5) multiplier = 0.5;
        }

        var ecoMsg = "💰 총 순자산: " + fp(eco.total) + "P\n" +
                     "🏦 은행 재고: " + fp(rData.bankReserve || 0) + "P\n" +
                     "⚖️ 물가 기준점: " + (base > 0 ? fp(base) + "P" : "설정 없음") + "\n" +
                     "📈 현재 물가 배율: x" + multiplier.toFixed(2) + "\n" +
                     "👥 활성 유저수: " + eco.count + "명\n" +
                     "💎 유저당 평균자산: " + fp(eco.average) + "P";

        replier.reply(formatAdmin("실시간 경제 리포트", ecoMsg));
        return true;
    }

   // [긴급] 헬러를 무시하고 부당 수량을 강제로 압축하는 최종 집행 로직
    if (msg === "/시장데이터교정") {
        var roomData = data.rooms[roomName];
        if (!roomData) return true;
        var fixUserCount = 0;
        var totalFixCount = 0;
        var healthyPrice = 175000; // 복구 기준가

        for (var r in data.rooms) {
            for (var uid in data.rooms[r].users) {
                var u = data.rooms[r].users[uid];
                if (!u.stockHoldings) continue;

                var isUserFixed = false;
                for (var sName in u.stockHoldings) {
                    var stock = data.stockMarket[sName];
                    var curQty = Number(u.stockHoldings[sName]);
                    
                    // [핵심 탐지] 주가는 17.5만P인데, 수량이 5주를 초과한다면 (기존 1,000P 시절 수량임)
                    if (stock && stock.price >= 150000 && curQty > 5) {
                        // 1. 헬러 방어막 즉시 가동
                        u.skipHealing = true; 
                        
                        // 2. 강제 병합 실행 (1,000P 시절 가치로 환산하여 재계산)
                        // 예: 100주(10만P 가치) -> 17.5만P 주식으로는 0.57주 -> 1주로 반올림
                        var estimatedOldValue = curQty * 1000; 
                        var correctedQty = Math.max(1, Math.round(estimatedOldValue / stock.price));
                        
                        u.stockHoldings[sName] = correctedQty;
                        if (!u.stockAvg) u.stockAvg = {};
                        u.stockAvg[sName] = stock.price; // 평단가 0%로 리셋
                        
                        isUserFixed = true;
                        totalFixCount++;
                    }
                }
                if (isUserFixed) fixUserCount++;
            }
        }

        // 헬러가 가동되기 전 물리 저장 강제 실행
        safeSaveData(data, false); 
        
        var resMsg = "🛠️ [중앙은행 강제 자산 조정 완료]\n" +
                     "━━━━━━━━━━━━━━━\n" +
                     "• 대상 인원: " + fixUserCount + "명\n" +
                     "• 조정 건수: " + totalFixCount + "건\n\n" +
                     "• 조치: 비정상 고액 수량 강제 병합\n" +
                     "• 결과: 화지여, 풀드포크바베큐 등 부당 이득 회수 성공";
        replier.reply(formatAdmin("데이터 정밀 수리 보고", resMsg));
        return true;
    }

    if (msg === "/경제전체리셋") {
        var roomData = data.rooms[roomName];
        if (!roomData) return true;
        
        var userCount = 0;
        var setPoint = 100000; // 설정된 현금 10만
        var setBank = 100000;  // 설정된 예금 10만

        for (var r in data.rooms) {
            for (var uid in data.rooms[r].users) {
                var u = data.rooms[r].users[uid];
                
                // 1. 헬러 방어막 가동 (급감 복구 차단)
                u.skipHealing = true; 
                
                // 2. 모든 자산 및 부채 청산
                u.point = setPoint;
                u.bank = setBank;
                u.loan = { debt: 0, items: [] }; // 빚 탕감
                u.stockHoldings = {};           // 주식 전량 몰수
                u.stockAvg = {};
                u.isTransferred = false;        // 대환 채무 삭제
                u.isDefaulter = false;          // 신불자 해제
                u.creditScore = 600;            // 신용점수 초기화
                u.tier = 0;                     // 티어 리셋 (선택 사항)
                
                userCount++;
            }
        }

        // 3. 중앙은행 재원 정상화 (물가 기준점의 30% 수준으로 수혈)
        var roomBase = roomData.economyBase || 3953977;
        roomData.bankReserve = Math.floor(roomBase * 0.3);

        safeSaveData(data, true); // 강제 백업 동시 수행
        
        var resMsg = "🚨 [국가 경제 대공황 및 강제 리셋 완료]\n" +
                     "━━━━━━━━━━━━━━━\n" +
                     "• 대상 인원: " + userCount + "명 전체\n" +
                     "• 공통 지급: 현금 10만 + 예금 10만\n" +
                     "• 특별 조치: 빚 탕감 / 주식 초기화 / 신불 해제\n" +
                     "• 국고 상태: " + fp(roomData.bankReserve) + "P (수혈 완료)\n" +
                     "━━━━━━━━━━━━━━━\n" +
                     "💡 모든 유저가 동일한 출발선에서 다시 시작합니다.";
        replier.reply(formatAdmin("경제 시스템 재시작", resMsg));
        return true;
    }

    /* [보안] 유저 고유 코드 전체 명부 조회 (v6.0 개선형) */
    if (msg === "/명부확인") {
        try {
            var regFile = new java.io.File(REGISTRY_PATH);
            if (!regFile.exists() || regFile.length() === 0) {
                replier.reply(formatAdmin("📜 유저 명부", "등록된 고유 코드 데이터가 없습니다."));
                return true;
            }

            var registry = JSON.parse(FileStream.read(REGISTRY_PATH));
            var list = [];
            for (var key in registry) {
                var parts = key.split("_");
                var rName = parts[0]; 
                var uName = parts.slice(1).join("_"); 
                var uid = registry[key];

                // [식별 보조] 실제 데이터와 대조하여 현재 상태 추출
                var uData = (data.rooms[rName] && data.rooms[rName].users[uid]) ? data.rooms[rName].users[uid] : null;
                var statusTag = uData ? " [" + fp(uData.point) + "P / " + (uData.lastDate || "미출석") + "]" : " [데이터 유실]";
                
                list.push("• [" + rName + "] " + uName + statusTag + "\n  └ " + uid);
            }

            if (list.length === 0) {
                replier.reply(formatAdmin("📜 유저 명부", "조회된 데이터가 없습니다."));
            } else {
                replier.reply(formatAdmin("📜 전체 유저 고유 코드 명부", list.join("\n\n")));
            }
        } catch (e) {
            replier.reply(formatAdmin("🚫 조회 오류", "명부 로드 실패: " + e));
        }
        return true;
    }

    /* [보안] 특정 닉네임 명부 강제 삭제 */
    if (msg.indexOf("/명부삭제 ") === 0) {
        var targetNick = msg.substring(6).trim();
        var regFile = new java.io.File(REGISTRY_PATH);
        if (!regFile.exists()) return replier.reply(formatAdmin("오류", "명부 파일이 없습니다."));

        var regData = JSON.parse(FileStream.read(REGISTRY_PATH));
        var matches = [];
        for (var key in regData) {
            var nickPart = key.substring(key.indexOf("_") + 1);
            if (nickPart.indexOf(targetNick) !== -1) {
                // 공통 엔진 규격에 맞춰 데이터 포맷팅
                matches.push({ id: key, data: { name: nickPart } });
            }
        }

        if (matches.length === 0) {
            replier.reply(formatAdmin("삭제 실패", "명부에서 [" + targetNick + "]이(가) 포함된 유저를 찾을 수 없습니다."));
        } else if (matches.length > 1) {
            // 섹터 11의 공통 중복 선택 엔진 호출 (이제 숫자가 작동합니다!)
            handleUserSelection(replier, targetUid, matches, "admin_reg_delete", null, user, roomName);
        } else {
            // 1명일 때는 즉시 삭제 실행
            var targetKey = matches[0].id;
            var targetFullNick = matches[0].data.name;
            delete regData[targetKey];
            FileStream.write(REGISTRY_PATH, JSON.stringify(regData));
            replier.reply(formatAdmin("명부 삭제 완료", "찾은 유저: [" + targetFullNick + "]\n관련 식별 코드를 명부에서 파기했습니다."));
        }
        return true;
    }

    /* [보안] 명부 일괄 최적화 (유령 데이터 전량 제거) */
    if (msg === "/명부업데이트") {
        var newRegistry = {};
        var count = 0;
        
        // 현재 메모리에 로드된(실제 존재하는) 유저들로만 명부를 새로 만듭니다.
        for (var rName in data.rooms) {
            var users = data.rooms[rName].users;
            for (var uid in users) {
                var regKey = rName + "_" + users[uid].name;
                newRegistry[regKey] = uid;
                count++;
            }
        }

        FileStream.write(REGISTRY_PATH, JSON.stringify(newRegistry));
        replier.reply(formatAdmin("✅ 명부 최적화 완료", "현재 존재하는 " + count + "명의 유저 정보로 명부를 새로 고침했습니다.\n(유령 데이터 전량 제거됨)"));
        return true;
    }

    /* [5] 데이터 교정 및 무결성 검사 */
    if (msg.trim() === "/데이터교정") {
        var fixCount = 0;
        var refundCount = 0;
        var totalRefunded = 0;

        for (var r in data.rooms) {
            var currentRoom = data.rooms[r];
            if (!currentRoom.loanPools) currentRoom.loanPools = {};
            if (!currentRoom.loanContracts) currentRoom.loanContracts = {};

            for (var id in currentRoom.users) {
                var u = currentRoom.users[id];
                if (!u) continue;

                if (Number(u.totalAttendance || 0) <= 3) {
                    for (var cid in currentRoom.loanContracts) {
                        var c = currentRoom.loanContracts[cid];
                        if (c.borrowerUid === id) {
                            var lender = currentRoom.users[c.lenderUid];
                            if (lender) {
                                lender.point = Number(lender.point) + Number(c.currentDebt);
                                totalRefunded += Number(c.currentDebt);
                                refundCount++;
                            }
                            delete currentRoom.loanContracts[cid];
                        }
                    }
                }
                u.point = Math.floor(Number(u.point || 0));
                u.bank = Math.floor(Number(u.bank || 0));
                u.creditScore = Math.min(1000, Math.max(0, Number(u.creditScore || 600)));
                u.isDefaulter = (u.creditScore < 500);
                if (!u.loan) u.loan = { debt: 0, items: [] };
                if (!u.stockHoldings) u.stockHoldings = {};

                // 교정 시점에 예금자가 기준 시간이 없다면 현재 시간으로 강제 주입
                if (u.bank > 0 && (!u.lastBankUpdateTime || u.lastBankUpdateTime === 0)) {
                    u.lastBankUpdateTime = Date.now();
                }

                fixCount++;
            }
        }
        
        safeSaveData(data);
        var resMsg = "전체 유저 " + fixCount + "명 동기화 완료\n" +
                     "📉 사채 환수: " + refundCount + "건 (" + fp(totalRefunded) + "P 반환)";
        replier.reply(formatAdmin("데이터 교정 및 분리 완료", resMsg));
        return true;
    }

    /* [6] 물가 조정 */
    if (msg.indexOf("/물가조정") === 0) {
        var args = msg.split(" ");
        var currentEco = calculateEconomy(data, roomName); 
        if (args[1] === "초기화") { data.rooms[roomName].economyBase = 0; safeSaveData(data); replier.reply(formatAdmin("⚖️ 물가 초기화", "기본가로 고정됩니다.")); return true; }
        var oldBase = data.rooms[roomName].economyBase || currentEco.total;
        var newBase = (args.length > 1 && !isNaN(parseInt(args[1]))) ? parseInt(args[1]) : Math.floor(Math.sqrt(oldBase * currentEco.total));
        data.rooms[roomName].economyBase = newBase;
        safeSaveData(data);
        replier.reply(formatAdmin("⚖️ 물가 조정 완료", "새 기준: " + fp(newBase) + "P"));
        return true;
    }

    /* [7] 물가 완충 비율 설정 */
    if (msg.indexOf("/물가완충") === 0) {
        var val = parseFloat(msg.split(" ")[1]);
        if (isNaN(val) || val < 0.0 || val > 1.0) { replier.reply(formatAdmin("오류", "0.0 ~ 1.0 사이의 소수를 입력하세요.")); return true; }
        data.economyDamping = val;
        safeSaveData(data);
        replier.reply(formatAdmin("🛡️ 물가 완충 설정 완료", "적용 비율: " + (val*100) + "%"));
        return true;
    }

    /* [8] 포인트 지급 */
    if (msg.indexOf("/포인트지급 ") === 0) {
        var parts = msg.trim().split(/\s+/);
        if (parts.length < 3) { replier.reply(formatError(user, "형식 오류", "/포인트지급 [닉네임] [금액]")); return true; }
        var am = parseInt(parts.pop());
        var tn = parts.slice(1).join(" ").trim();
        var roomData = data.rooms[roomName];
        var found = findUserByName(roomData, tn);
        if (found.length === 0) { replier.reply(formatError(user, "대상 없음", "[" + tn + "]님을 찾을 수 없습니다.")); return true; }
        if (found.length > 1) { handleUserSelection(replier, targetUid, found, "admin_point_give", { amount: am }, user, roomName); return true; }
    
    var targetUser = found[0].data;
    util_updatePoint(targetUser, roomData, am, "관리자 직접 지급", roomName);
        replier.reply(formatAdmin("포인트 지급 완료", getDisplayName(targetUser) + "님: +" + fp(am) + "P"));
        safeSaveData(data);
        return true;
    }

    /* [9] 포인트 차감 (강화: 잔액 초과 차감 시 안내 문구 추가) */
    if (msg.indexOf("/포인트차감 ") === 0) {
        var parts = msg.trim().split(/\s+/);
        if (parts.length < 3) { replier.reply(formatError(user, "형식 오류", "/포인트차감 [닉네임] [금액]")); return true; }
        var requestedAmount = parseInt(parts.pop());
        var tn = parts.slice(1).join(" ").trim();
        var roomData = data.rooms[roomName];
        var found = findUserByName(roomData, tn);

        if (found.length === 0) { replier.reply(formatError(user, "대상 없음", "[" + tn + "]님을 찾을 수 없습니다.")); return true; }
        if (found.length > 1) { handleUserSelection(replier, targetUid, found, "admin_point_take", { amount: requestedAmount }, user, roomName); return true; }
        
        var targetUser = found[0].data;
        var currentPoint = Number(targetUser.point);
        
        // 실제로 가져갈 수 있는 양 계산
        var actualTake = Math.min(currentPoint, requestedAmount);
        var isShortage = requestedAmount > currentPoint;

        // 실제 차감 집행 (섹터 7의 util_updatePoint 호출)
        util_updatePoint(targetUser, roomData, -actualTake, "관리자 직접 차감", roomName);
        
        var resContent = getDisplayName(targetUser) + "님: -" + fp(actualTake) + "P 차감 완료";
        if (isShortage) {
            resContent += "\n(⚠️ 요청액 " + fp(requestedAmount) + "P 중 잔액 부족으로 보유 전액 차감)";
        }
        resContent += "\n현재 잔액: " + fp(targetUser.point) + "P"; // [수정] 0P 고정 출력 버그 해결

        replier.reply(formatAdmin("포인트 차감 보고", resContent));
        safeSaveData(data);
        return true;
    }

    /* [10] 전체 포인트 지급 */
    if (msg.indexOf("/전체포인트지급 ") === 0) {
        var amt = parseInt(msg.split(" ")[1]);
        if (isNaN(amt)) return true;
        var count = 0;
        for (var r in data.rooms) {
            for (var id in data.rooms[r].users) {
                util_updatePoint(data.rooms[r].users[id], data.rooms[r], amt, "전체 포인트 지급", r);
                count++;
            }
        }
        safeSaveData(data);
        replier.reply(formatAdmin("전체 지급 완료", "총 " + count + "명에게 " + fp(amt) + "P 지급 완료"));
        return true;
    }

    /* [신규: Gemini 요청 사항] 경마 이월금 수동 조정 명령어 */
    if (msg.indexOf("/이월금수정 ") === 0) {
        var val = parseInt(msg.split(" ")[1].replace(/,/g, ""));
        if (isNaN(val)) {
            replier.reply(formatAdmin("오류", "수정할 이월 금액을 숫자로 입력하세요."));
            return true;
        }
        // 메인 운영 방("내리다")의 경마 이월금 강제 수정
        var targetRoom = data.rooms["내리다"];
        if (targetRoom && targetRoom.features && targetRoom.features.racing) {
            targetRoom.features.racing.carryOver = val;
            safeSaveData(data);
            replier.reply(formatAdmin("🏇 경마 이월금 수정 완료", "현재 적립된 이월금을 " + fp(val) + "P로 변경했습니다."));
        }
        return true;
    }

    /* [11] 포인트 뿌리기 (방별 독립 주머니 연동 - 먹통 해결 핵심) */
    if (msg === "/뿌리기") {
        var roomData = data.rooms[roomName];
        var sprinkleData = roomData.features.sprinkleData; // 방별 데이터 연결

        if (sprinkleData.active) { 
            replier.reply(formatAdmin("오류", "이미 뿌리기가 진행 중입니다.")); 
            return true; 
        }
        
        var count = Math.floor(Math.random() * 3) + 2; 
        var multiplier = util_getEcoMultiplier(roomName);
        
        var portions = [];
        var totalSprinkle = 0;
        for(var i=0; i<count; i++) {
            // 기본 범위를 5000 ~ 8000P로 상향
            var baseP = Math.floor(Math.random() * 3001) + 4000; 
            var finalP = Math.floor(baseP * multiplier);
            portions.push(finalP);
            totalSprinkle += finalP;
        }

        // [v5.9 수정] 전역 sprinkleData가 아닌 현재 방의 rFeatures.sprinkleData에 할당
        sprinkleData.active = true;
        sprinkleData.totalPoint = totalSprinkle;
        sprinkleData.remainingPoint = totalSprinkle;
        sprinkleData.limit = count;
        sprinkleData.currentWinners = 0;
        sprinkleData.winners = [];
        sprinkleData.portions = portions;

        Api.replyRoom(roomName, formatAdmin("🎉 포인트 뿌리기 시작!", "선착순 " + count + "명!\n채팅창에 [줍기]를 입력하세요!\n💰 총 배정: " + fp(totalSprinkle) + "P"));
        
        // 1분 후 자동 종료 타이머 (방 이름을 클로저로 전달)
        (function(targetRoom, targetData) {
            setTimeout(function() { 
                var rData = targetData.rooms[targetRoom];
                if (rData && rData.features.sprinkleData.active) { 
                    rData.features.sprinkleData.active = false; 
                    Api.replyRoom(targetRoom, formatAdmin("🏁 뿌리기 시간 초과", "이벤트가 종료되었습니다.")); 
                    safeSaveData(targetData);
                } 
            }, 60000);
        })(roomName, data);
        
        safeSaveData(data);
        return true;
    }

    /* [12] 시스템 초기화 세트 */
    if (msg === "/로또데이터초기화") {
        lotto = { round: (lotto.round || 0) + 1, entries: {}, dailyPool: 0, jackpot: 0, lastWinNums: [] };
        safeSaveData(data);
        replier.reply(formatAdmin("완료", "로또 시스템 리셋 완료"));
        return true;
    }
    if (msg === "/승급횟수초기화") {
        for (var r in data.rooms) {
            for (var id in data.rooms[r].users) {
                data.rooms[r].users[id].dailyPromotionAttempts = 1;
                data.rooms[r].users[id].purchasedPromotionAttempts = 0;
            }
        }
        safeSaveData(data);
        replier.reply(formatAdmin("완료", "전체 승급 기회 초기화"));
        return true;
    }
    if (msg === "/시즌강제종료") {
        for (var r in data.rooms) {
            for (var id in data.rooms[r].users) { data.rooms[r].users[id].tier = 0; }
        }
        safeSaveData(data);
        replier.reply(formatAdmin("완료", "모든 유저 티어 초기화"));
        return true;
    }

    /* [보안] 데이터 보호 엔진 자가진단 명령어 (v6.0 정밀 진단형) */
   if (msg === "/보안점검") {
        var st = function(ok) { return ok ? "🟢 가동" : "🔴 점검"; };
        
        // 1. 게이트웨이 체크 (Logic)
        var gw = {
            p: (typeof util_updatePoint === 'function'),
            u: (typeof util_setData === 'function'),
            r: (typeof util_updateReserve === 'function'),
            s: (typeof util_updateStock === 'function'),
            b: (typeof util_updateBank === 'function'),
            g: (typeof util_checkUserState === 'function')
        };

        // 2. 인프라 및 영속성 체크 (Infra)
        var infra = {
            lock: (typeof lock !== 'undefined' && !lock.isLocked()) || true,
            save: (typeof SaveExecutor !== 'undefined'),
            spam: (SYSTEM_CONFIG.SPAM !== undefined),
            backup: (SYSTEM_CONFIG.BACKUP.DISCORD_WEBHOOK_URL && SYSTEM_CONFIG.BACKUP.DISCORD_WEBHOOK_URL.indexOf("http") === 0),
            atomic: (new java.io.File(FILE_PATH).exists()),
            reg: (new java.io.File(REGISTRY_PATH).exists()),
            // [추가] 블랙박스 로그 기록 가능 여부 체크
            journal: (function() { try { return new java.io.File(BASE_DIR).canWrite(); } catch(e){return false;} })()
        };

        var report = "🛡️ [보안 관제 센터] v6.0\n" +
                     "━━━━━━━━━━━━━━━\n" +
                     "📁 [데이터 게이트웨이]\n" +
                     "• 포인트: " + st(gw.p) + " | 범용: " + st(gw.u) + "\n" +
                     "• 국고재원: " + st(gw.r) + " | 주식: " + st(gw.s) + "\n" +
                     "• 은행잔고: " + st(gw.b) + " | 상태: " + st(gw.g) + "\n\n" +
                     "⚙️ [실시간 방어 및 엔진]\n" +
                     "• 동기화 락: " + st(infra.lock) + " (Lock)\n" +
                     "• 비동기 저장: " + st(infra.save) + " (Save)\n" +
                     "• 신분 복구: " + st(infra.reg) + " (Registry)\n\n" +
                     "📦 [영속성 및 백업]\n" +
                     "• 블랙박스: " + st(infra.journal) + " (Journal)\n" + // 블랙박스 추가
                     "• 파손 방지: " + st(infra.atomic) + " (Atomic)\n" +
                     "• 원격 백업: " + st(infra.backup) + " (Discord)\n" +
                     "• 자가 치유: 🟢 활성화 (Healer)\n" +
                     "━━━━━━━━━━━━━━━\n" +
                     "✅ 모든 시스템이 보호되고 있습니다.";
        
        replier.reply(report);
        return true;
    }

    /* [신규] 보안 엔진 단계별 파괴 시뮬레이션 (Stress Test) */
    if (msg.indexOf("/보안테스트 ") === 0) {
        var step = msg.split(" ")[1];
        var roomData = data.rooms[roomName];

        if (step === "1") { // [1단계: 딥헬러 검증]
            replier.reply("🧪 [테스트 1: 딥헬러]\n내 메모리 데이터의 '가방'과 '은행' 필드를 강제로 삭제합니다...");
            delete user.inventory;
            delete user.bank;
            replier.reply("⚠️ 필드 삭제 완료. 이제 아무 메시지나 입력하여 '딥헬러'가 스키마를 복구하는지 확인하세요.\n(복구 성공 시 /가방 조회 가능)");
        } 
        
        else if (step === "2") { // [2단계: 게이트웨이 검증]
            replier.reply("🧪 [테스트 2: 게이트웨이]\n포인트에 숫자가 아닌 '오염된 문자열' 주입을 시도합니다...");
            util_updatePoint(user, roomData, "BAD_DATA", "보안 테스트 공격", roomName);
            replier.reply("✅ 결과: 게이트웨이가 오염된 연산을 차단했습니다. 상단 로그(Log.error) 또는 블랙박스 기록을 확인하세요.");
        } 

        else if (step === "3") { // [3단계: 최종 검역소 검증]
            replier.reply("🧪 [테스트 3: 최종 검역소]\n내 포인트를 강제로 'NaN(비숫자)'으로 오염시킨 뒤 저장을 시도합니다...");
            user.point = NaN; 
            safeSaveData(data, false);
            replier.reply("🛡️ 결과: '데이터 자가 치유' 알림이 뜨며 파일 저장이 차단되었는지 확인하세요.");
        }
        
        return true;
    }

    if (msg.trim() === "/시스템자가복원") {
        // 1. 휘발성 상태값 및 활동 락(Lock) 일괄 해제
        lottoPurchaseState = {}; 
        sprinkleData = { active: false, winners: [] };
        activeThefts = {}; 
        duelData = {}; 
        selectWaitState = {};
        bankProcessState = {}; 
        menuWaitState = {};
        miningState = {}; // 광산 활동 초기화
        feverData = { active: false, endTime: 0, scheduled: [] }; // 피버타임 상태 초기화

        // 2. UID 캐시 초기화 (메모리 정리)
        if (typeof uidCache !== 'undefined') {
            for (var k in uidCache) delete uidCache[k];
        }

        // 3. 시스템 핵심 경제 지표 복구
        if (!data.marketOpenPrice || data.marketOpenPrice <= 0) data.marketOpenPrice = 1000;
        marketOpenPrice = data.marketOpenPrice; // 전역 변수 동기화

        // 4. 전 유저 데이터 수치 정규화 및 방별 독립 상태 초기화
        var fixCount = 0;
        for (var r in data.rooms) {
            var roomObj = data.rooms[r];
            
            // [핵심 해결] /서버진단 수치에 반영되는 방별 states 주머니 강제 비우기
            if (roomObj.features && roomObj.features.states) {
                var st = roomObj.features.states;
                for (var sKey in st) { st[sKey] = {}; }
            }
            
            // 중앙은행 재원 누락 시 복구
            if (roomObj.bankReserve === undefined || roomObj.bankReserve === null) {
                roomObj.bankReserve = (SYSTEM_CONFIG && SYSTEM_CONFIG.ECO.BANK.INITIAL_RESERVE) ? SYSTEM_CONFIG.ECO.BANK.INITIAL_RESERVE : 10000;
            }
            // 위기 알림 상태 리셋
            roomObj.lastBankAlert = "normal";

            for (var id in roomObj.users) {
                var u = roomObj.users[id];
                if (!u) continue;
                u.point = Math.floor(Number(u.point || 0));
                u.bank = Math.floor(Number(u.bank || 0));
                u.creditScore = Math.min(1000, Math.max(0, Number(u.creditScore || 600)));
                
                if (!u.loan) u.loan = { debt: 0, items: [] };
                if (!u.stockHoldings) u.stockHoldings = {};
                fixCount++;
            }
        }

        // 5. 파일 시스템 락(Lock) 강제 해제 시도
        if (lock.isLocked()) {
            try { lock.unlock(); } catch(e) {}
        }

        safeSaveData(data);
        replier.reply(formatAdmin("⚙️ 시스템 자가 복원 완료", 
            "1. 모든 입력 대기 및 활동 상태 초기화 (방별 독립 상태 포함)\n" +
            "2. 중앙은행 재원 및 주식 시세 지표 복구\n" +
            "3. 국가 위기 알림 엔진 리셋\n" +
            "4. 유저 " + fixCount + "명의 데이터 정수화 완료"));
        return true;
    }

    /* [긴급] 지능형 전체 데이터 복구 (Smart Restore v5.9+) */
    if (msg.startsWith("/전체복원")) {
        var stablePath = BACKUP_DIR + "last_stable_backup.json";
        var stableFile = new java.io.File(stablePath);

        if (!stableFile.exists() || stableFile.length() === 0) {
            replier.reply(formatAdmin("🚫 복구 실패", "안전 백업 파일(last_stable_backup.json)을 찾을 수 없습니다."));
            return true;
        }

        try {
            var content = FileStream.read(stablePath);
            if (!content) throw new Error("파일 내용이 비어있음");

            // 1. 메모리 교체 및 메인 파일 물리적 동기화
            var backupObj = JSON.parse(content);
            globalData = backupObj;
            FileStream.write(FILE_PATH, content);

            // 2. [핵심] 실시간 블랙박스(Journal) 병합
            // 백업 시점 이후부터 현재까지 발생한 모든 포인트 변동을 소급 적용합니다.
            if (typeof recoverFromJournal === 'function') {
                recoverFromJournal(globalData);
            }

            // 3. 최종 정화된 데이터를 세션에 반영하고 즉시 저장
            safeSaveData(globalData, false);

            var resBody = "✅ 지능형 데이터 복구 완료\n" +
                          "━━━━━━━━━━━━━━━\n" +
                          "• 소스: last_stable_backup.json\n" +
                          "• 병합: 실시간 블랙박스 로그 통합\n" +
                          "• 상태: 오염 데이터 정화 성공";

            replier.reply(formatAdmin("🛠️ 시스템 복구 보고", resBody));

        } catch (e) {
            Log.error("Restore Logic Crash: " + e);
            replier.reply(formatAdmin("🚫 복구 중단", "데이터 파싱 중 오류가 발생했습니다.\n사유: " + e.message));
        }
        return true;
    }

    return false;
}

//==========섹터36==========

/**
 * [게임 명령어 분배기] (Game Logic Dispatcher - Registry Refactored)
 * 설명: 유저들의 게임/경제 활동 명령어를 각 전문 담당 함수로 연결합니다.
 * 섹터 1의 USER_COMMANDS 레지스트리를 참조하여 등록된 로직을 자동으로 매핑 및 실행합니다.
 */
function _handleGameLogic(msg, user, data, replier, roomName, targetUid, sender) {
    var roomData = data.rooms[roomName];
    var duelData = roomData.features.states.duelData; // 방별 결투 데이터 연결
    
    // 1. 명령어 첫 단어 추출
    var cmd = msg.split(" ")[0];

    // [가상 정부 시스템] 정책 및 투표 명령어 분기 처리
    if (cmd === "/의회" || cmd === "/투표") {
        if (typeof _gameGovernmentLogic === 'function') {
            return _gameGovernmentLogic(msg, user, data, replier, roomName, targetUid);
        }
    }

    // 2. 유저 명령어 레지스트리 검색
    if (USER_COMMANDS[cmd] && typeof USER_COMMANDS[cmd].execute === 'function') {
        
        // [결투 키워드 가드] localized duelData 사용
        if (cmd === "수락" || cmd === "거절" || cmd === "취소") {
            var hasDuel = false;
            if (duelData[targetUid]) hasDuel = true;
            else {
                for (var d in duelData) {
                    if (duelData[d].challengerUid === targetUid) { hasDuel = true; break; }
                }
            }
            if (!hasDuel) return false;
        }
        
        // 3. 검증된 명령어만 하위 로직 함수(섹터 40~44 등)로 실행 위임
        return USER_COMMANDS[cmd].execute(msg, user, data, replier, roomName, targetUid);
    }

    // 4. 등록되지 않은 명령어이거나 처리할 로직이 없는 경우 false 반환
    return false;
}

//==========섹터37==========

/**
 * [게임 하위 모듈 1] 은행 및 사채 관리
 * 기능: 은행 메뉴 호출, 대출금 직접 상환
 * 설명: 메뉴 UI에 기부 항목을 추가하고, 상환 시 중앙은행 재고로 환수되도록 연동함.
 */
function _gameBankLogic(msg, user, data, replier, roomName, targetUid) {
    var roomData = data.rooms[roomName];
    if (!roomData || !roomData.features) return false;

    // [상태 로컬라이징] 전역 변수 대신 방별 독립 상태 참조
    var menuWaitState = roomData.features.states.menuWait;
    var bankProcessState = roomData.features.states.bankProcess

    /* [기능 1] 은행 시스템 진입 (v5.2 기부 메뉴 추가) */
    if (msg === "/은행") {
        menuWaitState[targetUid] = { type: 'bank_menu', time: Date.now() };
        var bankMenu = "1. 💰 예금 (포인트 ➔ 은행)\n" +
                       "2. 🏧 출금 (은행 ➔ 포인트)\n" +
                       "3. 💸 송금 (타인에게 이체)\n" +
                       "4. 🏦 대출 (신용등급별)\n" +
                       "5. 📉 상환 (대출금 갚기)\n" +
                       "6. " + (SYSTEM_CONFIG.MSG.PREFIX.LOAN || "🚬") + " 사채 시장 (P2P 대출)\n" +
                       "7. 🎁 기부 (국고 후원)"; // [신규] 기부 항목 추가
        
        var myPoint = Number(user.point || 0);
        var myBank = Number(user.bank || 0);
        
        var content = bankMenu + "\n\n" +
               "🏦 은행 잔고 : " + fp(roomData.bankReserve) + "P\n\n" +
               "보유: " + fp(myPoint) + "P / 예금: " + fp(myBank) + "P\n" +
               "(번호를 선택해주세요)";

        // formatCommand를 호출하여 최종 메시지 조립
        replier.reply(formatCommand("🏦 은행 업무 선택", user, content, "입력 대기: 30초"));
        return true;
    }

    /* [기능 2] 대출금 상환 (직접 명령어) */
    if (msg.indexOf("/상환 ") === 0) {
        var myDebt = (user.loan && user.loan.debt) ? Number(user.loan.debt) : 0;
        if (myDebt <= 0) { 
            replier.reply(formatError(user, "상환 불가", "갚아야 할 은행 대출금이 존재하지 않습니다.")); 
            return true; 
        }

        var parts = msg.split(" ");
        // 쉼표가 포함된 입력도 처리 가능하도록 개선
        var amt = parseInt(parts[1].replace(/,/g, "")); 
        
        if (isNaN(amt) || amt <= 0) { 
            replier.reply(formatError(user, "금액 오류", "정확한 상환 금액을 입력하세요.")); 
            return true; 
        }
        
        var myPoint = Number(user.point || 0);
        if (myPoint < amt) { 
            replier.reply(formatError(user, "포인트 부족", "보유 포인트가 부족합니다.")); 
            return true; 
        }
        
        // 분산 상환 로직 호출 (섹터 13 정의)
        var res = distributeRepayment(user, amt, roomName);
        
        /* [중앙은행 연동] 통합 포인트 함수 사용 */
        // 유저 포인트 차감과 동시에 차감된 금액(res.actualRepay)이 bankReserve에 자동 입금됨.
        util_updatePoint(user, roomData, -Number(res.actualRepay), "대출 상환", roomName);
        
        var remainingDebt = (user.loan && user.loan.debt) ? Number(user.loan.debt) : 0;
        replier.reply(formatCommand("📉 상환 완료", user, fp(res.actualRepay) + "P 상환되었습니다.\n(신용 점수 +" + res.creditGain + ")", "남은 대출: " + fp(remainingDebt) + "P / 잔액: " + fp(user.point) + "P"));
        
        safeSaveData(data);
        return true;
    }

    return false;
}

//==========섹터38==========

/**
 * [게임 하위 모듈 2] 정보 및 랭킹 조회 (UI 최적화 및 출석 상태 추가)
 * 기능: 내정보, 유물도감, 신용등급, 대출한도, 명예의전당, 순위, 유저정보, 경마조회
 * 수정 사항: 도굴왕 달성 시 특별 축하 멘트 적용 및 유물 도감 UI 최종 최적화
 */
function _gameInfoLogic(msg, user, data, replier, roomName, targetUid) {
    var roomData = data.rooms[roomName];

    // 1. 방 데이터 및 기능 템플릿 존재 여부 체크 (안전 가드)
    if (!roomData || !roomData.features) return false;

    // 2. [핵심 고정] 전역 변수가 아닌 이 함수 전용 지역 변수로 데이터 연결
    // 이 코드가 있어야 /경마, /로또 등의 명령어가 먹통이 되지 않습니다.
    var racingData = roomData.features.racing;
    var lotto = roomData.features.lotto;

    /* [Gemini 요청 사항] 경마 정보 실시간 브리핑 기능 통합 (내 배팅 정보 포함) */
    if (msg === "/경마") {
        if (!racingData.isOperating) {
            replier.reply(formatSimple("🏇 경마장 휴장 안내", "현재 경마 운영 시간이 아닙니다.\n(운영시간: 09:00 ~ 23:59)", "오전 9시 정각에 개장합니다."));
            return true;
        }

        var hList = racingData.horses.map(function(h) {
            var horseBetSum = 0;
            for (var uid in racingData.bets) {
                if (racingData.bets[uid].horseId === h.id) horseBetSum += Number(racingData.bets[uid].amount);
            }
            return h.id + ". " + h.name + " [" + h.icon + "]\n    └ 현 배팅액: " + fp(horseBetSum) + "P";
        }).join("\n");

        var now = new Date();
        var nowMin = now.getMinutes();
        var remainMin = 49 - nowMin;
        var remainSec = 59 - now.getSeconds();
        if (remainMin < 0) { remainMin = 0; remainSec = 0; }

        var myBet = racingData.bets[targetUid];
        var myBetInfo = "";
        if (myBet) {
            var myHorse = racingData.horses[myBet.horseId - 1]; 
            myBetInfo = "👤 내 배팅: " + myBet.horseId + "번 " + myHorse.name + " (" + fp(myBet.amount) + "P)";
        } else {
            myBetInfo = "👤 내 배팅: 참여 내역 없음";
        }

        var raceHeader = (nowMin >= 50) ? "🏁 배팅 마감 및 정산 중" : "제 " + racingData.round + "회차 경기 배팅 진행 중";
        var totalPrizePool = racingData.totalPool + racingData.carryOver;
        var racingBody = raceHeader + "\n\n" +
                         "[🏇 출전마 라인업]\n" + hList + "\n\n" +
                         myBetInfo + "\n" +
                         "💰 현재 총 배당금: " + fp(totalPrizePool) + "P\n" +
                         (racingData.carryOver > 0 ? "✨ 이월 적립금: " + fp(racingData.carryOver) + "P 포함\n" : "") +
                         "🕒 배팅 마감: " + remainMin + "분 " + remainSec + "초 남음";

        replier.reply(formatCommand("🏇 내리다 중앙 경마장", user, racingBody, "배팅: [/배팅 번호 금액]"));
        return true;
    }

    /* [신규] 봇 응답 속도 체크 */
    if (msg === "/핑") {
        var ping = Date.now() - _msgReceiveTime;
        var status = ping < 150 ? "🚀 매우 쾌적" : (ping < 400 ? "🟢 양호" : (ping < 800 ? "🟡 지연" : "🔴 과부하"));
        replier.reply(formatSimple("🏓 퐁! (Pong)", "⏱️ 응답 속도: " + ping + "ms\n📊 현재 상태: " + status, "서버의 처리 지연 시간을 측정합니다."));
        return true;
    }

    /* [기능 3] 내 정보 조회 */
    if (msg === "/내정보") {
        var cr = getCreditInfo(user.creditScore);
        var authInfo = "🎮 게임 인증: " + (user.gameAuthCount || 0) + "/2 (시즌)";
        
        var bankDebt = (user.loan && user.loan.debt) ? Math.floor(Number(user.loan.debt)) : 0;
        var sacheDebt = 0;
        var sacheClaims = 0; 
        var overdueSache = 0;

        if (roomData && roomData.loanContracts) {
            for (var cid in roomData.loanContracts) {
                var c = roomData.loanContracts[cid];
                if (c.borrowerUid === targetUid) {
                    sacheDebt += Math.floor(c.currentDebt);
                    if (c.status === 'overdue') overdueSache += Math.floor(c.currentDebt);
                }
                if (c.lenderUid === targetUid) {
                    sacheClaims += Math.floor(c.currentDebt);
                }
            }
        }

        var todayStr = getSimpleDate();
        var attendMark = (user.lastDate === todayStr) ? " (✅)" : " (⏳)";
        var totalPromotion = (Number(user.dailyPromotionAttempts) || 0) + (Number(user.purchasedPromotionAttempts) || 0);

        var currentAccrued = Number(user.accruedInterest || 0);
        if (user.lastBankUpdateTime > 0 && Number(user.bank) > 0) {
            var passed = Date.now() - user.lastBankUpdateTime;
            currentAccrued += Number(user.bank) * 0.05 * (passed / 86400000);
        }

        var infoBody = authInfo + "\n" +
                       "💰 보유 포인트: " + fp(user.point) + "P\n" +
                       "🏦 예금: " + fp(user.bank) + "P\n" +
                       "🧧 지급 예정 이자: " + fp(Math.floor(currentAccrued)) + "P\n" + // 이 줄이 추가되었습니다.
                       (sacheClaims >= 1 ? "🤝 미수 채권: " + fp(sacheClaims) + "P\n" : "") +
                       "💳 신용 등급: " + cr.label + " (" + user.creditScore + "점)\n" +
                       "🏅 현재 티어: " + (TIERS[user.tier] || "아이언") + "\n" +
                       "📅 누적 출석: " + (user.totalAttendance || 0) + "일" + attendMark + "\n" +
                       "🔂 승급 기회: " + totalPromotion + "회";
        
        if (bankDebt > 0) {
            var transferTag = user.isTransferred ? " (🚨대환 채무: 70% 강제상환)" : "";
            infoBody += "\n🏦 미상환 대출: " + fp(bankDebt) + "P" + transferTag;
        }

        if (sacheDebt > 0) {
            infoBody += "\n🚬 미상환 사채: " + fp(sacheDebt) + "P";
            if (overdueSache > 0) infoBody += "\n🚨 사채 연체: " + fp(overdueSache) + "P (50% 자동상환)";
        }
        
        replier.reply(formatCommand("📌 내 상세 정보", user, infoBody, "아이템 구매: [/상점]")); 
        return true;
    }

    /* [Gemini 요청 사항] 유물 도감 조회 UI 가변 처리 자동화 */
    if (msg === "/유물도감") {
        var pieces = Number(user.artifactPieces || 0);
        
        // 1. 현재 조각 수에 따른 다음 목표치와 목표 칭호 설정
        var targetGoal = 10;
        var nextTitle = "도굴꾼";

        if (pieces >= 50) { 
            targetGoal = 50; 
            nextTitle = "도굴왕 ⚜️"; 
        } else if (pieces >= 40) { 
            targetGoal = 50; 
            nextTitle = "도굴왕 ⚜️"; 
        } else if (pieces >= 30) { 
            targetGoal = 40; 
            nextTitle = "트레저헌터"; 
        } else if (pieces >= 20) { 
            targetGoal = 30; 
            nextTitle = "발굴가"; 
        } else if (pieces >= 10) { 
            targetGoal = 20; 
            nextTitle = "탐사원"; 
        } else { 
            targetGoal = 10; 
            nextTitle = "도굴꾼"; 
        }

        // 2. 달성 상태 텍스트 판별
        var statusTxt = (pieces >= 50) ? "전설 등극!" : "진행 중...";
        
        // 3. UI 바디 구성
        var statusContent = "✨ 유물 조각\n" +
                            "🧩 보유: " + pieces + " / " + targetGoal + " 개\n\n" +
                            "🎁 수집 달성 보상\n" +
                            "🎖️ 칭호: [" + nextTitle + "] (" + statusTxt + ")";
        
        // 4. 가이드 문구 가변 처리
        var guideText = (pieces >= 50) 
            ? "🎉 축하합니다! 고대의 신비를 모두 풀어낸 당신은 이 시대의 진정한 전설, 도굴왕이십니다!" 
            : "광산에서 0.1% 확률로 조각이 발견됩니다. " + targetGoal + "개를 모으면 자동으로 칭호가 부여됩니다.";
        
        replier.reply(formatCommand("🏺 유물 도감", user, statusContent, guideText));
        return true;
    }

    /* [기능 4] 신용 등급 및 대출 한도 조회 */
    if (msg === "/신용등급" || msg === "/대출한도") {
        var cr = getCreditInfo(user.creditScore);
        
        // 1. 탄력 금수 승수 계산
        var dynMult = 1.0;
        if (typeof util_getDynamicRateMultiplier === 'function') {
            dynMult = util_getDynamicRateMultiplier(roomName);
        }

        // 2. 시장 상황 메시지 생성
        var marketStatus = "🟢 경제 안정";
        if (dynMult > 1.2) marketStatus = "🚨 국고 위기 (고금리)";
        else if (dynMult < 0.8) marketStatus = "✅ 유동성 풍부 (저금리)";

        // 3. 동적 이율 테이블 생성
        var conf = SYSTEM_CONFIG.ECO.CREDIT;
        var dynamicTable = [];
        for(var i=0; i<conf.SCORES.length; i++) {
            var baseRatePct = Math.round((conf.RATES[i] - 1) * 100);
            var appliedRate = (baseRatePct * dynMult).toFixed(1);
            dynamicTable.push(conf.ICONS[i] + " " + conf.LABELS[i] + ": " + appliedRate + "% (한도 " + fp(conf.LIMITS[i]) + "P)");
        }
        
        // 마지막 인덱스(신불자) 추가 처리
        var lastIdx = conf.SCORES.length;
        var lastBaseRate = Math.round((conf.RATES[lastIdx] - 1) * 100);
        var lastApplied = (lastBaseRate * dynMult).toFixed(1);
        dynamicTable.push(conf.ICONS[lastIdx] + " " + conf.LABELS[lastIdx] + ": " + lastApplied + "% (한도 " + fp(conf.LIMITS[lastIdx]) + "P)");

        var header = "[📊 실시간 대출 금리 리포트]\n" +
                     "🌐 시장 상황: " + marketStatus + " (x" + dynMult.toFixed(2) + ")\n" +
                     "━━━━━━━━━━━━━━━\n" +
                     dynamicTable.join("\n");

        var myCredit = "\n\n[내 실시간 적용 상태]\n" +
                       "• 신용점수: " + user.creditScore + "점 (" + cr.label + ")\n" +
                       "• 적용이율: " + (Math.round((cr.rate - 1) * 100) * dynMult).toFixed(1) + "%\n" +
                       "• 가능액수: " + fp(cr.limit) + "P";

        replier.reply(formatCommand("💳 신용 등급 및 실시간 한도", user, header + myCredit, "대출 실행: [/은행]"));
        return true;
    }

    /* [기능 5] 명예의 전당 */
    if (msg === "/명예의전당") {
        var challengers = [];
        var roomUsers = roomData.users;
        for (var id in roomUsers) {
            var u = roomUsers[id];
            if (u && u.tier === 9) {
                var count = Math.max(1, u.challengerCount || 0);
                challengers.push("🏆 " + u.name + " (누적 " + count + "회)");
            }
        }
        var content = challengers.length > 0 ? challengers.join("\n") : "현재 이 방에 등록된 챌린저가 없습니다.";
        replier.reply(formatSimple("🏅 명예의 전당", content, "최고 티어 달성 시 등록됩니다."));
        return true;
    }

    /* [기능 5-1] 계정 확인 및 연동 */
    // [기능 1] 내 고유 복구 코드 확인
    if (msg === "/코드확인") {
        var codeMsg = "당신의 고유 복구 코드입니다.\n닉네임과 프사를 동시에 바꿀 경우를 대비해 반드시 따로 저장해두세요.\n\n🔑 코드: " + targetUid;
        replier.reply(formatCommand("🔐 보안 복구 코드", user, codeMsg, "연동 방법: [/계정연동 코드]"));
        return true;
    }

    // [기능 2] 계정 연동 및 데이터 복구 (완전 결함 제거 버전)
    if (msg.indexOf("/계정연동") === 0) {
        var parts = msg.split(" ");
        if (parts.length < 2) return replier.reply(formatError(user, "입력 오류", "/계정연동 [복구코드]"));

        var inputCode = parts[1].split("-").join("").toLowerCase().trim();
        var oldUser = null;

        // 1. 전체 데이터베이스에서 소스 계정 탐색
        for (var rName in data.rooms) {
            var roomUsers = data.rooms[rName].users;
            for (var uid in roomUsers) {
                if (String(uid).split("-").join("").toLowerCase() === inputCode) {
                    oldUser = roomUsers[uid];
                    break;
                }
            }
            if (oldUser) break;
        }

        if (!oldUser) return replier.reply(formatError(user, "복구 실패", "일치하는 코드를 찾을 수 없습니다."));
        if (inputCode === String(targetUid).split("-").join("").toLowerCase()) return replier.reply(formatError(user, "작업 무효", "현재 접속 중인 코드와 동일합니다."));

        try {
            // 2. 데이터 정밀 복사 (Deep Copy)
            // 현재 유저의 고유 ID(targetUid)와 이름은 유지한 채 알맹이만 과거 데이터로 교체
            var backupData = JSON.parse(JSON.stringify(oldUser));
            
            // 필수 필드 선별 복사 (현재 닉네임과 ID 보존)
            var preservedName = user.name;
            var preservedHash = user.imageHash;

            // 핵심 자산 및 스탯 덮어쓰기
            var fields = [
                'point', 'bank', 'tier', 'creditScore', 'totalAttendance', 'loan', 
                'inventory', 'collectedIcons', 'stockHoldings', 'stockAvg', 
                'artifactPieces', 'totalGambleCount', 'totalGambleWins', 'totalTheftSuccess',
                'totalInvestAmount', 'totalMiningTime', 'totalDonation', 'boxFragments', 'boxTickets'
            ];

            fields.forEach(function(f) {
                if (backupData[f] !== undefined) user[f] = backupData[f];
            });

            user.name = preservedName;
            user.imageHash = preservedHash;

            safeSaveData(data);
            
            var resBody = "과거 자산 정보를 현재 계정으로 안전하게 복사해왔습니다.\n\n" +
                         "💰 복제 잔액: " + fp(user.point) + "P\n" +
                         "🏅 복제 티어: " + (TIERS[user.tier] || "아이언") + "\n" +
                         "📦 인벤토리: " + (user.inventory ? user.inventory.length : 0) + "개 항목 이관";

            replier.reply(formatCommand("✅ 데이터 정밀 복제 완료", user, resBody, "고유 코드는 현재 코드를 그대로 유지합니다."));
        } catch (e) {
            replier.reply(formatError(user, "시스템 오류", "복제 중 기술적 결함 발생: " + e));
        }
        return true;
    }

    /* [기능 6] 자산 순위 */
    if (msg === "/출석순위") {
        var users = [];
        var roomUsers = roomData.users;
        for (var id in roomUsers) {
            var u = roomUsers[id];
            var netWorth = util_calculateNetWorth(u, roomData);
            if (netWorth >= 1) users.push({ data: u, total: netWorth });
        }
        users.sort(function(a, b) { return b.total - a.total; });
        var rankList = [];
        for (var i = 0; i < Math.min(10, users.length); i++) {
            rankList.push((i + 1) + ". " + getDisplayName(users[i].data) + " (" + fp(users[i].total) + "P)");
        }
        var rankMsg = (rankList.length > 0 ? rankList.join("\n") : "순위 데이터가 없습니다.");
        replier.reply(formatSimple("자산 랭킹 (실질 순자산 기준)", rankMsg, "내 정보: [/내정보]"));
        return true;
    }

    /* [기능 7] 유저 정보 상세 조회 */
    if (msg.indexOf("/유저정보") === 0) {
        var tn = msg.substring(5).trim(); 
        if (tn === "") {
            replier.reply(formatError(user, "입력 오류", "조회할 유저의 닉네임을 입력하세요."));
            return true;
        }
        var found = findUserByName(roomData, tn);
        if (found.length === 0) { 
            replier.reply(formatError(user, "대상 없음", "[" + tn + "]님을 찾을 수 없습니다.")); 
            return true; 
        }
        if (found.length === 1) {
            var targetUser = found[0].data;
            var targetIdInside = found[0].id;
            var cr = getCreditInfo(targetUser.creditScore);
            
            var sDebt = 0;
            var sClaims = 0;
            if (roomData.loanContracts) {
                for (var cid in roomData.loanContracts) {
                    var c = roomData.loanContracts[cid];
                    if (c.borrowerUid === targetIdInside) sDebt += Math.floor(c.currentDebt);
                    if (c.lenderUid === targetIdInside) sClaims += Math.floor(c.currentDebt);
                }
            }

            var info = "💰 포인트: " + fp(targetUser.point) + "P\n" +
                       "🏦 예금: " + fp(targetUser.bank) + "P\n" +
                       (sClaims >= 1 ? "🤝 미수 채권: " + fp(sClaims) + "P\n" : "") +
                       "💳 신용: " + cr.label + " (" + targetUser.creditScore + "점)\n" +
                       "🏅 티어: " + (TIERS[targetUser.tier] || "아이언") + "\n" +
                       "📅 출석: " + (targetUser.totalAttendance || 0) + "일";
            
            var bDebt = (targetUser.loan && targetUser.loan.debt) ? Math.floor(Number(targetUser.loan.debt)) : 0;
            if (bDebt > 0) info += "\n🏦 미상환 대출: " + fp(bDebt) + "P";
            if (sDebt > 0) info += "\n🚬 미상환 사채: " + fp(sDebt) + "P";

            replier.reply(formatCommand("🔍 유저 상세 정보", targetUser, info, null));
        } else {
            handleUserSelection(replier, targetUid, found, "info", null, user, roomName);
        }
        return true;
    }

    return false;
}

//==========섹터39==========

/**
 * [게임 하위 모듈 3] 액션 및 도박 통합 분배기
 * 설명: 섹터 39(전체 분배기)로부터 호출받아, 실제 세부 로직(42-1 ~ 42-3)으로 연결합니다.
 * 이 구조를 통해 각 기능별로 독립적인 수정 및 관리가 가능해집니다.
 */
function _gameActionLogic(msg, user, data, replier, roomName, targetUid) {
    var cmd = msg.split(" ")[0]; // 명령어 첫 단어 추출
    
    // 1. 홀짝, 승급, 경마 관련 로직 (섹터 40 위임)
    // [수정]: /배팅 및 배팅취소 조건을 추가하여 Part1 함수가 실행될 수 있도록 입구를 개방함
    if (cmd === "/홀짝" || cmd === "/승급" || cmd === "/배팅" || cmd === "배팅취소") {
        return _gameActionLogic_Part1(msg, user, data, replier, roomName, targetUid);
    }
    
    // 2. 결투 로직 (섹터 41 위임)
    if (cmd === "/결투" || cmd === "수락" || cmd === "거절" || cmd === "취소") {
        return _gameActionLogic_Part2(msg, user, data, replier, roomName, targetUid);
    }
    
    // 3. 도둑질 및 줍기 로직 (섹터 42 위임)
    if (cmd === "/도둑질" || cmd === "잡았다요놈" || cmd === "줍기") {
        return _gameActionLogic_Part3(msg, user, data, replier, roomName, targetUid);
    }
    
    return false; // 해당되는 명령어가 없음
}

//==========섹터40==========

/**
 * [게임 하위 모듈 3-1] 액션 및 도박 게임 (홀짝 & 승급 & 경마 액션)
 * v5.9: 통합 엔진(7, 9, 11) 연결 완료
 */
function _gameActionLogic_Part1(msg, user, data, replier, roomName, targetUid) {
    var roomData = data.rooms[roomName];
    if (!roomData) return false;

    var racingData = roomData.features.racing;

    var rConf = SYSTEM_CONFIG.ECO.RACING; 

    /* [연결] 1. 경마 배팅 액션 (/배팅 [번호] [금액]) */
    if (msg.indexOf("/배팅 ") === 0) {
        if (util_isBankruptcy(roomName)) {
            replier.reply(formatError(user, "시스템 동결", "국가 부도 선포 상태에서는 경마 배팅이 금지됩니다.\n(회복 기준: 국고 50%)"));
            return true;
        }
        if (!racingData.isOperating) {
            replier.reply(formatError(user, "경마장 휴장", "현재 운영 시간이 아닙니다. (09:00 ~ 23:59)"));
            return true;
        }

        var nowMin = new Date().getMinutes();
        if (nowMin >= 50) {
            replier.reply(formatError(user, "배팅 마감", "현재 제 " + racingData.round + "회차 경기가 마감되어 정산 중입니다."));
            return true;
        }

        // [엔진 연결] 통합 상태 가드 체크 (징역/광산 등)
        var stateRes = util_checkUserState(user, targetUid);
        if (!stateRes.canAction) {
            replier.reply(formatError(user, "배팅 불가", stateRes.reason));
            return true;
        }

        var ps = msg.trim().split(/\s+/);
        if (ps.length < 3) { 
            replier.reply(formatError(user, "형식 오류", "/배팅 [말번호] [금액]")); 
            return true; 
        }
        
        var hId = parseInt(ps[1]);
        var betAmt = parseInt(ps[2].replace(/,/g, ""));

        if (isNaN(hId) || hId < 1 || hId > racingData.horses.length) {
            replier.reply(formatError(user, "번호 오류", "1~" + racingData.horses.length + "번 사이의 말을 선택하세요."));
            return true;
        }

        // [엔진 연결] 물가 배율 엔진 적용
        var minLimit = rConf.MIN_BET; 
        var maxLimit = rConf.MAX_BET;

        if (isNaN(betAmt) || betAmt < minLimit) {
            replier.reply(formatError(user, "금액 미달", "최소 " + fp(minLimit) + "P 이상 배팅해야 합니다."));
            return true;
        }
        if (betAmt > maxLimit) {
            replier.reply(formatError(user, "한도 초과", "최대 " + fp(maxLimit) + "P까지 배팅 가능합니다."));
            return true;
        }
        if (Number(user.point) < betAmt) {
            replier.reply(formatError(user, "포인트 부족", "보유 포인트가 부족합니다."));
            return true;
        }

        if (racingData.bets[targetUid]) {
            replier.reply(formatError(user, "중복 배팅 불가", "이미 배팅하셨습니다. [배팅취소] 후 다시 시도하세요."));
            return true;
        }

        // [엔진 연결] 게이트웨이를 통한 안전 차감 및 국고 입고
        util_updatePoint(user, roomData, -betAmt, "경마 배팅", roomName);
        
        var selectedHorse = racingData.horses[hId - 1];
        racingData.bets[targetUid] = { uid: targetUid, horseId: hId, amount: betAmt, name: user.name };
        racingData.totalPool += betAmt;

        var betSuccessContent = "🏇 선택: " + selectedHorse.id + "번 " + selectedHorse.name + "\n💰 금액: " + fp(betAmt) + "P 배팅 성공!";

        if (Math.random() < 0.1) { // 10% 확률
            var allParts = ["안장", "등자", "고삐", "채찍"];
            if (!user.horseParts) user.horseParts = [];
            var missingParts = allParts.filter(function(p) { return user.horseParts.indexOf(p) === -1; });
            
            if (missingParts.length > 0) {
                var newPart = missingParts[Math.floor(Math.random() * missingParts.length)];
                user.horseParts.push(newPart);
                betSuccessContent += "\n\n 🐎 경마장을 지나다 '" + newPart + "'을 발견했습니다!\n(보유 아이템: " + user.horseParts.join(", ") + " / 남은 부품: " + (missingParts.length - 1) + "개)";
                
                if (user.horseParts.length === 4) {
                    betSuccessContent += "\n\n 🐎 모든 장비가 갖춰져 [경마왕] 자격을 얻었습니다!";
                    util_checkAndAwardTitle(user, replier, "경마왕", 777, "🏇", "내리다 경마 협회", "경마 장비 4종 수집", "[장착 효과]: 경마 배팅 취소 시 발생하는 위약금(10%)이 전액 면제됩니다.", roomName);
                }
            }
        }

        replier.reply(formatCommand("✅ [경마 배팅 완료]", user, "🏇 선택: " + selectedHorse.id + "번 " + selectedHorse.name + "\n💰 금액: " + fp(betAmt) + "P 배팅 성공!", "내 잔액: " + fp(user.point) + "P"));
        safeSaveData(data);
        return true;
    }

    /* [연결] 2. 경마 배팅 취소 (배팅취소) */
    if (msg === "배팅취소") {
        if (!racingData.isOperating) return false;
        var nowMin = new Date().getMinutes();
        if (nowMin >= 50) {
            replier.reply(formatError(user, "취소 불가", "정산 중에는 취소가 불가능합니다."));
            return true;
        }

        var myBet = racingData.bets[targetUid];
        if (!myBet) {
            replier.reply(formatError(user, "내역 없음", "이번 회차 배팅 기록이 없습니다."));
            return true;
        }

       var isOwner = (user.title === "경마왕");
        var feeRate = isOwner ? 0 : rConf.CANCEL_FEE;
        var fee = Math.floor(myBet.amount * feeRate);
        var refund = myBet.amount - fee;

        var cancelMsg = "경마 배팅을 철회했습니다.\n\n💰 원래 배팅금: " + fp(myBet.amount) + "P\n";
        if (isOwner) {
            cancelMsg += "👑 [경마왕] 칭호 효과 적용!\n⚖️ 취소 위약금: 0P (전액 면제)\n";
        } else {
            cancelMsg += "⚖️ 취소 위약금(10%): -" + fp(fee) + "P\n";
        }
        cancelMsg += "🎁 최종 환불액: " + fp(refund) + "P";

        // [엔진 연결] 게이트웨이를 통한 환불 (수수료 제외)
        util_updatePoint(user, roomData, refund, "경마 배팅 취소", roomName);
        
        racingData.totalPool -= myBet.amount;
        delete racingData.bets[targetUid];

        var cancelMsg = "경마 배팅을 철회했습니다.\n\n💰 원래 배팅금: " + fp(myBet.amount) + "P\n⚖️ 취소 위약금(10%): -" + fp(fee) + "P\n🎁 최종 환불액: " + fp(refund) + "P";
        replier.reply(formatCommand("🚫 배팅 취소 완료", user, cancelMsg, "내 잔액: " + fp(user.point) + "P"));
        safeSaveData(data);
        return true;
    }

    /* [연결] 3. 홀짝 도박 (/홀짝) */
    if (msg.indexOf("/홀짝 ") === 0) {
        startTracking(user, "홀짝 게임");
        try {
            // [엔진 연결] 통합 상태 가드
            var stateRes = util_checkUserState(user, targetUid);
            if (!stateRes.canAction) {
                endTracking(user, false, stateRes.reason);
                replier.reply(formatError(user, "게임 불가", stateRes.reason));
                return true;
            }

            if (data.gambleLimit) {
                endTracking(user, false, "도박 제한");
                replier.reply(formatError(user, "시스템 제한", "현재 도박 시스템이 비활성화 상태입니다."));
                return true;
            }

            var rawInput = msg.replace("/홀짝", "").trim(); // "/홀짝" 제외한 나머지 문자열
            
            // 1. 홀/짝 글자 추출
            var pick = "";
            if (rawInput.indexOf("홀") !== -1) pick = "홀";
            else if (rawInput.indexOf("짝") !== -1) pick = "짝";

            // 2. 숫자(배팅금) 추출
            var betMatch = rawInput.match(/\d+/);
            var bet = betMatch ? Number(betMatch[0]) : 0;

            // 3. 유효성 검사 (하나라도 없으면 즉시 종료하여 에러 방지)
            if (pick === "" || bet <= 0) {
                replier.reply(formatError(user, "입력 오류", "정확한 배팅 정보를 입력하세요.\n(예: /홀짝 홀 10000 또는 /홀짝 홀10000)"));
                return true;
            }
            
            // [엔진 연결] 물가 배율 엔진
            var multiplier = util_getEcoMultiplier(roomName);
            var minBet = Math.floor((SYSTEM_CONFIG.ECO.GAMBLE_MIN || 300) * multiplier);
            var maxBet = Math.floor((SYSTEM_CONFIG.ECO.GAMBLE_MAX || 2000) * multiplier);

            if (isNaN(bet) || bet < minBet) { replier.reply(formatError(user, "금액 오류", "최소 " + fp(minBet) + "P 이상 베팅해야 합니다.")); return true; }
            if (bet > maxBet) { replier.reply(formatError(user, "상한 초과", "최대 " + fp(maxBet) + "P까지 베팅 가능합니다.")); return true; }
            if (Number(user.point) < bet) { replier.reply(formatError(user, "포인트 부족", "베팅할 포인트가 부족합니다.")); return true; }

            // [도박왕] 배당금 0.05배 상승 (0.85 -> 0.90)
            var payoutRate = 0.85;
            if (user.title === "도박왕") payoutRate += 0.05;
            var expectedPayout = Math.floor(bet * payoutRate);

            // 게임 컨텐츠는 긴급 삭감을 적용하지 않음
            var finalProfit = Math.floor(expectedPayout); 
            var totalPayout = bet + finalProfit; // 원금 + 수익 전체 보존

            if (!util_isBankSolvent(roomName, finalProfit)) {
                return replier.reply("🚨 [중앙은행 지불 정지]\n금고 잔액 부족으로 홀짝 승리금을 지급할 수 없습니다.");
            }

            // [수정] 미선언된 winProb 변수를 시스템 설정 및 상태에 따라 정의 (피버/부적 반영)
            var baseProb = data.feverData && data.feverData.active ? SYSTEM_CONFIG.PROB.ODD_EVEN_FEVER : SYSTEM_CONFIG.PROB.ODD_EVEN_WIN;
            var winProb = (user.luckyCharmEnd && Date.now() < user.luckyCharmEnd) ? baseProb + 0.03 : baseProb;

            var isWin = Math.random() < winProb; 
            var result = isWin ? pick : (pick === "홀" ? "짝" : "홀");
            
            // 1. 도박 참여 통계 갱신 (게이트웨이 보호 - 중복 연산 ++ 제거)
            var nextTotalGamble = Number(user.totalGambleCount || 0) + 1;
            util_setData(user, 'totalGambleCount', nextTotalGamble, "도박 통계 갱신", roomName);

            // 2. 일일 도박 횟수 갱신 (신용도 감점용)
            var nextDailyGamble = (user.dailyGambleCount || 0) + 1;
            util_setData(user, 'dailyGambleCount', nextDailyGamble, "홀짝 참여", roomName);

            if (user.dailyGambleCount > 10) {
                user.creditScore = Math.max(0, Number(user.creditScore || 600) - 1);
                checkAndHandleDefaulter(user, roomName);
            }

            if (isWin) {
                // 1. 승리 데이터 갱신
                var nextWins = Number(user.totalGambleWins || 0) + 1;
                util_setData(user, 'totalGambleWins', nextWins, "도박 승리 기록", roomName);
                
                var res = processRepayment(user, expectedPayout, targetUid, roomName);
                util_updatePoint(user, roomData, Number(res.actualGain), "홀짝 적중", roomName);
                
                /* ===== 수정 포인트: 변수 안전성 확보 ===== */
                // 변수가 선언되지 않았을 경우를 대비해 직접 상태 체크
                var isCharm = (user.luckyCharmEnd && Date.now() < user.luckyCharmEnd);
                var isFever = (data.feverData && data.feverData.active === true);
                
                var winPrefix = isCharm ? "🔮 [부적] " : (isFever ? "🔥 [피버] " : "🎊 ");
                var charmMsg = isCharm ? "\n(✨ 행운의부적 효과 적용 중: 승률 +3%)" : "";
                var repayInfo = (res && res.repayMsg) ? res.repayMsg : ""; // undefined 방어
                
                var outputMsg = "결과: [" + result + "]\n축하합니다! " + fp(Number(res.actualGain)) + "P 획득!" + repayInfo + charmMsg;
                
                // 최종 출력
                replier.reply(formatCommand(winPrefix + "홀짝 적중!", user, outputMsg, "잔액: " + fp(user.point) + "P"));
                
            } else {
                // 2. 패배 처리
                util_updatePoint(user, roomData, -bet, "홀짝 미적중", roomName);
                
                /* ===== 수정 포인트: 변수 안전성 확보 ===== */
                var isCharm = (user.luckyCharmEnd && Date.now() < user.luckyCharmEnd);
                var isFever = (data.feverData && data.feverData.active === true);
                
                var losePrefix = isCharm ? "🔮 [부적] " : (isFever ? "🔥 [피버] " : "💀 ");
                
                var outputMsg = "결과: [" + result + "]\n아쉽지만 " + fp(bet) + "P를 잃었습니다.";
                
                // 최종 출력
                replier.reply(formatCommand(losePrefix + "홀짝 미적중", user, outputMsg, "잔액: " + fp(user.point) + "P"));
            }

            // [엔진 연결] 칭호 자동 부여 시스템
            var winRate = (user.totalGambleWins / user.totalGambleCount) * 100;
            var rStub = { reply: function(m) { Api.replyRoom(roomName, m); } };

            if (user.totalGambleCount >= 500) {
                util_checkAndAwardTitle(user, rStub, "도박왕", 4003, "🎲", "내리다 카지노 협회", "도박 횟수 500회", "[장착 효과]: 홀짝 적중 시 배당금이 0.05배 추가로 상승합니다.");
            } else if (user.totalGambleCount >= 100 && winRate >= 60) {
                util_checkAndAwardTitle(user, rStub, "타짜", 4002, "🎴", "내리다 카지노 협회", "총 승률 60% 돌파", "판의 흐름을 꿰뚫어 보는 냉철한 눈을 가졌습니다.");
            } else if (user.totalGambleCount >= 100) {
                util_checkAndAwardTitle(user, rStub, "꾼", 4001, "🃏", "내리다 카지노 협회", "도박 횟수 100회", "도박판의 생리를 완벽히 깨닫기 시작한 무서운 승부사입니다.");
            }

            safeSaveData(data);
            endTracking(user, true, "완료");
            return true;
        } catch(e) { endTracking(user, false, "CRASH: " + e); return true; }
    }

    /* [기존 로직 유지] 4. 티어 승급 (/승급) */
    if (msg === "/승급") {
        var totalAttempts = Number(user.dailyPromotionAttempts || 0) + Number(user.purchasedPromotionAttempts || 0);
        if (totalAttempts <= 0) { replier.reply(formatError(user, "기회 없음", "상점에서 승급권을 구매하세요.")); return true; }
        if (user.tier >= 9) { replier.reply(formatError(user, "최고 등급", "이미 챌린저 등급입니다.")); return true; }

        var usedDaily = false;
        if (Number(user.dailyPromotionAttempts) > 0) { 
            util_setData(user, 'dailyPromotionAttempts', user.dailyPromotionAttempts - 1, "일일 승급 기회 차감", roomName);
            usedDaily = true; 
        }
        else { 
            util_setData(user, 'purchasedPromotionAttempts', user.purchasedPromotionAttempts - 1, "구매 승급권 차감", roomName);
        }

        var prob = TIER_PROBS[user.tier] || { up: 50, stay: 40, down: 10 };
        var rand = Math.random() * 100;
        var isSundayFever = (new Date().getDay() === 0);
        if (isSundayFever) rand -= 5; 

        startTracking(user, "승급 도전");

        if (rand < prob.up) { 
            // 1. 차세대 티어 계산 및 게이트웨이 검증
            var nextTier = Number(user.tier || 0) + 1;
            util_setData(user, 'tier', nextTier, "승급 성공", roomName);

            var successBody = "티어: [" + TIERS[nextTier] + "]\n\n";
            
            if (nextTier === 9) { // 챌린저 도달 판정
                // 챌린저 횟수 통계도 게이트웨이로 보호
                util_setData(user, 'challengerCount', (user.challengerCount || 0) + 1, "챌린저 달성", roomName);
                user.challengerIconSeason = getSimpleSeason();
                successBody += "🎊 축하합니다! 챌린저 등급 도달! 명예의 전당에 기록되었습니다.";
            } else {
                // 승급 성공 보너스 기회 증가도 게이트웨이로 보호
                if (usedDaily) {
                    util_setData(user, 'dailyPromotionAttempts', (user.dailyPromotionAttempts || 0) + 1, "승급 성공 보너스", roomName);
                } else {
                    util_setData(user, 'purchasedPromotionAttempts', (user.purchasedPromotionAttempts || 0) + 1, "승급 성공 보너스", roomName);
                }
                successBody += "🎉 승급 성공 보너스: 재도전 기회 유지!";
            }
            replier.reply(formatCommand("🎊 승급 성공!", user, successBody, "남은 기회: " + (Number(user.dailyPromotionAttempts) + Number(user.purchasedPromotionAttempts)) + "회"));
            endTracking(user, true, "승급 성공");
        } else if (rand > (100 - prob.down)) {
            if (Number(user.tierGuard || 0) > 0) {
                util_setData(user, 'tierGuard', user.tierGuard - 1, "강등 방어권 사용", roomName);
                replier.reply(formatCommand("🛡️ 강등 방어", user, "티어: [" + TIERS[user.tier] + "] 유지\n방어권을 사용하여 보호했습니다.", "남은 방어권: " + user.tierGuard + "개"));
                endTracking(user, true, "강등 방어");
            } else {
                util_setData(user, 'tier', Math.max(0, user.tier - 1), "승급 실패 강등", roomName);
                replier.reply(formatCommand("📉 강등 발생", user, "티어: [" + TIERS[user.tier] + "]\n상태: 티어가 하락했습니다.", "남은 기회: " + (Number(user.dailyPromotionAttempts) + Number(user.purchasedPromotionAttempts)) + "회"));
                endTracking(user, false, "강등 발생");
            }
        } else {
            replier.reply(formatCommand("😐 승급 실패", user, "티어: [" + TIERS[user.tier] + "] 유지\n상태: 승급에 실패했습니다.", "남은 기회: " + (Number(user.dailyPromotionAttempts) + Number(user.purchasedPromotionAttempts)) + "회"));
            endTracking(user, false, "승급 실패");
        }
        safeSaveData(data);
        return true;
    }

    return false;
}

//==========섹터41==========

/**
 * [게임 하위 모듈 3-2] 액션 및 도박 게임 (결투 시스템)
 */
function _gameActionLogic_Part2(msg, user, data, replier, roomName, targetUid) {
    var roomData = data.rooms[roomName];
    if (!roomData || !roomData.features) return false;

    // [상태 로컬라이징] 방별 독립 결투 데이터 참조
    var duelData = roomData.features.states.duelData;

    /* [기능 11] 결투 신청 */
    if (msg.indexOf("/결투 ") === 0) {
        if (data.gambleLimit) { replier.reply(formatError(user, "도박 제한", "현재 도박 기능이 제한되어 있습니다.")); return true; }
        var myState = util_checkUserState(user, targetUid);
        if (!myState.canAction) { replier.reply(formatError(user, "결투 불가", myState.reason)); return true; }
        var parts = msg.trim().split(/\s+/);
        if (parts.length < 3) { replier.reply(formatError(user, "형식 오류", "/결투 [닉네임] [금액]")); return true; }
        var am = parseInt(parts.pop().replace(/,/g, ""));
        var tn = parts.slice(1).join(" ").trim();

        var minBet = Math.floor(100 * util_getEcoMultiplier(roomName));

        if (isNaN(am) || am < minBet) { replier.reply(formatError(user, "금액 오류", "최소 " + fp(minBet) + "P 이상 결투 가능합니다.")); return true; }
        if (Number(user.point) < am) { replier.reply(formatError(user, "포인트 부족", "베팅할 포인트가 부족합니다.")); return true; }
        
        var found = findUserByName(roomData, tn);
        if (found.length === 0) { replier.reply(formatError(user, "대상 없음", "[" + tn + "]님을 찾을 수 없습니다.")); return true; }
        if (found.length > 1) { handleUserSelection(replier, targetUid, found, "duel", { bet: am }, user, roomName); return true; }
        var target = found[0];
        if (target.id === targetUid) { replier.reply(formatError(user, "결투 불가", "자신과는 싸울 수 없습니다.")); return true; }
        if (isUserBusy(target.id)) { replier.reply(formatError(user, "대상 활동 중", "상대방이 현재 다른 활동을 하고 있습니다.")); return true; }

        util_updatePoint(user, roomData, -am, "결투 신청 베팅", roomName);

        duelData[target.id] = { challengerUid: targetUid, point: am, expire: Date.now() + 30000, room: roomName };
        replier.reply(formatCommand("⚔️ 결투 신청", target.data, getDisplayName(user) + "님이 " + fp(am) + "P 결투를 신청했습니다!\n\n승낙하시겠습니까? (수락/거절/취소)", "내 잔액: " + fP(user.point) + "P"));
        safeSaveData(data);
        return true;
    }

    /* [v5.9 수정] 결투 취소 (신청자가 직접 철회) */
    if (msg === "취소") {
        var cancelTargetId = null;
        // 현재 방의 결투 데이터 중 내가 신청자인 건을 탐색
        for (var tid in duelData) {
            if (duelData[tid].challengerUid === targetUid) {
                cancelTargetId = tid;
                break;
            }
        }

        if (cancelTargetId) {
            var d = duelData[cancelTargetId];
            // [엔진 연동] 신청자에게 베팅금 즉시 환급
            util_updatePoint(user, roomData, d.point, "결투 취소 환급", roomName);
            delete duelData[cancelTargetId];
            
            replier.reply(formatCommand("🚫 결투 취소 완료", user, "결투 신청을 철회하고 베팅금을 반환받았습니다.", "내 잔액: " + fp(user.point) + "P"));
            safeSaveData(data);
            return true;
        }
    }

    /* [v5.9 수정] 결투 수락 (상대방이 승낙) */
    if (msg === "수락" && duelData[targetUid]) {
        if (data.gambleLimit) { replier.reply(formatError(user, "도박 제한", "현재 도박 기능이 제한되어 있습니다.")); return true; }
        
        var d = duelData[targetUid];
        var challenger = roomData.users[d.challengerUid];
        if (!challenger) { delete duelData[targetUid]; return true; }

        // 수락자의 가용 포인트 체크
        if (Number(user.point) < d.point) {
            util_updatePoint(challenger, roomData, d.point, "상대 포인트 부족 환급", roomName);
            delete duelData[targetUid];
            replier.reply(formatError(user, "포인트 부족", "수락하기 위한 포인트가 부족하여 결투가 무산되었습니다."));
            return true;
        }

        // [엔진 연동] 수락자 베팅금 차감
        util_updatePoint(user, roomData, -d.point, "결투 수락 베팅", roomName);

        // 승패 판정 (50:50)
        var isChallengerWin = Math.random() < 0.5;
        var winner = isChallengerWin ? challenger : user;
        var winnerId = isChallengerWin ? d.challengerUid : targetUid;
        var winPrize = d.point * 2;

        // [핵심] 상환 엔진 통과 후 게이트웨이로 최종 승리금 지급
        var res = processRepayment(winner, winPrize, winnerId, roomName);
        util_updatePoint(winner, roomData, Number(res.actualGain), "결투 승리 보상", roomName);

        var resBody = "⚔️ 결투 결과\n" + getDisplayName(challenger) + " VS " + getDisplayName(user) + "\n\n🏆 승자: " + getDisplayName(winner) + "\n💰 획득: " + fp(winPrize) + "P" + (res.repayMsg || "");
        replier.reply(formatCommand("⚔️ 결투 종료", winner, resBody, "내 잔액: " + fp(winner.point) + "P"));
        
        delete duelData[targetUid];
        safeSaveData(data);
        return true;
    }

    /* [v5.9 수정] 결투 거절 (상대방이 거부) */
    if (msg === "거절" && duelData[targetUid]) {
        var d = duelData[targetUid];
        var challenger = roomData.users[d.challengerUid];
        
        if (challenger) {
            // [엔진 연동] 신청자에게 베팅금 안전 환급
            util_updatePoint(challenger, roomData, d.point, "결투 거절 환급", roomName);
        }
        
        delete duelData[targetUid];
        replier.reply(formatCommand("🚫 결투 거절", user, "결투 신청을 거절했습니다.\n신청자에게 베팅금이 반환되었습니다.", "닫기: [취소]"));
        safeSaveData(data);
        return true;
    }
    return false;
}

//==========섹터42==========

/**
 * [게임 하위 모듈 3-3] 액션 및 도박 게임 (도둑질 & 줍기)
 * 수정 사항: 벌금 이중 가산 버그 수정 및 모든 포인트 로직에 방 격리 식별자(roomName) 적용
 */
function _gameActionLogic_Part3(msg, user, data, replier, roomName, targetUid) {
    var roomData = data.rooms[roomName];
    if (!roomData || !roomData.features) return false;

    // [상태 로컬라이징] 방별 독립 뿌리기 및 도둑질 상태 참조
    var sprinkleData = roomData.features.sprinkleData;
    var activeThefts = roomData.features.states.activeThefts;

    /* [기능 12] 도둑질 시도 */
    if (msg.indexOf("/도둑질 ") === 0) {
        if (data.gambleLimit) { replier.reply(formatError(user, "도박 제한", "현재 도박 기능이 제한되어 있습니다.")); return true; }
        
        var myState = util_checkUserState(user, targetUid);
        if (!myState.canAction) {
            replier.reply(formatError(user, "도둑질 금지", myState.reason));
            return true;
        }

        // 1. 도둑 글로벌 쿨타임 체크 (1시간)
        var now = Date.now();
        if (now - (user.lastTheftActionTime || 0) < 3600000) {
            var remainMin = Math.ceil((3600000 - (now - user.lastTheftActionTime)) / 60000);
            replier.reply(formatError(user, "쿨타임 제한", "도둑질 후 재정비 시간이 필요합니다.\n" + remainMin + "분 후 다시 시도하세요."));
            return true;
        }

        var tn = msg.substring(5).trim();
        var found = findUserByName(roomData, tn);
        if (found.length === 0) { replier.reply(formatError(user, "대상 없음", "[" + tn + "]님을 찾을 수 없습니다.")); return true; }
        if (found.length > 1) { handleUserSelection(replier, targetUid, found, "theft", null, user, roomName); return true; }
        
        var victim = found[0];
        if (victim.id === targetUid) { replier.reply(formatError(user, "강탈 불가", "자신의 지갑은 털 수 없습니다.")); return true; }

        // 2. 피해자 조건 체크: 최소 자산 1만P 초과 & 피해자 보호 6시간 체크
        if (Number(victim.data.point) <= 10000) { 
            replier.reply(formatError(user, "강탈 대상 부적합", "보유 포인트가 " + fp(10000) + "P를 초과하는 유저만 털 수 있습니다.")); 
            return true; 
        }
        if (now < (victim.data.lastTheftVictimTime || 0)) {
            var remainSec = Math.ceil((victim.data.lastTheftVictimTime - now) / 1000);
            var h = Math.floor(remainSec / 3600);
            var m = Math.ceil((remainSec % 3600) / 60);
            replier.reply(formatError(user, "보호 대상", "해당 유저는 최근 피해를 입어 국가의 보호를 받고 있습니다.\n(남은 시간: " + h + "시간 " + m + "분)"));
            return true;
        }
        if (activeThefts[victim.id]) { replier.reply(formatError(user, "중복 강탈 불가", getDisplayName(victim.data) + "님은 현재 다른 도둑이 작업 중입니다!")); return true; }

        // 3. 도둑질 프로세스 설정 (30초 단축 및 랜덤 타이머)
        user.lastTheftActionTime = now; // 쿨타임 시작 시점 기록
        
        // 성공 타이머: 정확히 30초 (30000ms)
        var successDelay = 30000;
        // 경찰 타이머: 15초 후 출동 확률 계산 (15000ms)
        var policeDelay = 15000;
        
        var policeProb = (user.title === "약탈왕") ? 0.3 : 0.5;
        
        var sT = setTimeout(function(){ processTheftResult(roomName, targetUid, victim.id); }, successDelay);
        var pT = setTimeout(function(){ if (Math.random() < policeProb) { processPoliceResult(roomName, targetUid, victim.id); } }, policeDelay);
        
        activeThefts[victim.id] = { thiefUid: targetUid, successTimer: sT, policeTimer: pT };
        user.creditScore = Math.max(0, Number(user.creditScore || 600) - 10);

        var attemptMsg = getDisplayName(victim.data) + "님 강탈 시도 중 (30초 소요)\n\n" +
                         "🚓 15초 후 경찰 출동 확률 " + (policeProb * 100) + "%!";

        replier.reply(formatCommand("🕵️ 도둑질 시도", user, attemptMsg, "방어: 30초 내 [잡았다요놈] 입력"));
        
        // [Gemini 요청 사항] 방 식별자 roomName 추가
        checkAndHandleDefaulter(user, roomName);
        safeSaveData(data);
        return true;
    }

    /* 도둑질 방어 (잡았다요놈) */
    if (msg === "잡았다요놈") {
        if (!activeThefts[targetUid]) return false;
        var theft = activeThefts[targetUid];
        if (theft.successTimer) clearTimeout(theft.successTimer);
        if (theft.policeTimer) clearTimeout(theft.policeTimer);
        var thief = roomData.users[theft.thiefUid];
        
        var multiplier = util_getEcoMultiplier(roomName);

        // 1. 벌금 계산: 현보유액의 10% 차감
        var cashFine = Math.floor(Number(thief.point) * 0.1);
        // 2. 대납 계산: 최소 벌금 1,000P 미달 시 부족분을 대출로 전환
        var loanGap = Math.max(0, 1000 - cashFine);

        util_updatePoint(thief, roomData, -cashFine, "도둑질 체포 벌금", roomName);
        
        var loanMsg = "";
        if (loanGap > 0) {
            if (!thief.loan) thief.loan = { debt: 0, items: [] };
            thief.loan.debt = Number(thief.loan.debt || 0) + loanGap;
            if (!thief.loan.items) thief.loan.items = [];
            thief.loan.items.push(loanGap);
            loanMsg = "\n⚠️ 벌금 부족분 대납: " + fp(loanGap) + "P 대출 전환";
        }
        
        thief.jailReleaseTime = Date.now() + (1 * 60 * 60 * 1000); 
        delete activeThefts[targetUid];
        
        var resContent = "🚨 [현행범 체포]\n대상: " + getDisplayName(thief) + "\n결과: -" + fp(cashFine) + "P 차감 / 징역 1시간" + loanMsg + "\n내 잔액: " + fp(thief.point) + "P";
        replier.reply(formatAdmin("🚓 체포 완료", resContent));
        safeSaveData(data);
        return true;
    }

   /* [Gemini 요청 사항] 뿌리기 줍기 (참조 기반 데이터 확인 및 국고 연동) */
    if (msg === "줍기") {
        // 1. 이벤트 활성화 체크 (방별 주머니 기준)
        if (!sprinkleData || sprinkleData.active !== true) return false;

        var currentUser = user || roomData.users[targetUid];
            // 이벤트가 없을 때 무응답 대신 안내를 주어 '먹통' 오해를 해소합니다.
            // replier.reply(formatError(user, "줍기 실패", "현재 진행 중인 뿌리기 이벤트가 없습니다."));
            if (!currentUser) return false;

        // 2. 유저 데이터 무결성 체크
        var currentUser = user || roomData.users[targetUid];
        if (!currentUser) return false;

        // 3. 중복 참여 및 선착순 검증
        if (sprinkleData.winners.indexOf(targetUid) !== -1) {
            replier.reply(formatError(currentUser, "중복 참여 불가", "이미 이 이벤트에서 포인트를 획득하셨습니다."));
            return true;
        }
        if (sprinkleData.currentWinners >= sprinkleData.limit) {
            replier.reply(formatError(currentUser, "선착순 마감", "이미 모든 포인트가 소진되었습니다."));
            return true;
        }

        // 4. 포인트 배정 및 지급 (portions 배열에서 마지막 값 추출)
        var prize = sprinkleData.portions.pop();
        if (prize === undefined) return false;

        sprinkleData.winners.push(targetUid);
        sprinkleData.currentWinners++;
        sprinkleData.remainingPoint -= prize;

        // [v5.9] 통합 상환 엔진 및 게이트웨이 지급
        var res = processRepayment(currentUser, prize, targetUid, roomName);
        util_updatePoint(currentUser, roomData, Number(res.actualGain), "뿌리기 줍기", roomName);

        replier.reply(formatCommand("🎉 줍기 성공!", currentUser, fp(prize) + "P를 주웠습니다!" + res.repayMsg, "내 잔액: " + fp(currentUser.point) + "P"));

        // 5. 전량 소진 시 이벤트 자동 종료
        if (sprinkleData.currentWinners >= sprinkleData.limit) {
            sprinkleData.active = false;
            Api.replyRoom(roomName, formatAdmin("🏁 뿌리기 마감", "모든 포인트가 소진되어 이벤트가 종료되었습니다."));
        }
        safeSaveData(data);
        return true;
    }

    return false;
}

//==========섹터43==========

/**
 * [게임 하위 모듈 4] 주식 투자 관리 (성취 기반 칭호 통합 버전)
 * 기능: 주식 시세 조회, 내 주식 확인, 매수, 매도
 * 설명: 폐쇄형 순환 경제 연동 - 매수금은 금고 입고, 매도금은 금고 지출
 */
function _gameStockLogic(msg, user, data, replier, roomName, targetUid) {
    var roomData = data.rooms[roomName];
    if (!roomData) return false;

    // 중앙은행 재원 초기화 (안전장치)
    if (roomData.bankReserve === undefined || roomData.bankReserve === null) {
        roomData.bankReserve = SYSTEM_CONFIG.ECO.BANK.INITIAL_RESERVE;
    }

    /* [기능 13] 주식 거래 */

    // 1. 실시간 시세 조회
    if (msg === "/주식") {
        var currentHour = new Date().getHours();
        var isMarketOpen = (currentHour >= 7 && currentHour <= 23);
        var statusText = isMarketOpen ? "🟢 장 운영 중 (07:00 ~ 23:59)" : "🔴 장 마감 (00:00~06:59)";
        var stockList = generateStockList(data); 
        
        replier.reply("📈 실시간 주식 시세\n━━━━━━━━━━━━━━━\n" + statusText + "\n\n" + (stockList || "상장된 종목이 없습니다.") + "\n━━━━━━━━━━━━━━━\n💡 [가이드]: 매수: [/매수 종목명 수량]");
        return true;
    }

    // 2. 내 보유 주식 확인
    if (msg === "/내주식") {
        var holdings = user.stockHoldings || {};
        var keys = Object.keys(holdings);
        var title = "📊 " + getDisplayName(user) + "의 주식 상황";

        if (keys.length === 0) {
            replier.reply(formatCommand(title, null, "보유 중인 주식이 없습니다.", "매수: [/매수 종목명 수량]"));
            return true;
        }

        var list = [];
        var totalEvaluation = 0;
        var totalPurchase = 0;

        for (var i = 0; i < keys.length; i++) {
            var sName = keys[i];
            var count = Number(holdings[sName]);
            if (count <= 0) continue;

            var stock = data.stockMarket[sName];
            var isDelisted = !stock; 
            var curPrice = isDelisted ? 0 : Math.floor(Number(stock.price));
            var avgPrice = Math.floor(Number(user.stockAvg[sName] || 0));
            
            var purchaseVal = Math.floor(avgPrice * count);
            var evaluationVal = Math.floor(curPrice * count);
            
            totalPurchase += purchaseVal;
            totalEvaluation += evaluationVal;
            
            var profit = evaluationVal - purchaseVal;
            var profitRate = avgPrice > 0 ? ((profit / purchaseVal) * 100).toFixed(1) : "0.0";
            var signIcon = profit > 0 ? "🔺" : (profit < 0 ? "🔹" : "➖");
            var nameDisplay = isDelisted ? "⚠️(상폐) " + sName : sName;
            
            list.push("• " + nameDisplay + " " + count + "주\n" +
                      "  수익: " + fp(Math.floor(profit)) + "P (" + signIcon + profitRate + "%)\n" +
                      "  평단: " + fp(avgPrice) + "P ➔ 현재: " + fp(curPrice) + "P");
        }

        var totalProfit = totalEvaluation - totalPurchase;
        var totalRate = totalPurchase > 0 ? ((totalProfit / totalPurchase) * 100).toFixed(1) : "0.0";
        var totalSignIcon = totalProfit > 0 ? "🔺" : (totalProfit < 0 ? "🔹" : "➖");

        var summary = "💎 총 평가금액: " + fp(Math.floor(totalEvaluation)) + "P\n" +
                      "📊 총 수익률: " + fp(Math.floor(totalProfit)) + "P (" + totalSignIcon + totalRate + "%)\n" +
                      "💰 보유 포인트: " + fp(Math.floor(user.point)) + "P";

        replier.reply(formatCommand(title, null, list.join("\n\n") + "\n\n" + summary, "매도: [/매도 종목명 수량]"));
        return true;
    }

    // 3. 주식 매수 (금고 입고 및 투자 칭호 연동)
    if (msg.indexOf("/매수 ") === 0) {
        if (util_isBankruptcy(roomName)) {
            replier.reply(formatError(user, "거래 동결", "국가 부도 상태에서는 신규 주식 매수가 불가능합니다."));
            return true;
        }

        var stateRes = util_checkUserState(user, targetUid);
        if (!stateRes.canAction) {
            replier.reply(formatError(user, "거래 불가", stateRes.reason));
            return true;
        }
        var currentHour = new Date().getHours();
        if (currentHour < 7) { replier.reply(formatError(user, "주식 시장 마감", "현재는 주식 장외 시간입니다.\n(운영시간: 07:00 ~ 23:59)")); return true; }

        var parts = msg.split(" ");
        if (parts.length < 3) { replier.reply(formatError(user, "형식 오류", "/매수 [종목명] [수량]")); return true; }
        var sInput = parts[1], count = parseInt(parts[2].replace(/,/g, ""));
        var matched = util_findStockByShorthand(data.stockMarket, sInput);
        
        if (matched.length === 0) { replier.reply(formatError(user, "종목 없음", "[" + sInput + "] 종목을 찾을 수 없습니다.")); return true; }
        if (matched.length > 1) { handleStockSelection(replier, targetUid, matched, "stock_buy", count, user, roomName); return true; }
        
        var sName = matched[0];
        var stock = data.stockMarket[sName];
        if (!stock) { replier.reply(formatError(user, "종목 없음", "[" + sName + "]을 찾을 수 없습니다.")); return true; }
        if (isNaN(count) || count <= 0) { replier.reply(formatError(user, "수량 오류", "수량을 정확히 입력하세요.")); return true; }
        
        var totalPrice = Math.floor(Number(stock.price) * count);
        if (Number(user.point) < totalPrice) { replier.reply(formatError(user, "포인트 부족", "필요: " + fp(totalPrice) + "P")); return true; }
        
        /* [핵심] 중앙은행 연동: 매수 대금을 금고에 입고 */
        util_updatePoint(user, roomData, -totalPrice, "주식 매수", roomName);

        // 1. 평단가 계산 로직 (계산은 유지하되, 데이터 구조는 딥헬러가 보장함)
        var curCount = Number(user.stockHoldings[sName] || 0);
        var curAvg = Number(user.stockAvg[sName] || 0);
        var newAvg = Math.floor(((curAvg * curCount) + totalPrice) / (curCount + count));
        
        // 평단가 업데이트 (객체 내부 키 대입)
        user.stockAvg[sName] = newAvg; 
        
        // 2. 주식 수량 업데이트 (전용 보안 함수 호출)
        util_updateStock(user, sName, count, "주식 매수", roomName);

        // 3. [교체] 누적 투자 데이터 게이트웨이 보호
        // 직접 연산(+=) 대신 안전하게 합산된 최종값을 전달합니다.
        var nextInvestAmount = Number(user.totalInvestAmount || 0) + totalPrice;
        util_setData(user, 'totalInvestAmount', nextInvestAmount, "주식 투자 총액 갱신", roomName);

        var replierStub = { reply: function(m) { Api.replyRoom(roomName, m); } };

        if (user.totalInvestAmount >= 10000000) {
            util_checkAndAwardTitle(user, replierStub, "투자왕", 4303, "📈", "내리다 경제 위원회", "누적 투자액 10,000,000P", "[장착 효과]: 주식 매도 시 발생한 순수익의 5%를 보너스로 추가 지급합니다.");
        } else if (user.totalInvestAmount >= 5000000) {
            util_checkAndAwardTitle(user, replierStub, "큰손", 4302, "📉", "내리다 경제 위원회", "누적 투자액 5,000,000P", "당신의 움직임 하나에 전 국가의 차트가 요동칩니다.");
        } else if (user.totalInvestAmount >= 3000000) {
            util_checkAndAwardTitle(user, replierStub, "개미", 4301, "🐜", "내리다 경제 위원회", "누적 투자액 3,000,000P", "위대한 투자의 여정에서 첫 번째 결실을 맺었습니다.");
        }
        
        if (!data.stockTraffic) data.stockTraffic = {};
        if (!data.stockTraffic[sName]) data.stockTraffic[sName] = { buy: 0, sell: 0 };
        data.stockTraffic[sName].buy += count;

        if (Math.random() < 0.1) { // 10% 확률
            user.stockCertCount = (user.stockCertCount || 0) + 1;
            buySuccessMsg += "\n\n 📈 서류 봉투에서 '미발행확인서'가 발견되었습니다.\n(현재 수집: " + user.stockCertCount + " / 10)";
            
            if (user.stockCertCount >= 10) {
                user.stockCertCount = 0; // 초기화
                util_checkAndAwardTitle(user, replier, "최대주주", 888, "🏢", "내리다 경제 위원회", "확인서 10장 수집 완료", "[장착 효과]: 주식 매도 시 국고로 귀속되는 세금이 50% 감면됩니다.", roomName);
            }
        }
        
        replier.reply(formatCommand("📈 주식 매수 완료", user, "종목: " + sName + "\n수량: " + count + "주\n매수가: " + fp(stock.price) + "P (총 " + fp(totalPrice) + "P)", "내 잔액: " + fp(user.point) + "P"));
        safeSaveData(data);
        return true;
    }

    // 4. 주식 매도 (금고 지출 연동 및 뱅크런 방지)
    if (msg.indexOf("/매도 ") === 0) {

        if (util_isBankruptcy(roomName)) {
            replier.reply(formatError(user, "자산 동결", "국가 부도 선포로 인해 주식 매도(현금화)가 일시 정지되었습니다.\n(회복 기준: 국고 50%)"));
            return true;
        }

        var stateRes = util_checkUserState(user, targetUid);
        if (!stateRes.canAction) {
            replier.reply(formatError(user, "거래 불가", stateRes.reason));
            return true;
        }
        var currentHour = new Date().getHours();
        if (currentHour < 7) { replier.reply(formatError(user, "주식 시장 마감", "현재는 주식 장외 시간입니다.")); return true; }

        var parts = msg.split(" ");
        if (parts.length < 3) { replier.reply(formatError(user, "형식 오류", "/매도 [종목명] [수량]")); return true; }
        
        var sInput = parts[1]; 
        var count = parseInt(parts[2].replace(/,/g, ""));
        
        // [지능형 매도 검색] 보유 중인 주식 리스트에서만 검색 풀(Pool) 생성
        var myMarket = {};
        for (var key in user.stockHoldings) { 
            if (data.stockMarket[key] && Number(user.stockHoldings[key]) > 0) {
                myMarket[key] = data.stockMarket[key]; 
            }
        }
        
        // 약어 검색 엔진 가동
        var matched = util_findStockByShorthand(myMarket, sInput);
        
        if (matched.length === 0) { 
            replier.reply(formatError(user, "보유 종목 없음", "보유 중인 주식 중 [" + sInput + "]와 일치하는 종목이 없습니다.")); 
            return true; 
        }
        
        // 검색 결과가 2개 이상일 경우 선택 대기 상태로 전환
        if (matched.length > 1) { 
            handleStockSelection(replier, targetUid, matched, "stock_sell", count, user, roomName); 
            return true; 
        }
        
        // 1개일 경우 종목명 확정
        var sName = matched[0];

        var holdings = (user.stockHoldings && user.stockHoldings[sName]) ? Number(user.stockHoldings[sName]) : 0;
        if (holdings < count || count <= 0) { replier.reply(formatError(user, "수량 부족", "보유 수량을 확인해주세요.")); return true; }

        user.skipHealing = true; 

        // [가상 정부] 현재 시행 중인 정책 데이터 로드
        var pol = util_getActivePolicy(roomData);

        var stock = data.stockMarket[sName];
        var sellPrice = stock ? Math.floor(Number(stock.price)) : 0;
        var totalSell = sellPrice * count; 

        var isMajor = (user.title === "최대주주");
        var baseTaxRate = pol.stockTax || 0.05;
        var appliedTaxRate = isMajor ? (baseTaxRate / 2) : baseTaxRate; // 최대주주면 세금 50% 감면
        
        var fee = Math.floor(totalSell * appliedTaxRate);
        var baseFinalPrice = totalSell - fee;

        // [투자왕] 매도 시 수익(수익금 기준)의 5% 추가 지급
        if (user.title === "투자왕" && profit > 0) {
            var bonus = Math.floor(profit * 0.05);
            baseFinalPrice += bonus;
        }

        // 투자 컨텐츠는 긴급 삭감(0.5)을 적용하지 않고 전액(baseFinalPrice)을 지급액으로 설정
        var finalPrice = Math.floor(baseFinalPrice); 

        // 단, 은행에 실제 줄 돈이 없는 '부도' 상태일 때 지급이 정지되는 가드는 유지합니다.
        if (!util_isBankSolvent(roomName, finalPrice)) {
            return replier.reply("🚨 [중앙은행 지불 정지]\n중앙은행의 현금 유동성 부족으로 주식 매도 대금 지급이 불가능합니다.");
        }

        var avgPrice = (user.stockAvg && user.stockAvg[sName]) ? Number(user.stockAvg[sName]) : sellPrice; 
        var purchaseVal = Math.floor(avgPrice * count); 
        var profit = totalSell - purchaseVal; 
        var profitRate = purchaseVal > 0 ? ((profit / purchaseVal) * 100).toFixed(1) : "0.0";
        var signIcon = (profit > 0) ? "🔺" : (profit < 0 ? "🔹" : "➖");

        util_updateStock(user, sName, -count, "주식 매도", roomName);
        if (user.stockHoldings[sName] <= 0) { 
            delete user.stockHoldings[sName]; 
            if (user.stockAvg) delete user.stockAvg[sName]; 
        }
        
        var res = processRepayment(user, finalPrice, targetUid, roomName); 
        
        /* [핵심] 중앙은행 연동: 매도 대금을 금고에서 차감 지급 */
        util_updatePoint(user, roomData, Number(res.actualGain), "주식 매도", roomName);
        
        if (!data.stockTraffic) data.stockTraffic = {};
        if (!data.stockTraffic[sName]) data.stockTraffic[sName] = { buy: 0, sell: 0 };
        data.stockTraffic[sName].sell += count;

        var taxText = isMajor ? "🏢 [최대주주] 감세 혜택 적용!\n적용 세금 : " + fp(fee) + "P (" + (appliedTaxRate * 100).toFixed(1) + "%)" 
                              : "수수료 : -" + fp(fee) + "P (" + (appliedTaxRate * 100).toFixed(1) + "%)";
        
        var sellMsg = "📉 주식 매도 완료\n" +
              "━━━━━━━━━━━━━━━\n" +
              getDisplayName(user) + "님\n" +
              "종목: " + sName + " " + count + "주\n" +
              "수익 : " + fp(Math.abs(profit)) + "P (" + signIcon + Math.abs(profitRate).toFixed(1) + "%)\n" +
              "실현손익 : " + fp(finalPrice) + "P (수수료 -" + (appliedTaxRate * 100).toFixed(1) + "% 포함)" + (res.repayMsg || "") + "\n" +
              "━━━━━━━━━━━━━━━\n" +
              "💡 [가이드]: 내 잔액: " + fp(user.point) + "P";

        replier.reply(sellMsg);
        safeSaveData(data);
        return true;
    }

    return false;
}

//==========섹터44==========

/**
 * [게임 하위 모듈 5] 상점 및 기타 활동
 * 기능: 상점 메뉴 호출, 출석 체크
 * 설명: 폐쇄형 순환 경제 연동 - 출석 보상을 중앙은행 금고에서 지급합니다.
 */
function _gameShopLogic(msg, user, data, replier, roomName, targetUid) {
    var roomData = data.rooms[roomName];
    if (!roomData || !roomData.features) return false;

    // [상태 로컬라이징] 방별 독립 메뉴 대기 상태 참조
    var menuWaitState = roomData.features.states.menuWait;

    // 중앙은행 재원 초기화 (안전장치)
    if (roomData.bankReserve === undefined || roomData.bankReserve === null) {
        roomData.bankReserve = SYSTEM_CONFIG.ECO.BANK.INITIAL_RESERVE;
    }

    /* [기능 14] 상점 메뉴 호출 */
    if (msg === "/상점") {
        var stateRes = util_checkUserState(user, targetUid);
        if (!stateRes.canAction && stateRes.reason.indexOf("광산") === -1) {
            replier.reply(formatError(user, "상점 이용 불가", stateRes.reason));
            return true;
        }
        menuWaitState[targetUid] = { type: 'shop_category', time: Date.now() };
        var categoryList = [];
        for (var id in SHOP_CATEGORIES) {
            categoryList.push(id + ". " + SHOP_CATEGORIES[id]);
        }
        var shopMenu = "원하시는 카테고리 번호를 입력하세요.\n\n" + categoryList.join("\n");
        replier.reply(formatCommand("🛒 내리다봇 통합 상점", user, shopMenu, "취소: [취소] / 입력 대기: 30초"));
        return true;
    }

    /* [기능 2] 출석 체크 (중앙은행 연동) */
    if (msg === "/출석") {
        var stateRes = util_checkUserState(user, targetUid);
        if (!stateRes.canAction && stateRes.reason.indexOf("광산") === -1) {
            replier.reply(formatError(user, "출석 불가", stateRes.reason));
            return true;
        }

        var today = getSimpleDate();
        // 1. 중복 출석 체크
        if (user.lastDate === today) { 
            replier.reply(formatError(user, "이미 출석 완료", "출석은 하루에 한 번만 가능합니다.")); 
            return true; 
        }

       // [가상 정부] 현재 정책 데이터 로드
        var pol = util_getActivePolicy(roomData);

        var multiplier = util_getEcoMultiplier(roomName); 
        var minR = SYSTEM_CONFIG.ECO.ATTEND_MIN || 1000;
        var maxR = SYSTEM_CONFIG.ECO.ATTEND_MAX || 1500;

        var baseReward = Math.floor(Math.random() * (maxR - minR + 1)) + minR;
        
        // 정책 배율(pol.attendMult)을 보상 계산에 최종 적용
        var reward = Math.floor(baseReward * multiplier * (pol.attendMult || 1.0));

        var emergencyMult = util_getEmergencyMultiplier(roomName);
        var baseResult = Math.floor(baseReward * multiplier * (pol.attendMult || 1.0));
        var reward = Math.floor(baseResult * emergencyMult);

        if (!util_isBankSolvent(roomName, reward)) {
            return replier.reply("🚨 [중앙은행 지불 정지]\n국고가 완전히 고갈되어 출석 보상을 지급할 수 없습니다.\n관리자의 재원 수혈이 필요합니다.");
        }

        /* [핵심 수정] 출석 보상 지급 전 통합 상환 엔진 호출 */
        var res = processRepayment(user, reward, targetUid, roomName);
        
        /* [핵심 수정] 중앙은행 연동: 보상금을 금고에서 차감 지급 */
        // util_updatePoint 호출 시 roomData를 전달하여 "출석 보상" 사유로 금고 잔액 차감
        util_updatePoint(user, roomData, Number(res.actualGain), "출석 보상", roomName);

        // 4. 유저 상태 데이터 업데이트
        user.lastDate = today; 
        user.totalAttendance = (user.totalAttendance || 0) + 1;
        user.creditScore = Math.min(1000, (user.creditScore || 600) + 2); 
        
        // 정책 효과가 기본값(1.0)이 아닐 때만 UI에 정책 태그 표시
        var policyTag = (pol.attendMult && pol.attendMult !== 1.0) ? "\n⚖️ 정책 효과: x" + pol.attendMult.toFixed(1) + " (적용 중)" : "";

        var content = fp(reward) + "P가 지급되었습니다! (신용 +2)" + (res.repayMsg || "") + policyTag + "\n" +
                      "🏦 국고 재원에서 연금이 지급되었습니다.";

        replier.reply(formatCommand("✅ 일일 출석 완료", user, content, "내 잔액: " + fp(user.point) + "P"));
        
        safeSaveData(data); 
        return true;
    }

    return false;
}

//==========섹터45==========

/* [지연 실행] 명령어 레지스트리 초기화 (Initialization) */
// 모든 로직 함수(섹터 30~44)가 메모리에 적재된 후 실행되어야 하므로 파일 맨 끝에 배치합니다.
(function initializeRegistry() {
    try {
        // 1. 유저 명령어 등록
        // 섹터 6의 CMD_LIST.user에 추가된 경마 관련 명령어들을 자동으로 순회하며 등록합니다.
        for (var i = 0; i < CMD_LIST.user.length; i++) {
            var c = CMD_LIST.user[i];
            
            // eval을 사용하여 문자열 이름(예: "_gameActionLogic")을 실제 함수 객체로 변환합니다.
            var executor = null;
            try { executor = eval(c.func); } catch(e) {}

            if (typeof executor === 'function') {
                registerUserCmd(c.cmd, c.desc, c.cat, executor);
            } else {
                Log.error("❌ 명령어 등록 실패 (함수 미발견): " + c.cmd + " -> " + c.func);
            }
        }

        // 2. 관리자 명령어 등록
        for (var j = 0; j < CMD_LIST.admin.length; j++) {
            var a = CMD_LIST.admin[j];
            
            var adminExecutor = null;
            try { adminExecutor = eval(a.func); } catch(e) {}

            if (typeof adminExecutor === 'function') {
                registerAdminCmd(a.cmd, a.desc, adminExecutor);
            } else {
                Log.error("❌ 관리자 명령어 등록 실패: " + a.cmd);
            }
        }
        
        // [Gemini 알림] 경마 시스템 로드 확인 로그 (디버깅용)
        Log.info("🐎 [Racing System] 경마 엔진 및 관련 명령어 로드 완료.");
        
    } catch(e) {
        Log.error("Registry Init Critical Error: " + e);
    }
})();

//==========섹터46==========

/**
 * [신설] 가상 정부 시스템 핵심 엔진
 * 기능: 정책 안건 생성, 티어별 가중 투표 처리, 참여 보상 지급
 */

/**
 * 1. 명령어 통합 핸들러
 * 처리: /의회 (현황 조회), /투표 (의사 결정)
 */
function _gameGovernmentLogic(msg, user, data, replier, roomName, targetUid) {
    var roomData = data.rooms[roomName];
    if (!roomData || !roomData.features) return false;
    
    var gov = roomData.features.government;

    // A. [조회] /의회 : 현재 정책 및 투표 진행 상황 브리핑
    if (msg === "/의회") {
        var pol = gov.activePolicy || { stockTax: 0.05, mineMult: 1.0, attendMult: 1.0, loanLimitMult: 1.0 };
        
        var currentPolicyStr = "• 주식 세금: " + (pol.stockTax * 100).toFixed(1) + "%\n" +
                               "• 채굴 효율: x" + pol.mineMult.toFixed(1) + "\n" +
                               "• 출석 보상: x" + pol.attendMult.toFixed(1) + "\n" +
                               "• 대출 한도: x" + pol.loanLimitMult.toFixed(1);

        var billStatus = "현재 상정된 안건이 없습니다.";
        if (gov.pendingBill) {
            billStatus = "📜 안건: " + gov.pendingBill.name + "\n" +
                         "✅ 혜택: " + gov.pendingBill.buffDesc + "\n" +
                         "⚠️ 대가: " + gov.pendingBill.penaltyDesc + "\n\n" +
                         "🗳️ 현황: 찬성 " + gov.votes.pro + " | 반대 " + gov.votes.con + "\n" +
                         "(참여 인원: " + gov.votes.voters.length + "명)";
        }

        replier.reply(formatCommand("🏛️ 내리다 정부 국회 의사당", user, "[현재 시행 중인 정책]\n" + currentPolicyStr + "\n\n[실시간 투표 현황]\n" + billStatus, "투표참여: [/투표 찬성/반대]"));
        return true;
    }

    // B. [액션] /투표 : 찬반 투표권 행사
    if (msg.indexOf("/투표 ") === 0) {
        if (!gov.pendingBill) {
            replier.reply(formatError(user, "투표 불가", "현재 진행 중인 의회 안건이 없습니다."));
            return true;
        }

        // 투표 가능 시간 체크 (20:00 ~ 23:50)
        var now = new Date();
        var currentHour = now.getHours();
        var currentMin = now.getMinutes();
        var timeVal = currentHour * 100 + currentMin;

        if (timeVal < 2000 || timeVal > 2350) {
            replier.reply(formatError(user, "시간 외 투표", "투표는 매일 20:00 ~ 23:50에만 가능합니다."));
            return true;
        }

        if (user.hasVotedToday) {
            replier.reply(formatError(user, "중복 투표", "이미 오늘 투표에 참여하여 거마비를 수령하셨습니다."));
            return true;
        }

        var choice = msg.substring(4).trim();
        if (choice !== "찬성" && choice !== "반대") {
            replier.reply(formatError(user, "입력 오류", "[/투표 찬성] 또는 [/투표 반대]를 입력하세요."));
            return true;
        }

        // 1. 티어별 투표 가중치 계산 (Gemini 추천 사양)
        var weight = gov_getVoteWeight(user.tier);
        
        // 2. 투표 결과 반영
        if (choice === "찬성") gov.votes.pro += weight;
        else gov.votes.con += weight;
        
        gov.votes.voters.push(targetUid);
        user.hasVotedToday = true;

        // 3. 참여 보상 지급 (2,000P 거마비 - 중앙은행 연동 인자 누락 수정)
        // [교정]: roomData 인자를 추가하여 국고 차감 및 블랙박스 기록 활성화
        util_updatePoint(user, roomData, 2000, "의회 투표 거마비 지급", roomName);

        var resMsg = "'" + gov.pendingBill.name + "' 안건에 " + choice + "하셨습니다.\n" +
                     "의원님의 티어에 따라 [" + weight + "표]가 행사되었습니다.\n\n" +
                     "💰 참여 보상: +2,000P 지급 완료";

        replier.reply(formatCommand("✅ 투표 완료", user, resMsg, "내 잔액: " + fp(user.point) + "P"));
        safeSaveData(data);
        return true;
    }

    return false;
}

/**
 * 2. 티어별 투표 가중치 계산 함수
 * 아이언(0)~실버(2): 1표 / 골드(3)~에메(5): 2표 / 다이아(6)~챌(9): 3표
 */
function gov_getVoteWeight(tier) {
    var t = Number(tier || 0);
    if (t >= 6) return 3;
    if (t >= 3) return 2;
    return 1;
}

/**
 * 3. 밸런스 안건 자동 생성기
 * 정책의 버프와 디버프를 세트로 조합하여 반환
 */
function gov_generateBill() {
    var bills = [
        {
            name: "개미 투자자 구제법",
            buffDesc: "주식 매도 수수료 5% ➔ 2% 인하",
            penaltyDesc: "출석 체크 기본 보상 20% 차감",
            effects: { stockTax: 0.02, mineMult: 1.0, attendMult: 0.8, loanLimitMult: 1.0, bankInterest: 0.02, theftFineMult: 1.0, policeProbAdj: 0.0, volatilityMult: 1.0 }
        },
        {
            name: "노동의 가치 실현법",
            buffDesc: "채굴 기본 수익 1.3배 상향",
            penaltyDesc: "주식 매도 수수료 5% ➔ 12% 인상",
            effects: { stockTax: 0.12, mineMult: 1.3, attendMult: 1.0, loanLimitMult: 1.0, bankInterest: 0.02, theftFineMult: 1.0, policeProbAdj: 0.0, volatilityMult: 1.0 }
        },
        {
            name: "금융 대공황 극복안",
            buffDesc: "은행 대출 한도 1.5배 확대",
            penaltyDesc: "예금 이자 지급 일시 중단 (0%)",
            effects: { stockTax: 0.05, mineMult: 1.0, attendMult: 1.0, loanLimitMult: 1.5, bankInterest: 0.0, theftFineMult: 1.0, policeProbAdj: 0.0, volatilityMult: 1.0 }
        },
        {
            name: "무법지대 선포안",
            buffDesc: "도둑질 성공 확률 상향 (경찰 출동 지연)",
            penaltyDesc: "체포 시 벌금 3배 및 경찰 출동 확률 80% 상향",
            effects: { stockTax: 0.05, mineMult: 1.0, attendMult: 1.0, loanLimitMult: 1.0, bankInterest: 0.02, theftFineMult: 3.0, policeProbAdj: 0.3, volatilityMult: 1.0 }
        },
        {
            name: "시장 안정화 정책",
            buffDesc: "주식 변동성 0.5배 축소 (안정적 수익)",
            penaltyDesc: "모든 보상형 활동(출석/채굴) 수익 15% 차감",
            effects: { stockTax: 0.05, mineMult: 0.85, attendMult: 0.85, loanLimitMult: 1.0, bankInterest: 0.02, theftFineMult: 1.0, policeProbAdj: 0.0, volatilityMult: 0.5 }
        },
        {
            name: "한탕주의 장려법",
            buffDesc: "주식 변동성 2배 증가 (폭등/폭락 유도)",
            penaltyDesc: "은행 대출 금리 10%로 인상",
            effects: { stockTax: 0.05, mineMult: 1.0, attendMult: 1.0, loanLimitMult: 1.0, bankInterest: 0.02, theftFineMult: 1.0, policeProbAdj: 0.0, volatilityMult: 2.0 }
        }
    ];
    return bills[Math.floor(Math.random() * bills.length)];
}

//==========섹터47==========
/**
 * [신설] 즉석복권 스피또 처리 엔진
 */
function _gameLotteryLogic(msg, user, data, replier, roomName, targetUid) {
    var roomData = data.rooms[roomName];
    if (msg === "/스피또") {
        var stateRes = util_checkUserState(user, targetUid);
        // [수정]: 채굴 중일 때도 구매 허용 (가드 완화)
        if (!stateRes.canAction && stateRes.reason.indexOf("채굴") === -1) {
            replier.reply(formatError(user, "구매 불가", stateRes.reason));
            return true; 
        }

        var conf = SYSTEM_CONFIG.ECO.SPITTO;
        var price = conf.PRICE;
        if (Number(user.point) < price) return replier.reply(formatError(user, "잔액 부족", fp(price) + "P가 필요합니다."));

        // 1. 포인트 게이트웨이 호출 (구매 대금 차감 및 국고 입고)
        util_updatePoint(user, roomData, -price, "스피또 구매", roomName);
        
        // 2. 섹터 30의 효과 처리 엔진 호출 (여기서 복권 개봉 및 당첨금 상환 로직이 실행됨)
        // 인자 설명: (아이템객체, 유저, 방이름, 리플라이어, 데이터, UID, 가격, 이용권여부, 수량)
        _handleShopEffect({ effect: "spitto" }, user, roomName, replier, data, targetUid, price, false, 1);

        // _handleShopEffect에서 당첨금이 지급되지 않았을 경우(꽝)를 체크
        // (참고: _handleShopEffect 내부 로직에 의해 꽝 메시지가 이미 나갔으므로 획득 알림만 추가 발송)
        if (Math.random() < 0.2) { // 20% 확률
            user.lottoFailCount = (user.lottoFailCount || 0) + 1;
            var charmMsg = "\n\n 📩 아쉬운 마음에 '위로의편지'가 도착했습니다.\n";
            
            if (user.lottoFailCount >= 15) {
                user.lottoFailCount = 0;
                user.luckyCharmEnd = Date.now() + 3600000; // 1시간
                user.inventory.push({ id: 888, name: "행운의부적", icon: "🔮", effect: "item", title: "행운의부적" });
                charmMsg += "✉️ 편지 15장이 모두 모여 [행운의부적]이 완성되었습니다! ✨\n⏳ 지금부터 1시간 동안 홀짝 승률 +3% 보너스가 자동 적용됩니다.";
            } else {
                charmMsg += "현재 수집: " + user.lottoFailCount + " / 15";
            }
            replier.reply(formatCommand("📩 위로의 편지 도착", user, charmMsg, "내 잔액: " + fp(user.point) + "P"));
        }
        
        // 3. 실시간 저장 보장
        safeSaveData(data);
        return true;
    }
    return false;
}

//==========섹터48==========
/**
 * [업그레이드] 낚시 시스템 엔진 v2.0
 * 설정: 10분 쿨타임, 물고기 등급제 보상 또는 유물 조각(0.5%)
 */
function _gameActivityLogic(msg, user, data, replier, roomName, targetUid) {
    var roomData = data.rooms[roomName];
    if (msg === "/낚시") {
        var stateRes = util_checkUserState(user, targetUid);
        if (!stateRes.canAction && stateRes.reason.indexOf("채굴") === -1) {
            replier.reply(formatError(user, "활동 불가", stateRes.reason));
            return true;
        }

        var conf = SYSTEM_CONFIG.ECO.FISHING;
        var now = Date.now();
        if (now - (user.lastFishingTime || 0) < conf.COOLDOWN) {
            var diff = conf.COOLDOWN - (now - user.lastFishingTime);
            var m = Math.floor(diff / 60000);
            var s = Math.floor((diff % 60000) / 1000);
            replier.reply(formatError(user, "낚시 금지", "물고기들이 경계 중입니다.\n" + (m > 0 ? m + "분 " : "") + s + "초 후 다시 시도하세요."));
            return true;
        }

        user.lastFishingTime = now;
        var rand = Math.random();

        // 1. 꽝 판정 (25%)
        if (rand < conf.FAIL_PROB) {
            replier.reply(formatCommand("🎣 낚시 실패", user, "찌가 미동도 하지 않습니다...\n허탕을 쳤습니다.", "다음 낚시: 10분 후"));
        } 
        // 2. 성공 판정
        else {
            var successRand = Math.random(); 

            // [A] 유물 조각 판정 (5% 확률)
            if (successRand < 0.05) {
                var nextArtifacts = Number(user.artifactPieces || 0) + 1;
                util_setData(user, 'artifactPieces', nextArtifacts, "낚시 중 유물 발견", roomName);
                
                var artifactBody = "낚싯줄에 엄청난 무게감이 느껴집니다!\n\n" +
                                   "✨ [심해의 보물] ✨\n" +
                                   "이끼 낀 낡은 보물상자를 건져 올렸습니다!\n\n" +
                                   "🧩 유물 조각 획득 (+1)\n" +
                                   "(현재 보유: " + user.artifactPieces + " 개)";
                
                replier.reply(formatCommand("🎊 [내리다 고고학 연구소: 유물 발견]", user, artifactBody, "유물 도감: [/유물도감]"));
            } 
            // [B] 물가 등급 판정 (유물 실패 시 실행)
            else {
                var fishPool = [
                    { name: "피라미", min: 500, max: 1000, prob: 0.35, desc: "작고 귀여운" },
                    { name: "붕어", min: 1500, max: 2000, prob: 0.30, desc: "힘차게 파닥거리는" },
                    { name: "배스", min: 2500, max: 3000, prob: 0.20, desc: "입이 아주 큰" },
                    { name: "잉어", min: 3500, max: 4000, prob: 0.09, desc: "묵직한 무게감의" },
                    { name: "황금쏘가리", min: 7000, max: 8000, prob: 0.06, desc: "전설 속의 영물," }
                ];

                var fishRand = Math.random();
                var selectedFish = fishPool[0];
                var cumulative = 0;
                for (var i = 0; i < fishPool.length; i++) {
                    cumulative += fishPool[i].prob;
                    if (fishRand < cumulative) {
                        selectedFish = fishPool[i];
                        break;
                    }
                }

                var reward = Math.floor(Math.random() * (selectedFish.max - selectedFish.min + 1)) + selectedFish.min;

                // [해왕] 칭호 효과: 물고기 판매 보상 20% 증가
                if (user.title === "해왕") reward = Math.floor(reward * 1.2);

                var res = processRepayment(user, reward, targetUid, roomName);
                util_updatePoint(user, roomData, Number(res.actualGain), "낚시 보상: " + selectedFish.name, roomName);

                // [신설] 낚시 성공 카운트 증가 및 칭호 체크
                user.totalFishingSuccess = (user.totalFishingSuccess || 0) + 1;
                
                var rStub = { reply: function(m) { replier.reply(m); } };
                var fCount = user.totalFishingSuccess;

                if (fCount >= 300) {
                    util_checkAndAwardTitle(user, rStub, "해왕", "F003", "🔱", "내리다 해양수산부", "낚시 성공 300회", "[장착 효과]: 낚시 성공 시 획득하는 물고기 판매 보상이 20% 상승합니다.", roomName);
                } else if (fCount >= 150) {
                    util_checkAndAwardTitle(user, rStub, "도시어부", "F002", "🛶", "내리다 해양수산부", "낚시 성공 150회", "이제 어떤 물길에서도 고기를 낚아낼 줄 아는 베테랑입니다.", roomName);
                } else if (fCount >= 50) {
                    util_checkAndAwardTitle(user, rStub, "강태공", "F001", "🎣", "내리다 해양수산부", "낚시 성공 50회", "세월을 낚는 여유와 기술을 겸비하기 시작했습니다.", roomName);
                }

                var content = "찌가 깊숙이 가라앉습니다! 영차!\n\n" +
                              "🐟 [" + selectedFish.desc + " " + selectedFish.name + "]를 낚았습니다!\n" +
                              "💰 판매 보상: +" + fp(reward) + "P" + (res.repayMsg || "");

                replier.reply(formatCommand("🎣 낚시 성공!", user, content, "내 잔액: " + fp(user.point) + "P"));
            }
        }
        safeSaveData(data);
        return true;
    }
    return false;
}

//==========섹터49==========

/**
 * [신설: 지능형 금리 산출 엔진] v1.0
 * 기능: 중앙은행의 재원 상태를 분석하여 시장 탄력 금리 승수(Multiplier)를 도출합니다.
 * @param {String} roomName - 방 이름
 * @returns {Number} 금리 승수 (0.5 ~ 3.0)
 */
function util_getDynamicRateMultiplier(roomName) {
    var data = getDatabase();
    var roomData = data.rooms[roomName];
    
    // [Safe-Fall] 데이터가 없거나 기준점이 없으면 기본 승수(1.0) 반환
    if (!roomData || !roomData.economyBase || roomData.economyBase <= 0) return 1.0;

    var reserve = Number(roomData.bankReserve || 0);
    var base = Number(roomData.economyBase);
    
    /**
     * [금리 산출 로직]
     * 현금 보유 비율(Reserve Ratio) = 현재 금고 재원 / 경제 기준점
     * 1. 비율이 낮을수록(금고가 빌수록) 승수 상승 (최대 3.0배) -> 대출 억제, 상환 독려
     * 2. 비율이 높을수록(금고가 찰수록) 승수 하락 (최소 0.5배) -> 대출 권장, 투자 활성화
     */
    var ratio = reserve / (base * 0.1); // 기준점의 10%를 적정 금고 수준으로 가정
    var multiplier = 1.0;

    if (ratio < 1.0) {
        // [위기 구간] 금고가 적정치 미만일 때: 승수 급격히 상승
        multiplier = 1.0 + (1.0 - ratio) * 2.0; 
    } else {
        // [호황 구간] 금고가 넉넉할 때: 승수 완만하게 하락
        multiplier = 1.0 - (ratio - 1.0) * 0.2;
    }

    // [최종 가드] 금리가 비상식적으로 변하는 것을 방지 (하한 0.5배 ~ 상한 3.0배)
    return Math.max(0.5, Math.min(3.0, multiplier));
}
