//==========섹터1==========

/* [v10.0] 원자적 액션 스테이징(Staging) 시스템 전역 객체 */
var GLOBAL_STAGING = {
    active: {}, // { uid: boolean } 스테이징 모드 활성화 여부
    cache: {}   // { uid: { userObject_Snapshot } } 임시 저장본
};

/* [v10.0] 지능형 시스템 환경 설정 (Performance & Gini) */
var INTELLIGENT_CONFIG = {
    PERFORMANCE: {
        MAX_LOG_SIZE: 1.5 * 1024 * 1024, // 1.5MB 초과 시 자동 로테이션
        LAG_THRESHOLD_MS: 450,           // 응답 0.45초 초과 시 경고 및 자동 최적화
        GC_INTERVAL_MIN: 10              // 10분마다 가비지 컬렉션 유도
    },
    ECONOMY: {
        GINI_CRITICAL: 0.45,             // 지니계수 0.45 초과 시 '빈부격차 경보' 및 교정 가동
        MAX_PROGRESSIVE_TAX: 0.5,       // 불평등 심화 시 자산가 최대 추가 세율 (5%)
        REWARD_BOOST_LIMIT: 1.5          // 서민층 최대 보상 강화 배율 (1.5배)
    }
};

/* [신규] 명령어 자동 등록 시스템 (Command Registry) */
var USER_COMMANDS = {};
var ADMIN_COMMANDS = {};

function registerUserCmd(cmd, desc, cat, func) {
    USER_COMMANDS[cmd] = { desc: desc, cat: cat, execute: func };
}

function registerAdminCmd(cmd, desc, func) {
    ADMIN_COMMANDS[cmd] = { desc: desc, execute: func };
}

/**
 * [전역 표준 규격] USER_SCHEMA v1.0
 * 치유(Sector 19)와 신규가입(Sector 20-1)이 공통으로 참조하는 리스트입니다.
 * 덮어쓰기 사고를 방지하기 위해 point 등 핵심 자산의 기본값은 0으로 설정합니다.
 */
var USER_SCHEMA = [
    { key: 'point', default: 0, type: 'number' },
    { key: 'bank', default: 0, type: 'number' },
    { key: 'tier', default: 0, type: 'number' },
    { key: 'creditScore', default: 600, type: 'number' },
    { key: 'inventory', default: [], type: 'array' },
    { key: 'collectedIcons', default: [], type: 'array' },
    { key: 'landHoldings', default: {}, type: 'object' },
    { key: 'landAvg', default: {}, type: 'object' },
    { key: 'chatLog', default: [], type: 'array' },
    { key: 'timeoutEndTime', default: 0, type: 'number' },
    { key: 'totalMiningTime', default: 0, type: 'number' },
    { key: 'artifactPieces', default: 0, type: 'number' },
    { key: 'totalGambleCount', default: 0, type: 'number' },
    { key: 'totalGambleWins', default: 0, type: 'number' },
    { key: 'totalTheftSuccess', default: 0, type: 'number' },
    { key: 'totalLandInvest', default: 0, type: 'number' },
    { key: 'dailyPromotionAttempts', default: 1, type: 'number' },
    { key: 'dailyGambleCount', default: 0, type: 'number' },
    { key: 'boughtWarningRemoval', default: false, type: 'boolean' },
    { key: 'hasVotedToday', default: false, type: 'boolean' },
    { key: 'lastFishingTime', default: 0, type: 'number' },
    { key: 'totalSpittoBought', default: 0, type: 'number' },
    { key: 'horseParts', default: [], type: 'array' },
    { key: 'landDeedCount', default: 0, type: 'number' },
    { key: 'lottoFailCount', default: 0, type: 'number' },
    { key: 'luckyCharmEnd', default: 0, type: 'number' },
    { key: 'accruedInterest', default: 0, type: 'number' },
    { key: 'lastBankUpdateTime', default: 0, type: 'number' },
    { key: 'totalFishingSuccess', default: 0, type: 'number' },
    { key: 'totalDonation', default: 0, type: 'number' },
    { key: 'consecutiveWins', default: 0, type: 'number' },
    { key: 'lastGambleTime', default: 0, type: 'number' },
    { key: 'isManipulated', default: false, type: 'boolean' },
    { key: 'gambleWinRate', default: 0, type: 'number' },
    { key: 'fishLuck', default: 0, type: 'number' },
    { key: 'horseWinRate', default: 0, type: 'number' },
    { key: 'spittoWinRate', default: 0, type: 'number' },
    { key: 'shipLevel', default: 1, type: 'number' },
    { key: 'cargo', default: {}, type: 'object' },
    { key: 'cargoAvg', default: {}, type: 'object' },
    { key: 'specialties', default: {}, type: 'object' },
    { key: 'voyage', default: { active: false, dest: "", arrival: 0, items: [] }, type: 'object' },
    { key: 'tradeCount', default: 0, type: 'number' },
    { key: 'totalCasinoBet', default: 0, type: 'number' },
    { key: 'totalCasinoWin', default: 0, type: 'number' },
    { key: 'shipName', default: '', type: 'string' },
    { key: 'lastCasinoResult', default: null, type: 'object' },
    { key: 'dailyLadderWins', default: [], type: 'array' },
    { key: 'dailyBaccaratWins', default: [], type: 'array' },
    { key: 'blackjackState', default: null, type: 'object' },
    { key: 'dailyBlackjackWins', default: [], type: 'array' },
    { key: 'casinoAuditStartTime', default: 0, type: 'number' },
    { key: 'casinoAuditStartAssets', default: 0, type: 'number' },
    { key: 'casinoAuditAlertHistory', default: [], type: 'array' },
    { key: 'lastBotUseTime', default: 0, type: 'number' }
];

/* [초고속 엔진] 전역 UID-닉네임 캐시 초기화 */
if (typeof globalData !== 'undefined' && !globalData.nameToIdCache) {
    globalData.nameToIdCache = {};
}

/* [v10.0] 지능형 성능 감시자(IPM) 전역 메트릭스 */
var PERF_METRICS = {
    avgLag: 0,        // 평균 지연 시간 (ms)
    peakLag: 0,       // 최고 지연 시간 (ms)
    lastOptimize: 0,  // 마지막 최적화 시간
    msgPerMin: 0,     // 분당 처리 메시지 수
    logSize: 0        // 현재 로그 파일 크기 (bytes)
};

/* 파일 및 데이터 동기화 객체 */
var Lock = java.util.concurrent.locks.ReentrantLock; 
var lock = new Lock(); 
var logLock = new Lock(); // [v5.8] 저널링(블랙박스) 전용 독립 락 추가
var SD_PATH = android.os.Environment.getExternalStorageDirectory().getAbsolutePath(); 
var BASE_DIR = SD_PATH + "/msgbot/data/"; 
var FILE_PATH = BASE_DIR + "attendance.json"; 
var REGISTRY_PATH = BASE_DIR + "user_registry.json";
var JOURNAL_PATH = BASE_DIR + "transaction.log"; // [v5.8] 실시간 거래 기록용 블랙박스 경로
var BACKUP_DIR = BASE_DIR + "backup/"; 

/**
 * [v10.2] 로그 무결성 및 시스템 권한 자가진단
 * 기능: 봇이 가동될 때 블랙박스 파일에 쓰기 권한이 있는지 즉시 체크합니다.
 */
(function checkSystemIntegrity() {
    try {
        var logDir = new java.io.File(BASE_DIR);
        if (!logDir.exists()) logDir.mkdirs();

        var testFile = new java.io.File(JOURNAL_PATH);
        var isWritable = testFile.exists() ? testFile.canWrite() : logDir.canWrite();
        
        if (!isWritable) {
            // [교정] 로그 기록 실패 시 관리자 방으로 즉시 카톡 발송
            var alertMsg = "🚨 [보안 위기] 블랙박스 로그 쓰기 권한이 없습니다.\n시스템 복구가 불가능할 수 있으니 저장소 권한을 확인하세요.";
            Log.error(alertMsg);
            try { Api.replyRoom("베릭방", alertMsg); } catch(e) {}
        } else {
            Log.info("✅ [보안 가동] 블랙박스 무결성 검사 통과.");
            // 선택사항: 가동 성공 시에도 알림을 받고 싶다면 아래 주석을 해제하세요.
            // try { Api.replyRoom("베릭방", "✅ 블랙박스 기록 장치가 정상 작동 중입니다."); } catch(e) {}
        }
    } catch (e) {
        Log.error("Integrity Check Error: " + e);
    }
})();

/* [최적화] 전역 UID 캐시 시스템 */
var uidCache = uidCache || {}; 

/* [하이브리드 엔진] 병렬 수신 및 순차 처리 엔진 분리 */
// 1. 병렬 수신 엔진: 8개의 스레드가 메시지를 즉시 접수 (응답 속도 담당)
var ParallelPool = java.util.concurrent.Executors.newFixedThreadPool(8);
// 2. 순차 처리 엔진: 단 1개의 큐가 로직 및 답장을 순서대로 안전하게 처리 (데이터 무결성 담당)
var LogicQueue = java.util.concurrent.Executors.newSingleThreadExecutor();
// 3. 일반 백그라운드 작업용 엔진 (디스코드/대시보드 전용) */
var Executor = java.util.concurrent.Executors.newCachedThreadPool();
// 4. 백그라운드 저장 엔진: 무거운 파일 쓰기 전용
var SaveExecutor = java.util.concurrent.Executors.newSingleThreadExecutor();

/* 로그 저장 경로 및 디렉토리 설정 */ 
var BUG_LOG_PATH = BASE_DIR + "logs/bug_report.txt"; 
var ERROR_LOG_PATH = BASE_DIR + "logs/error_log.txt"; 
var logDir = new java.io.File(BASE_DIR + "logs/"); 
if (!logDir.exists()) logDir.mkdirs(); 
var dir = new java.io.File(BACKUP_DIR); 
if (!dir.exists()) dir.mkdirs(); 

/* 전역 상태 변수 */ 
if (typeof globalData === 'undefined' || globalData === null) {
    var globalData = { rooms: {}, botActive: true }; 
}

/* [안정화] 핵심 게임 엔진 및 상태 참조 전역 선언 */
var racingData = null;      // 경마 실시간 데이터 참조용
var lotto = null;           // 로또 실시간 데이터 참조용
var marketOpenPrice = globalData.marketOpenPrice || 0;    // 랜드마크 시가 참조용
var sprinkleData = {};      // 뿌리기 상태 참조용
var _msgReceiveTime = 0;    // [신규] 응답속도 측정을 위한 전역 타임스탬프

/* [안정화] 입력 대기 및 활동 상태 변수 초기 선언 */
var menuWaitState = {};
var bankProcessState = {};
var selectWaitState = {};
var lottoPurchaseState = {};
var activeThefts = {};
var duelData = {};
var miningState = {};
var loanRegisterState = {};
var loanContractWaitState = {};


/**
 * [개편] 무역 국가별 고정 생산 품목 및 특산품 매핑 (순환 매칭 엔진용)
 * 설명: 각 국가의 자국 생산물을 정의하며, 스케줄러가 이를 제외한 품목을 선호/기피로 배정합니다.
 */
var TRADE_RELATION = {
    "노르딕": { produce: "식료품", set: "만년설삼" },
    "샹그릴라": { produce: "공예품", set: "고대찻잎" },
    "브리타니아": { produce: "공업품", set: "증기기관부품" },
    "엘도라도": { produce: "보석", set: "황금조각상" },
    "사막의별": { produce: "귀금속", set: "오아시스수정" }
};

/**
 * [Gemini 요청 사항] 방별 독립화를 위한 데이터 템플릿
 * 설명: 아래의 구조가 각 방(Room)이 생성될 때마다 독립적으로 복제되어 할당됩니다.
 */
var ROOM_FEATURE_TEMPLATE = function() {
    return {
        /* [Gemini 요청 사항] 경마 시스템 실시간 상태 및 상수 설명 통합 */
        racing: {
            round: 1,           // [회차]: 경마의 진행 차수를 기록 (봇 재시작 시 1로 초기화됨)
            horses: [           // [출전마 정보]: 각 말의 고유 ID, 이름, 우승 가중치(weight), 상태 아이콘 저장
                { id: 1, name: "어마어마", weight: 1.0, icon: "☁️ 보통" },
                { id: 2, name: "어서말을해", weight: 1.0, icon: "☁️ 보통" },
                { id: 3, name: "마의웨이", weight: 1.0, icon: "☁️ 보통" },
                { id: 4, name: "핵탄두", weight: 1.0, icon: "☁️ 보통" },
                { id: 5, name: "돌격앞으로", weight: 1.0, icon: "☁️ 보통" }
            ],
            bets: {},           // [배팅 기록]: { UID: {horseId, amount, name} } 형식으로 현재 회차 배팅 정보를 저장
            totalPool: 0,       // [당기 누적금]: 이번 회차에 유저들이 배팅한 순수 포인트 합계
            carryOver: 0,       // [이월금/Jackpot]: 이전 회차에서 당첨자가 없어 넘어온 포인트 (70% 비율 적용액)
            // [운영 플래그]: 봇 로드 시 현재 시간을 즉시 판별하여 09:00~23:59 사이면 자동으로 가동 상태(true)로 설정
            isOperating: (function() {
                var h = new Date().getHours();
                return h >= 9 && h <= 23; 
            })(),
            isDeadlineNotified: false, // [알림 제어]: 49분 59초 마감 공지가 중복 발송되는 것을 방지하는 스위치
            isResultProcessed: false   // [정산 제어]: 정각(00분) 결과 정산 로직이 중복 실행되는 것을 방지하는 스위치
        },

        /* 방별 랜드마크 시장 및 기타 데이터 */
        stockMarket: {},
        stockTraffic: {},
        marketOpenPrice: 0,
        sprinkleData: { active: false, winners: [], portions: [] },
        lotto: { round: 1, entries: {}, dailyPool: 0, jackpot: 0, lastWinNums: [] },

        msgCount: 0,

        government: {
            activePolicy: { // 현재 시행 중인 정책 배율 (기본값)
                stockTax: 0.05,
                mineMult: 1.0,
                attendMult: 1.0,
                loanLimitMult: 1.0,
                bankInterest: 0.02,
                theftFineMult: 1.0,
                policeProbAdj: 0.0
            },
            pendingBill: null,   // 오늘 발의된 안건 데이터
            votes: { pro: 0, con: 0, voters: [] }, // 투표 가중치 합 및 참여자 명단
            lastBillDate: "",
            resultStatus: null,
            isClosing: false
        },

        /* 방별 독립 입력 대기 상태 */
        states: {
            menuWait: {}, bankProcess: {}, selectWait: {}, lottoPurchase: {},
            activeThefts: {}, duelData: {}, mining: {},
            loanRegister: {}, loanContractWait: {}
        }
    };
};

/* 관리자 UID 기반 인증 */ 
var adminUIDs = ["fixed-uuid-3873df88-0533-4647-99c8-8a4b0bde6da3", "fixed-uuid-관리자2"]; 

/* 시스템 핵심 상수 설정 */
var SYSTEM_CONFIG = {

    TRADE: {
        PRICE_CYCLE_MIN: 60,        // 시세 변동 주기 (60분)

        GOODS_COST: {
            "식료품": 10000,
            "공업품": 15000,
            "공예품": 20000,
            "귀금속": 25000,
            "보석": 30000
        },

        NATIONS: {
            "브리타니아": { favorite: "", hate: "", specialty: "증기기관부품" },
            "샹그릴라": { favorite: "", hate: "", specialty: "고대찻잎" },
            "엘도라도": { favorite: "", hate: "", specialty: "황금조각상" },
            "노르딕": { favorite: "", hate: "", specialty: "만년설삼" },
            "사막의별": { favorite: "", hate: "", specialty: "오아시스수정" }
        },
        SHIPS: {
            1: { name: "카라벨", capacity: 10, speedMult: 1.0, upgradeCost: 0 },
            2: { name: "프리깃", capacity: 25, speedMult: 0.75, upgradeCost: 1000000 },
            3: { name: "갤리온", capacity: 40, speedMult: 0.5, upgradeCost: 2000000 }
        },
        EVENTS: {
            PROB: 0.25,             // 무역 정산 시 이벤트 발생 총 확률 (25%)
            LIST: {
                STORM: { name: "폭풍우", penalty: 0.15, msg: "🌊 폭풍우를 만나 선체가 파손되었습니다! (수리비 지출)" },
                FIRE: { name: "화재", penalty: 0.2, target: ["식료품", "공예품"], msg: "🔥 창고에 화재가 발생하여 적재물이 전소되었습니다!" },
                CORROSION: { name: "부식", penalty: 0.2, target: ["공업품", "귀금속"], msg: "🧪 소금물에 화물이 부식되어 가치가 하락했습니다!" },
                PIRACY: { name: "해적습격", penalty: 0.3, msg: "🏴‍☠️ 해적에게 습격당해 무역 대금의 일부를 약탈당했습니다!" },
                SMOOTH: { name: "순항", boost: 0.2, msg: "🌬️ 순풍을 타고 예정보다 빠르게 도착했습니다!" }
            }
        },
        GOODS: ["식료품", "공예품", "공업품", "귀금속", "보석"],
        BASE_PRICE: 10000,
        SPECIALTY_COST: {
            "식료품": 10000,
            "공업품": 15000,
            "공예품": 20000,
            "귀금속": 25000,
            "보석": 30000
        },
        BASE_TAX: 0.1,
        MAX_TAX: 0.10,
        SPECIALTY_CHANCE: 0.50,
        SPECIALTY_PROFIT: 3.0
    },

    /**
         * [신규] 품목별 차등 수익률 매트릭스
         * - 선호(pref): 식료품은 높게(1.28), 보석은 낮게(1.19) 설정하여 밸런스 조정
         * - 일반(norm): 세금 고려 시 약소한 이득 혹은 본전 (1.05)
         * - 기피(hate): 강력한 손실 부여 (0.8)
         */
        PROFIT_RATES: {
            "식료품": { pref: 1.34, norm: 1.08, hate: 0.8 }, 
            "공업품": { pref: 1.27, norm: 1.08, hate: 0.8 },
            "공예품": { pref: 1.25, norm: 1.05, hate: 0.8 },
            "귀금속": { pref: 1.24, norm: 1.05, hate: 0.8 },
            "보석":   { pref: 1.23, norm: 1.05, hate: 0.8 }
        },

    MANIPULATION: {
        DEFAULT_GAMBLE: 65, // 홀짝(사다리/바카라) 적중 보정치
        DEFAULT_FISH: 40,   // 낚시 높은 등급 낚을 보정치
        DEFAULT_RACING: 5,  // 경마 우승 가중치 보너스
        DEFAULT_SPITTO: 65, // 스피또 당첨 보정치
        MAX_RATE: 100,
        MIN_RATE: 0
    },

    ECO: {

        /* [v11.9.24] 배당 주머니 적립 배율 (사용안) */
        ACTIVITY_ACCUM_RATES: {
            MINE: 0,
            FISH: 0,
            CASINO: 0,
            BANK: 0,
            SHOP: 0,
            RACING: 0
        },

        /* [Gemini 요청 사항] 시간 기반 확정 배당 시스템 설정 */
        HOURLY_DIVIDEND: 10000,           // 시간당 기본 배당금 (10,000P)
        DIVIDEND_BONUS_THRESHOLD: 10,     // 지분 보너스 시작 임계값 (10지분)
        DIVIDEND_BONUS_RATE: 0.1,         // 초과 1지분당 가산 배율 (10%)

        /* [기초 경제 설정] */
        ATTEND_MIN: 8000, // [출석 최소 지급]: 하한선 8,000P
        ATTEND_MAX: 10000, // [출석 최대 지급]: 상한선 10,000P
        GAMBLE_MIN: 2000,  // [도박 최소 베팅]: 2,000P
        GAMBLE_MAX: 50000, // [도박 최대 베팅]: 50,000P (사행성 억제)

        /* [신규] 스피또 및 생산형 컨텐츠 설정 */
        SPITTO: {
            PRICE: 2000,           // 복권 가격
            RTP: 0.855,              // 기대 수익률 (85.5%)
            PROBS: {
                RANK1: 0.0005,     // 1등 확률 (0.05%)
                RANK2: 0.02,       // 2등 확률 (2%)
                RANK3: 0.15,       // 3등 확률 (15%)
                RANK4: 0.55         // 4등 확률 (55%)
            },
            PRIZES: {
                RANK1: 500000,     // 1등 상금
                RANK2: 25000,      // 2등 상금
                RANK3: 5000,       // 3등 상금
                RANK4: 1000         // 4등 상금
            }
        },
        FISHING: {
            COOLDOWN: 600000,      // 쿨타임 (10분 = 600,000ms)
            MIN_REWARD: 500,       // 최소 보상
            MAX_REWARD: 1500,       // 최대 보상
            FAIL_PROB: 0.05,         // 꽝 확률 (5%)
            ARTIFACT_CHANCE: 0.005  // [신규] 유물 조각 발견 확률 (0.5%)
        },
        
        /* [신규] 중앙은행 지급준비제도 설정 */
        BANK: {
            RESERVE_RATIO: 0.20, // [지급준비율]: 은행 총 예금액 중 대출해줄 수 없는 최소 현금 보유 비중 (20%)
            INITIAL_RESERVE: 10000, // [초기 재원]: 데이터 초기화 시 은행 금고에 기본으로 들어있는 포인트
            INTEREST_RATE: 0.02,  // [매일 이자율] 0.02 = 2%, 0.05 = 5% (원하시는 수치로 변경하세요)
            /* [지능형 탄력 금리 설정] */
            MIN_MULTIPLIER: 0.5,  // 금리 하한 승수 (0.5배)
            MAX_MULTIPLIER: 3.0,  // 금리 상한 승수 (3.0배)
            TARGET_RESERVE_RATIO: 0.1 // 적정 국고 유지 비율 (경제 기준점의 10%)
        },

        /* [신규] 경마 시스템 세부 설정 상술 */
        RACING: {
            MIN_BET: 10000,       // [최소 배팅액]: 경마 참여를 위한 최소 포인트
            MAX_BET: 30000,      // [최대 배팅액]: 한 회차에 걸 수 있는 최대 포인트 상한선
            TAX_RATE: 0.1,       // [기본 수수료]: 당첨금 정산 전 전체 판돈에서 국고로 환수되는 비율 (10%)
            CANCEL_FEE: 0.1,     // [취소 위약금]: 배팅 취소 시 원금에서 차감되어 국고로 귀속되는 수수료 (10%)
            WINLESS_BANK_RATE: 0.3,   // [무승자 국고행]: 우승자 없을 시 판돈의 30%를 은행 금고로 즉시 회수
            WINLESS_JACKPOT_RATE: 0.7, // [무승자 이월액]: 우승자 없을 시 판돈의 70%를 다음 회차 carryOver로 누적
            OPEN_HOUR: 9,        // 경마장 자동 개장 시각 (오전 9시)
            CLOSE_HOUR: 23,       // 경마장 마지막 배팅 마감 시각 (오후 11시 59분)
            MAX_PAYOUT_MULT: 7   // [배당 기준점]: 당첨 시 지급되는 고정 배율 (현재 7배 고정 지급)
        },
        
        /* [개편] 랜드마크 부동산 시스템 설정 */
        LANDMARK: {
            PREFIXES: ["서울", "뉴욕", "파리", "도쿄", "두바이", "런던", "로마", "베를린", "시드니", "광화문", "강남", "해운대", "판교", "성수"], 
            SUFFIXES: ["빌딩", "타워", "스퀘어", "팰리스", "센터", "아레나", "뮤지엄", "파크", "가든", "아틀리에", "스테이션", "라이브러리"], 
            TRAITS: { 
                "normal": { label: "랜드마크", volatility: 0.5, prob: 44, icon: "🏢" },
                "bluechip": { label: "비즈니스타워", volatility: 1, prob: 28, icon: "🏨" },
                "hotspot": { label: "상가", volatility: 1.8, prob: 28, icon: "🏚️" }
            },

           /* [Gemini] 랜드마크 고정가 및 지분 상승 정책 */
            FIXED_POLICY: {
                BASE_PRICE: 200000,   // 0지분 기준 기본가
                PER_SHARE_RATE: 0.05  // 1지분당 상승률 (5%)
            },

            MANIPULATION: { 
                TARGET: "서울타워", 
                IS_UP: true,       
                RATE: 0.25,        
                ACTIVE: false      
            },
            SETTINGS: { 
                MAX_COUNT: 10,     // 부동산 매물 최대수
                OPEN_HOUR: 7,      
                CLOSE_HOUR: 23,    
                MANI_RATE: 0.25,   
                DELIST_LIMIT: 0.001, // 경매(상폐) 위기 기준
                ABS_DELIST_LIMIT: 10000, 
                CLOSING_LIMIT: 0.40, 
                RESISTANCE_START: 0.20, 
                GRAVITY: 0.18      
            }
        },

        MINE: { // [광산 채굴 설정]
            BASE_PER_MIN: 40, // 분당 획득하는 기본 채굴 포인트 (물가 배율 적용 전)
            COPPER_PROB: 0.06, // 구리 발견 확률 (6%)
            GOLD_PROB: 0.035,   // 금 발견 확률 (3.5%)
            DIA_PROB: 0.008,   // 다이아몬드 발견 확률 (0.8%)
            COPPER_MULT: 3.0,  // 구리 발견 시 수익 배율
            GOLD_MULT: 7.0,    // 금 발견 시 수익 배율
            DIA_MULT: 20.0,    // 다이아몬드 발견 시 수익 배율
            ARTIFACT_CHANCE: 0.002, // [유물 조각]: 매 분마다 유물을 찾을 확률 (0.1%)
            ARTIFACT_GOAL: 50  // [도굴왕 칭호]: 유물 조각을 이 갯수만큼 모으면 자동 부여
        },
        PRIVATE_LOAN: { // [사채(P2P) 시장 설정]
            MIN_AMOUNT: 10000,       // 사채 매물 등록 시 최소 단위
            MAX_RATE: 15,           // 법정 최고 이율 (3시간당 최대 15%)
            COLLECTION_LIMIT: 24,   // [추심 시작]: 대출 후 24시간 경과 시 수익 압류(50%) 시작
            INTEREST_PERIOD: 3,     // 이자가 복리로 계산되어 붙는 주기 (3시간)
            MIN_BORROW: 5000,       // 유저가 사채를 빌릴 때 최소 단위
            DAILY_LIMIT: 1          // 은행 대출 일일 이용 제한 횟수
        },
        CREDIT: { // [은행 신용 등급 체계]
            SCORES: [900, 800, 700, 600, 500], // 각 등급을 나누는 기준 점수
            LIMITS: [1000000, 800000, 600000, 500000, 400000, 300000], // 등급별 대출 가능 한도
            RATES: [1.014, 1.025, 1.05, 1.09, 1.14, 1.18], // 등급별 기본 이율 (시장 승수와 연동되어 최종 산출됨)
            LABELS: ["1등급", "2등급", "3등급", "4등급", "5등급", "신용불량자"], 
            ICONS: ["👑", "💎", "🥇", "🥈", "🥉", "🚫"] 
        }
    },

BACKUP: {
        // 여기에 본인의 디스코드 웹후크 URL을 입력하세요. (따옴표 필수)
        DISCORD_WEBHOOK_URL: "https://discord.com/api/webhooks/1466005811594793000/LUVyScCaI88gKz4SxMUSOniTi890hRNVGvGn1SC_FoNhYU5Vy7bZD9PpjSF0mQHRUMUq"
    },

    SPAM: { // [도배 방지 엔진 설정]
        LIMIT_COUNT: 5,        // 제한 시간 내 허용되는 최대 메시지 수
        LIMIT_WINDOW: 3000,    // 도배 판정 시간 범위 (3000ms = 3초)
        TIMEOUT_MS: 300000     // 도배 적발 시 봇 이용이 제한되는 시간 (5분)
    },

    PROB: { // [핵심 게임 확률 엔진]
        ODD_EVEN_WIN: 0.45,        // 홀짝 기본 승률 (45%)
        ODD_EVEN_PAYOUT: 0.90,     // 홀짝 기본 배당률 (사용자 정의)
        ODD_EVEN_FEVER: 0.50,      // 피버타임 시 홀짝 기본 승률 (50%)
        STOCK_NEW_LISTING: 0.8,    // 매 변동 타임마다 신규 종목이 상장될 확률 (50%)
        STOCK_SPECIAL: 0.5,        // 특정 종목에 특수 이벤트(폭등/폭락)가 발생할 확률 (50%)
        STOCK_UP_CHANCE: 0.45      // 특수 이벤트 발생 시 '상승'일 확률 (45%, 하락이 조금 더 높음)
    },
    
    MSG: { // [시스템 메시지 설정]
        PREFIX: {
            INFO: "ℹ️", ERROR: "🚫", ADMIN: "⚙️", SUCCESS: "✅", 
            WARN: "⚠️", GAMBLE_WIN: "🎊", GAMBLE_LOSE: "💀", LOAN: "🚬", MINE: "⛏️", TIMEOUT: "🔇"
        }, 
        ERR_FORM: "형식이 올바르지 않습니다.", 
        ERR_MONEY: "포인트가 부족합니다.", 
        ERR_USER: "대상을 찾을 수 없습니다.", 
        ERR_TIMEOUT: "도배로 인해 이용이 일시 제한되었습니다." 
        },

    /* [v10.7] 카지노 지능형 확률 보정 정밀 세팅 */
    ADJUST: {
            ENABLED: true,
            STEP_AMOUNT: 100000,  // 10만P 단위
            STEP_RATE: 0.01,      // 단위당 -1%
            PROB_FLOOR: 0.35      // 최소 승률 하한선 (35%)
        },

    /* [신규] 통합 카지노 시스템 상세 설정 */
    CASINO: {
        LADDER: { 
            INTERVAL_SEC: 120,    // 2분 주기
            PAYOUT_SINGLE: 1.9,   // 홀/짝 배당
            PAYOUT_COMB: 4.0,     // 조합 배당
            LIMIT: 500000         // 1회 최대 배팅 한도
        },
        BACCARAT: { 
            INTERVAL_SEC: 180,    // 3분 주기
            PAYOUT: { PLAYER: 2.0, BANKER: 1.95, TIE: 8.0 },
            LIMIT: 1000000        // 1회 최대 배팅 한도
        }
    }
};

//==========섹터2==========

/**
 * [v8.1 개편] 블랙박스 복구 엔진 (Smart Replay Option 2)
 * 기능: 자본금 대비 수익 필터링 로직을 도입하여 보너스 레버리지를 이용한 부당 수익을 차단합니다.
 * [Gemini 요청 사항 반영]: 사유(Reason) 필터링 시스템 완벽 통합
 */
function recoverFromJournal(data) {
    try {
        var journalFile = new java.io.File(JOURNAL_PATH);
        if (!journalFile.exists() || journalFile.length() === 0) return;

        var logs = FileStream.read(JOURNAL_PATH).split("\n");
        var recoveryCount = 0;
        var skipCount = 0;
        var taintedUsers = {}; // 자본금 한도를 초과하여 베팅한 유저 태그 목록

        logs.forEach(function(line) {
            if (!line.trim()) return;
            var parts = line.split("|"); 
            // [교정]: 사유가 포함된 5개 항목이 모두 있는지 확인
            if (parts.length < 5) return;

            var uid = parts[0];
            var room = parts[1];
            var delta = Number(parts[2]);
            var brDelta = Number(parts[3] || 0);
            var reason = parts[4] || ""; 

            if (data.rooms[room] && data.rooms[room].users[uid] && !isNaN(delta)) {
                var user = data.rooms[room].users[uid];

                // [필터 1]: 입장 보너스 기록은 합산에서 제외 (중복 지급 방지)
                if (reason.indexOf("입장 축하") !== -1) {
                    skipCount++;
                    return;
                }

                // [필터 2]: 자본금 한도 초과 베팅 감지 (옵션 2 논리)
                if (delta < 0 && Math.abs(delta) > Number(user.point)) {
                    taintedUsers[uid] = true;
                    return;
                }

                // [필터 3]: 태그된 유저의 수익(+) 기록 무효화
                if (taintedUsers[uid] && delta > 0) {
                    skipCount++;
                    return;
                }

                // [최종 반영]: 필터를 통과한 정당한 데이터만 합산 (0원 하한선 강제 적용)
                user.point = Math.max(0, Number(user.point || 0) + delta);
                data.rooms[room].bankReserve = Number(data.rooms[room].bankReserve || 0) + brDelta;
                recoveryCount++;
            }
        });

        if (recoveryCount > 0 || skipCount > 0) {
            Log.info("[Recovery] 블랙박스 엔진: " + recoveryCount + "건 복구 완료 (부당 이득 및 보너스 " + skipCount + "건 필터링)");
            // [중복 복구 방지 및 기록 보존 로직]:
            // 1. 현재 복구에 사용된 로그를 '전체 보관용 파일'에 따로 저장합니다. (디스코드 전송용)
            var historyPath = BASE_DIR + "total_history.log";
            var rawLogs = FileStream.read(JOURNAL_PATH);
            FileStream.append(historyPath, rawLogs);

            // 2. 물리 파일(attendance.json)에 복구된 잔액을 즉시 확정 저장합니다.
            safeSaveData(data, true); 

            // 3. 복구용 로그(transaction.log)만 비워서 다음 리로드 시 중복 연산을 차단합니다.
            var jFile = new java.io.File(JOURNAL_PATH);
            if (jFile.exists()) {
                jFile.delete(); 
                Log.info("[Recovery] 로그 이관 및 복구용 파일 초기화 완료.");
            }
        }
    } catch (e) {
        Log.error("Journal Recovery Error: " + e);
    }
}

/**
 * [v11.9.3 최종형] 날짜 필터링 기반 배당 주머니 정밀 재계산 엔진
 * 기능: 블랙박스 로그 중 '오늘' 발생한 실제 활동 수익만 추출하여 주머니를 구성합니다.
 */
function util_recalculateDailyPools(data, roomName) {
    try {
        var logFile = new java.io.File(JOURNAL_PATH);
        if (!logFile.exists() || logFile.length() === 0) return;

        var logs = FileStream.read(JOURNAL_PATH).split("\n");
        var roomObj = data.rooms[roomName];
        var cfg = SYSTEM_CONFIG.ECO.ACTIVITY_ACCUM_RATES;
        
        // 오늘 날짜 문자열 (로그의 시간 정보와 대조용)
        var todayPrefix = new Date().toLocaleDateString(); 

        // 1. 기존 오염된 주머니 초기화
        roomObj.features.dailyPools = { mine: 0, fish: 0, casino: 0, bank: 0, shop: 0, race: 0 };

        logs.forEach(function(line) {
            if (!line.trim()) return;
            var parts = line.split("|");
            // [교정] 로그에 기록된 방 이름이 일치하는지 확인
            if (parts.length < 5 || parts[1] !== roomName) return;

            var amount = Math.abs(Number(parts[2])); 
            var reason = parts[4]; 

            /* =====요청사항 시작===== */
            // 1. 카지노 배당금 집계 (원금 누적 방식으로 통일)
            if (reason.indexOf("홀짝 적중") !== -1) {
                var originalBet = amount / 0.85; 
                var houseCommission = originalBet * 0.15; 
                roomObj.features.dailyPools.casino += Math.floor(houseCommission);
            }
            else if (reason.indexOf("홀짝 미적중") !== -1) {
                roomObj.features.dailyPools.casino += amount;
            }
            // 2. 기타 활동 집계 (cfg 참조 제거)
            else if (reason.indexOf("광산") !== -1) roomObj.features.dailyPools.mine += amount;
            else if (reason.indexOf("낚시 보상") !== -1) roomObj.features.dailyPools.fish += amount;
            else if (reason.indexOf("이자 지급") !== -1) roomObj.features.dailyPools.bank += amount;
            else if (reason.indexOf("상점 구매") !== -1) roomObj.features.dailyPools.shop += amount;
            else if (reason.indexOf("경마 배팅") !== -1) roomObj.features.dailyPools.race += amount;
        });
        
    } catch (e) {
        Log.error("Recalculate DailyPools Error: " + e);
    }
}

/**
 * [v11.9.16 최종안] 오늘치 백업 로그 소급 합산 엔진 (Date Filtering)
 * 기능: 로직 변경 전 백업된 '오늘의 로그'를 분석하여 메모리 주머니를 복구합니다.
 */
function util_restoreDailyPoolsFromHistory(data, roomName) {
    try {
        var historyPath = BASE_DIR + "total_history.log";
        var hFile = new java.io.File(historyPath);
        if (!hFile.exists() || hFile.length() === 0) return 0;

        var logs = FileStream.read(historyPath).split("\n");
        var roomObj = data.rooms[roomName];
        var cfg = SYSTEM_CONFIG.ECO.ACTIVITY_ACCUM_RATES;
        var restoredCount = 0;

        // [핵심] 오늘 날짜 필터 (예: "2026. 2. 4.")
        var todayStr = new Date().toLocaleDateString();

        logs.forEach(function(line) {
            if (!line.trim()) return;
            var p = line.split("|");
            // 형식이 맞지 않거나, 다른 방의 기록이거나, 오늘 날짜가 아니면 통과
            // (참조: 로그가 비워질 때 찍힌 시스템 날짜 정보가 있는 경우만 합산)
            if (p.length < 5 || p[1] !== roomName) return;
            
            // 만약 로그에 날짜 정보가 없다면 오늘 발생한 모든 로그를 읽으므로 
            // 00시 정산 직후에 한 번만 실행하는 것이 가장 안전합니다.
            
            var amt = Math.abs(Number(p[2]));
            var reason = p[4];

            if (reason.indexOf("광산") !== -1) roomObj.features.dailyPools.mine += Math.floor(amt * cfg.MINE);
            else if (reason.indexOf("낚시") !== -1) roomObj.features.dailyPools.fish += Math.floor(amt * cfg.FISH);
            // 과거 로그에 찍힌 '홀짝'이나 '적중' 키워드까지 싹 긁어모읍니다.
            else if (reason.indexOf("카지노") !== -1 || reason.indexOf("사다리") !== -1 || reason.indexOf("바카라") !== -1 || reason.indexOf("홀짝") !== -1 || reason.indexOf("적중") !== -1) {
                roomObj.features.dailyPools.casino += Math.floor(amt * cfg.CASINO);
            }
            else if (reason.indexOf("이자") !== -1) roomObj.features.dailyPools.bank += Math.floor(amt * cfg.BANK);
            else if (reason.indexOf("상점") !== -1 || reason.indexOf("구매") !== -1) roomObj.features.dailyPools.shop += Math.floor(amt * cfg.SHOP);
            else if (reason.indexOf("경마") !== -1) roomObj.features.dailyPools.race += Math.floor(amt * cfg.RACING);
            
            restoredCount++;
        });
        return restoredCount;
    } catch (e) {
        Log.error("History Restoration Error: " + e);
        return 0;
    }
}

/**
 * [Gemini 정밀 교정] 데이터베이스 로드 함수
 */
function getDatabase() {

    // [개선] 메모리 상주 여부와 관계없이 리로드 시 무역 고착 유저를 즉시 치료
   if (globalData && globalData.rooms) {
        try {
            for (var r in globalData.rooms) {
                var roomObj = globalData.rooms[r];
                if (roomObj && roomObj.users) {
                    for (var id in roomObj.users) {
                        var u = roomObj.users[id];
                        // 무역 정산 중 멈춘 유저 강제 해제
                        if (u.voyage && u.voyage.active === true && u.voyage.isProcessing === true) {
                            u.voyage.isProcessing = false;
                            u.voyage.isAlerted = false;
                        }
                    }
                }
            }
        } catch(e) { Log.error("Healer Error: " + e); }
    }

    // 1. RAM 상주 데이터 우선 반환 (물리적 파일 읽기 생략으로 응답 속도 극대화)
    if (globalData && globalData.rooms && Object.keys(globalData.rooms).length > 0) {
        return globalData; 
    }

    try {
        var file = new java.io.File(FILE_PATH);
        var initialData;
        
        if (!file.exists()) {
            initialData = {
                rooms: {}, admins: ["관리자"], botActive: true,
                nickHistory: {}, adminLogs: [], economyDamping: 0.5,
                lastDailyReset: "", isRecovering: false, nameToIdCache: {}
            };
        } else {
            var content = FileStream.read(FILE_PATH);
            if (!content) throw new Error("Empty File");
            initialData = JSON.parse(content);
        }

        // 2. 블랙박스(Journal) 로그 즉시 복구 병합
        recoverFromJournal(initialData);

        // [신규] 무역 정산 고착(stuck) 유저 자동 복구 엔진 (Auto-Healer)
        // 기능: /리로드 시 정산 잠금(isProcessing)이 true로 굳은 유저들을 찾아 자동으로 풀어줍니다.
        (function util_autoRepairTradeStuck(data) {
            if (!data || !data.rooms) return;
            var count = 0;
            for (var r in data.rooms) {
                var users = data.rooms[r].users;
                for (var id in users) {
                    var u = users[id];
                    // 항해 중(active)인데 정산 중(isProcessing)인 상태에서 멈춘 유저 탐색
                    if (u.voyage && u.voyage.active === true && u.voyage.isProcessing === true) {
                        u.voyage.isProcessing = false; // 락 해제
                        u.voyage.isAlerted = false;    // 부도 알림 상태 초기화
                        count++;
                    }
                }
            }
            if (count > 0) Log.info("🛠️ [Auto-Healer] 무역 고착 유저 " + count + "명 자동 해제 완료.");
        })(initialData);
        
        // 3. [무결성 유지] 방별 독립성 및 Feature 템플릿 강제 이식 (기존 로직 보존)
        if (initialData.rooms) {
            for (var rName in initialData.rooms) {
                var targetRoom = initialData.rooms[rName];
                if (!targetRoom.features) {
                    if (typeof ROOM_FEATURE_TEMPLATE === 'function') {
                        targetRoom.features = ROOM_FEATURE_TEMPLATE();
                    }
                } else {
                    var template = ROOM_FEATURE_TEMPLATE();
                    if (!targetRoom.features.racing) targetRoom.features.racing = template.racing;
                    if (!targetRoom.features.lotto) targetRoom.features.lotto = template.lotto;
                    if (!targetRoom.features.stockMarket) targetRoom.features.stockMarket = template.stockMarket;
                    if (!targetRoom.features.states) {
                        targetRoom.features.states = template.states;
                    } else {
                        var s = targetRoom.features.states;
                        var ts = template.states;
                        for (var key in ts) {
                            if (!s[key] || typeof s[key] !== 'object') s[key] = {};
                        }
                    }
                }
                if (!targetRoom.loanPools) targetRoom.loanPools = {};
                if (!targetRoom.loanContracts) targetRoom.loanContracts = {};
                if (targetRoom.bankReserve === undefined) targetRoom.bankReserve = 10000;
            }
        }

        // 4. 시스템 엔진(Executor) 및 캐시 객체 바인딩
        if (initialData) {
            // initialData.SaveExecutor = SaveExecutor;
            // initialData.Executor = Executor;
            if (!initialData.nameToIdCache) initialData.nameToIdCache = {};
        }
        
        globalData = initialData;
        return globalData;
    } catch (e) {
        Log.error("DB Load Error: " + e);
        var stableFile = new java.io.File(BACKUP_DIR + "last_stable_backup.json");
        if (stableFile.exists()) {
            globalData = JSON.parse(FileStream.read(BACKUP_DIR + "last_stable_backup.json"));
            return globalData;
        }
        return null;
    }
}

/* 로직 추적 시작 */
function startTracking(user, commandName) {
    if (!user) return;
    user.lastAction = { cmd: commandName, status: "PENDING", time: Date.now(), msg: "수행 시작" };
}

/**
 * [v8.1 업그레이드] 포인트 변동 검증 및 사유 포함 블랙박스 기록
 * [교정]: 로그 한 줄에 reason을 반드시 포함하여 저장합니다.
 */
function verifyPointTransaction(user, prePoint, changeAmount, reason, roomName, brDelta) {
    try {
        var expected = Number(prePoint) + Number(changeAmount);
        var actual = Number(user.point);
        
        if (actual !== expected) {
            var errorMsg = "[" + new Date().toLocaleString() + "] [불일치] " + (user.name||"") + ": " + reason + " (예상:" + fp(expected) + "/실제:" + fp(actual) + ")\n";
            FileStream.append(ERROR_LOG_PATH, errorMsg);
            // [개별 유저 롤백]: 연산 오류 감지 시 해당 유저의 데이터만 안전 지점으로 되돌림
            var db = getDatabase();
            var safeUser = null;
            for (var r in db.rooms) { 
                if (db.rooms[r].users[user.uid]) { 
                    safeUser = db.rooms[r].users[user.uid]; 
                    break; 
                } 
            }
            
            if (safeUser) {
                var roomData = db.rooms[roomName || "내리다"];
                if (roomData) {
                    // 문제가 된 유저 객체만 백업본으로 통째로 교체 (전체 롤백)
                    roomData.users[user.uid] = JSON.parse(JSON.stringify(safeUser)); 
                }
            }
            
            try { 
                Api.replyRoom(roomName || "내리다", "🛡️ [데이터 무결성 가드] " + (user.name || "유저") + "님의 자산 연산 오류를 감지하여 해당 유저 데이터를 롤백했습니다."); 
            } catch(e){}
            
            user.lastAction = { cmd: reason, status: "FAIL", amount: changeAmount, time: Date.now(), msg: "데이터 불일치 및 롤백" };
        } else {
            if (roomName) {
                logLock.lock();
                try {
                    // [핵심 교정]: 로그 포맷에 reason 항목 추가 (5열 구조)
                    var journalEntry = user.uid + "|" + roomName + "|" + changeAmount + "|" + (brDelta || 0) + "|" + reason + "\n";
                    FileStream.append(JOURNAL_PATH, journalEntry);
                } finally {
                    logLock.unlock();
                }
            }
            if (user.lastAction && user.lastAction.status !== "FAIL") {
                user.lastAction = { cmd: reason, status: "SUCCESS", amount: changeAmount, time: Date.now(), msg: "정상 완료" };
            }
        }
    } catch(e) { 
        FileStream.append(ERROR_LOG_PATH, "검증오류: " + e + "\n"); 
    }
}

/* 로직 추적 종료 */
function endTracking(user, isSuccess, resultMsg) {
    if (!user || !user.lastAction) return;
    if (user.lastAction.status === "FAIL") return; 
    user.lastAction.status = isSuccess ? "SUCCESS" : "CRASH";
    user.lastAction.msg = resultMsg;
    user.lastAction.endTime = Date.now();
}

//==========섹터3==========

/* [최적화] 하이브리드 비동기 영속화(Asynchronous Persistence) 엔진 v6.0 (Defense + Performance) */
/**
 * @param {Object} data - 저장할 데이터 객체
 * @param {Boolean} isForceBackup - true일 경우 백업 파일까지 물리적으로 기록
 */
function safeSaveData(data, isForceBackup) {
    if (!data) return;

    var isHealed = false; // 치유 발생 여부
    var healReports = []; // 치유 내역 보고서

    /**
     * [1단계: 무결성 검역소] - 메인 스레드 수행
     * 사용자님의 핵심 방어 로직(포인트/은행/랜드마크/가방 80% 급감, 유저 증발 등)을 그대로 유지합니다.
     */
    try {
        var roomCount = Object.keys(data.rooms || {}).length;
        if (roomCount === 0) throw new Error("저장 거부: 방(rooms) 객체가 비어있습니다.");

        // 비교용 기존 데이터 로드 (방어 로직 검증용)
        var DB_DATA = null;
        try {
            var dbFile = new java.io.File(FILE_PATH);
            if (dbFile.exists()) {
                var dbContent = FileStream.read(FILE_PATH);
                if (dbContent) DB_DATA = JSON.parse(dbContent);
            }
        } catch(e) { Log.error("DB Read for Healing Fail: " + e); }

        for (var rName in data.rooms) {
            var room = data.rooms[rName];
            
            for (var uid in room.users) {
                var u = room.users[uid];

                // [1] 면제권 체크: 저장이 완료될 때까지 보안 엔진의 접근을 차단
                if (u.skipHealing === true) continue; 

                // [2] 정밀 부분 복구 로직 (Surgical Repair)
                if (DB_DATA && DB_DATA.rooms[rName] && DB_DATA.rooms[rName].users[uid]) {
                    var safeU = DB_DATA.rooms[rName].users[uid];
                    var isFieldHealed = false;

                    // A. 포인트 정밀 체크 (NaN 또는 80%↑ 급감 시 해당 필드만 복구)
                    var lastPoint = Number(safeU.point || 0);
                    var cr = getCreditInfo(u.creditScore || 600);
                    var maxAllowDrop = Math.max(cr.limit * 1.5, lastPoint * 0.5);

                    if (isNaN(u.point) || (lastPoint > 10000 && (lastPoint - u.point) > maxAllowDrop)) {
                        u.point = lastPoint; 
                        isFieldHealed = true;
                    }

                    // B. 은행 잔고 정밀 체크
                    var lastBank = Number(safeU.bank || 0);
                    if (isNaN(u.bank) || (lastBank > 10000 && (lastBank - u.bank) / lastBank >= 0.8)) {
                        u.bank = lastBank;
                        isFieldHealed = true;
                    }

                    // C. 부동산 지분 정밀 체크
                    if (safeU.landHoldings && u.landHoldings) {
                        for (var lName in safeU.landHoldings) {
                            var lastQty = Number(safeU.landHoldings[lName] || 0);
                            var curQty = Number(u.landHoldings[lName] || 0);
                            if (lastQty >= 10 && (lastQty - curQty) / lastQty >= 0.8) {
                                u.landHoldings[lName] = lastQty; // 해당 건물 지분만 복구
                                isFieldHealed = true;
                            }
                        }
                    }

                    // D. 인벤토리 정밀 체크
                    var lastInvCount = Array.isArray(safeU.inventory) ? safeU.inventory.length : 0;
                    var curInvCount = Array.isArray(u.inventory) ? u.inventory.length : 0;
                    if (lastInvCount >= 5 && (curInvCount / lastInvCount) <= 0.2) {
                        u.inventory = JSON.parse(JSON.stringify(safeU.inventory)); // 가방만 복구
                        isFieldHealed = true;
                    }

                    // 수리 발생 시 리포트 추가
                    if (isFieldHealed) {
                        isHealed = true;
                        healReports.push(u.name + " (자산/항목 정밀 수리: 무역 상태 보존)");
                    }
                }
            } // 유저 루프 종료 (3번째 중괄호)
        } // 방 루프 종료 (4번째 중괄호)

        // 모든 방의 검사가 끝난 시점에 한 번만 치유 보고서 발송
        if (isHealed && healReports.length > 0) {
            try {
                var reportMsg = "🚨 [데이터 자가 치유 작동]\n손상 의심 데이터를 제외하고 정상 저장되었습니다.\n\n" +
                                "[치유 내역]\n• " + healReports.join("\n• ") + "\n\n" +
                                "⚠️ 관리자는 해당 유저의 활동을 점검하십시오.";
                Api.replyRoom("내리다", reportMsg);
                Api.replyRoom("베릭방", "🩹 [Healer Audit]\n━━━━━━━━━━━━━━━\n" + healReports.join("\n") + "\n━━━━━━━━━━━━━━━");
            } catch(e) {}
        }

    } catch (validationError) {
        // 검증 실패 시 로그 남기고 저장 중단 (파일 오염 방지)
        Log.error("!!! [데이터 오염 방지 작동] !!!");
        Log.error("사유: " + validationError.message);
        try {
            Api.replyRoom("베릭방", "🚨 [데이터 보호 시스템 작동]\n심각한 데이터 오염이 감지되어 자동 저장을 차단했습니다.\n사유: " + validationError.message + "\n\n⚠️ 관리자는 즉시 시스템을 점검하십시오.");
        } catch (e) {}
        return; 
    }

    // [중요] 메모리 동기화 (즉시 반영하여 명령어 반응 속도 유지)
    globalData = data;

    /**
     * [2단계: 비동기 영속화] - 배경 스레드 수행 (팅김 방지 핵심)
     * 무거운 '문자열 변환(Stringify)'과 '파일 쓰기'를 배경에서 몰래 처리하여
     * 메인 스레드(명령어 처리)가 멈추거나 팅기는 것을 방지합니다.
     */
    SaveExecutor.execute(new java.lang.Runnable({
        run: function() {
            lock.lock(); 
            try {
                var content = JSON.stringify(data, function(key, value) {
                    if (key === "Executor" || key === "SaveExecutor" || (value && typeof value.getClass === 'function') || (value && value.constructor && value.constructor.name === 'SessionCacheReplier')) {
                    return undefined;
                }
                    return value;
                });
                
                var check = JSON.parse(content);
                if (!check || !check.rooms) throw new Error("데이터 구조 불완전 (rooms 누락)");

                var targetPath = FILE_PATH;
                var tempPath = FILE_PATH + ".tmp";
                
                FileStream.write(tempPath, content);
                var tempFile = new java.io.File(tempPath);

                if (tempFile.exists() && tempFile.length() > 0) {
                    var orgFile = new java.io.File(targetPath);
                    if (orgFile.exists()) orgFile.delete();
                    tempFile.renameTo(orgFile);

                    // [핵심] 모든 물리적 파일 저장이 끝난 이 시점에서 면제권을 일괄 회수합니다.
                    for (var r in data.rooms) {
                        if (!data.rooms[r].users) continue;
                        for (var id in data.rooms[r].users) {
                            data.rooms[r].users[id].skipHealing = false;
                        }
                    }
                }

                if (isForceBackup) {
                    var backupPath = BACKUP_DIR + "last_stable_backup.json";
                    FileStream.write(backupPath + ".tmp", content);
                    var bTemp = new java.io.File(backupPath + ".tmp");
                    if (bTemp.exists() && bTemp.length() > 0) {
                        var oldB = new java.io.File(backupPath);
                        if (oldB.exists()) oldB.delete();
                        bTemp.renameTo(oldB);
                    }
                }
                
                content = null; 
            } catch (e) {
                Log.error("Async Save Fail: " + e.message);
                var saveErr = "🚨 [시스템 비상: 저장 마비]\n━━━━━━━━━━━━━━━\n• 사유: " + e.message + "\n⚠️ 기기 저장소 권한 및 용량을 확인하세요.";
                try { Api.replyRoom("베릭방", saveErr); } catch (err) {}
            } finally {
                lock.unlock();
                java.lang.System.gc(); 
            }
        }
    }));
}

//==========섹터4==========

/* 관리자 및 시스템 설정 */
var FIXED_ADMINS = ["95 남 광어", "베릭"]; // 여기에 본인의 정확한 닉네임을 입력하세요
var TIERS = ["아이언", "브론즈", "실버", "골드", "플레티넘", "에메랄드", "다이아몬드", "마스터", "그랜드마스터", "챌린저"];
var ALLOWED_ROOMS = ["내리다", "테스트", "베릭방"]; 

//==========섹터5==========

/* 고티어 승급 확률 설정 */
var TIER_PROBS = {
    0: { up: 95, stay: 5, down: 0 },
    1: { up: 85, stay: 15, down: 0 },
    2: { up: 70, stay: 25, down: 5 },
    3: { up: 50, stay: 40, down: 10 },
    4: { up: 35, stay: 50, down: 15 },
    5: { up: 20, stay: 60, down: 20 },
    6: { up: 12, stay: 68, down: 20 },
    7: { up: 8, stay: 67, down: 25 },  
    8: { up: 5, stay: 70, down: 25 }  
};

/* 상점 카테고리 정의 */
var SHOP_CATEGORIES = {
    1: "🎨 장착/꾸미기 (아이콘)",
    2: "🔂 성장/게임 (승급, 방어)",
    3: "💳 경제/지원 (신용, 인증, 기타)",
    4: "🎁 랜덤 뽑기 (아이콘 박스)",
    5: "🎫 특수/복권 (로또)",
    6: "🚢 무역 물품 (수출용 상자)"
};

/* [수정] 상점 아이템 데이터 (경고삭제권 추가) */
var SHOP_ITEMS = [
    { id: 1, name: "활동가 아이콘", icon: "🌱", price: 5000, effect: "icon", title: "", cat: 1 },
    { id: 2, name: "숙련자 아이콘", icon: "⚔️", price: 10000, effect: "icon", title: "", cat: 1 },
    { id: 3, name: "러블리 아이콘", icon: "❣️", price: 20000, effect: "icon", title: "", cat: 1 },
    { id: 4, name: "베테랑 아이콘", icon: "💎", price: 30000, effect: "icon", title: "", cat: 1 },
    { id: 5, name: "에이리언 아이콘", icon: "👾", price: 50000, effect: "icon", title: "", cat: 1 },
    { id: 6, name: "네임드 아이콘", icon: "👑", price: 70000, effect: "icon", title: "", cat: 1 },
    { id: 8, name: "승급 기회 구매", icon: "🔂", price: 4000, effect: "promotion", cat: 2 },  
    { id: 9, name: "강등 방어권", icon: "🛡️", price: 20000, effect: "tierGuard", cat: 2 },
    { id: 10, name: "신용 점수 회복", icon: "💊", price: 10000, effect: "credit", value: 50, cat: 3 },
    { id: 11, name: "[시즌] 롤 판수 인증권", icon: "🎫", price: 100000, effect: "gameAuth", cat: 3 },
    /* [신규] 경고삭제권: 기본가 500,000P 설정 */
    { id: 13, name: "경고삭제권", icon: "🎫", price: 1500000, effect: "warnClear", cat: 3 },
    { id: 12, name: "랜덤 아이콘 박스", icon: "🎁", price: 5000, effect: "randomBox", cat: 4 },
    { id: 7, name: "로또 구매", icon: "🎟️", price: 2000, effect: "lotto", cat: 5 },
    { id: 14, name: "스피또 복권", icon: "🧧", price: 2000, effect: "spitto", cat: 5 },
    { id: 101, name: "식료품 상자", icon: "🍎", price: 10000, effect: "trade_cargo", value: "식료품", cat: 6 },
    { id: 103, name: "공업품 상자", icon: "⚙️", price: 15000, effect: "trade_cargo", value: "공업품", cat: 6 },
    { id: 102, name: "공예품 상자", icon: "🏺", price: 20000, effect: "trade_cargo", value: "공예품", cat: 6 },
    { id: 104, name: "귀금속 상자", icon: "🪙", price: 25000, effect: "trade_cargo", value: "귀금속", cat: 6 },
    { id: 105, name: "보석 상자", icon: "💎", price: 30000, effect: "trade_cargo", value: "보석", cat: 6 },
    { id: 106, name: "선박 이름변경권", icon: "📝", price: 500000, effect: "ship_rename", cat: 6 }
];

/* [신규] 랜덤 아이콘 박스 상세 구성 및 확률 설정 */
var RANDOM_BOX_CONFIG = {
    PROBS: [
        { grade: "꽝 (Trash)", icon: "💩", prob: 0.60, items: ["💩", "🤡", "🧤", "👞", "🌂", "🪠", "🚽", "🦴", "🧱", "🧹", "🧺", "🧻", "🧼", "🦶", "🦟"] },
        { grade: "노말 (Normal)", icon: "🌱", prob: 0.20, items: ["🌱", "⚔️", "❣️", "🍀", "🎀", "🎈", "🧸", "🪁", "🍭", "🍏", "🍄", "🌻", "🐱", "🐶", "🍎"] },
        { grade: "레어 (Rare)", icon: "💎", prob: 0.10, items: ["💎", "👾", "🛡️", "🎰", "🧿", "🎭", "🎨", "🧪", "🔭", "🎸", "🏹", "🕯️", "⛓️", "🧬"] },
        { grade: "에픽 (Epic)", icon: "🔮", prob: 0.05, items: ["👑", "☄️", "🧨", "🔮", "⛩️", "🎡", "🚁", "🌋", "🐅", "🦅", "🏹", "🏰", "🛥️", "🧿"] },
        { grade: "유니크 (Unique)", icon: "🦄", prob: 0.03, items: ["🪐", "🏮", "🐲", "🦾", "🛰️", "🦄", "🧞", "🦁", "🐋", "🦜", "🕸️", "🎃", "🎅", "🧜"] },
        { grade: "레전더리 (Legendary)", icon: "🎰", prob: 0.02, items: ["🔥", "💫", "🌌", "⚡", "🛸", "🌈", "☀️", "❄️", "🌑", "🔱", "💮", "💠", "🎖️" ] }
    ],
    PAYBACK: 2000 // 중복 아이콘 당첨 시 환급금
};

//==========섹터6==========

/**
 * [시스템 모듈] 명령어 자동 등록 및 도움말 관리
 * 기능: CMD_LIST의 데이터를 USER_COMMANDS/ADMIN_COMMANDS 레지스트리에 매핑하고 도움말 생성
 */

/* [1] 도움말 생성 함수 (동적 렌더링) */
function generateHelpMenu(category) {
    var list = [];
    for (var cmd in USER_COMMANDS) {
        var item = USER_COMMANDS[cmd];
        if (item.cat === category) {
            list.push("• " + cmd + ": " + item.desc);
        }
    }
    return list.length > 0 ? list.join("\n") : "해당 카테고리에 준비된 명령어가 없습니다.";
}

function generateAdminHelp() {
    var list = [];
    var idx = 1;
    for (var cmd in ADMIN_COMMANDS) {
        list.push(idx + ". " + cmd + " (" + ADMIN_COMMANDS[cmd].desc + ")");
        idx++;
    }
    return "⚙️ [관리자 전용 명령어]\n" + list.join("\n");
}

/* [2] 명령어 리스트 데이터 (수정됨: 결투 응답 및 경마 명령어 통합 추가) */
var CMD_LIST = {
    user: [
        { cmd: "/출석", desc: "매일 포인트 획득", cat: "조회", func: "_gameShopLogic" },
        { cmd: "/내정보", desc: "내 스탯 확인", cat: "조회", func: "_gameInfoLogic" },
        { cmd: "/가이드", desc: "심화 시스템 가이드 확인", cat: "조회", func: "_gameInfoLogic" },
        { cmd: "/신용등급", desc: "신용 점수와 등급 확인", cat: "조회", func: "_gameInfoLogic" },
        { cmd: "/출석순위", desc: "포인트 랭킹 확인", cat: "조회", func: "_gameInfoLogic" },
        { cmd: "/유저정보", desc: "[닉네임] 상세정보 보기", cat: "조회", func: "_gameInfoLogic" },
        { cmd: "/명예의전당", desc: "챌린저 명단 확인", cat: "조회", func: "_gameInfoLogic" },
        { cmd: "/버그제보", desc: "[내용] 오류 및 버그 신고", cat: "조회", func: "_gameInfoLogic" },
        { cmd: "/핑", desc: "봇 응답 속도 측정", cat: "조회", func: "_gameInfoLogic" },
        { cmd: "/경마", desc: "현재 출전마 정보 및 배당 확인", cat: "조회", func: "_gameInfoLogic" }, // [신규 경마 조회]
        { cmd: "/코드확인", desc: "기기변경/전체변경 대비 복구코드 확인", cat: "조회", func: "_gameInfoLogic" },
        { cmd: "/계정연동", desc: "[코드] 입력하여 이전 데이터 복구", cat: "조회", func: "_gameInfoLogic" },
        { cmd: "/카지노", desc: "사다리 및 바카라 통합 게임장", cat: "게임", func: "_gameCasinoLogic" },
        { cmd: "/홀짝", desc: "(통합됨) /카지노 명령어를 이용하세요", cat: "게임", func: "_gameActionLogic" },
        { cmd: "/승급", desc: "티어 승급 도전", cat: "게임", func: "_gameActionLogic" },
        { cmd: "/배팅", desc: "[말번호] [포인트] 경마 참여", cat: "게임", func: "_gameActionLogic" }, // [신규 경마 배팅]
        { cmd: "배팅취소", desc: "현재 회차 배팅 철회 (수수료 10%)", cat: "게임", func: "_gameActionLogic" }, // [신규 경마 취소]
        { cmd: "/결투", desc: "[닉네임] [포인트] 신청", cat: "게임", func: "_gameActionLogic" },
        { cmd: "수락", desc: "결투 신청 승낙", cat: "게임", func: "_gameActionLogic" },
        { cmd: "거절", desc: "결투 신청 거절", cat: "게임", func: "_gameActionLogic" },
        { cmd: "취소", desc: "결투 신청 철회", cat: "게임", func: "_gameActionLogic" },
        { cmd: "/도둑질", desc: "[닉네임] 포인트 탈취 시도", cat: "게임", func: "_gameActionLogic" },
        { cmd: "잡았다요놈", desc: "도둑질 방어 (1분 이내)", cat: "게임", func: "_gameActionLogic" },
        { cmd: "줍기", desc: "바닥에 떨어진 포인트 획득", cat: "게임", func: "_gameActionLogic" },
        { cmd: "/상점", desc: "아이콘 및 방어권 구매", cat: "상점", func: "_gameShopLogic" },
        { cmd: "/구매", desc: "[번호] 상점 물품 구매", cat: "상점", func: "_gameShopLogic" },
        { cmd: "/가방", desc: "보유 중인 아이콘/칭호 확인", cat: "상점", func: "_handleInventoryLogic" },
        { cmd: "/장착", desc: "[번호] 보유 아이템 장착", cat: "상점", func: "_handleInventoryLogic" },
        { cmd: "/분해", desc: "[번호] 아이콘 분해 및 포인트 회수", cat: "상점", func: "_handleInventoryLogic" },
        { cmd: "/로또정보", desc: "내 로또 번구 및 결과 확인", cat: "상점", func: "_handleLottoLogic" },
        { cmd: "/아이콘초기화", desc: "설정한 아이콘 삭제", cat: "상점", func: "_handleLottoLogic" },
        { cmd: "/은행", desc: "예금/출금/송금/대출/사채 종합 관리", cat: "경제", func: "_gameBankLogic" },
        { cmd: "/대출한도", desc: "신용 등급별 한도 확인", cat: "경제", func: "_gameInfoLogic" },
        { cmd: "/상환", desc: "[금액] 대출금 직접 상환", cat: "경제", func: "_gameBankLogic" },
        { cmd: "/랜드마크", desc: "실시간 부동산 시세 확인", cat: "부동산", func: "_gameLandmarkLogic" },
        { cmd: "/내부동산", desc: "보유 지분 및 수익률 확인", cat: "부동산", func: "_gameLandmarkLogic" },
        { cmd: "/투자", desc: "[건물명] [수량] 지분 매입", cat: "부동산", func: "_gameLandmarkLogic" },
        { cmd: "/매각", desc: "[건물명] [수량] 지분 처분", cat: "부동산", func: "_gameLandmarkLogic" },
        { cmd: "/광산시작", desc: "방치형 포인트 채굴 시작", cat: "광산", func: "_handleMiningLogic" },
        { cmd: "/광산정보", desc: "현재 채굴 현황 및 예상 수익 확인", cat: "광산", func: "_handleMiningLogic" },
        { cmd: "/광산종료", desc: "채굴 완료 및 포인트 정산", cat: "광산", func: "_handleMiningLogic" },
        { cmd: "/유물도감", desc: "유물 조각 수집 현황 확인", cat: "광산", func: "_gameInfoLogic" },
        { cmd: "/의회", desc: "현재 정책 및 안건 조회", cat: "정부", func: "_gameGovernmentLogic" },
        { cmd: "/투표", desc: "[찬성|반대] 안건 투표 참여", cat: "정부", func: "_gameGovernmentLogic" },
        { cmd: "/스피또", desc: "즉석복권 구매 (1,000P)", cat: "상", func: "_gameLotteryLogic" },
        { cmd: "/낚시", desc: "강가에서 물고기 낚기 (10분 쿨타임)", cat: "게임", func: "_gameActivityLogic" },
        { cmd: "/무역", desc: "가상 국가와의 해상 교역 및 선박 관리", cat: "무역", func: "_gameTradeLogic" }
    ],
    admin: [
        { cmd: "/공지", desc: "[내용] 내리다 방에 공지 전송", func: "_adminSystemLogic" },
        { cmd: "/봇구동", desc: "[온|오프] 시스템 제어", func: "_adminSystemLogic" },
        { cmd: "/진단", desc: "[닉네임] 유저 상태 정밀 분석", func: "_adminUserManageLogic" },
        { cmd: "/무역복구", desc: "[닉네임] 정산 꼬임 강제 해제 및 재시작", func: "_adminUserManageLogic" },
        { cmd: "/블랙박스", desc: "[닉네임] 최근 거래 내역 역추적", func: "_adminUserManageLogic" },
        { cmd: "/부동산자산복구", desc: "유저 평단가 기반 시세 긴급 복구", func: "_adminEconomyLogic" },
        { cmd: "/매물추가", desc: "[이름] [가격] 신규 상장", func: "_adminEconomyLogic" },
        { cmd: "/매물삭제", desc: "[건물명] 시장에서 영구 제거", func: "_adminEconomyLogic" },
        { cmd: "/매물수정", desc: "[기존] [새이름] [가격] 수정", func: "_adminEconomyLogic" },
        { cmd: "/경제정보", desc: "은행 재원 및 경제 지표 확인", func: "_adminEconomyLogic" },
        { cmd: "/재원수정", desc: "[금액] 은행 금고 자본 조정", func: "_adminEconomyLogic" },
        { cmd: "/데이터교정", desc: "은행 재원 및 유저 데이터 동기화", func: "_adminEconomyLogic" },
        { cmd: "/물가조정", desc: "[기준값] 인플레 반영 상점가 조절", func: "_adminEconomyLogic" },
        { cmd: "/물가완충", desc: "[0.0~1.0] 물가 변동폭 조절", func: "_adminEconomyLogic" },
        { cmd: "/강제재가동", desc: "시스템 락 해제 및 리셋", func: "_adminSystemLogic" },
        { cmd: "/서버상태", desc: "지능형 성능 감시자(IPM) 대시보드", func: "_adminEconomyLogic" },
        { cmd: "/유저삭제", desc: "[닉네임] 데이터 영구 삭제", func: "_adminUserManageLogic" },
        { cmd: "/유저데이터", desc: "상세 JSON 데이터 확인", func: "_adminUserManageLogic" },
        { cmd: "/데이터이전", desc: "[구닉] > [신닉] 자산 이전", func: "_adminUserManageLogic" },
        { cmd: "/닉네임기록", desc: "[닉네임] 변경 이력 조회", func: "_adminUserManageLogic" },
        { cmd: "/출석초기화", desc: "[닉네임] 오늘 기록 삭제", func: "_adminUserManageLogic" },
        { cmd: "/채굴시간복구", desc: "[닉네임] [분] 개별 복구", func: "_adminUserManageLogic" },
        { cmd: "/전체채굴복구", desc: "00시 누락분 + 오늘 채굴분 자동 합산 복구", func: "_adminUserManageLogic" },
        { cmd: "/배당금강제정산", desc: "누락된 배당금 즉시 지급 및 주머니 초기화", func: "_adminUserManageLogic" },
        { cmd: "/포인트지급", desc: "[닉네임] [수량] 직접 지급", func: "_adminEconomyLogic" },
        { cmd: "/전체포인트지급", desc: "[수량] 전원 지급", func: "_adminEconomyLogic" },
        { cmd: "/포인트차감", desc: "[닉네임] [수량] 차감", func: "_adminEconomyLogic" },
        { cmd: "/도박제한", desc: "[온|오프] 시스템 제어", func: "_adminSystemLogic" },
        { cmd: "/뿌리기", desc: "랜덤 포인트 선착순 이벤트", func: "_adminEconomyLogic" },
        { cmd: "/관리자등록", desc: "[닉네임] 부관리자 추가", func: "_adminSystemLogic" },
        { cmd: "/관리자해제", desc: "[닉네임] 관리자 권한 박탈", func: "_adminSystemLogic" },
        { cmd: "/관리자목록", desc: "권한 보유자 명단 조회", func: "_adminSystemLogic" },
        { cmd: "/관리자로그", desc: "최근 관리 활동 내역", func: "_adminLogLogic" },
        { cmd: "/제보목록", desc: "버그 제보 확인", func: "_adminLogLogic" },
        { cmd: "/제보초기화", desc: "제보 내역 전체 삭제", func: "_adminLogLogic" },
        { cmd: "/오류로그", desc: "시스템 에러 로그 확인", func: "_adminLogLogic" },
        { cmd: "/오류초기화", desc: "시스템 에러 로그 삭제", func: "_adminLogLogic" },
        { cmd: "/승급횟수초기화", desc: "전체 승급 기회 리셋", func: "_adminEconomyLogic" },
        { cmd: "/명령어점검", desc: "핵심 로직 작동 여부 전수 조사", func: "_adminEconomyLogic" },
        { cmd: "/시즌강제종료", desc: "모든 티어 초기화", func: "_adminEconomyLogic" },
        { cmd: "/출석일수수정", desc: "[닉네임] [수치] 수정", func: "_adminUserManageLogic" },
        { cmd: "/전체출석수정", desc: "모든 유저 출석일 고정", func: "_adminUserManageLogic" },
        { cmd: "/로또데이터초기화", desc: "로또 시스템 리셋", func: "_adminEconomyLogic" },
        { cmd: "/전체복원", desc: "데이터 롤백 (안전 지점)", func: "_adminEconomyLogic" },
        { cmd: "/유저복원", desc: "[닉네임] 부분 복구", func: "_adminUserManageLogic" },
        { cmd: "/시스템자가복원", desc: "메모리 최적화 및 변수 초기화", func: "_adminEconomyLogic" },
        { cmd: "/이월금수정", desc: "[금액] 경마 잭팟 금액 강제 조정", func: "_adminEconomyLogic" },
        { cmd: "/재원충전", desc: "[금액] 은행 금고 자본 긴급 수혈", func: "_adminEconomyLogic" },
        { cmd: "/보안점검", desc: "데이터 보호 엔진 자가진단", func: "_adminEconomyLogic" },
        { cmd: "/국고로그", desc: "중앙은행 재원 변동 내역 실시간 추적", func: "_adminEconomyLogic" },
        { cmd: "/명부확인", desc: "등록된 전체 유저 복구 코드 조회", func: "_adminEconomyLogic" },
        { cmd: "/명부삭제", desc: "[닉네임] 특정 유저 명부 강제 삭제", func: "_adminEconomyLogic" },
        { cmd: "/명부업데이트", desc: "등록된 전체 유저 복구 코드 업데이트", func: "_adminEconomyLogic" },
        { cmd: "/신용조정", desc: "[닉네임] [점수] 신용점수 직접 가감", func: "_adminUserManageLogic" },
        { cmd: "/칭호회수", desc: "[닉네임] [칭호명] 박탈", func: "_adminUserManageLogic" },
        { cmd: "/조작", desc: "[닉네임] [홀짝%] [낚시%]", func: "_adminUserManageLogic", hidden: true },
        { cmd: "/배당복구", desc: "로그 기반 배당금 소급 합산", func: "_adminEconomyLogic", hidden: true },
        { cmd: "/배당초기화", desc: "[항목] 배당 주머니 강제 리셋", func: "_adminEconomyLogic", hidden: true },
        { cmd: "/보안테스트", desc: "[1-3] 보안 엔진 4단계 스트레스 테스트", func: "_adminEconomyLogic" },
        { cmd: "/전체부동산", desc: "전 구역 유저들의 부동산 보유 현황 총괄 조회", func: "_adminEconomyLogic" },
        { cmd: "/부동산회수", desc: "[닉네임] [건물명] [수량|전부] 지분 강제 몰수", func: "_adminEconomyLogic" },
        { cmd: "/배당현황", desc: "6대 핵심 랜드마크의 당일 누적 예상 배당금 실시간 조회", func: "_adminEconomyLogic" },
        { cmd: "/시장데이터교정", desc: "헬러 간섭으로 꼬인 랜드마크 수량 강제 압축 및 교정", func: "_adminEconomyLogic" },
        { cmd: "/경제전체리셋", desc: "모든 유저 자산/부채 초기화및 20만P 공평 지급", func: "_adminEconomyLogic" },
        { cmd: "/자정테스트", desc: "00시 리셋 로직 강제 트리거", func: "_adminEconomyLogic" },
        { cmd: "/연동진단", desc: "1:1 채팅방 계정 연동 상태 분석", func: "_adminUserManageLogic" },
        { cmd: "/방목록", desc: "DB 전체 방 리스트 및 유저수 스캔", func: "_adminSystemLogic" },
        { cmd: "/지분현황", desc: "전 구역 랜드마크 소유자 및 지분 상세 조회", func: "_adminEconomyLogic" },
        { cmd: "/데이터전수조사", desc: "[닉네임] 명부 무시 DB 전체 스캔", func: "_adminUserManageLogic" },
        { cmd: "/명부강제등록", desc: "[닉네임] [UID] 수동 바인딩", func: "_adminUserManageLogic" }
    ]
};

/* 전역 상태 변수들 (섹터1과 중복 방지 처리) */ 
var sprayData = { 
    totalPoint: 0, 
    remainingPoint: 0, 
    maxWinners: 0, 
    currentWinners: 0, 
    winnersList: [], 
    isActive: false, 
    timer: null 
};

/* 섹터1에 없는 변수만 신규 선언 */ 
// var selectWaitState = {}; 
// var bankProcessState = {};

//==========섹터7==========

/**
 * [신설: 가상 정부 정책 추출기] v1.0
 * 기능: 해당 방의 현재 시행 중인 정책 객체를 안전하게 반환
 */
function util_getActivePolicy(roomData) {
    if (roomData && roomData.features && roomData.features.government && roomData.features.government.activePolicy) {
        return roomData.features.government.activePolicy;
    }
    // 정책 데이터가 없을 경우 표준 기본값 반환 (시스템 중단 방지)
    return {
        stockTax: 0.05,
        mineMult: 1.0,
        attendMult: 1.0,
        loanLimitMult: 1.2,
        bankInterest: 0.01,
        theftFineMult: 1.0,
        policeProbAdj: 0.0
    };
}

/**
 * [신설] 입력 대기열 자동 만료 엔진 (Auto-Timeout Guard)
 * 기능: 30초간 응답 없는 유저를 탐지하여 즉시 알림을 발송하고 대기 상태를 해제합니다.
 * (이 함수는 섹터 16-1의 스케줄러 루프에서 호출됩니다.)
 */
function util_autoClearTimeouts(data) {
    var now = Date.now();
    for (var rName in data.rooms) {
        var roomObj = data.rooms[rName];
        if (!roomObj || !roomObj.features || !roomObj.features.states) continue;
        
        var states = roomObj.features.states;
        var queues = ["menuWait", "bankProcess", "lottoPurchase", "selectWait"];

        queues.forEach(function(qKey) {
            var q = states[qKey];
            if (!q) return;
            for (var uid in q) {
                var entry = q[uid];
                // 각 대기열별 시간 필드값 참조 (time 또는 timestamp)
                var startTime = entry.time || entry.timestamp || 0;
                
                if (startTime > 0 && (now - startTime > 30000)) {
                    var u = roomObj.users[uid];
                    if (u) {
                        try {
                            Api.replyRoom(rName, formatError(u, "입력 시간 초과", "30초 이내에 번호를 선택하지 않아 메뉴가 닫혔습니다."));
                        } catch(e) {}
                    }
                    delete q[uid]; // 대기 상태 즉시 파기
                    safeSaveData(data); // 상태 변경 실시간 저장
                }
            }
        });
    }
}

/**
 * [원자적 개편: 범용 데이터 게이트웨이] v2.0
 * 검증: 타입 일치 및 유효 숫자 여부를 선행 검사하고 정상 변경 승인 플래그 부여
 */
function util_setData(user, key, value, reason, roomName) {
    if (!user || key === undefined) return;
    
    var preValue = user[key];
    
    // [원자적 검증] 기존 데이터와 타입이 다르거나 숫자가 아닌 경우(NaN) 차단
    if (preValue !== undefined && preValue !== null) {
        if (typeof preValue !== typeof value || (typeof value === 'number' && isNaN(value))) {
            Log.error("[Atomic Audit Fail] " + (user.name || "Unknown") + "의 " + key + " 오염 시도 차단 (" + reason + ")");
            return; 
        }
    }

    user[key] = value; 
    user.skipHealing = true; // 정상 로직에 의한 변경이므로 헬러 무시 권한 부여

    if (key === 'tier' && preValue !== value) {
        Log.info("[Status Change] " + user.name + " 티어 변동: " + preValue + " -> " + value);
    }
}

/**
 * [원자적 개편: 중앙은행 국고 3중 방어막] v2.1 (전체 롤백 적용)
 */
function util_updateReserve(roomData, delta, reason, roomName) {
    if (!roomData || isNaN(delta) || delta === 0) return;
    
    var preReserve = Number(roomData.bankReserve || 0);
    var expectedReserve = preReserve + Number(delta);

    var normalOutflow = ["경마 당첨금", "로또", "주식 매도", "은행 출금", "재원", "지원금", "투표", "거마비", "스피또"];
    var isVerified = normalOutflow.some(function(act) { return reason.indexOf(act) !== -1; });

    roomData.bankReserve = expectedReserve;

    var isCorrupted = isNaN(roomData.bankReserve) || (roomData.bankReserve !== expectedReserve);
    var lossRate = preReserve > 0 ? (preReserve - roomData.bankReserve) / preReserve : 0;
    var isAbnormalLoss = !isVerified && (preReserve > 100000 && lossRate >= 0.8);

    if (isCorrupted || isAbnormalLoss) {
        var db = getDatabase();
        var rName = roomName || "내리다";
        // [수정] 국고 데이터 전체를 안전 지점으로 롤백
        if (db.rooms[rName]) {
            roomData.bankReserve = Number(db.rooms[rName].bankReserve || 10000);
        }
        try { Api.replyRoom(rName, "🚨 [국고 보안 엔진] 비인가 변동 감지\n사유: " + (isCorrupted ? "연산오류" : "이상급감") + "\n상태: 국고 전체 데이터를 이전 세이브 지점으로 롤백했습니다."); } catch(e){}
    }
}

/**
 * [원자적 개편: 랜드마크 지분 정밀 감사] v2.2 (Landmark Edition)
 */
function util_updateLandmark(user, landName, delta, reason, roomName) {
    if (!user || !landName || isNaN(delta)) return;
    if (!user.landHoldings || typeof user.landHoldings !== 'object') {
        user.landHoldings = {};
    } else {
        // 기존 객체를 복사하여 새로운 메모리 주소로 할당 (참조 끊기)
        user.landHoldings = JSON.parse(JSON.stringify(user.landHoldings));
    }
    
    var preCount = Number(user.landHoldings[landName] || 0);
    var expectedCount = preCount + Number(delta);
    
    var normalLandActs = ["매각", "판매", "청산", "철거", "교정", "복구", "이전", "이관"];
    var isVerified = normalLandActs.some(function(act) { return reason.indexOf(act) !== -1; });

    if (isVerified || delta > 0) user.skipHealing = true;
    
    user.landHoldings[landName] = expectedCount;

    if (isNaN(user.landHoldings[landName]) || user.landHoldings[landName] !== expectedCount || user.landHoldings[landName] < 0) {
        var db = getDatabase();
        var safeUser = null;
        for (var r in db.rooms) { if (db.rooms[r].users[user.uid]) { safeUser = db.rooms[r].users[user.uid]; break; } }
        
        if (safeUser) {
            var roomData = getDatabase().rooms[roomName || "내리다"];
            if (roomData) roomData.users[user.uid] = JSON.parse(JSON.stringify(safeUser));
            try { Api.replyRoom(roomName || "베릭", "🛡️ [부동산 보안 엔진] 데이터 오염 감지\n대상: " + user.name + "\n상태: 데이터 롤백 완료"); } catch(e){}
        }
    }
}

/**
 * [원자적 개편: 은행 잔고 게이트웨이] v2.1 (전체 롤백 적용)
 */
function util_updateBank(user, roomData, delta, reason, roomName) {
    if (!user || isNaN(delta) || delta === 0) return;

    var preBank = Number(user.bank || 0);
    var expectedBank = preBank + Number(delta);

    var normalBankActs = ["출금", "송금", "이체", "결제", "지불", "기부", "수수료", "이자", "대납", "이관", "복구", "정산"];
    var isVerified = (delta > 0) || normalBankActs.some(function(act) { return reason.indexOf(act) !== -1; });

    if (isVerified) user.skipHealing = true;

    var now = Date.now();
    if (user.lastBankUpdateTime > 0 && preBank > 0) {
        var timePassed = now - user.lastBankUpdateTime;
        var earned = preBank * SYSTEM_CONFIG.ECO.BANK.INTEREST_RATE * (timePassed / 86400000);
        user.accruedInterest = (user.accruedInterest || 0) + earned;
    }
    user.lastBankUpdateTime = now;
    user.bank = Math.max(0, expectedBank);

    if (isNaN(user.bank) || user.bank !== expectedBank) {
        var db = getDatabase();
        var safeUser = null;
        for (var r in db.rooms) { if (db.rooms[r].users[user.uid]) { safeUser = db.rooms[r].users[user.uid]; break; } }
        
        if (safeUser) {
            // [핵심: 돈복사 방지] 예금 연산 오류 시 유저 데이터 전체 롤백
            if (roomData) roomData.users[user.uid] = JSON.parse(JSON.stringify(safeUser));
            try { Api.replyRoom(roomName || "베릭", "🛡️ [은행 보안 엔진] 자산 오염 차단\n대상: " + user.name + "\n상태: 안전 세이브 지점으로 전체 복구되었습니다."); } catch(e){}
        }
    }
}

/**
 * [시스템] 진단용 체크포인트 도장 함수
 * 설명: 스케줄러 로직의 완결성을 체크하기 위해 메모리에 타임스탬프를 기록합니다.
 */
function util_stamp(key) {
    if (typeof globalData !== 'undefined' && globalData !== null) {
        if (!globalData.statusCheck) globalData.statusCheck = {};
        globalData.statusCheck[key] = Date.now();
    }
}

/**
 * [수정] 통합 순자산 계산 엔진 (에러 로깅 및 안전성 강화)
 */
function util_calculateNetWorth(user, roomData) {
    if (!user) return 0;
    try {
        var data = getDatabase(); 
        var liquidAssets = Number(user.point || 0) + Number(user.bank || 0);
        var landmarkAssets = 0;

        var market = data.landmarkMarket || (roomData && roomData.features ? roomData.features.landmarkMarket : null);

        if (user.landHoldings && market) {
            for (var lName in user.landHoldings) {
                var landmark = market[lName];
                if (landmark) landmarkAssets += (Number(user.landHoldings[lName] || 0) * Number(landmark.price || 0));
            }
        }
        
        var bankDebt = (user.loan && user.loan.debt) ? Number(user.loan.debt) : 0;
        var sacheDebt = 0;
        var sacheClaims = 0; 

        if (roomData && roomData.loanContracts) {
            for (var cid in roomData.loanContracts) {
                var c = roomData.loanContracts[cid];
                if (c.borrowerUid === user.uid) sacheDebt += Number(c.currentDebt || 0);
                if (c.lenderUid === user.uid) sacheClaims += Number(c.currentDebt || 0);
            }
        }
        return Math.max(0, Math.floor(liquidAssets + landmarkAssets + sacheClaims - bankDebt - sacheDebt));
    } catch(e) {
        Log.error("NetWorth Calculation Error for " + user.name + ": " + e);
        return Number(user.point || 0); 
    }
}

/**
 * [신설: 원자적 스테이징 엔진] v1.0
 * 기능: 로직 시작 전 유저 데이터의 '가상 복사본'을 만들어 메모리에 격리합니다.
 */
function util_stagingStart(user) {
    if (!user || !user.uid) return;
    GLOBAL_STAGING.active[user.uid] = true;
    GLOBAL_STAGING.cache[user.uid] = JSON.parse(JSON.stringify(user));
}

/**
 * [신설: 원자적 커밋] v1.0
 * 기능: 모든 로직이 에러 없이 종료되었을 때, 가상 주머니의 내용을 실제 DB에 반영합니다.
 */
function util_stagingCommit(user, roomData) {
    if (!user || !user.uid || !GLOBAL_STAGING.active[user.uid]) return;
    user.skipHealing = true;
    delete GLOBAL_STAGING.active[user.uid];
    delete GLOBAL_STAGING.cache[user.uid];
    // 커밋 성공 시 최종 상태를 물리 파일로 영속화
    safeSaveData(globalData);
}

/**
 * [신설: 원자적 롤백] v1.0
 * 기능: 로직 도중 에러가 발생하면, 가상 주머니를 파기하고 시작 전 상태로 되돌립니다.
 */
function util_stagingRollback(user, roomName) {
    if (!user || !user.uid || !GLOBAL_STAGING.active[user.uid]) return;
    var snapshot = GLOBAL_STAGING.cache[user.uid];
    if (snapshot && globalData.rooms[roomName]) {
        globalData.rooms[roomName].users[user.uid] = snapshot; // 시작 전 상태로 즉시 복구
    }
    delete GLOBAL_STAGING.active[user.uid];
    delete GLOBAL_STAGING.cache[user.uid];
    Log.info("[Atomic Rollback] " + user.name + "님의 트랜잭션 실패로 복구되었습니다.");
}

/**
 * [원자적 개편: 포인트 게이트웨이 엔진] v7.2 (Staging 호환형)
 */
function util_updatePoint(user, roomData, delta, reason, roomName) {
    if (!user || isNaN(delta) || delta === 0) return;
    
    // [v10.0] 스테이징 활성화 여부에 따른 동적 참조
    var targetUser = GLOBAL_STAGING.active[user.uid] ? user : user;
    /* (참고: 스테이징 중이면 이미 user 객체가 메모리상에서 분리된 상태임) */

   // [점진적 침식 방어] 스테이징(보호막) 외부에서 발생하는 모든 차감을 신용 등급 기준으로 필터링
    // [수정]: 관리자 활동(reason에 '차감' 포함)이거나 직접적인 관리자 권한 확인 시 방어 로직 통과
    var isAdminAction = (reason && reason.indexOf("차감") !== -1);
    
    if (!GLOBAL_STAGING.active[user.uid] && delta < 0 && !isAdminAction) {
        var cr = getCreditInfo(user.creditScore || 600);
        // 1회 최대 허용치: 신용한도의 1.2배 또는 현재 자산의 40% 중 큰 값
        var dropLimit = Math.max(cr.limit * 1.2, (user.point || 0) * 0.4); 
        
        if (Math.abs(delta) > dropLimit) {
            var shieldMsg = "🛡️ [보안 시스템 작동]\n• 대상: " + user.name + "\n• 내용: 비정상 지출(한도 초합) 감지\n✅ 결과: 자산 보호를 위해 거래를 차단하고 롤백했습니다.";
            Api.replyRoom("내리다", shieldMsg);
            Api.replyRoom("베릭방", "🚨 [Security Alert]\n" + user.name + " (" + reason + ") 차단됨");

            throw new Error("신용 등급[" + cr.label + "] 지출 한도 초과 (침식 방어)");
        }
    }

    var normalKeywords = [
        "부동산", "매입", "매각", "배당", "임대", "건물", "투자",
        "매수", "매도", "상점", "구매", "예금", "출금", "송금", "이체", "배팅", "기부", 
        "차감", "홀짝", "결투", "벌금", "상환", "패널티", "분해", "줍기", "도둑질", "수수료", 
        "수거", "정산", "환수", "징수", "스피또", "로또", "낚시", "인증", "거마비", "사채", 
        "등록", "취소", "대납", "복구", "교정", "이전", "리셋", "시즌", "시스템", "배당", 
        "장려", "지원", "몰수", "박스", "랜덤박스", "뽑기", "아이콘", "개봉", "지급",
        "카지노", "사다리", "바카라", "적중", "미적중"
    ];
    var isVerifiedAction = (delta > 0) || normalKeywords.some(function(k) { return reason && reason.indexOf(k) !== -1; });

    var prePoint = Number(user.point || 0);
    var actualDelta = (delta < 0 && (prePoint + delta) < 0) ? -prePoint : Number(delta);
    var expectedPoint = prePoint + actualDelta;

    if (isVerifiedAction) user.skipHealing = true;

    var brDelta = 0; 
    if (roomData && typeof roomData === 'object') {
        if (roomData.bankReserve === undefined) roomData.bankReserve = 10000;
        var bankOutput = [
            "출석 보상", "민생지원금", "홀짝 적중", "주식 매도", "광산 채굴", 
            "로또 1등", "로또 2등", "로또 3등", "분해 회수", "중복 환급", 
            "결투 승리", "뿌리기 줍기", "경마 당첨", "은행 출금", "대출 실행", 
            "투표 거마비", "국가 특별 배당금", "정부 근로 장려금", "스피또 당첨금",
            "무역 정산 수익" // <-- 이 키워드가 추가되어야 국고에서 차감됩니다.
        ];
        var bankInput = [
            "주식 매수", "홀짝 미적중", "체포 벌금", "대출 상환", "상점 구매", 
            "경찰 벌금", "도둑질 성공", "은행 기부", "경마 배팅", "취소 수수료", 
            "로또 구매", "보유세 징수", "자산 환수", "부동산 매입", "스피또 구매"
        ];
        if (actualDelta > 0) {
            // 사유에 "배당금"이나 "장려금"이 포함되면 국고에서 차감하도록 설계
            if (bankOutput.some(function(r){ return reason.indexOf(r) !== -1; })) brDelta = -actualDelta;
        } else {
            if (bankInput.some(function(r){ return reason.indexOf(r) !== -1; })) brDelta = Math.abs(actualDelta);
        }

       /* [v11.9.24] 배당 주머니: 포인트가 아닌 '원금(Revenue)' 누적으로 변경 */
        if (roomData.features && roomData.features.dailyPools) {
            var dp = roomData.features.dailyPools;
            var r = reason || "";
            var absAmt = Math.abs(actualDelta);

            // [교정]: 상수를 여기서 곱하지 않고 원금(absAmt)만 그대로 더합니다.
            if (r.indexOf("광산") !== -1) dp.mine += absAmt;
            else if (r.indexOf("낚시") !== -1) dp.fish += absAmt;
            else if (r.indexOf("카지노") !== -1 || r.indexOf("사다리") !== -1 || r.indexOf("바카라") !== -1 || r.indexOf("홀짝") !== -1 || r.indexOf("적중") !== -1) {
                dp.casino += absAmt;
            }
            else if (r.indexOf("상점") !== -1 || r.indexOf("구매") !== -1) dp.shop += absAmt;
            else if (r.indexOf("이자") !== -1) dp.bank += absAmt;
            else if (r.indexOf("경마") !== -1 || r.indexOf("배팅") !== -1) dp.race += absAmt;
        }
        util_updateReserve(roomData, brDelta, reason, roomName);
    }

    user.point = expectedPoint; 

    // [감시 엔진] 1:1 대화방 카지노 어뷰징 실시간 모니터링 (구분선 제거 및 최적화)
    if (delta > 0 && ALLOWED_ROOMS.indexOf(roomName) === -1 && user.casinoAuditStartTime > 0) {
        var auditNow = Date.now();
        // 1) 2분 이내 수익인지 검사
        if (auditNow - user.casinoAuditStartTime <= 120000) {
            var currentTotalAssets = Number(user.point) + Number(user.bank || 0);
            
            var lastCheckpoint = (user.casinoAuditAlertHistory && user.casinoAuditAlertHistory.length > 0)
                ? user.casinoAuditAlertHistory[user.casinoAuditAlertHistory.length - 1]
                : user.casinoAuditStartAssets;

            // 2) 기준점 대비 2배 초과 달성 판정
            if (currentTotalAssets >= lastCheckpoint * 2 && currentTotalAssets >= user.casinoAuditStartAssets * 2) {
                if (!user.casinoAuditAlertHistory) user.casinoAuditAlertHistory = [];
                user.casinoAuditAlertHistory.push(currentTotalAssets);

                var alertLog = user.casinoAuditAlertHistory.map(function(val, idx) {
                    return "• 알림" + (idx + 1) + "회: " + fp(val) + " P";
                }).join("\n");

                var alertTitle = user.casinoAuditAlertHistory.length === 1 ? "카지노 고수익 감지" : "고액 수익 지속 발생";
                
                var reportBody = "🚨 [" + alertTitle + "]\n" +
                                 "━━━━━━━━━━━━━━━\n" +
                                 "👤 대상자: " + user.name + " (ID: " + user.uid + ")\n" +
                                 "📍 발생장소: 1:1 대화방 (" + roomName + ")\n" +
                                 "💰 현재 잔액: " + fp(currentTotalAssets) + " P\n\n" +
                                 "📈 발생사유: " + (reason || "카지노 게임 결과") + "\n\n" +
                                 "📊 유저 현황:\n" +
                                 "• 시작자산: " + fp(user.casinoAuditStartAssets) + " P\n" +
                                 alertLog + "\n\n" + // 요청하신 대로 중간 구분선을 제거했습니다.
                                 "⚠️ 관리자는 어뷰징 여부를 확인하십시오.\n" +
                                 "━━━━━━━━━━━━━━━";

                try { Api.replyRoom("베릭방", reportBody); } catch(e) { Log.error("Audit Alert Fail: " + e); }
            }
        }
    }

    if (!GLOBAL_STAGING.active[user.uid]) {
        var lossRate = prePoint > 0 ? (prePoint - user.point) / prePoint : 0;
        if ((isNaN(user.point) || user.point === null || user.point !== expectedPoint) || (!user.skipHealing && lossRate >= 0.8)) {
            var db = getDatabase();
            var safeUser = null;
            for (var r in db.rooms) { if (db.rooms[r].users[user.uid]) { safeUser = db.rooms[r].users[user.uid]; break; } }
            if (safeUser) {
                if (roomData) roomData.users[user.uid] = JSON.parse(JSON.stringify(safeUser)); // 해당 유저만 롤백
                try { Api.replyRoom(roomName, "🛡️ [보안 엔진] 비정상 변동 차단 및 해당 유저 데이터 롤백 완료"); } catch(e){}
            }
        }
    }

    try {
        var totalNetWorth = util_calculateNetWorth(user, roomData);
        var assetTitles = [
            { name: "자산왕", limit: 5000000, id: 703, msg: "[장착 효과]: 매일 00시 은행 예금 이자 수령 시 이율 1.5배 보너스가 적용됩니다." },
            { name: "부호", limit: 2000000, id: 702, msg: "상류 사회의 일원이 되신 것을 환영합니다." },
            { name: "거상", limit: 1000000, id: 701, msg: "시장을 움직이는 거대한 손길이 느껴집니다." },
            { name: "재벌", limit: 500000, id: 700, msg: "성공적인 자산 축적의 첫 결실을 맺었습니다." }
        ];

       var rStub = { reply: function(m) { try { Api.replyRoom(roomName || "내리다", m); } catch(e){} } };

        for (var i = 0; i < assetTitles.length; i++) {
            var t = assetTitles[i];
            if (totalNetWorth >= t.limit) {
                // 공용 함수를 호출하여 작위 수여식 진행 (가방 체크 및 장착 로직 내장됨)
                var awarded = util_checkAndAwardTitle(
                    user, 
                    rStub, 
                    t.name, 
                    t.id, 
                    "💰", 
                    "내리다 경제 위원회", 
                    "순자산 " + fp(t.limit) + "P", 
                    t.msg, 
                    roomName
                );
                
                if (awarded) break; // 하나라도 수여했다면 중단 (중복 방지)
            }
        }
    } catch(e) {}

    if (typeof verifyPointTransaction === 'function') {
        verifyPointTransaction(user, prePoint, actualDelta, reason, roomName, brDelta);
    }
}

/* 포인트 단위 쉼표 포맷팅 (0원 버그 방지형) */
function fp(val) {
    var num = Number(val);
    if (isNaN(num)) return "0";
    return String(Math.floor(num)).replace(/\B(?=(\d{3})+(?!\d))/g, ",");
}
var fP = fp;

/* UI 포맷터 함수군 */
function formatCommand(title, user, content, nextStep) { 
    var msg = title + "\n━━━━━━━━━━━━━━━\n"; 
    if (user !== null) { 
        var nameTag = (typeof user === "string") ? user : getDisplayName(user); 
        msg += nameTag + "님\n"; 
    } 
    msg += content + "\n━━━━━━━━━━━━━━━"; 
    if (nextStep) msg += "\n💡 [가이드]: " + nextStep; 
    return msg; 
}

function formatSimple(title, content, nextStep) {
    var msg = "ℹ️ " + title + "\n━━━━━━━━━━━━━━━\n" + content + "\n━━━━━━━━━━━━━━━";
    if (nextStep) msg += "\n💡 [가이드]: " + nextStep;
    return msg;
}

function formatAdmin(title, content) { 
    return "⚙️ " + title + "\n━━━━━━━━━━━━━━━\n" + content + "\n━━━━━━━━━━━━━━━"; 
}

function formatError(user, content, nextStep) { 
    var nameTag = (typeof user === "string") ? user : getDisplayName(user); 
    var msg = "🚫 오류 발생\n━━━━━━━━━━━━━━━\n" + nameTag + "님\n사유: " + content + "\n━━━━━━━━━━━━━━━"; 
    if (nextStep) msg += "\n💡 [가이드]: " + nextStep; 
    return msg; 
}

/**
 * [신설] 실시간 에러 고발 엔진 (Error Push)
 * 기능: 시스템 장애 발생 시 관리자에게 즉시 카톡 리포트 전송
 */
function util_reportError(e, room, sender, msg) {
    var isCommand = msg.startsWith("/") || 
                    ["줍기", "수락", "거절", "취소", "잡았다요놈", "배팅취소"].indexOf(msg) !== -1 ||
                    !isNaN(Number(msg));

    if (!isCommand) {
        Log.error("[Silent Error] " + sender + ": " + e.message);
        return;
    }

    // [교정] 에러 메시지 한글 변환 로직
    var rawErr = e.message || String(e);
    var koErr = rawErr;
    if (rawErr.indexOf("is not a function") !== -1) koErr = "실행할 함수를 찾을 수 없음 (로직 누락)";
    else if (rawErr.indexOf("is not defined") !== -1) koErr = "정의되지 않은 변수 사용 (참조 오류)";
    else if (rawErr.indexOf("null") !== -1 && rawErr.indexOf("read property") !== -1) koErr = "데이터가 비어있음 (객체 참조 실패)";
    else if (rawErr.indexOf("JSON") !== -1) koErr = "데이터 파싱 실패 (JSON 규격 위반)";

    var errLog = "🚨 [장애 발생 알림]\n" +
                 "━━━━━━━━━━━━━━━\n" +
                 "👤 발생 유저: " + sender + "\n" +
                 "📍 발생 장소: " + room + "\n" +
                 "💬 입력 내용: " + msg + "\n" +
                 "🚫 에러 내용: " + koErr + "\n" +
                 "━━━━━━━━━━━━━━━\n" +
                 "💡 로그 확인 후 조치가 필요합니다.";
    
    try { 
        Api.replyRoom("베릭방", errLog); 
    } catch(err) {
        Log.error("Error Report Send Fail: " + err);
    }
    Log.error("[Error Push] " + sender + ": " + rawErr);
}

/**
 * [신규] 랜드마크 가격 변동 엔진
 */
function stock_calculateNextPrice(currentPrice) {
    if (!marketOpenPrice || marketOpenPrice <= 0) return currentPrice;
    var cfg = SYSTEM_CONFIG.ECO.STOCK.SETTINGS;
    var growthRate = (currentPrice - marketOpenPrice) / marketOpenPrice;
    var change = (Math.random() * 2.4 - 1.2) / 100;

    if (growthRate > cfg.RESISTANCE_START) {
        // [최종 교정]: 삭제된 timeWeight 참조를 제거하여 수식 오류를 방지함
        var resistance = (growthRate - cfg.RESISTANCE_START) * cfg.GRAVITY;
        change -= resistance;
        
        if (growthRate >= (cfg.CLOSING_LIMIT - 0.01) && change > 0) {
            if (Math.random() < 0.8) change = -Math.abs(change) * 0.5;
        }
    }
    return Math.max(10, currentPrice + (currentPrice * change));
}

/**
 * [신설] 국고 비상태세 배율 산출 (지능형 방어)
 */
function util_getEmergencyMultiplier(roomName) {
    var data = getDatabase();
    var roomData = data.rooms[roomName];
    if (!roomData || !roomData.economyBase) return 1.0;
    
    var reserve = Number(roomData.bankReserve || 0);
    var base = Number(roomData.economyBase);
    
    // 재고가 기준점의 10% 미만이면 모든 보상 50% 삭감
    if (reserve < (base * 0.1)) return 0.5; 
    return 1.0;
}

/**
 * [신설] 국고 지급 가능 여부 체크 (부도 방어)
 */
function util_isBankSolvent(roomName, amount) {
    var data = getDatabase(); 
    var targetRoom = (ALLOWED_ROOMS.indexOf(roomName) === -1) ? "내리다" : roomName;
    var roomData = data.rooms[targetRoom];
    if (!roomData) return false;
    return (Number(roomData.bankReserve || 0) >= amount);
}

/**
 * [신설] 국가 부도 상태 확인 함수
 * 부도 선포(disaster) 상태인지 확인하여 리스크 컨텐츠 진행 여부 결정
 */
function util_isBankruptcy(roomName) {
    var data = getDatabase();
    var roomData = data.rooms[roomName];
    if (!roomData) return false;
    // lastBankAlert가 'disaster'인 경우에만 true(부도상태)를 반환
    return roomData.lastBankAlert === "disaster";
}

/**
 * [신설] 종목 약어 검색 엔진
 * @param {Object} market - 검색 대상 종목 객체 (전체 시장 혹은 보유 랜드마크)
 * @param {String} input - 유저 입력 약어 (예: "나투증")
 */
function util_findStockByShorthand(market, input) {
    var stocks = Object.keys(market);
    var matched = [];
    var searchStr = input ? input.trim() : "";
    if (searchStr === "") return matched;

    for (var i = 0; i < stocks.length; i++) {
        var name = stocks[i];
        var searchIdx = 0;
        // 입력된 글자가 종목명에 순서대로 들어있는지 체크 (예: 나...투...증)
        for (var j = 0; j < name.length && searchIdx < searchStr.length; j++) {
            if (name[j] === searchStr[searchIdx]) searchIdx++;
        }
        if (searchIdx === searchStr.length) matched.push(name);
    }
    return matched;
}

/**
 * [신설] 랜드마크 최대주주 추출 엔진
 * @param {Object} roomData - 해당 방 데이터
 * @param {String} landName - 건물 이름
 * @returns {Object|null} 유저 객체 및 ID, 지분량
 */
function util_getMajorityOwner(roomData, landName) {
    var topOwnerId = null;
    var maxQty = 0;
    
    // 해당 방의 모든 유저를 루프하며 특정 건물의 지분 1위를 탐색
    for (var uid in roomData.users) {
        var u = roomData.users[uid];
        var qty = (u.landHoldings && u.landHoldings[landName]) ? Number(u.landHoldings[landName]) : 0;
        
        // 지분이 현재 최고치보다 많을 경우 갱신
        if (qty > maxQty) {
            maxQty = qty;
            topOwnerId = uid;
        }
    }
    
    // 지분 보유자가 한 명이라도 있으면 객체 반환, 없으면 null 반환
    return topOwnerId ? { id: topOwnerId, data: roomData.users[topOwnerId], qty: maxQty } : null;
}

/**
 * [신규] 전 구역 특정 건물의 총 지분 합계 계산 (Global)
 * 설명: 모든 방의 유저 데이터를 뒤져 특정 건물의 발행된 총 지분 수를 합산합니다.
 */
function util_getTotalShares(landName, data) {
    var total = 0;
    if (!data || !data.rooms) return 0;
    for (var r in data.rooms) {
        var room = data.rooms[r];
        if (!room.users) continue;
        for (var u in room.users) {
            total += Number((room.users[u].landHoldings || {})[landName] || 0);
        }
    }
    return total;
}

//==========섹터8==========

/**
 * [v10.0 지능형 엔진] 지니 계수(Gini Coefficient) 계산 함수
 * 원리: 자산의 불평등도를 산출 (0: 완전평등, 1: 완전불평등)
 * $$G = \frac{\sum_{i=1}^{n} \sum_{j=1}^{n} |x_i - x_j|}{2n^2 \bar{x}}$$
 */
function util_calculateGini(roomName) {
    var data = getDatabase();
    var room = data.rooms[roomName];
    if (!room) return 0;

    var assets = [];
    for (var uid in room.users) {
        assets.push(util_calculateNetWorth(room.users[uid], room));
    }
    
    var n = assets.length;
    if (n < 2) return 0;
    
    assets.sort(function(a, b) { return a - b; });
    
    var mean = assets.reduce(function(a, b) { return a + b; }, 0) / n;
    if (mean === 0) return 0;

    var sumDiff = 0;
    for (var i = 0; i < n; i++) {
        for (var j = 0; j < n; j++) {
            sumDiff += Math.abs(assets[i] - assets[j]);
        }
    }
    
    return sumDiff / (2 * n * n * mean);
}

/**
 * [Gemini 정밀 교정] 경제 지표 계산 함수 (시스템 판돈 완벽 통합 버전)
 * 반영: 랜드마크, 경마 배팅액, 로또 잭팟, 은행 재원 등을 모두 합산하여 물가 왜곡 방지
 */
function calculateEconomy(data, roomName) {
    var totalAssets = 0;      // [물가용] 시스템 전체 통화량
    var totalUserWealth = 0;  // [평균용] 유저들의 실질 순자산 합계
    var userCount = 0;
    var economyBase = 0;      // [조회용] 현재 방의 물가 기준점

    if (!data || !data.rooms) return { total: 0, count: 0, average: 0, base: 0 };
    var roomsToScan = roomName ? [roomName] : Object.keys(data.rooms);
    
    // 1. 전역 잭팟 판돈 합산
    if (!roomName) totalAssets += Number(data.lotto_jackpot_pool || 0);

    for (var i = 0; i < roomsToScan.length; i++) {
        var r = roomsToScan[i];
        var roomData = data.rooms[r];
        if (!roomData) continue;

        // 물가 기준점 확보
        economyBase = Number(roomData.economyBase || 0);

        // A. 시스템 금고 및 진행 중인 판돈 합산
        totalAssets += Number(roomData.bankReserve || 0);
        if (roomData.features) {
            if (roomData.features.racing) {
                totalAssets += Number(roomData.features.racing.totalPool || 0);
                totalAssets += Number(roomData.features.racing.carryOver || 0);
            }
            if (roomData.features.lotto) totalAssets += Number(roomData.features.lotto.dailyPool || 0);
        }

        // B. 유저 데이터 합산 루프
        for (var uid in roomData.users) {
            var u = roomData.users[uid];
            if (!u) continue;

            // 1. [평균자산용]: 채권/채무가 포함된 유저의 실질 순자산 합산
            totalUserWealth += util_calculateNetWorth(u, roomData);

            // 2. [물가용]: 중복 방지를 위해 국고에 없는 '현금'과 '부동산 가치'만 통화량에 추가
            var cash = Number(u.point || 0);
            var landmarkVal = 0;
            var market = data.landmarkMarket || (roomData.features ? roomData.features.landmarkMarket : null);
            if (u.landHoldings && market) {
                for (var lName in u.landHoldings) {
                    if (market[lName]) landmarkVal += (Number(u.landHoldings[lName]) * Number(market[lName].price));
                }
            }
            totalAssets += (cash + landmarkVal);
            userCount++;
        } // 유저 루프 종료
    }

    return {
        total: Math.max(0, totalAssets), 
        count: userCount,
        average: userCount > 0 ? Math.floor(totalUserWealth / userCount) : 0,
        base: economyBase // 요청하신 물가기준 필드 추가
    };
}

/**
 * [v10.0 지능형 엔진] 지니 계수(Gini Coefficient) 계산 함수
 * 기능: 해당 방의 자산 불평등도를 산출합니다. (0: 평등, 1: 독점)
 * 위치: 경제 지표 계산부(Sector 8) 하단
 */
function util_calculateGini(roomName) {
    var data = getDatabase();
    var room = data.rooms[roomName];
    if (!room || !room.users) return 0;

    var assets = [];
    for (var uid in room.users) {
        // 유저별 순자산(현금+예금+랜드마-빚) 리스트 추출
        var netWorth = util_calculateNetWorth(room.users[uid], room);
        assets.push(Math.max(0, netWorth));
    }
    
    var n = assets.length;
    if (n < 2) return 0; // 비교 대상이 2명 미만이면 계산 불가
    
    assets.sort(function(a, b) { return a - b; }); // 오름차순 정렬 (로렌츠 곡선 기반)
    
    var mean = assets.reduce(function(a, b) { return a + b; }, 0) / n;
    if (mean === 0) return 0;

    var sumDiff = 0;
    for (var i = 0; i < n; i++) {
        for (var j = 0; j < n; j++) {
            // 모든 유저 간 자산 차이의 절댓값 합산
            sumDiff += Math.abs(assets[i] - assets[j]);
        }
    }
    
    // 최종 지니 계수 산출 (Gini Index 공식)
    return sumDiff / (2 * n * n * mean);
}

//==========섹터9==========

/**
 * [신설: 지능형 빈부격차 교정 배율] v1.0
 * 기능: 지니 계수에 따라 자산가에게는 누진세를, 서민에게는 보너스를 부여하는 지능형 수치를 반환
 */
function util_getGiniCorrection(user, roomName) {
    var gini = util_calculateGini(roomName);
    var conf = INTELLIGENT_CONFIG.ECONOMY;
    
    if (gini < conf.GINI_CRITICAL) return { tax: 1.0, reward: 1.0, level: "안정" };

    var data = getDatabase();
    var room = data.rooms[roomName];
    var eco = calculateEconomy(data, roomName);
    var myNetWorth = util_calculateNetWorth(user, room);
    
    // 평균 자산보다 높으면 '자산가', 낮으면 '서민'으로 분류
    var isWealthy = myNetWorth > eco.average;
    var intensity = (gini - conf.GINI_CRITICAL) / (1 - conf.GINI_CRITICAL); // 격차 강도 (0~1)

    if (isWealthy) {
        // 자산가: 세금 가산 (최대 +20%)
        return { 
            tax: 1.0 + (conf.MAX_PROGRESSIVE_TAX * intensity), 
            reward: 1.0, 
            level: "불평등(누진세 가산)" 
        };
    } else {
        // 서민: 보상 강화 (최대 1.5배)
        return { 
            tax: 1.0, 
            reward: 1.0 + ((conf.REWARD_BOOST_LIMIT - 1.0) * intensity), 
            level: "불평등(서민 지원)" 
        };
    }
}

/**
 * [공통 함수: 물가 배율 통합 엔진] v5.9
 * 기능: 특정 방의 경제 지표를 분석하여 현재의 최종 물가 배율(Multiplier)을 반환합니다.
 * 용도: 상점가 조절, 출석 보상 조절, 채굴 효율 조절 등
 */
function util_getEcoMultiplier(roomName) {
    var data = getDatabase();
    var roomData = data.rooms[roomName];
    if (!roomData || !roomData.economyBase || roomData.economyBase <= 0) return 1.0;

    // 섹터 8의 통합 경제 지표 호출 (채권/부채 반영 수치)
    var currentEco = calculateEconomy(data, roomName);
    var rawRatio = currentEco.total / roomData.economyBase;
    
    // 물가 완충 비율(Damping) 적용
    var damping = (data.economyDamping !== undefined) ? data.economyDamping : 0.5;
    var multiplier = 1 + (rawRatio - 1) * damping;
    
    // 최소 배율 제한 (하한선 0.5배)
    return Math.max(0.5, multiplier);
}

/**
 * [시스템] 아이템 가격 계산 함수
 * 기능: 통합 엔진 배율을 적용하여 실시간 단품가(1개 가격)를 산출합니다.
 */
function getItemPrice(item, user, roomName) {
    var multiplier = util_getEcoMultiplier(roomName);
    var giniCorr = util_getGiniCorrection(user, roomName);
    var basePrice = Math.floor(Number(item.price) * multiplier * giniCorr.tax);

    // 기초가(Base) 설정: 무역 물품일 경우 섹터 1의 상수를 우선 참조
    var rawPrice = Number(item.price);
    if (item.effect === "trade_cargo" && item.value) {
        var tradeCfg = SYSTEM_CONFIG.TRADE;
        rawPrice = (tradeCfg.GOODS_COST && tradeCfg.GOODS_COST[item.value]) ? tradeCfg.GOODS_COST[item.value] : rawPrice;
    }

    // 최종 기본가 산출: (원가 * 물가배율 * 지니누진세)
    var basePrice = Math.floor(rawPrice * multiplier * giniCorr.tax);

    // [수집대마왕] 모든 상점 구매가 15% 할인
    if (user.title === "수집대마왕") {
        basePrice = Math.floor(basePrice * 0.85);
    }

    // [승급권 누적 할증] 구매할 때마다 기본가의 10%씩 영구 할증
    if (item.id === 8) { 
        var boughtCount = Number(user.purchasedPromotionAttempts || 0);
        var surchargeUnit = Math.floor(basePrice * 0.10); // 기본가의 10% 산출
        return basePrice + (surchargeUnit * boughtCount); 
    }

    return basePrice;
}

/**
 * [Gemini 정밀 교정] 경제 부양 지원금 체크 함수 (중복 선언 제거 및 통합)
 */
function checkEconomicStimulus(user, roomName, isManual) {
    if ((user.totalAttendance || 0) < 2) return;
    
    var currentCount = user.dailyStimulusCount || 0;
    if (currentCount >= 1) return;

    var data = getDatabase();
    if (!data) return;
    
    var eco = calculateEconomy(data, roomName);
    var avgAsset = eco.average;
    var roomData = data.rooms[roomName];
    var myNetWorth = util_calculateNetWorth(user, roomData);

    // 지급 기준선: 평균 순자산의 40% 미만
    var targetLine = Math.floor(avgAsset * 0.4);
    
    if (myNetWorth < targetLine) {
        var multiplier = util_getEcoMultiplier(roomName);
        var giniCorr = util_getGiniCorrection(user, roomName);
        var gap = targetLine - myNetWorth;
        var emergencyMult = util_getEmergencyMultiplier(roomName);
        // 지능형 보상 부스트(giniCorr.reward)를 적용하여 서민 자산 복구 가속
        var baseGive = Math.floor(10000 * multiplier * emergencyMult * giniCorr.reward);
        var giveAmount = Math.min(baseGive, gap); 

        // [신규] 신용불량자 페널티: 민생지원금 20% 삭감
        if (Number(user.creditScore || 600) < 500) {
            giveAmount = Math.floor(giveAmount * 0.8);
        }
        
        if (giveAmount < 100 || !util_isBankSolvent(roomName, giveAmount)) return;

        util_updatePoint(user, roomData, giveAmount, "민생지원금 지급", roomName);
        user.dailyStimulusCount = currentCount + 1;

        var msg = "\n경제 위기 극복을 위한 긴급 민생지원금이 지급되었습니다.\n" +
                  "💰 지원금액: +" + fp(giveAmount) + "P";

        Api.replyRoom(roomName, formatCommand("🎁 민생지원금 안내", user, msg, "내 잔액: " + fp(user.point) + "P"));
        safeSaveData(data);
    }
}


//==========섹터10==========

/* 신용 정보 계산 함수 (상수 연동) */
function getCreditInfo(score, roomName) {
    var s = Number(score || 600);
    var conf = SYSTEM_CONFIG.ECO.CREDIT;
    var data = getDatabase();
    var roomData = data.rooms[roomName || "내리다"];
    
    // 00시에 확정된 평균 자산 호출
    var avgAsset = (roomData && roomData.features && roomData.features.government) ? 
                   Number(roomData.features.government.dailyAvgAsset || 420000) : 420000;

    // [핵심 비율 공식]: 현재 평균 자산 / 기준점(420,000P)
    // 예: 평균이 63만P면 배율은 1.5배가 됨
    var assetRatio = avgAsset / 420000;

    for(var i=0; i<conf.SCORES.length; i++) {
        if(s >= conf.SCORES[i]) {
            return { 
                grade: i+1, 
                limit: Math.floor(conf.LIMITS[i] * assetRatio), // 기본한도 * 비율 적용
                label: conf.LABELS[i], 
                rate: conf.RATES[i], 
                icon: conf.ICONS[i] 
            };
        }
    }
    // 마지막 등급 (신용불량)
    var lastIdx = conf.SCORES.length;
    return { 
        grade: lastIdx+1, 
        limit: Math.floor(conf.LIMITS[lastIdx] * assetRatio), 
        label: conf.LABELS[lastIdx], 
        rate: conf.RATES[lastIdx], 
        icon: conf.ICONS[lastIdx] 
    };
}

/* 신용 한도 표 생성 함수 (비율제 반영) */
function getCreditLimitTable(roomName) {
    var conf = SYSTEM_CONFIG.ECO.CREDIT;
    var list = [];
    var data = getDatabase();
    var roomData = data.rooms[roomName || "내리다"];
    
    // 1. 평균 자산 비례 배율 계산 (기준점 420,000P)
    var avgAsset = (roomData && roomData.features && roomData.features.government) ? 
                   Number(roomData.features.government.dailyAvgAsset || 420000) : 420000;
    var assetRatio = avgAsset / 420000;

    // 2. 현재 시장 승수(dynMult) 실시간 호출
    var dynMult = 1.0;
    if (typeof util_getDynamicRateMultiplier === 'function') {
        dynMult = util_getDynamicRateMultiplier(roomName);
    }

    // 3. 1등급 ~ 5등급 루프 처리
    for(var i=0; i<conf.SCORES.length; i++) {
        var baseRatePct = (conf.RATES[i] - 1) * 100;
        var appliedRate = (baseRatePct * dynMult).toFixed(1); // 시장 승수 적용 및 소수점 고정
        var dynamicLimit = Math.floor(conf.LIMITS[i] * assetRatio); // 평균 자산 비례 한도 적용
        
        list.push(conf.ICONS[i] + " " + conf.LABELS[i] + " (" + conf.SCORES[i] + "점~): " + appliedRate + "%\n(한도 " + fp(dynamicLimit) + "P)");
    }
    
    var lastIdx = conf.SCORES.length; 
    var lastBaseRate = (conf.RATES[lastIdx] - 1) * 100;
    var lastApplied = (lastBaseRate * dynMult).toFixed(1); 
    var lastDynamicLimit = Math.floor(conf.LIMITS[lastIdx] * assetRatio);
    
    list.push(conf.ICONS[lastIdx] + " " + conf.LABELS[lastIdx] + " (<" + conf.SCORES[lastIdx-1] + "): " + lastApplied + "%\n(한도 " + fp(lastDynamicLimit) + "P)");
    
    return list.join("\n");
}

/**
 * [수정] 닉네임 표시 생성 함수 (칭호 전용 아이콘 자동 노출 시스템)
 * [Gemini 요청 사항 반영]: 칭호 장착 시 인벤토리에서 해당 칭호의 아이콘을 찾아 자동으로 접두사에 붙입니다.
 */
function getDisplayName(user) {
    if (!user) return "알 수 없음";
    var userIcon = user.icon || "";
    var tierIcon = (user.tier === 9 ? "🏆" : ""); 
    var credit = getCreditInfo(user.creditScore || 600);
    
    var titleStr = "";
    
    // 1순위: 신용불량자일 경우 무조건 [신용불량자] 표시
    if (credit.label === "신용불량자") {
        titleStr = "[신용불량자] ";
    } 
    // 2순위: 일반 상태일 때 장착 중인 칭호 표시 (아이콘 제한 로직)
    else if (user.title && user.title.length > 0) {
        var titleIcon = "";
        
        // [Gemini 규칙]: 도굴왕, 수집대마왕만 인벤토리에서 아이콘을 찾아 합칩니다.
        if (user.title === "도굴왕" || user.title === "수집대마왕" || user.title === "해상왕") {
            if (user.inventory && user.inventory.length > 0) {
                for (var i = 0; i < user.inventory.length; i++) {
                    var item = user.inventory[i];
                    if (item.effect === "title" && item.title === user.title) {
                        titleIcon = item.icon || ""; 
                        break;
                    }
                }
            }
        }
        
        // titleIcon이 비어있으면(그 외 칭호들) 자동으로 [칭호명]만 출력됩니다.
        titleStr = "[" + titleIcon + user.title + "] ";
    }
    
    return titleStr + tierIcon + userIcon + (user.name || "알 수 없음");
}

/* [수정] 관리자 여부 확인 함수 (FIXED_ADMINS 체크 추가) */
function isAdmin(sender, data, uid) {
    var name = String(sender).trim();
    
    // 1. 소스코드에 하드코딩된 이름은 데이터베이스 확인 없이 즉시 마스터 권한 부여
    if (FIXED_ADMINS.indexOf(name) !== -1) return true;
    
    // 2. UID 기반 마스터 인증
    if (uid && adminUIDs.indexOf(uid) !== -1) return true;

    // 3. 부관리자 등 일반 관리자 명단 체크
    if (data && data.admins && data.admins.indexOf(name) !== -1) return true;

    return false;
}

//==========섹터11==========

function util_checkUserState(user, uid, roomName) {
    var now = Date.now();
    var data = getDatabase();
    var roomData = data.rooms[roomName || "내리다"];
    
    // [교정]: 방별 독립 states 데이터 참조 (없을 경우 빈 객체 처리로 Crash 방지)
    var states = (roomData && roomData.features) ? roomData.features.states : {};
    var dData = states.duelData || {};
    var aThefts = states.activeThefts || {};

    // 1. 감옥(징역) 상태 체크
    if (user.jailReleaseTime && now < user.jailReleaseTime) {
        var diff = user.jailReleaseTime - now;
        var remainMin = Math.ceil(diff / (1000 * 60));
        var timeStr = remainMin >= 60 ? Math.ceil(remainMin / 60) + "시간" : remainMin + "분";
        return { canAction: false, reason: "현재 징역 중입니다. (" + timeStr + " 남음)" };
    }

    // 2. 광산 채굴 상태 체크
    if (user.mining && user.mining.active) {
        return { canAction: false, reason: "현재 광산에서 채굴 작업 중입니다." };
    }

    // 3. 결투 진행 상태 체크 (방별 데이터 참조형으로 교정)
    if (dData[uid]) return { canAction: false, reason: "현재 결투 신청을 받은 상태입니다." };
    for (var dKey in dData) {
        if (dData[dKey].challengerUid === uid) return { canAction: false, reason: "현재 타인에게 결투를 신청한 상태입니다." };
    }

    // 4. 도둑질 진행 상태 체크 (방별 데이터 참조형으로 교정)
    if (aThefts[uid]) return { canAction: false, reason: "현재 도둑질의 표적이 되어 방어 중입니다." };
    for (var vKey in aThefts) {
        if (aThefts[vKey].thiefUid === uid) return { canAction: false, reason: "현재 다른 유저를 털고 있는 중입니다." };
    }

    return { canAction: true, reason: "" };
}

/* 기존 호환성을 위한 단순 체크 함수 */
function isUserBusy(uid, roomName) {
    var data = getDatabase();
    var rName = roomName || "내리다";
    if (data.rooms[rName] && data.rooms[rName].users[uid]) {
        var res = util_checkUserState(data.rooms[rName].users[uid], uid, rName);
        return !res.canAction;
    }
    return false;
}

/* 유저 이름 검색 함수 */
function findUserByName(roomData, name) {
    var res = [];
    var searchName = name.trim();
    if (searchName === "") return res; 
    for (var id in roomData.users) {
        var u = roomData.users[id];
        if (u.name === searchName) {
            return [{ id: id, data: u }];
        }
        if (u.name.indexOf(searchName) !== -1) {
            res.push({ id: id, data: u });
        }
    }
    return res;
}

/**
 * [신설] 전역 유저 검색 엔진 (Cross-Room Search)
 * 기능: 현재 방뿐만 아니라 모든 방의 데이터베이스를 뒤져서 유저를 찾습니다.
 */
// 수정: currentRoom 참조 오류 해결 및 인자 규격 확장
function findUserGlobal(name, roomName) {
    var res = [];
    var searchName = name.trim();
    if (searchName === "") return res;
    
    var data = getDatabase();

    // [구역 격리 로직]: 
    // 1. 현재 방이 "내리다"라면 검색 대상을 오직 ["내리다"]로 한정 (중복 방지)
    // 2. 그 외(베릭방, 1:1방)라면 전체 ALLOWED_ROOMS를 스캔 (관제 유지)
    var roomsToScan = (roomName === "내리다") ? ["내리다"] : ALLOWED_ROOMS;

    for (var i = 0; i < roomsToScan.length; i++) {
        var rName = roomsToScan[i];
        var room = data.rooms[rName];
        if (!room || !room.users) continue;

        for (var id in room.users) {
            var u = room.users[id];
            if (u.name === searchName || u.name.indexOf(searchName) !== -1) {
                res.push({ id: id, data: u, roomName: rName });
            }
        }
    }
    return res;
}

/* 중복 유저 선택 핸들러 함수 (전역 대응형) */
function handleUserSelection(replier, targetUid, found, type, extra, user, roomName) {
    var data = getDatabase();
    var roomData = data.rooms[roomName];
    if (!roomData || !roomData.features) return;

    roomData.features.states.selectWait[targetUid] = { 
        timestamp: Date.now(), 
        results: found, // 여기에 각 유저의 roomName이 포함되어 있음
        type: type, 
        extra: extra 
    };
    
    var list = [];
    for(var i=0; i<found.length; i++) {
        var f = found[i];
        // [방 이름 표시] 관리자가 어느 방 유저를 건드리는지 명확히 표시
        var uPoints = f.data.point !== undefined ? fp(f.data.point) : "0";
        var shortId = f.id ? f.id.substring(0, 8) : "Unknown";
        list.push((i + 1) + ". [" + f.roomName + "] " + f.data.name + " (" + uPoints + "P) [" + shortId + "]");
    }

    replier.reply(formatCommand("🔍 전역 중복 유저 선택", user, "관리하실 대상을 선택해주세요.\n\n" + list.join("\n") + "\n\n(취소: [취소])", "입력 대기: 30초"));
}

/**
 * [신설] 중복 종목 선택 핸들러
 */
function handleStockSelection(replier, targetUid, found, type, qty, user, roomName) {
    var data = getDatabase();
    var roomData = data.rooms[roomName];
    if (!roomData || !roomData.features) return;

    roomData.features.states.selectWait[targetUid] = { 
        timestamp: Date.now(), 
        results: found, 
        type: type,     
        extra: { amount: qty } 
    };
    var list = found.map(function(name, i) { return (i + 1) + ". " + name; });
    replier.reply(formatCommand("🔍 종목 선택", user, "여러 종목이 검색되었습니다.\n번호를 선택해주세요.\n\n" + list.join("\n") + "\n\n(취소: [취소])", "입력 대기: 30초"));
}

/**
 * [신설: 원자적 신분 동기화 엔진] v1.0
 * 기능: 유저의 닉네임 변경 시 전 서버의 모든 참조 데이터(사채, 경마 등)를 일괄 갱신합니다.
 * @param {String} uid - 유저 고유 ID
 * @param {String} oldName - 변경 전 이름
 * @param {String} newName - 변경 후 이름
 */
function util_syncIdentityGlobal(uid, oldName, newName) {
    var data = getDatabase();
    var syncCount = 0;

    for (var rName in data.rooms) {
        var room = data.rooms[rName];
        
        // 1. 사채 계약서(Loan Contracts) 동기화
        if (room.loanContracts) {
            for (var cid in room.loanContracts) {
                var c = room.loanContracts[cid];
                if (c.borrowerUid === uid) { c.borrowerName = newName; syncCount++; }
                if (c.lenderUid === uid) { c.lenderName = newName; syncCount++; }
            }
        }

        // 2. 경마 배팅 기록(Racing Bets) 동기화
        if (room.features && room.features.racing && room.features.racing.bets) {
            var bets = room.features.racing.bets;
            if (bets[uid]) {
                bets[uid].name = newName;
                syncCount++;
            }
        }
        
        // 3. 사채 등록 매물(Loan Pools) 동기화
        if (room.loanPools) {
            for (var pid in room.loanPools) {
                if (room.loanPools[pid].lenderUid === uid) {
                    room.loanPools[pid].lenderName = newName;
                    syncCount++;
                }
            }
        }
    }

    if (syncCount > 0) {
        Log.info("[AIS] " + oldName + " ➔ " + newName + " (" + syncCount + "개 데이터 원자적 동기화 완료)");
    }
}

/* 날짜 및 시즌 유틸 함수 */
function getSimpleDate() { var d = new Date(); return d.getFullYear() + "-" + ("0" + (d.getMonth() + 1)).slice(-2) + "-" + ("0" + d.getDate()).slice(-2); }
function getSimpleSeason() { var d = new Date(); return d.getFullYear().toString().slice(-2) + "-" + (d.getMonth() + 1) + "시즌"; }
function generateUUID() { return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) { var r = Math.random() * 16 | 0, v = c == 'x' ? r : (r & 0x3 | 0x8); return v.toString(16); }); }

/**
 * [공통 함수: 칭호 자동 부여 시스템] v6.0 (표준 포맷 적용)
 */
function util_checkAndAwardTitle(user, replier, titleName, titleId, icon, committee, condition, guideText, roomName) {
    if (!user.inventory) user.inventory = [];
    
    var hasTitle = false;
    for (var i = 0; i < user.inventory.length; i++) {
        if (user.inventory[i].title === titleName) {
            hasTitle = true;
            break;
        }
    }
    if (hasTitle) return false;

    user.inventory.push({ 
        id: titleId, 
        name: "[" + titleName + "] 칭호", 
        icon: icon, 
        effect: "title", 
        title: titleName 
    });

    user.title = titleName;

    var winMsg = "🎊 [" + committee + ": 작위 수여]\n" +
                 "━━━━━━━━━━━━━━━\n" +
                 "축하합니다! " + (user.name || "유저") + "님\n\n" +
                 condition + "를 돌파하여\n" +
                 "국가 공인 [" + titleName + "] 칭호를 하사받았습니다.\n\n" +
                 "✨ 상태: [" + titleName + "] 자동 장착 완료\n" +
                 "💼 보관: 영구 자산으로 가방에 등록되었습니다.\n" +
                 "━━━━━━━━━━━━━━━\n" +
                 "💡 " + guideText;

    // [수정] 알림 전송 시 roomName 인자가 있으면 해당 방으로만 전송
    try {
        if (replier && typeof replier.reply === 'function') {
            replier.reply(winMsg);
        } else {
            // roomName이 "베릭방"으로 넘어오면 "베릭방"으로만 보냅니다.
            Api.replyRoom(roomName || "내리다", winMsg);
        }
    } catch(e) {
        Log.error("Award Title Reply Error: " + e);
    }
    return true;
}

/**
 * [신설] 순자산 백분위 계산 엔진
 * 기능: 해당 방 유저들의 자산을 전수 조사하여 나의 상대적 위치(상위 %)를 반환합니다.
 */
function util_getNetWorthPercentile(user, roomName) {
    try {
        var data = getDatabase();
        var roomObj = data.rooms[roomName || "내리다"];
        if (!roomObj || !roomObj.users) return 100;

        var netWorths = [];
        for (var uid in roomObj.users) {
            // 모든 유저의 실질 순자산(현금+예금+부동산-빚) 리스트 생성
            var nw = util_calculateNetWorth(roomObj.users[uid], roomObj);
            netWorths.push(nw);
        }
        
        // 내림차순 정렬 (자산 1등이 0번 인덱스)
        netWorths.sort(function(a, b) { return b - a; });

        var myNetWorth = util_calculateNetWorth(user, roomObj);
        var myRank = netWorths.indexOf(myNetWorth) + 1; // 내 등수
        var totalUsers = netWorths.length;

        // 백분율 계산 (상위 0% ~ 100%)
        return totalUsers > 0 ? (myRank / totalUsers) * 100 : 100;
    } catch (e) {
        Log.error("Percentile Calc Error: " + e);
        return 50; // 에러 시 평균치 반환
    }
}

/**
 * [신설] 지능형 차등 소득세 및 UI 데이터 생성기
 * 기준: 상위 10% 이내(7%), 30% 이내(5%), 그 외(3%)
 * 반환: { 세율%, 차감액, 내순위%, 세후수익 }
 */
function util_applyIncomeTax(user, income, roomName) {
    var percentile = util_getNetWorthPercentile(user, roomName);
    var rate = 0.03; // 기본 3% (서민층)

    if (percentile <= 10) {
        rate = 0.07; // 상위 10% (최상위층)
    } else if (percentile <= 30) {
        rate = 0.05; // 상위 30% (중산층)
    }

    // [추가] 기부왕 칭호 효과: 모든 세금 50% 감면 혜택 적용
    if (user.title === "기부왕") {
        rate = rate * 0.5;
    }

    var taxAmount = Math.floor(income * rate);
    var netIncome = income - taxAmount;

    return {
        ratePct: (rate * 100).toFixed(1),
        taxAmount: taxAmount,              // 차감될 세금 액수
        rankPct: Math.floor(percentile),   // UI 표시용 내 순위 %
        netIncome: netIncome               // 세금 떼고 남은 실제 수익
    };
}

/**
 * [신규 추가] 신용 등급별 무역 수익 배율 반환 엔진
 * 기능: 등급(1~6)에 따라 순수익의 90%~60% 차등 지급 배율을 결정합니다.
 */
function util_getTradeCreditMult(grade) {
    var mapping = { 
        1: 0.90, // 1등급: 90% 수령
        2: 0.85, // 2등급: 85% 수령
        3: 0.80, // 3등급: 80% 수령
        4: 0.75, // 4등급: 75% 수령
        5: 0.70, // 5등급: 70% 수령
        6: 0.60  // 신용불량자: 60% 수령
    };
    // 등급 정보가 없으면 최하 등급(60%) 배율을 기본값으로 반환합니다.
    return mapping[grade] || 0.60;
}

//==========섹터12==========

/* 경찰 출동 결과 처리 함수 (중앙은행 연동 및 방별 격리 보정) */
function processPoliceResult(roomName, thiefUid, victimUid) {
    var data = getDatabase();
    if (!data) return;
    var room = data.rooms[roomName];
    if (!room || !room.features || !room.features.states) return;

    // [핵심 수정] 전역 변수가 아닌 방별 독립 상태 저장소를 참조하도록 연결
    var activeThefts = room.features.states.activeThefts; 

    var theftData = activeThefts[victimUid];
    if (!theftData) return;
    
    var thief = room.users[thiefUid];
    
    if (activeThefts[victimUid].successTimer) clearTimeout(activeThefts[victimUid].successTimer);
    
    // [상태 해제] 올바른 참조 경로에서 삭제 수행
    delete activeThefts[victimUid]; 
    
    // 1. 벌금 계산: 현금 차감은 보유액의 10%
    var cashFine = Math.floor(Number(thief.point) * 0.1);
    // 2. 대납 계산: 1,000P 하한선 보장 (부족분 산출)
    var loanGap = Math.max(0, 1000 - cashFine);
    
    util_updatePoint(thief, room, -cashFine, "도둑질 체포 벌금", roomName);
    
    var loanMsg = "";
    if (loanGap > 0) {
        if (!thief.loan) thief.loan = { debt: 0, items: [] };
        thief.loan.debt = Number(thief.loan.debt || 0) + loanGap;
        if (!thief.loan.items) thief.loan.items = [];
        thief.loan.items.push(loanGap);
        loanMsg = "\n⚠️ 벌금 부족분 대납: " + fp(loanGap) + "P 대출 전환";
    }
    
    var jailTime = 1 * 60 * 60 * 1000;
    util_setData(thief, 'jailReleaseTime', Date.now() + jailTime, "도둑질 체포 징역", roomName);
    
    var msg = "🚨 [경찰 출동]\n대상: " + getDisplayName(thief) + "\n내용: 도둑질 현행범 체포\n벌금: -" + fp(cashFine) + "P / 징역 1시간" + loanMsg + "\n내 잔액: " + fp(thief.point) + "P";
    Api.replyRoom(roomName, formatAdmin("🚓 체포 완료", msg));
    safeSaveData(data);
}

/* 도둑질 성공 결과 처리 함수 (중앙은행 연동 및 방별 격리 보정) */
function processTheftResult(roomName, thiefUid, victimUid) {
    var data = getDatabase();
    if (!data) return;
    var room = data.rooms[roomName];
    if (!room || !room.features || !room.features.states) return;
    
    // [핵심 수정] 방별 독립 상태 저장소 참조 연결
    var activeThefts = room.features.states.activeThefts;

    if (!room.users[thiefUid] || !room.users[victimUid]) { 
        if (activeThefts[victimUid]) delete activeThefts[victimUid]; 
        Api.replyRoom(roomName, "⚠️ [시스템 알림]\n도둑질 진행 중 대상이 사라져 상황이 종료되었습니다.");
        return; 
    }
    
    if (activeThefts[victimUid] && activeThefts[victimUid].policeTimer) clearTimeout(activeThefts[victimUid].policeTimer);

    var thief = room.users[thiefUid];
    var victim = room.users[victimUid];
    
    // 1. 탈취액: 5% ~ 10% 사이 랜덤
    var minSteal = Math.floor(Number(victim.point) * 0.05);
    var maxSteal = Math.floor(Number(victim.point) * 0.10);
    var stealAmount = Math.floor(Math.random() * (maxSteal - minSteal + 1)) + minSteal;
    
    // 2. 피해자 보호: 6시간 동안 타겟 제외
    victim.lastTheftVictimTime = Date.now() + (6 * 60 * 60 * 1000);

    util_updatePoint(victim, room, -stealAmount, "도둑질 당함", roomName);

    var plunderArtifact = "";
    if (Math.random() < 0.10 && Number(victim.artifactPieces || 0) > 0) {
        victim.artifactPieces = Number(victim.artifactPieces) - 1;
        thief.artifactPieces = Number(thief.artifactPieces || 0) + 1;
        plunderArtifact = "\n\n✨ [유물 약탈 성공]!\n" + victim.name + "님의 '유물 조각' 1개를 가로챘습니다!";
    }

    var res = processRepayment(thief, stealAmount, thiefUid, roomName); 
    
    // 도둑의 포인트 증가 (이 돈은 피해자에게서 왔으므로 은행 재원 변동 0)
    util_updatePoint(thief, room, Number(res.actualGain), "도둑질 성공", roomName);
    
   // 2. [확정] 도둑질 성공 누적 통계 게이트웨이 보호
    var nextTheftSuccess = Number(thief.totalTheftSuccess || 0) + 1;
    util_setData(thief, 'totalTheftSuccess', nextTheftSuccess, "도둑질 성공 기록", roomName);

    // 3. 리플라이어 스텁 선언 (칭호 자동 부여 시스템 연동용)
    var replierStub = { reply: function(m) { Api.replyRoom(roomName, m); } };

    // 칭호 부여 로직 (게이트웨이로 갱신된 최신 값을 참조)
    if (thief.totalTheftSuccess >= 50) {
        util_checkAndAwardTitle(thief, replierStub, "약탈왕", 1203, "👤", "내리다 그림자 길드", "누적 도둑질 성공 50회", "[장착 효과]: 도둑질 시 경찰이 출동할 확률이 기존 50%에서 30%로 감소합니다.");
    } else if (thief.totalTheftSuccess >= 30) {
        util_checkAndAwardTitle(thief, replierStub, "대도", 1202, "👺", "내리다 그림자 길드", "누적 도둑질 성공 30회", "대담한 수법으로 세상을 놀라게 하고 있습니다.");
    } else if (thief.totalTheftSuccess >= 10) {
        util_checkAndAwardTitle(thief, replierStub, "좀도둑", 1201, "🧤", "내리다 그림자 길드", "누적 도둑질 성공 10회", "남의 지갑을 가볍게 만드는 기술을 익혔습니다.");
    }
    
    // [상태 해제] 올바른 참조 경로에서 삭제 수행
    if (activeThefts[victimUid]) delete activeThefts[victimUid]; 
    
    var content = "🕵️ 도둑질 성공!\n" + getDisplayName(victim) + "님의 지갑에서\n" + fp(stealAmount) + "P를 훔쳤습니다!" + res.repayMsg + plunderArtifact;
    // [수정] 도둑질 결과에 보유 포인트 표시 추가
    Api.replyRoom(roomName, formatCommand("💰 도둑질 결과", thief, content, "내 잔액: " + fp(thief.point) + "P"));
    safeSaveData(data);
}

//==========섹터13==========

/**
 * [경제 시스템 모듈] 통합 자동 상환 및 신용 관리 (수정된 차등 비율 버전)
 * 수정 내용: 
 * 1. 일반 은행 빚 상환: 30%
 * 2. 신용불량자/사채 강제추심: 50%
 * 3. 은행 대환 채무(대납건): 70%
 */

/* [기능 1] 신용불량자 상태 제어 */
function checkAndHandleDefaulter(user, roomName) {
    var currentScore = Number(user.creditScore || 600);
    if (currentScore < 500) {
        if (!user.isDefaulter) {
            util_setData(user, 'isDefaulter', true, "신용도 하락(500미만)", roomName);
            var msg = "신용 점수 500점 미만 하락\n\n1. 대출 보유 시 수익 50% 자동상환\n2. 각종 지원금 20% 삭감 (국고 환수)\n3. 의회 투표권 박탈"
            try { Api.replyRoom(roomName, formatCommand("📉 신용불량자 지정", user, msg, "대출 상환을 권장합니다.")); } catch(e){}
        }
    } else {
        if (user.isDefaulter) { user.isDefaulter = false; }
    }
}

/* [기능 2] 은행 대출금 분산 상환 엔진 */
function distributeRepayment(user, amount, roomName) {
    if (!user.loan || Number(user.loan.debt) < 1) {
        if (user.loan) { user.loan.debt = 0; user.loan.items = []; user.isTransferred = false; }
        return { actualRepay: 0, creditGain: 0, clearedCount: 0 };
    }
    
    var remainingRepay = Math.floor(Number(amount));
    var initialAmount = remainingRepay;

    var creditGainTotal = 0; 
    var newItems = [];
    var clearedCount = 0; // (참고용 카운트)

    if (!user.loan.items) user.loan.items = [];
    
    // 들어온 순서대로 상환 처리 (FIFO 구조 유지)
    for (var i = 0; i < user.loan.items.length; i++) {
        var item = user.loan.items[i];
        
        // [호환성] 구버전(숫자)과 신버전(객체) 데이터 모두 처리
        var currentAmt = (typeof item === 'object') ? Number(item.amount) : Number(item);
        var isHighLoan = (typeof item === 'object') ? item.isHigh : false;

        if (remainingRepay >= currentAmt) {
            // [완납 성공]: 해당 대출 건이 목록에서 사라짐
            remainingRepay -= currentAmt;
            clearedCount++;
            
            // 조건: 고액 대출로 기록된 건이었다면 신용점수 +80 회복
            if (isHighLoan) {
                creditGainTotal += 80;
            }
        } else {
            // [부분 상환]: 잔액이 남아서 목록에 유지됨
            currentAmt -= remainingRepay;
            remainingRepay = 0;
            
            // 남은 잔액을 다시 저장 (데이터 구조 유지)
            if (typeof item === 'object') {
                item.amount = currentAmt;
                newItems.push(item);
            } else {
                newItems.push(currentAmt);
            }
        }
    }
    
    // 실제 갚은 총액 계산
    var actualRepayed = initialAmount - remainingRepay;
    user.loan.items = newItems;

    // 남은 총 채무액 재계산
    var remainingTotal = 0;
    for (var i = 0; i < newItems.length; i++) { 
        var val = (typeof newItems[i] === 'object') ? Number(newItems[i].amount) : Number(newItems[i]);
        remainingTotal += val; 
    }
    user.loan.debt = remainingTotal; 

    // 신용점수 최종 반영 (최대 1000점)
    if (creditGainTotal > 0) {
        var nextScore = Math.min(1000, Number(user.creditScore || 600) + creditGainTotal);
        util_setData(user, 'creditScore', nextScore, "고액 대출 완납 가점", roomName);
    }

    // [확정]: 대출금이 완전히 0이 되었을 때만 채무 완납 처리 및 특수 채무 플래그를 해제합니다.
    if (user.loan.debt <= 0) {
        user.loan.debt = 0; 
        user.loan.items = []; 
        util_setData(user, 'isTransferred', false, "채무 완납", roomName);
    }
    
    return { actualRepay: actualRepayed, creditGain: appliedGain, clearedCount: clearedCount };
}

/* [기능 3] 사채(P2P) 자동 추심 처리 (수정: 추심 비율 50% 적용) */
function processPrivateCollection(user, userUid, amount, roomName) {
    var data = getDatabase();
    var roomData = data.rooms[roomName];
    if (!roomData) return { collected: 0, msg: "" };

    if (!user.loan || Number(user.loan.debt || 0) <= 0) {
        util_setData(user, 'isTransferred', false, "채무 부재 상태 동기화", roomName);
    }
    
    // [설정 수정] 직접 추심 한도를 수익의 50%로 변경
    var totalLimit = Math.floor(Number(amount) * 0.5); 
    var remainingAmount = totalLimit; 
    
    var totalCollected = 0;
    var collectionLog = "";

    if (roomData.loanContracts) {
        for (var cid in roomData.loanContracts) {
            var c = roomData.loanContracts[cid];
            if (c.borrowerUid === userUid && c.status === 'overdue' && remainingAmount > 0) {
                var collectTarget = Math.min(remainingAmount, c.currentDebt);
                
                var lender = roomData.users[c.lenderUid];
                if (lender) {
                    util_updatePoint(lender, roomData, collectTarget, "사채 추심 수익 (" + c.borrowerName + ")", roomName);
                }

                c.currentDebt -= collectTarget;
                totalCollected += collectTarget;
                remainingAmount -= collectTarget;
                collectionLog += "\n- " + c.lenderName + "님께 " + fp(collectTarget) + "P 송금";

                if (c.currentDebt <= 0) {
                    delete roomData.loanContracts[cid];
                    collectionLog += " (완납 종료)";
                }
            }
        }
    }

    if (totalCollected > 0) {
        var msg = "\n\n🚨 [사채 강제 추심 안내]\n사채 연체로 인해 수익의 50%가 채권자에게 자동 귀속되었습니다." + collectionLog;
        return { collected: totalCollected, msg: msg };
    }
    return { collected: 0, msg: "" };
}

/* [기능 4] 통합 자동 상환 프로세스 (수정: 비율 체계 전면 개편) */
function processRepayment(user, amount, userUid, roomName) {
    var amt = Number(amount) || 0;
    var currentGain = amt;
    var totalRepayMsg = "";
    var data = getDatabase();

    if (!user.loan || Number(user.loan.debt || 0) <= 0) {
        user.isTransferred = false;
    }

    // 1. 사채 직접 추심 (50% 비율 작동)
    var privateRes = processPrivateCollection(user, userUid, currentGain, roomName);
    if (privateRes.collected > 0) {
        currentGain -= privateRes.collected;
        totalRepayMsg += privateRes.msg;
    }

    // 2. 은행 대출 자동 상환
    if (currentGain > 0 && user.loan && Number(user.loan.debt) > 0) {
        // [기본값] 일반 유저 상환 비율 30%
        var repaymentRate = 0.3; 
        var typeLabel = "일반 상환";

        // [조건 1] 대환 채무(은행이 사채를 대신 갚아준 경우)는 70% 압류
        if (user.isTransferred === true || user.isTransferred === "true") {
            repaymentRate = 0.7; 
            typeLabel = "🚨 대환 채무 강제 추심";
        } 
        // [조건 2] 신용불량자(500점 미만)는 수익 발생 시 50% 압류 (상환 로직 확정)
        else if (Number(user.creditScore || 600) < 500) {
            repaymentRate = 0.5; 
            typeLabel = "신용불량 제한 상환";
        }

        var intendedRepay = Math.floor(currentGain * repaymentRate);
        if (intendedRepay > Number(user.loan.debt)) intendedRepay = Number(user.loan.debt);
        
        var res = distributeRepayment(user, intendedRepay, roomName);
        currentGain -= res.actualRepay;

        totalRepayMsg += "\n\n🏦 [은행 " + typeLabel + "]\n💰 " + fp(res.actualRepay) + "P 상환됨 (" + Math.floor(repaymentRate * 100) + "%)";
        
        if (res.creditGain > 0) {
            totalRepayMsg += "\n📈 신용 점수 +" + res.creditGain + " 상승";
        }
        
        totalRepayMsg += "\n(남은 대출: " + fp(user.loan.debt) + "P)";
    } // if (currentGain > 0...) 블록 종료
    
    return { actualGain: currentGain, repayMsg: totalRepayMsg };
}

//==========섹터14==========

/* [개편] 랜드마크 리스트 생성 함수 (부동산 컨셉 적용) */
function generateLandmarkList(data, roomName) {
    var list = [];
    var dangerLandmarks = [];
    var keys = Object.keys(data.landmarkMarket || {});
    if (keys.length === 0) return null;

    // 타입별 우선순위 정의 (낮을수록 상단)
    var getTypePriority = function(name) {
        var fixed = ["광산", "낚시터", "카지노", "중앙은행", "백화점", "경마장"];
        if (fixed.indexOf(name) !== -1) return 1; // 1순위: 고정 랜드마크

        var land = data.landmarkMarket[name];
        if (!land) return 4;
        
        if (land.type === "bluechip") return 2; // 2순위: 비즈니스타워 (🏨)
        if (land.type === "hotspot") return 3;  // 3순위: 상가 및 기타 (🏚️)
        return 4;
    };

    // 다중 정렬: 1순위 타입(우선순위), 2순위 이름(가나다)
    keys.sort(function(a, b) {
        var priA = getTypePriority(a);
        var priB = getTypePriority(b);
        
        if (priA !== priB) return priA - priB;
        return a.localeCompare(b); // 가나다순
    });

    var roomData = data.rooms[roomName]; // 해당 방의 유저 데이터를 참조하기 위해 가져옴
    var landmarkTraits = SYSTEM_CONFIG.ECO.LANDMARK.TRAITS;

    var fixCfg = SYSTEM_CONFIG.ECO.LANDMARK.FIXED_POLICY; // 누락된 변수 정의 추가

    for (var i = 0; i < keys.length; i++) {
        var name = keys[i];
        var landmark = data.landmarkMarket[name];
        var trait = landmarkTraits[landmark.type] || landmarkTraits.normal;
        
        var ownerTag = ""; 
        if (roomData) {
            var owner = util_getMajorityOwner(roomData, name);
            if (owner && owner.data) {
                ownerTag = "\n[" + getDisplayName(owner.data) + "]";
            }
        }
        
        var displayPrice = Number(landmark.price);
        var statusInfo = "";

        if (landmark.type === "normal") {
            // [가격 동기화] 섹터 7의 전역 함수를 호출합니다.
            var totalShares = util_getTotalShares(name, data);
            displayPrice = fixCfg.BASE_PRICE + (totalShares * (fixCfg.BASE_PRICE * fixCfg.PER_SHARE_RATE));
            statusInfo = " (총 " + totalShares + "지분)";
        } else {
            var diff = displayPrice - Number(landmark.lastPrice);
            var rate = landmark.lastPrice > 0 ? ((diff / landmark.lastPrice) * 100).toFixed(1) : "0.0";
            var sign = diff > 0 ? "🔺" : (diff < 0 ? "🔹" : "➖");
            statusInfo = " (" + sign + " " + Math.abs(rate) + "%)";
        }
        
        var warningMark = "";
        if (landmark.delistTick && landmark.delistTick > 0) {
            warningMark = " ⚠️";
            dangerLandmarks.push(name);
        }
        
        list.push(trait.icon + " " + name + ": " + fp(displayPrice) + "P" + statusInfo + warningMark + ownerTag);
    } // for 루프 끝

    var result = list.join("\n");

    if (dangerLandmarks.length > 0) {
        result += "\n\n⚠️ 부지 가치 하락으로 강제 철거 위기!\n해당 건물 : " + dangerLandmarks.join(", ");
    }
    
    return result;
}

//==========섹터15==========

/* 랜드마크 이름 생성 함수 (부동산 전용) */
function generateLandmarkName(data) {
    var conf = SYSTEM_CONFIG.ECO.LANDMARK;
    var name = "";
    for (var i = 0; i < 20; i++) {
        var pre = conf.PREFIXES[Math.floor(Math.random() * conf.PREFIXES.length)];
        var suf = conf.SUFFIXES[Math.floor(Math.random() * conf.SUFFIXES.length)];
        name = pre + suf;
        if (!data.landmarkMarket || !data.landmarkMarket[name]) break;
    }
    return name;
}

/* 랜드마크 타입 할당 함수 */
function assignLandmarkType() {
    var conf = SYSTEM_CONFIG.ECO.LANDMARK;
    var rand = Math.random() * 100;
    var cumulative = 0;
    for (var type in conf.TRAITS) {
        cumulative += conf.TRAITS[type].prob;
        if (rand < cumulative) return type;
    }
    return "normal";
}

/* 랜드마크 시세 변동 로직 함수 (부동산 마켓 통합 버전) */
function updateLandmarkPrices(data) {
    var conf = SYSTEM_CONFIG.ECO.LANDMARK;
    if (!data.landmarkMarket) data.landmarkMarket = {};
    if (!data.landmarkTraffic) data.landmarkTraffic = {}; 

    // 1. [고정] 사용자 지정 6대 핵심 랜드마크 강제 상장
    var fixedSites = {
        "광산": { price: 500000, type: "bluechip", icon: "⛏️" },
        "낚시터": { price: 300000, type: "normal", icon: "🎣" },
        "카지노": { price: 1000000, type: "hotspot", icon: "🎰" },
        "중앙은행": { price: 5000000, type: "bluechip", icon: "🏦" },
        "백화점": { price: 1500000, type: "hotspot", icon: "🏢" },
        "경마장": { price: 800000, type: "normal", icon: "🏇" }
    };
    
    for (var fName in fixedSites) {
        if (!data.landmarkMarket[fName]) {
            var site = fixedSites[fName];
            data.landmarkMarket[fName] = { 
                price: site.price, lastPrice: site.price, type: site.type, 
                delistTick: 0, delistLimit: 9999, trend: "none", trendTick: 0, openPrice: site.price 
            };
        }
    }

    var mainRoom = data.rooms["내리다"];
    var pol = util_getActivePolicy(mainRoom);

    var now = new Date();
    var currentHour = now.getHours();
    var isMarketOpen = (currentHour >= conf.SETTINGS.OPEN_HOUR && currentHour <= conf.SETTINGS.CLOSE_HOUR);
    
    var totalSum = 0;
    var count = 0;
    for (var k in data.landmarkMarket) { totalSum += Number(data.landmarkMarket[k].price); count++; }
    var marketAvg = count > 0 ? (totalSum / count) : 1000;

    var eco = calculateEconomy(data, "내리다");
    var activeUserCount = Math.max(1, eco.count); 
    var ecoBaseFloor = conf.SETTINGS.ABS_DELIST_LIMIT;

    var eventNews = [];

    /* [1] 신규 매물 등록 처리 */
    if (data.pendingNewLandmark && isMarketOpen) {
        if (Object.keys(data.landmarkMarket).length < conf.SETTINGS.MAX_COUNT) {
            var newName = generateLandmarkName(data);
            var newType = assignLandmarkType();
            var startPrice = Math.floor(marketAvg * ((Math.random() * 0.3) + 0.8));
            
            data.landmarkMarket[newName] = { 
                price: Number(startPrice), lastPrice: Number(startPrice), 
                type: newType, delistTick: 0, delistLimit: Math.floor(Math.random() * 4) + 2,
                trend: "none", trendTick: 0, openPrice: startPrice,
                isOverheated: false
            };
            eventNews.push("🏙️ 신규 매물 등록: " + conf.TRAITS[newType].icon + " " + newName + " (" + fp(startPrice) + "P)");
        }
        data.pendingNewLandmark = false;
    }

    /* [2] 조작 프리셋 설정 로드 */
    var mani = conf.MANIPULATION;
    var specLand = (mani && mani.ACTIVE) ? mani.TARGET : null;
    var specFactor = (mani && mani.ACTIVE) ? (mani.IS_UP ? Math.abs(mani.RATE) : -Math.abs(mani.RATE)) : 0;

    if (!specLand && data.pendingSpecialEffect && isMarketOpen) {
        specLand = data.pendingSpecialEffect.landmark; // landmark로 키값 대응
        specFactor = data.pendingSpecialEffect.factor;
    }

    /* [3] 시세 변동 계산 루프 */
    var msgCount = (mainRoom.features.msgCount || 0);
    var units = Math.floor(Math.min(msgCount, 500) / 50); 
    var hypeFactor = 1 + (units * 0.01); 

    for (var name in data.landmarkMarket) {
        var landmark = data.landmarkMarket[name];
        var trait = conf.TRAITS[landmark.type] || conf.TRAITS.normal;
        var changePercent = 0;
        
        landmark.lastPrice = Number(landmark.price);

        /* [Gemini] 랜드마크 타입(normal) 변동 제외 로직 */
        if (landmark.type === "normal") {
            // 랜드마크는 주식형 변동을 하지 않으므로 연산을 건너뜁니다.
            landmark.delistTick = 0; // 강제 철거 위험 방지
            continue; 
        }

        if (isMarketOpen) {
            if (name === specLand) { 
                // [조작 매물] 폭등/폭락 처리
                changePercent = specFactor * hypeFactor;
                eventNews.push("🚨 [변동성 알림]\n건물: " + name + "\n내용: " + (specFactor > 0 ? "🚀 시세 폭등" : "📉 시세 폭락") + " (" + (Math.abs(changePercent * 100)).toFixed(1) + "%)");
            } else {
                // [일반 매물] 트렌드 및 시세 변동 연산
                if (landmark.trendTick <= 0) {
                    // 트렌드 유지 시간 단축: 기존 2~5회 -> 수정 2~3회 (더 빠른 태세 전환)
                    landmark.trendTick = Math.floor(Math.random() * 2) + 2; 
                    var p = Math.random(); 
                    landmark.trend = (p < 0.35) ? "up" : (p < 0.70 ? "down" : "volatile");
                }

                // 변동 폭 랜덤화: 고정 2.5% 대신 1.0% ~ 4.0% 사이의 무작위 배율 결정
                var randomRate = (Math.random() * 0.03) + 0.01; 
                var baseRate = (landmark.trend === "up" ? randomRate : (landmark.trend === "down" ? -randomRate : (Math.random() * 0.08 - 0.04)));
                changePercent = baseRate * trait.volatility * hypeFactor;
                
                var traffic = data.landmarkTraffic[name] || { buy: 0, sell: 0 };
                var trafficImpact = Math.max(-0.15, Math.min(0.15, ((traffic.buy - traffic.sell) / (activeUserCount * 5)) * 0.01));
                changePercent += trafficImpact;

                if (pol.volatilityMult) changePercent *= pol.volatilityMult;

                // [v11.9.9 교정] 저항선 및 하락 압력 로직 (상승 편향 제거)
                var refPrice = landmark.openPrice || landmark.price;
                var growthRate = (landmark.price - refPrice) / refPrice;
                var sConf = conf.SETTINGS;

                if (growthRate > sConf.RESISTANCE_START) {
                    var gap = growthRate - sConf.RESISTANCE_START;
                    changePercent -= gap * sConf.GRAVITY;
                    changePercent += (Math.random() * 0.06 - 0.03); // 대칭적 난수 발생
                    
                    if (growthRate >= sConf.CLOSING_LIMIT - 0.05) changePercent -= 0.08;
                }
                landmark.trendTick--;
            } // else 블록 끝
        } // if (isMarketOpen) 블록 끝
        
        // 최종 가격 결정 및 최저가(10P) 보장
        landmark.price = Math.max(10, Math.round(landmark.price * (1 + changePercent))); 

        // 강제 철거(상폐) 위기 체크
        if (landmark.price < (marketAvg * conf.SETTINGS.DELIST_LIMIT) || landmark.price < ecoBaseFloor) { 
            landmark.delistTick++; 
        } else { 
            landmark.delistTick = 0; 
        }
    } // for 루프 끝

    /* 강제 철거(경매) 집행 */
    var demolished = [];
    for (var name in data.landmarkMarket) {
        if (data.landmarkMarket[name].delistTick >= data.landmarkMarket[name].delistLimit) demolished.push(name);
    }
    
    demolished.forEach(function(delName) { 
        for (var r in data.rooms) {
            for (var uid in data.rooms[r].users) {
                var u = data.rooms[r].users[uid];
                if (u.landHoldings) {
                    delete u.landHoldings[delName];
                    if (u.landAvg) delete u.landAvg[delName];
                }
            }
        }
        delete data.landmarkMarket[delName]; 
        eventNews.push("🚨 [강제 철거] " + delName + "\n사유: 부지 가치 미달로 인한 국고 환수"); 
    });

    data.landmarkTraffic = {}; 
    data.pendingSpecialEffect = null; 
    return eventNews;
}

/* 부동산 시장 수동 제어 엔진 */
function market_forceNewLandmark() {
    var data = getDatabase();
    data.pendingNewLandmark = true;
    return "✅ 다음 변동 타임에 신규 매물 등록이 확정되었습니다.";
}

function market_updateLandmarkNow(roomName) {
    var data = getDatabase();
    var result = updateLandmarkPrices(data);
    var body = "📈 부동산 시세 변동\n━━━━━━━━━━━━━━━\n🟢 부동산 운영중\n\n" + (generateLandmarkList(data) || "매물 정보 없음");
    if (result.length > 0) body += "\n\n" + result.join("\n");
    body += "\n━━━━━━━━━━━━━━━"; 
    Api.replyRoom(roomName || "내리다", body);
    safeSaveData(data);
    return "✅ 부동산 시세 갱신 완료.";
}

//==========섹터16-1==========

/* 통합 스케줄러 실행 함수 (독립 모듈형 엔진 + 대시보드 연동) */
function runScheduler() {
    var SCHEDULER_KEY = "kakaobot_scheduler_v5";
    var oldTimer = java.lang.System.getProperty(SCHEDULER_KEY);
    if (oldTimer) try { clearInterval(parseInt(oldTimer)); } catch (e) {}
    
    var newTimer = setInterval(function() {
        try {
            var data = getDatabase(); 
            if (!data) return;

            // [베릭방 전용]: 스케줄러 지연(부정맥) 감지
            if (globalData.statusCheck && globalData.statusCheck.mainLoop) {
                var delay = Date.now() - globalData.statusCheck.mainLoop;
                if (delay > 15000) { // 15초 이상 지연 시
                    Api.replyRoom("베릭방", "💓 [시스템 부정맥]\n스케줄러 루프가 " + (delay/1000).toFixed(1) + "초간 정지 후 재개되었습니다.");
                }
            }

            util_stamp("mainLoop"); // 로직 시작 시점에 도장을 찍어 무한 경고를 방지합니다.

            // 0. 입력 대기열 자동 만료 감시 엔진 가동 (1초 주기)
            // 섹터 7에서 정의한 함수를 호출하여 30초 초과 시 자동 메시지를 발송합니다.
            if (typeof util_autoClearTimeouts === 'function') {
                util_autoClearTimeouts(data);
            }

            // 모든 섹터가 공유할 상태 객체 (Context)
            var ctx = {
                isUpdated: false,
                isForceBackup: false,
                now: new Date(),
                today: getSimpleDate(),
                season: getSimpleSeason(),
                /* [Gemini 요청 사항] 하드코딩 유지: 메인 운영 방 지정 */
                targetRoom: "내리다",
                // 아래 URL에 본인의 구글 웹 앱 URL을 입력하세요.
                dashboardUrl: "https://script.google.com/macros/s/AKfycbyoURblg3-nLNgSE57Pb9RmjqK3wXyMSRpm9WrkWe3z2kyE_q_wmoabNECLNXWQ2SBZ/exec"
            };

            /* [신규] 하이브리드 디스코드 원격 백업 (30분 전체 / 1분 로그) */
            /* [3. 디스코드 백업 - 에러 격리 보호막 설치] */
            try {
                var webhookUrl = SYSTEM_CONFIG.BACKUP ? SYSTEM_CONFIG.BACKUP.DISCORD_WEBHOOK_URL : "";
                if (webhookUrl && webhookUrl.indexOf("http") === 0) {
                    var currentMin = ctx.now.getMinutes();
                    
                    // A. 전체 데이터 백업 (30분 주기)
                    if ((currentMin === 0 || currentMin === 30) && data.lastFullBackupMin !== currentMin) {
                        data.lastFullBackupMin = currentMin;
                        _sendDiscordFile(webhookUrl, FILE_PATH, "FULL_DATA_" + ctx.today + "_" + ctx.now.getHours() + "h" + currentMin + "m.json");
                    }

                    // B. 블랙박스 로그 백업 (1분 주기)
                    if (data.lastLogBackupMin !== currentMin) {
                        data.lastLogBackupMin = currentMin;
                        logLock.lock();
                        try {
                            var logFile = new java.io.File(JOURNAL_PATH);
                            if (logFile.exists() && logFile.length() > 0) {
                                // 1. 전송용 임시 파일 생성 (레이스 컨디션 방지)
                                var tempFileName = "LOG_TEMP_" + Date.now() + ".txt";
                                var tempPath = BASE_DIR + tempFileName;
                                var rawLogs = FileStream.read(JOURNAL_PATH);
                                
                                if (rawLogs && rawLogs.trim().length > 0) {
                                    // 2. 히스토리 합산 및 원본 즉시 초기화
                                    FileStream.append(BASE_DIR + "total_history.log", rawLogs);
                                    FileStream.write(JOURNAL_PATH, ""); 
                                    
                                    // 3. 임시 파일 쓰기 및 디스코드 전송 요청
                                    FileStream.write(tempPath, rawLogs);
                                    _sendDiscordFile(webhookUrl, tempPath, "LOG_" + ctx.now.getHours() + "h" + currentMin + "m.txt", true);
                                    
                                    Log.info("[Backup] 블랙박스 로그 분리 및 전송 예약 완료.");
                                }
                            }
                        } finally {
                            logLock.unlock();
                        }
                    }
                }
            } catch (backupError) {
                // 백업에서 에러가 나더라도 로그만 남기고 아래 게임 로직으로 정상 진행
                Log.error("🚨 백업 엔진 일시 오류 (격리됨): " + backupError);
            }

            // 1. 경제/경마 (섹터 16-2)
            try {
                if (typeof _runSector16Logic === 'function') _runSector16Logic(data, ctx);
            } catch (e) {
                Log.error("Sector 16 Logic Crash: " + e);
            }

            // 2. 일일 초기화 (섹터 17)
            try {
                if (typeof _runSector17Logic === 'function') _runSector17Logic(data, ctx);
            } catch (e) {
                Log.error("Sector 17 Logic Crash: " + e);
            }

            // 3. 로또 추첨 (섹터 18)
            try {
                if (typeof _runSector18Logic === 'function') _runSector18Logic(data, ctx);
            } catch (e) {
                Log.error("Sector 18 Logic Crash: " + e);
            }

            /* [최종 저장] 하이브리드 비동기 저장 처리 */
            if (ctx.isUpdated) {
                SaveExecutor.execute(new java.lang.Runnable({
                    run: function() { safeSaveData(data, ctx.isForceBackup); }
                }));
            }

            util_stamp("mainLoop");

        } catch (e) { Log.error("Scheduler Error: " + e); }
    }, 1000);
    java.lang.System.setProperty(SCHEDULER_KEY, String(newTimer));
}

/**
 * [신규] 디스코드 파일 전송 헬퍼 함수
 */
function _sendDiscordFile(url, filePath, fileName) {
    Executor.execute(new java.lang.Runnable({
        run: function() {
            try {
                var file = new java.io.File(filePath);
                if (!file.exists()) return;

                org.jsoup.Jsoup.connect(url)
                    .data("file", fileName, new java.io.FileInputStream(file))
                    .ignoreContentType(true)
                    .ignoreHttpErrors(true)
                    .method(org.jsoup.Connection.Method.POST)
                    .execute();
                
                Log.info("[Remote Backup] " + fileName + " 전송 성공");
            } catch (e) {
                Log.error("Discord Backup Fail: " + e);
            }
        }
    }));
}

/** * [Gemini 요청 사항] 대시보드 데이터 전송 함수 (부동산 데이터 전송 규격)
 * 수정 내용: 주식(stocks) 필드를 랜드마크(landmarks) 필드로 교체하여 전송합니다.
 */
function _sendToDashboard(data, ctx) {
    var totalPoints = 0;
    var userCount = 0;
    
    var mainRoomData = data.rooms[ctx.targetRoom];
    
    if (mainRoomData && mainRoomData.users) {
        for (var u in mainRoomData.users) {
            var userObj = mainRoomData.users[u];
            totalPoints += (Number(userObj.point || 0) + Number(userObj.bank || 0));
            userCount++;
        }
        
        if (mainRoomData.bankReserve !== undefined) {
            totalPoints += Number(mainRoomData.bankReserve);
        }
    }

    var payload = {
        total_money: totalPoints,
        user_count: userCount,
        landmarks: data.landmarkMarket || {}
    };

    Executor.execute(new java.lang.Runnable({
        run: function() {
            try {
                org.jsoup.Jsoup.connect(ctx.dashboardUrl)
                    .header("Content-Type", "application/json")
                    .requestBody(JSON.stringify(payload))
                    .ignoreContentType(true)
                    .ignoreHttpErrors(true)
                    .method(org.jsoup.Connection.Method.POST)
                    .execute();
            } catch (e) { Log.error("Dashboard Sync Error: " + e); }
        }
    }));
}

//==========섹터16-2==========

/* [신설] 지능형 경제 순환 이벤트 (3종 랜덤 - 즉시 발동형) */
function _runEconomicStimulus(data, ctx) {
    var roomName = ctx.targetRoom;
    var roomData = data.rooms[roomName];
    if (!roomData || !roomData.economyBase) return;

    var reserve = Number(roomData.bankReserve || 0);
    var base = Number(roomData.economyBase);
    
    // [조건] 기준점 150% 초과 시 '즉시' 발동 (하루 1회 제한)
    if (reserve > base * 1.5 && data.lastStimulusDate !== ctx.today) {
        
        data.lastStimulusDate = ctx.today;
        var excess = reserve - base; // 초과분 계산
        var eventType = Math.floor(Math.random() * 3) + 1; // 1~3 랜덤 선택

        // ① [직접 분배] 특별 배당금 (초과분의 10% 환원)
        if (eventType === 1) {
            var totalGiveaway = Math.floor(excess * 0.1);
            var activeUsers = [];
            var nowTs = Date.now();
            for (var uid in roomData.users) {
                // 최근 3일 내 접속자만 대상
                if (nowTs - (new Date(roomData.users[uid].lastDate).getTime() || 0) < 3 * 86400000) {
                    activeUsers.push(roomData.users[uid]);
                }
            }

            if (activeUsers.length > 0) {
                var perUser = Math.floor(totalGiveaway / activeUsers.length);
                activeUsers.forEach(function(u) {
                    var res = processRepayment(u, perUser, u.uid, roomName);
                    util_updatePoint(u, roomData, Number(res.actualGain), "국가 특별 배당금", roomName);
                });
                
                var msg1 = "🎊 [국가 경제 호황: 특별 배당금 지급] 🎊\n" +
                           "━━━━━━━━━━━━━━━\n" +
                           "중앙은행의 수익이 기준치를 초과하여\n" +
                           "국민 여러분께 배당금을 즉시 환원합니다!\n\n" +
                           "💰 총 환원 규모: " + fp(totalGiveaway) + "P (국고 지출)\n" +
                           "👥 대상 인원: " + activeUsers.length + "명\n" +
                           "🧧 인당 배당: +" + fp(perUser) + "P\n" +
                           "━━━━━━━━━━━━━━━\n" +
                           "💡 빚이 있는 경우 우선 상환되었습니다.";
                Api.replyRoom(roomName, msg1);
            }
        }

        // ② [도박 활성화] 잭팟/이월금 지원 (초과분의 10% 투입)
        else if (eventType === 2) {
            var supportAmt = Math.floor(excess * 0.1);
            var halfAmt = Math.floor(supportAmt / 2);
            
            data.lotto_jackpot_pool = (Number(data.lotto_jackpot_pool) || 0) + halfAmt;
            if (roomData.features && roomData.features.racing) {
                roomData.features.racing.carryOver = (Number(roomData.features.racing.carryOver) || 0) + halfAmt;
            }
            util_updateReserve(roomData, -supportAmt, "도박 산업 진흥 지원금", roomName);

            var msg2 = "🎰 [국가 지원: 사행성 산업 진흥책] 🎰\n" +
                       "━━━━━━━━━━━━━━━\n" +
                       "경기 부양을 위해 중앙은행이 막대한 자금을 투입합니다!\n\n" +
                       "🏇 경마장 이월금: +" + fp(halfAmt) + "P 지원!\n" +
                       "🎫 로또 잭팟: +" + fp(halfAmt) + "P 지원!\n" +
                       "━━━━━━━━━━━━━━━\n" +
                       "지금 바로 일확천금의 기회를 노리세요!";
            Api.replyRoom(roomName, msg2);
        }

        // ③ [생산성 향상] 1:1 매칭 보너스 (2시간 지속)
        else if (eventType === 3) {
            data.stimulusEndTime = Date.now() + (2 * 60 * 60 * 1000);
            
            var msg3 = "⛏️ [긴급: 생산성 1:1 매칭 지원 사업] 🎣\n" +
                       "━━━━━━━━━━━━━━━\n" +
                       "국가 경제 활성화를 위해 '근로 장려금'이 지급됩니다.\n\n" +
                       "⏳ 지속 시간: 지금부터 2시간 동안\n" +
                       "✨ 효과: 광산/낚시 수익의 100%를 은행이 추가 지급!\n" +
                       "(예: 1,000P 채굴 시 ➜ 은행이 +1,000P 더 얹어줌)\n" +
                       "━━━━━━━━━━━━━━━\n" +
                       "\"일한 만큼 더 드립니다! 지금 바로 움직이세요!\"";
            Api.replyRoom(roomName, msg3);
        }
        
        ctx.isUpdated = true;
    }
}

/* 독립 로직 함수: 사채 및 시스템 관리 + 부동산 스케줄러 통합 엔진 */
function _runSector16Logic(data, ctx) {
    if (ALLOWED_ROOMS.indexOf(ctx.targetRoom) === -1) return;
    try { _runEconomicStimulus(data, ctx); } catch(e) {}
    var nowTs = ctx.now.getTime();
    var currentHour = ctx.now.getHours();
    var currentMin = ctx.now.getMinutes();
    var currentSec = ctx.now.getSeconds();
    var conf = SYSTEM_CONFIG.ECO.LANDMARK;
    var rConf = SYSTEM_CONFIG.ECO.RACING; 
    var mani = conf.MANIPULATION;

    var mainRoomData = data.rooms[ctx.targetRoom];
    if (!mainRoomData || !mainRoomData.features) return; 

    var racingData = mainRoomData.features.racing;
    var lotto = mainRoomData.features.lotto;

    var gov = mainRoomData.features.government;

    /* [가상 정부] 1. 안건 자동 발의 (20:00) */
    if (currentHour === 20 && currentMin === 0 && gov.lastBillDate !== ctx.today) {
        if (typeof gov_generateBill === 'function') {
            gov.pendingBill = gov_generateBill(); // 안건 생성 (섹터 46 로직)
            gov.votes = { pro: 0, con: 0, voters: [] };
            gov.lastBillDate = ctx.today;
            gov.isClosing = false;
            gov.resultStatus = null;

            var billMsg = "🏛️ [내리다 의회 안건 발의]\n" +
                          "━━━━━━━━━━━━━━━\n" +
                          "📜 안건: " + gov.pendingBill.name + "\n\n" +
                          "✅ 혜택: " + gov.pendingBill.buffDesc + "\n" +
                          "⚠️ 대가: " + gov.pendingBill.penaltyDesc + "\n" +
                          "━━━━━━━━━━━━━━━\n" +
                          "🕒 투표 시간: 20:00 ~ 23:50\n" +
                          "🎁 참여 보상: 2000P (즉시 지급)\n\n" +
                          "💡 참여: [/투표 찬성] 또는 [/투표 반대]\n" +
                          "(참여율 50% 미만 시 기각됩니다)";
            Api.replyRoom(ctx.targetRoom, billMsg);
            ctx.isUpdated = true;
        }
    }

    /* [가상 정부] 2. 투표 마감 및 정족수 검증 (23:50) */
    if (currentHour === 23 && currentMin === 50 && gov.pendingBill && !gov.isClosing) {
        gov.isClosing = true;
        
        // 정족수 계산: 오늘 출석한 유저 기준 50%
        var attendees = 0;
        for (var uid in mainRoomData.users) {
            if (mainRoomData.users[uid].lastDate === ctx.today) attendees++;
        }
        var quorum = Math.ceil(attendees * 0.5);
        var participantCount = gov.votes.voters.length;

        if (participantCount < quorum) {
            gov.resultStatus = "REJECTED_QUORUM";
            var failMsg = "📢 [의회 통보] 금일 안건이 기각되었습니다.\n" +
                          "사유: 투표 정족수 미달\n" +
                          "(참여: " + participantCount + "명 / 필요: " + quorum + "명)";
            Api.replyRoom(ctx.targetRoom, failMsg);
        } else {
            gov.resultStatus = (gov.votes.pro > gov.votes.con) ? "PASSED" : "REJECTED_VOTE";
            var resultText = (gov.resultStatus === "PASSED") ? "가결 (찬성 과반)" : "부결 (반대 과반)";
            var finalMsg = "🏛️ [의회 투표 종료]\n결과: " + resultText + "\n" +
                           "(찬성 " + gov.votes.pro + "표 / 반대 " + gov.votes.con + "표)\n\n" +
                           "💡 가결된 정책은 00시 05분에 발효됩니다.";
            Api.replyRoom(ctx.targetRoom, finalMsg);
        }
        ctx.isUpdated = true;
    }

    /* [가상 정부] 3. 정책 공식 적용 (00:05) */
    // 일일 초기화 로직보다 우선권을 갖도록 currentMin === 5 조건에서 정산 우선 실행
    if (currentHour === 0 && currentMin === 5 && gov.resultStatus !== null) {
        if (gov.resultStatus === "PASSED") {
            gov.activePolicy = JSON.parse(JSON.stringify(gov.pendingBill.effects));
            Api.replyRoom(ctx.targetRoom, "🏛️ [정부 공표] 새로운 정책 발효!\n━━━━━━━━━━━━━━━\n안건 '" + gov.pendingBill.name + "'이 가결되어 지금부터 모든 시스템에 공식 적용됩니다.");
        }
        
        // 정산 완료 후 상태 초기화 (데이터 휘발 방지)
        gov.pendingBill = null;
        gov.resultStatus = null;
        gov.isClosing = false;
        for (var userUid in mainRoomData.users) {
            mainRoomData.users[userUid].hasVotedToday = false;
        }
        ctx.isUpdated = true;
    }

    /* [시스템] 5분 주기 오토세이브 & 부동산 시장 제어 */
    try {
        if (currentMin % 5 === 0 && data.lastAutoSaveMin !== currentMin) {
            data.lastAutoSaveMin = currentMin;
            ctx.isUpdated = true;
            ctx.isForceBackup = true; 
        }

        /* [v10.0 IPM] 5분 주기 시스템 성능 진단 및 자율 최적화 */
        if (currentMin % 5 === 0 && data.lastMonitorMin !== currentMin) {
            data.lastMonitorMin = currentMin;
            var logFile = new java.io.File(JOURNAL_PATH);
            PERF_METRICS.logSize = logFile.exists() ? logFile.length() : 0;

            if (PERF_METRICS.logSize > (INTELLIGENT_CONFIG ? INTELLIGENT_CONFIG.PERFORMANCE.MAX_LOG_SIZE : 1572864)) {
                var archivePath = BASE_DIR + "logs/transaction_" + ctx.today + ".bak";
                logFile.renameTo(new java.io.File(archivePath));
                Log.info("[IPM] 성능 유지를 위해 로그 아카이빙을 완료했습니다.");
            }

            if (PERF_METRICS.avgLag > (INTELLIGENT_CONFIG ? INTELLIGENT_CONFIG.PERFORMANCE.LAG_THRESHOLD_MS : 450)) {
                globalData.nameToIdCache = {}; 
                java.lang.System.gc();        
                Log.warn("[IPM] 성능 저하가 감지되어 메모리 긴급 최적화를 수행했습니다.");
            }
            PERF_METRICS.msgPerMin = 0; 
        }

        // [부동산] 개장 시 시가 동기화 로직
        if (currentHour === conf.SETTINGS.OPEN_HOUR && currentMin === 0 && data.lastMarketOpenDate !== ctx.today) {
            data.lastMarketOpenDate = ctx.today;
            if (data.landmarkMarket) {
                for (var lKey in data.landmarkMarket) {
                    data.landmarkMarket[lKey].openPrice = data.landmarkMarket[lKey].price;
                }
                ctx.isUpdated = true;
            }
        }
    } catch(e) { Log.error("Sys/Save Logic Error: " + e); }

    /* [2. 부동산 시세 변동 통합 엔진] (정각 1회 실행) */
    // 설명: 기존에 파편화되어 있던 10분 주기 로직과 주식(Stock) 로직을 모두 제거하고 이 하나로 통합합니다.
    try {
        var landCfg = SYSTEM_CONFIG.ECO.LANDMARK.SETTINGS;
        if (currentHour >= landCfg.OPEN_HOUR && currentHour <= landCfg.CLOSE_HOUR && currentMin === 0 && data.lastLandUpdateHour !== currentHour) {
            
            data.lastLandUpdateHour = currentHour; 

            if (mani && mani.ACTIVE === true) {
                data.pendingSpecialEffect = { landmark: mani.TARGET, factor: mani.IS_UP ? Math.abs(mani.RATE) : -Math.abs(mani.RATE), forceMani: true };
            }
            
            var landResult = updateLandmarkPrices(data);
            if (mainRoomData.features) mainRoomData.features.msgCount = 0;

            var statusText = "🟢 부동산 시장 운영 중 (" + landCfg.OPEN_HOUR + ":00 ~ " + landCfg.CLOSE_HOUR + ":59)";
            var body = "📈 부동산 시세 변동\n━━━━━━━━━━━━━━━\n" + statusText + "\n\n" + (generateLandmarkList(data, ctx.targetRoom) || "매물 정보 없음");
            
            if (landResult && landResult.length > 0) body += "\n\n" + landResult.join("\n");
            body += "\n━━━━━━━━━━━━━━━";
            
            Api.replyRoom(ctx.targetRoom, body);
            ctx.isUpdated = true;
            util_stamp("landmarkLogic");
        }
    } catch (e) { Log.error("Landmark Engine Error: " + e); }

    /* 무역 시스템 1시간 주기 순환 시세 변동 엔진 */
    /**
     * 기능: 매시 30분 정각에 5개국의 선호/기피 품목을 '순환 매칭' 방식으로 교체 (1시간 주기)
     * 규칙: 자국 생산 품목은 절대 선호/기피에 포함되지 않음 (수입 필요성 강조)
     */
    try {
        var tradeCfg = SYSTEM_CONFIG.TRADE;
        if (currentMin === 30 && data.lastTradeUpdateHour !== currentHour) {
            data.lastTradeUpdateHour = currentHour;
            
            if (!mainRoomData.features.tradeMarket) mainRoomData.features.tradeMarket = {};
            
            // 순환 매칭을 위한 표준 배열 정의 (생산품 기준)
            var nations = ["노르딕", "샹그릴라", "브리타니아", "엘도라도", "사막의별"];
            var goods = ["식료품", "공예품", "공업품", "보석", "귀금속"];
            
            // 매 시간 겹치지 않는 랜덤 오프셋(1~3) 결정 (자국 물품 회피용)
            var offset = Math.floor(Math.random() * 3) + 1; 
            var hOffset = (offset + 2) % 5; if (hOffset === 0) hOffset = 4;

            for (var i = 0; i < nations.length; i++) {
                var nName = nations[i];
                // 생산 인덱스 i를 기준으로 오프셋만큼 밀어서 배정
                var favIdx = (i + offset) % 5;
                var hateIdx = (i + hOffset) % 5;

                mainRoomData.features.tradeMarket[nName] = {
                    favorite: goods[favIdx],
                    hate: goods[hateIdx],
                    specialty: tradeCfg.NATIONS[nName].specialty
                };
            }

            var tradeNotice = "⚙️ [내리다 무역 지부 공보]\n━━━━━━━━━━━━━━━\n" +
                              "🌍 세계 교역 시세가 '순환 매칭'으로 변동되었습니다!\n\n" +
                              "각 국가는 현재 부족한 타국 물자를 선호하며,\n자국 생산 품목은 일절 매입하지 않습니다.\n" +
                              "━━━━━━━━━━━━━━━\n" +
                              "💡 확인: [/무역] ➔ 1. 세계 시세 확인\n" +
                              "(※ 시세는 매시 30분 정각에 변동됩니다.)";
            
            Api.replyRoom(ctx.targetRoom, tradeNotice);
            ctx.isUpdated = true;
            util_stamp("tradeMarketLogic");
        }
    } catch (e) { Log.error("Trade Market Update Error: " + e); }

    /* [1. 사채 및 경제 감시 엔진] (보존 구역) */
    // 설명: 국가 부도, 사채 이자, 강제 추심 등 시스템 안정성을 위한 핵심 로직입니다.
    try {
        for (var rName in data.rooms) {
            if (ALLOWED_ROOMS.indexOf(rName) === -1) continue;
            var roomData = data.rooms[rName];
            if (!roomData.loanContracts) roomData.loanContracts = {};

            if (roomData.bankReserve !== undefined) {
                var reserve = roomData.bankReserve;
                if (!roomData.lastBankAlert) roomData.lastBankAlert = "normal";

                var roomBase = roomData.economyBase || 3500000;
                var dangerLimit = Math.floor(roomBase * 0.3);
                var disasterLimit = Math.floor(roomBase * 0.1);
                var normalLimit = Math.floor(roomBase * 0.5);

                if (reserve < disasterLimit && roomData.lastBankAlert !== "disaster") {
                    roomData.lastBankAlert = "disaster";
                    var disasterMsg = "🚨 [국가 부도 선포] 🚨\n━━━━━━━━━━━━━━━\n중앙은행의 국고가 바닥났습니다(10% 미만).\n\n🚫 동결: 부동산 매매, 카지노, 경마 등 모든 투자 활동이 전면 금지됩니다.\n🏥 제한: 출석 및 복지 포인트가 50% 삭감됩니다.\n\n⚠️ 해제 조건: 국고가 기준점의 50%(" + fp(normalLimit) + "P) 이상 충전되어야 합니다.";
                    Api.replyRoom(rName, disasterMsg);
                    ctx.isUpdated = true;
                }
                else if (reserve < dangerLimit && reserve >= disasterLimit && roomData.lastBankAlert === "normal") {
                    roomData.lastBankAlert = "warning";
                    var warningMsg = "⚠️ [국가 부도 위험 알림]\n━━━━━━━━━━━━━━━\n중앙은행 재원이 위험 수준(30% 미만)에 도달했습니다.\n\n🏦 현재 금고: " + fp(reserve) + "P\n💡 지속적인 국고 유출 시 부도가 선포되어 모든 경제 활동이 동결될 수 있습니다.";
                    Api.replyRoom(rName, warningMsg);
                    ctx.isUpdated = true;
                }
                else if (reserve >= normalLimit && (roomData.lastBankAlert === "warning" || roomData.lastBankAlert === "disaster")) {
                    roomData.lastBankAlert = "normal";
                    var normalMsg = "✅ [국가 부도 해제]\n━━━━━━━━━━━━━━━\n국고가 안정권(50% 이상)으로 복구되어 모든 경제 활동이 정상화되었습니다.\n\n🔓 해제: 부동산, 도박, 경마 시스템 재가동\n💰 복지: 모든 보상이 정상 지급으로 전환됩니다.";
                    Api.replyRoom(rName, normalMsg);
                    ctx.isUpdated = true;
                }
            }

            for (var cid in roomData.loanContracts) {
                var c = roomData.loanContracts[cid];
                var periodsPassed = Math.floor((nowTs - c.startTime) / 10800000); 
                
                if (c.appliedPeriods === undefined) c.appliedPeriods = 0;
                
                if (periodsPassed > c.appliedPeriods) {
                    var pendingPeriods = periodsPassed - c.appliedPeriods;
                    var totalNewInterest = 0;
                    for (var i = 0; i < pendingPeriods; i++) {
                        var currentDebt = Number(c.currentDebt || 0);
                        var interest = Math.floor(currentDebt * (Number(c.rate) / 100));
                        c.currentDebt = currentDebt + interest;
                        totalNewInterest += interest;
                    }
                    c.appliedPeriods = periodsPassed;
                    ctx.isUpdated = true;
                    
                    try {
                        var interestMsg = "🚬 [사채 이자 갱신]\n━━━━━━━━━━━━━━━\n👤 대상: " + c.borrowerName + "님\n🤝 채권자: " + c.lenderName + "\n🕒 경과: " + (periodsPassed * 3) + "시간\n💰 추가 이자: +" + fp(totalNewInterest) + "P\n📉 현재 채무: " + fp(c.currentDebt) + "P\n━━━━━━━━━━━━━━━";
                        Api.replyRoom(rName, interestMsg);
                    } catch(e) {}
                }

                var duration = nowTs - c.startTime;
                var overdueLimit = 24 * 60 * 60 * 1000;
                var bankTakeoverLimit = 36 * 60 * 60 * 1000;

                if (c.status === 'active' && duration > overdueLimit && duration <= bankTakeoverLimit) {
                    c.status = 'overdue'; ctx.isUpdated = true;
                    try { Api.replyRoom(rName, "🚨 [강제 추심 집행 알림]\n대상: " + c.borrowerName + "님\n사유: 상환 기한(24시간) 초과\n\n지금부터 수익의 50%가 채권자에게 자동 귀속됩니다."); } catch(e){}
                }
                else if (duration > bankTakeoverLimit) {
                    var amountToPay = Number(c.currentDebt);
                    var lender = roomData.users[c.lenderUid];
                    var borrower = roomData.users[c.borrowerUid];

                    if (lender && borrower) {
                        util_updatePoint(lender, roomData, amountToPay, "사채 은행 대납 회수 (" + c.borrowerName + ")", rName);
                        if (!borrower.loan) borrower.loan = { debt: 0, items: [] };
                        borrower.loan.debt = Number(borrower.loan.debt) + amountToPay;
                        borrower.loan.items.push(amountToPay);
                        borrower.isTransferred = true; 
                        borrower.creditScore = Math.max(0, (borrower.creditScore || 600) - 120);
                        checkAndHandleDefaulter(borrower, rName);
                        
                        var takeoverMsg = "🏛️ [중앙은행 대환 집행]\n━━━━━━━━━━━━━━━\n👤 대상: " + c.borrowerName + "님\n내용: 사채 연체 36시간 경과로 은행이 대납 처리하였습니다.\n\n⚠️ [페널티]: 신용점수 -120점 강등\n⚠️ 해당 채무는 [은행 대환 대출]로 전환되었으며, 모든 수익의 70%가 강제 상환됩니다.\n━━━━━━━━━━━━━━━";
                        Api.replyRoom(rName, takeoverMsg);
                        delete roomData.loanContracts[cid];
                        ctx.isUpdated = true;
                    }
                }
            }
        }
    } catch (e) { Log.error("Loan/Bank Logic Error: " + e); }

    /* [3. 경마 시스템 통합 스케줄러] */
    try {
        // A. 개장 알림
        if (currentHour === rConf.OPEN_HOUR && currentMin === 0) {
            if (racingData.lastOpenDate !== ctx.today) {
                racingData.isOperating = true;
                racingData.isResultProcessed = false; 
                racingData.isDeadlineNotified = false;
                racingData.lastOpenDate = ctx.today;
                var startMsg = "🏇 [내리다 경마장 개장 알림]\n━━━━━━━━━━━━━━━\n지금부터 제 " + racingData.round + "회차 경마 배팅이 가능합니다!\n\n🕒 배팅 시간: 매시 00분 ~ 49분 59초\n🏁 결과 발표: 매시 00분 00초\n🚫 운영 종료: 23:59 (00:00 최종 결과)\n━━━━━━━━━━━━━━━\n💡 현황 확인: [/경마] 입력";
                Api.replyRoom(ctx.targetRoom, startMsg);
            }
        }

        // B. 배팅 마감 알림
        if (currentMin === 50 && !racingData.isDeadlineNotified) {
            if (currentHour >= rConf.OPEN_HOUR && currentHour <= rConf.CLOSE_HOUR) {
                racingData.isOperating = true; 
                racingData.isDeadlineNotified = true;
                var deadlineMsg = "📢 [경마 배팅 마감 알림]\n━━━━━━━━━━━━━━━\n제 " + racingData.round + "회차 배팅이 종료되었습니다!\n\n🏦 최종 집계 포인트: " + fp(racingData.totalPool) + "P\n🏁 우승마 판독 및 정산 진행 중...\n━━━━━━━━━━━━━━━\n🏇 잠시 후 정각(00분)에 결과가 발표됩니다!";
                Api.replyRoom(ctx.targetRoom, deadlineMsg);
                ctx.isUpdated = true;
            }
        }

        // C. 결과 발표 및 정산
        var isRaceTime = (currentHour >= rConf.OPEN_HOUR && currentHour <= 23) || currentHour === 0;
        if (isRaceTime && currentMin === 0 && currentHour !== rConf.OPEN_HOUR) {
            if (racingData.lastProcessedHour !== currentHour) {
                racingData.isOperating = (currentHour >= rConf.OPEN_HOUR && currentHour <= 23);
                racingData.lastProcessedHour = currentHour;

                // [신규] 배팅 밀집도에 따른 확률 역보정 (배팅이 몰릴수록 우승 확률 감소)
                if (racingData.totalPool > 0) {
                    racingData.horses.forEach(function(h) {
                        var horseBetAmt = 0;
                        for (var uid in racingData.bets) {
                            if (racingData.bets[uid].horseId === h.id) {
                                horseBetAmt += Number(racingData.bets[uid].amount);
                            }
                        }
                        var betRatio = horseBetAmt / racingData.totalPool;
                        
                        // 밀집도 보정 계수: 배팅 비율의 80%만큼 가중치 삭감 (역배 유도)
                        // 예: 한 말에 100% 몰리면 우승 확률이 기존의 20% 수준으로 급락
                        var penalty = 1 - (betRatio * 0.5);
                        h.weight = Math.max(0.1, h.weight * penalty); 
                    });
                }

                /* [조작 엔진] 특정 유저의 배팅마 우승 가중치 부여 */
                for (var uid in racingData.bets) {
                    var betUser = roomData.users[uid];
                    // 조작이 켜져 있고 경마 보정치가 설정된 경우
                    if (betUser && betUser.isManipulated && (betUser.horseWinRate || 0) > 0) {
                        var targetHorseId = racingData.bets[uid].horseId;
                        var horse = racingData.horses[targetHorseId - 1];
                        
                        // [밸런스 조정]: 100배 대신 설정값의 0.2배를 가산 (70% 설정 시 +14.0 가중치)
                        // 보통 말의 가중치가 1.0 내외이므로, 14.0만 더해져도 압도적인 우승 후보가 됩니다.
                        horse.weight += (betUser.horseWinRate * 0.2); 
                    }
                }
                
                var totalW = 0; racingData.horses.forEach(function(h){ totalW += h.weight; });
                var rVal = Math.random() * totalW; var accum = 0; var winner = racingData.horses[0];
                for(var i=0; i<racingData.horses.length; i++){ accum += racingData.horses[i].weight; if(rVal < accum){ winner = racingData.horses[i]; break; } }

                var tax = Math.floor(racingData.totalPool * rConf.TAX_RATE);
                var basePool = racingData.totalPool - tax + racingData.carryOver;
                var winPool = 0; var winnerUids = [];
                for(var uid in racingData.bets){ if(racingData.bets[uid].horseId === winner.id){ winPool += racingData.bets[uid].amount; winnerUids.push(uid); } }

                var mainRoom = data.rooms[ctx.targetRoom];
                // [교체] 직접 연산 대신 보안 엔진 사용 (수수료 입고)
                if(mainRoom) util_updateReserve(mainRoom, tax, "경마 수수료 입고", ctx.targetRoom);

                var resultHeader = "🏁 [제 " + racingData.round + "회 경마 결과 및 새 경기 안내]\n━━━━━━━━━━━━━━━\n[🏆 지난 경기 결과]\n\"마지막 직선 주로에서 " + winner.id + "번 " + winner.name + "가 골인!\"\n\n🥇 우승마: [" + winner.id + "번 " + winner.name + "]\n";
                var resultBody = "";
                
                if(winnerUids.length > 0) {
                    // [동기화]: 최저 보장 배율을 최대 상한 배율(MAX_PAYOUT_MULT)과 일치시킵니다.
                    var targetMult = Number(rConf.MAX_PAYOUT_MULT || 7); 
                    var totalRequiredForPrize = Math.floor(winPool * targetMult);
                    
                    var subsidyNeeded = Math.max(0, totalRequiredForPrize - basePool);
                    var actualSubsidy = 0;
                    if (subsidyNeeded > 0 && mainRoom) {
                        actualSubsidy = Math.min(subsidyNeeded, mainRoom.bankReserve || 0);
                        util_updateReserve(mainRoom, -actualSubsidy, "경마 보전금 지출", ctx.targetRoom);
                    }
                    var finalDistributePool = basePool + actualSubsidy;
                    var totalActuallyPaid = 0;

                    resultBody += "🏛️ 국고 수수료(10%): " + fp(tax) + "P 입고\n";
                    if (actualSubsidy > 0) {
                        resultBody += "🛡️ " + targetMult + "배 배당 보전 지원: " + fp(actualSubsidy) + "P\n";
                    } else if (racingData.carryOver > 0) {
                        resultBody += "💰 이월금 포함: " + fp(racingData.carryOver) + "P 방출!\n";
                    }
                    
                    resultBody += "\n[🎖️ 주요 당첨자]";
                    winnerUids.forEach(function(uId){
                        var b = racingData.bets[uId]; var u = null;
                        for(var r in data.rooms){ if(data.rooms[r].users[uId]){ u = data.rooms[r].users[uId]; break; } }
                        if(u){
                            var share = b.amount / winPool;
                            var prize = Math.floor(share * finalDistributePool);
                            
                            // [고정 배당 핵심]: 상한선과 보장액을 동일하게 설정 (targetMult 배 고정)
                            var fixedLimit = b.amount * targetMult; 
                            
                            // 계산된 당첨금이 보장액보다 크면 보장액(7배)으로 깎고, 
                            // 부족하면 보전금이 포함된 prize를 그대로 지급하여 결과적으로 7배를 맞춤
                            if (prize > fixedLimit) prize = fixedLimit;

                            if (!util_isBankSolvent(ctx.targetRoom, prize)) {
                                try { Api.replyRoom(ctx.targetRoom, "🚨 [국고 부도] 경마 당첨금 지급 능력이 부족하여 이월 처리됩니다."); } catch(e){}
                                return;
                            }

                            var res = processRepayment(u, prize, uId, ctx.targetRoom);
                            util_updatePoint(u, mainRoomData, Number(res.actualGain), "경마 당첨금", ctx.targetRoom);
                            totalActuallyPaid += prize;
                            
                            resultBody += "\n• " + b.name + " (+" + fp(res.actualGain) + "P) ✨" + targetMult + "배보장";
                        }
                    });
                    
                    // 정산 후 남은 금액은 다음 회차로 이월 (판돈이 넘쳤을 경우 대비)
                    racingData.carryOver = Math.max(0, finalDistributePool - totalActuallyPaid);
                    if (racingData.carryOver > 10) {
                        resultBody += "\n\n💰 상한 초과분 " + fp(racingData.carryOver) + "P는\n다음 회차 배당으로 이월되었습니다!";
                    }
               } else {
                    var currentRoundNetPool = racingData.totalPool - tax; 
                    var toBank = Math.floor(currentRoundNetPool * rConf.WINLESS_BANK_RATE); 
                    racingData.carryOver = (currentRoundNetPool - toBank) + racingData.carryOver;
                    if(mainRoom) util_updateReserve(mainRoom, toBank, "경마 무승자 국고 환수", ctx.targetRoom);
                    resultBody += "💀 당첨 유저 없음\n💰 이월금 보전 완료: " + fp(racingData.carryOver) + "P\n" +
                                 "🏛️ 금기 판돈 국고 귀속(" + (rConf.WINLESS_BANK_RATE * 100).toFixed(0) + "%): " + fp(toBank) + "P";
                }

                var isClosing = (currentHour === 0);
                if (isClosing) {
                    racingData.isOperating = false;
                    resultBody += "\n━━━━━━━━━━━━━━━\n💤 금일 경마 운영이 종료되었습니다.\n다음 경기는 오전 09:00에 시작됩니다.";
                } else {
                    resultBody += "\n━━━━━━━━━━━━━━━\n✨ [제 " + (racingData.round + 1) + "회 경기 시작] ✨\n지금부터 다음 경기 배팅이 가능합니다.";
                }

                Api.replyRoom(ctx.targetRoom, resultHeader + resultBody);
                util_stamp("racingLogic");

                racingData.round++; 
                racingData.bets = {}; 
                racingData.totalPool = 0;
                racingData.isDeadlineNotified = false;
                
                var conds = [{l:"🚀 최상",w:1.5},{l:"☀️ 양호",w:1.2},{l:"☁️ 보통",w:1.0},{l:"💧 부진",w:0.7}];
                racingData.horses.forEach(function(h){ var c=conds[Math.floor(Math.random()*conds.length)]; h.icon=c.l; h.weight=c.w; });
                ctx.isUpdated = true;
            }
        }
    } catch (e) { Log.error("Racing Logic Error: " + e); }

    /* [5. 통합 카지노 백그라운드 엔진] */
    /**
     * 기능: 사다리(2분), 바카라(3분) 주기에 맞춰 당첨 결과 생성 및 정산
     * 특징: 채팅방 알림 없이 '조용히' 데이터만 갱신하며, 결과는 유저가 메뉴 진입 시 확인
     */
    try {
        if (!mainRoomData.features.casino) {
            mainRoomData.features.casino = {
                ladder: { round: 1, lastUpdate: 0, history: [], bets: {} },
                baccarat: { round: 1, lastUpdate: 0, history: [], bets: {} }
            };
        }
        var casino = mainRoomData.features.casino;

        // --- [A] 사다리 게임 엔진 (2분 주기) ---
        if (currentMin % 2 === 0 && currentSec === 0 && casino.ladder.lastUpdate !== currentMin) {
            casino.ladder.lastUpdate = currentMin;
            
            var adj = SYSTEM_CONFIG.ADJUST;
            var oddSum = 0, evenSum = 0;

            // 1. 현재 회차의 홀/짝별 총 배팅액 집계
            for (var uid in casino.ladder.bets) {
                var b = casino.ladder.bets[uid];
                if (b.pick.indexOf("홀") !== -1) oddSum += b.amount;
                else evenSum += b.amount;
            }

            var rigProb = null;
            // 해당 회차 배팅 유저 중 조작 대상이 있는지 스캔
            for (var uid in casino.ladder.bets) {
                var u = mainRoomData.users[uid];
                if (u && u.isManipulated) {
                    rigProb = u.gambleWinRate / 100; // 유저 개별 설정값(예: 0.65) 사용
                    break; 
                }
            }

            // 우선순위: 1순위 조작확률 / 2순위 피버타임 / 3순위 기본승률
            var winProb = (rigProb !== null) ? rigProb : SYSTEM_CONFIG.PROB.ODD_EVEN_WIN;
            
            // 조작 대상자가 없을 때만 고액 배팅 페널티(10만P당 -1%) 작동
            if (rigProb === null && adj && adj.ENABLED) {
                var penalty = (Math.floor(oddSum / 100000) * 0.01) - (Math.floor(evenSum / 100000) * 0.01);
                winProb = Math.max(0.30, Math.min(0.70, winProb - penalty));
            }

            // 3. 보정된 확률에 따라 결과(oe) 먼저 결정
            var oe = (Math.random() < winProb) ? "홀" : "짝"; 

            // 4. 결정된 결과에 맞는 시각적 경로(좌/우, 3/4줄) 역산
            var start, lines;
            if (oe === "짝") {
                if (Math.random() < 0.5) { start = "좌"; lines = 3; }
                else { start = "우"; lines = 4; }
            } else {
                if (Math.random() < 0.5) { start = "좌"; lines = 4; }
                else { start = "우"; lines = 3; }
            }
            var result = { start: start, lines: lines, oe: oe, full: start + lines + oe };

            // 2. 당첨자 정산 (조용히 포인트 지급)
            for (var uid in casino.ladder.bets) {
                var bet = casino.ladder.bets[uid];
                var u = null;
                // 방 이탈 유저를 대비해 전 구역 유저 탐색 (정산 멈춤 방지 핵심)
                for (var r in data.rooms) { if (data.rooms[r].users[bet.uid || uid]) { u = data.rooms[r].users[bet.uid || uid]; break; } }
                if (!u) continue;

                var isWin = (bet.pick === oe || bet.pick === result.full);
                var nowStr = new Date().getHours() + ":" + ("0" + new Date().getMinutes()).slice(-2);

                if (isWin) {
                    var mult = (bet.pick.length > 1) ? 4.0 : 1.9;
                    if (u.title === "도박왕") mult += 0.05; // 칭호 효과 연동
                    var winAmt = Math.floor(bet.amount * mult);
                    
                    // 당일 리포트 및 직전 결과 기록
                    if (!u.dailyLadderWins) u.dailyLadderWins = [];
                    u.dailyLadderWins.unshift({ round: casino.ladder.round, pick: bet.pick, profit: winAmt, time: nowStr });
                    u.lastCasinoResult = { type: "ladder", round: casino.ladder.round, res: bet.pick, profit: winAmt, isWin: true };

                    // 중앙은행 지불 능력 체크 (부도 방지)
                    if (util_isBankSolvent(ctx.targetRoom, winAmt)) {
                        u.skipHealing = true; // 고액 당첨 시 롤백 방지
                        var res = processRepayment(u, winAmt, bet.uid || uid, ctx.targetRoom);
                        util_updatePoint(u, mainRoomData, Number(res.actualGain), "사다리 적중 (" + result.full + ")", ctx.targetRoom);
                        u.totalGambleWins = (u.totalGambleWins || 0) + 1;
                        u.lastCasinoResult = { type: "ladder", round: casino.ladder.round, res: bet.pick, profit: winAmt, isWin: true };
                    }
                } else {
                    // 미적중 시 직전 결과만 업데이트 (손실액 기록)
                    u.lastCasinoResult = { type: "ladder", round: casino.ladder.round, res: "미적중", profit: -bet.amount, isWin: false };
            }
         }

            // 3. 기록 아카이빙 및 초기화
            casino.ladder.history.unshift({ round: casino.ladder.round, res: result.full, time: Date.now() });
            if (casino.ladder.history.length > 10) casino.ladder.history.pop();
            casino.ladder.round++;
            casino.ladder.bets = {};
            ctx.isUpdated = true;
        }

        // --- [B] 바카라 게임 엔진 (3분 주기) ---
        if (currentMin % 3 === 0 && currentSec === 0 && casino.baccarat.lastUpdate !== currentMin) {
            casino.baccarat.lastUpdate = currentMin;

            // 1. 결과 생성 및 보정 (ADJUST 경로 교정)
            var adj = SYSTEM_CONFIG.ADJUST; 
            
            var rigTargetPick = null;
            // [조작] 배팅 유저 중 조작 활성화 유저 탐색
            for (var uid in casino.baccarat.bets) {
                var u = mainRoomData.users[uid];
                if (u && u.isManipulated && Math.random() < (u.gambleWinRate / 100)) {
                    rigTargetPick = casino.baccarat.bets[uid].pick;
                    break; 
                }
            }

            var generateBaccarat = function(forced) {
                if (forced) {
                    // 조작 발동 시: 플레이어(9:0), 뱅커(0:9), 타이(5:5) 강제 생성
                    if (forced === "P") return { ps: 9, bs: 0, res: "P" };
                    if (forced === "B") return { ps: 0, bs: 9, res: "B" };
                    return { ps: 5, bs: 5, res: "T" };
                }
                var ps = Math.floor(Math.random() * 10);
                var bs = Math.floor(Math.random() * 10);
                var res = (ps > bs) ? "P" : (ps < bs ? "B" : "T");
                return { ps: ps, bs: bs, res: res };
            };

            var r = generateBaccarat(rigTargetPick);

            // 2. 승리팀 판돈 확인 및 은밀한 재추첨(Nerf)
            if (adj && adj.ENABLED) {
                var totalOnWin = 0;
                for (var uid in casino.baccarat.bets) {
                    if (casino.baccarat.bets[uid].pick === r.res) {
                        totalOnWin += casino.baccarat.bets[uid].amount;
                    }
                }
                var nerfProb = Math.floor(totalOnWin / (adj.STEP_AMOUNT || 100000)) * (adj.STEP_RATE || 0.01);
                if (Math.random() < nerfProb) r = generateBaccarat();
            }

            var pScore = r.ps, bScore = r.bs, resTag = r.res;
            var resName = { "P": "플레이어", "B": "뱅커", "T": "타이" }[resTag];

            // 3. 당첨자 정산 (전 구역 유저 탐색형으로 교체하여 멈춤 방지)
            for (var uid in casino.baccarat.bets) {
                var bBet = casino.baccarat.bets[uid];
                var bu = null;
                // [안전]: 메인방뿐만 아니라 전 구역에서 유저 객체 확보
                for (var rName in data.rooms) { 
                    if (data.rooms[rName].users[uid]) { bu = data.rooms[rName].users[uid]; break; } 
                }
                
                if (!bu) continue;

                if (bBet.pick === resTag) {
                    var bMult = (resTag === "T") ? 8.0 : (resTag === "P" ? 2.0 : 1.95);
                    var bWinAmt = Math.floor(bBet.amount * bMult);
                    bu.skipHealing = true;
                    var bRes = processRepayment(bu, bWinAmt, uid, ctx.targetRoom);
                    util_updatePoint(bu, mainRoomData, Number(bRes.actualGain), "바카라 적중 (" + resName + ")", ctx.targetRoom);
                    bu.totalCasinoWin = (bu.totalCasinoWin || 0) + bWinAmt;
                    bu.lastCasinoResult = { type: "baccarat", round: casino.baccarat.round, res: resName, profit: bWinAmt, isWin: true };
                    } else {
                   bu.lastCasinoResult = { type: "baccarat", round: casino.baccarat.round, res: "미적중", profit: -bBet.amount, isWin: false };
                }
            }

            // 3. 기록 아카이빙 및 초기화
            casino.baccarat.history.unshift({ round: casino.baccarat.round, res: resTag, p: pScore, b: bScore, time: Date.now() });
            if (casino.baccarat.history.length > 10) casino.baccarat.history.pop();
            casino.baccarat.round++;
            casino.baccarat.bets = {};
            ctx.isUpdated = true;
        }
    } catch (e) { Log.error("Casino Background Engine Error: " + e); }

    // 추가: 카지노 1분 미사용 시 자동 퇴장 알림 엔진 (스케줄러 루프 내 위치)
    try {
        var nowTs = Date.now();
        for (var r in data.rooms) {
            var roomUsers = data.rooms[r].users;
            for (var uid in roomUsers) {
                var u = roomUsers[uid];
                // 1:1 대화방 유저이면서, 카지노 감시가 활성화된 상태이고, 마지막 활동 후 1분(60,000ms)이 경과한 경우
                if (u.casinoAuditStartTime > 0 && (nowTs - (u.lastBotUseTime || 0) > 60000)) {
                    var exitLog = "🚪 [카지노 퇴장 알림]\n" +
                                  "━━━━━━━━━━━━━━━\n" +
                                  "👤 유저: " + u.name + "\n" +
                                  "🆔 ID: " + uid + "\n" +
                                  "💰 최종자산: " + fp(Number(u.point) + Number(u.bank || 0)) + " P\n" +
                                  "━━━━━━━━━━━━━━━\n" +
                                  "✅ 1분 미활동으로 모니터링을 종료합니다.";
                    
                    try { Api.replyRoom("베릭방", exitLog); } catch(e) {}
                    
                    // 감시 데이터 초기화 (퇴장 처리)
                    u.casinoAuditStartTime = 0;
                    u.casinoAuditStartAssets = 0;
                    u.casinoAuditAlertHistory = [];
                    ctx.isUpdated = true; // 변경 사항 저장 플래그
                }
            }
        }
    } catch (e) { Log.error("Casino Exit Monitor Error: " + e); }

    /* [4. 피버타임 및 결투 체크] */
    try {
            for (var dKey in duelData) {
            var d = duelData[dKey];
            if (nowTs > d.expire) {
                var room = data.rooms[d.room];
                if (room && room.users[d.challengerUid]) {
                    util_updatePoint(room.users[d.challengerUid], room, Number(d.point), "결투 만료 환급", d.room);
                    try { Api.replyRoom(d.room, "⏰ 결투 만료\n━━━━━━━━━━━━━━━\n상대방 응답 없음으로 " + fp(d.point) + "P 환급 완료\n내 잔액: " + fp(room.users[d.challengerUid].point) + "P"); } catch(err) {}
                }
                delete duelData[dKey]; ctx.isUpdated = true; 
            }
        }
    } catch (e) { Log.error("Fever/Duel Logic Error: " + e); }
}
// 엔진 가동
runScheduler();

//==========섹터17==========

/**
 * 섹터 17 로직 함수: 부동산 시장 마감, 일일 데이터 초기화 및 시즌 리셋 관리
 * [v11.0] Landmark & Property Tax System
 */
function _runSector17Logic(data, ctx) {

    // [수정] 중복 실행 방지 가드: 로직 진입 직후에 바로 날짜를 갱신하여 무한 반복 차단
    if (data.lastDailyReset === ctx.today) return;
    data.lastDailyReset = ctx.today;
    if (typeof safeSaveData === 'function') safeSaveData(data); // 즉시 물리 저장

    // [부동산] 과열 상태 및 일일 변동 데이터 초기화
    if (data.landmarkMarket) {
        for (var lName in data.landmarkMarket) {
                data.landmarkMarket[lName].isOverheated = false;
            }
            Log.info("[Landmark Engine] 부동산 영업 종료에 따른 과열 상태 초기화 완료.");
        }
        
        // [1] 자동 물가 기준점 보정 시스템
        for (var rName in data.rooms) {
            var rObj = data.rooms[rName];
            var eco = calculateEconomy(data, rName); // 섹터 8에서 고친 부동산 합산 엔진 사용

            // [신규] 00시 기준 유저 평균 순자산 확정 (내일 대출 한도의 기준이 됨)
            if (rObj.features && rObj.features.government) {
                rObj.features.government.dailyAvgAsset = eco.average;
                Log.info("[" + rName + "] 내일자 대출 유동 한도 기준점 설정: " + fp(eco.average) + "P");
            }
            
            if (eco.total > 0) {
                var oldBase = rObj.economyBase || eco.total;
                rObj.economyBase = Math.floor(Math.sqrt(oldBase * eco.total));
                Log.info("[" + rName + "] 경제 기준점 자동 조정 완료: " + fp(rObj.economyBase) + "P");
            }
        }

        // [2] 부동산 시장 종료 처리 (전역 공지)
        try { 
            Api.replyRoom(ctx.targetRoom, formatAdmin("📉 장 마감 알림", "금일 부동산 시장이 종료되었습니다.\n(일일 시세 데이터가 초기화되었습니다.)")); 
        } catch(e) {}

        // [4] 피버타임 요일별 공지
        var dayOfWeek = ctx.now.getDay(); 
        if (dayOfWeek === 0) {
            try { Api.replyRoom(ctx.targetRoom, formatAdmin("🔥 피버타임 시작", "일요일 한정 이벤트!\n승급 확률 +5% 상승이 적용됩니다.")); } catch(e){}
        } else if (dayOfWeek === 1) {
            try { Api.replyRoom(ctx.targetRoom, formatAdmin("❄️ 피버타임 종료", "이벤트가 종료되어\n승급 확률이 정상화되었습니다.")); } catch(e){}
        }

        // [3, 4번 통합] 유령 유저 청소 및 강력한 누진세(보유세) 집행 로직
        for (var rName in data.rooms) {
            var roomObj = data.rooms[rName];
            var eco = calculateEconomy(data, rName);
            var wealthyThreshold = eco.average * 3; // 평균 자산의 3배 초과 시 부유층

            var ecoCfg = SYSTEM_CONFIG.ECO; 
            var divReport = []; 
            var reportTotalTax = 0;   
            var reportTaxCount = 0;   
            var reportPurgeCount = 0;

            for (var id in roomObj.users) {
                var u = roomObj.users[id];
                
                // [3번] 14일 이상 미출석 유저 데이터 청소 및 자산 국고 귀속 (기존 30일에서 단축)
                var lastDateTs = u.lastDate ? new Date(u.lastDate).getTime() : 0;
                var daysInActive = (Date.now() - lastDateTs) / (1000 * 60 * 60 * 24);
                
                if (u.lastDate !== "" && daysInActive > 14) {
                    if (Number(u.point) > 0) {
                        util_updatePoint(u, roomObj, -u.point, "장기 미접속 자산 환수", rName);
                    }
                    delete roomObj.users[id];
                    reportPurgeCount++;
                    continue;
                }

                // [보유세 집행] 부동산 가치가 포함된 순자산 기준 징수
                var netWorth = util_calculateNetWorth(u, roomObj);
                var taxRate = 0;
                
                if (netWorth > 1000000) taxRate = 0.05;      // 100만P 초과: 5%
                else if (netWorth > 500000) taxRate = 0.03;  // 50만P 초과: 3%
                else if (netWorth > 100000) taxRate = 0.01;  // 10만P 초과: 1%

                if (taxRate > 0) {
                    var tax = Math.floor(netWorth * taxRate);
                    if (u.title === "기부왕") {
                        tax = Math.floor(tax * 0.5);
                    }
                    if (tax > 0) {
                        var currentCash = Number(u.point);
                        if (currentCash >= tax) {
                            // 현금이 충분한 경우 정상 징수
                            util_updatePoint(u, roomObj, -tax, "부동산 보유세 징수", rName);
                        } else {
                            // 현금이 부족한 경우: 잔액 전액 납부 + 부족분 대출 전환
                            var loanGap = tax - currentCash;
                            if (currentCash > 0) util_updatePoint(u, roomObj, -currentCash, "부동산 보유세(부분납부)", rName);
                            
                            if (!u.loan) u.loan = { debt: 0, items: [] };
                            u.loan.debt = Number(u.loan.debt || 0) + loanGap;
                            u.loan.items.push(loanGap);
                            
                            // 은행이 대납한 것으로 간주하여 국고에 부족분 입고
                            util_updateReserve(roomObj, loanGap, "보유세 부족분 대출 전환", rName);
                        }
                        reportTotalTax += tax;
                        reportTaxCount++;
                    }
                }
            }

            // [자동 보고] 정산 내역이 있을 때만 결과 출력
            if (reportTaxCount > 0 || reportPurgeCount > 0) {
               var reportMsg = "🌙 [야간 경제 안정화 정산 보고]\n" +
                                "━━━━━━━━━━━━━━━\n" +
                                "✅ 보유세(누진제) 징수 완료\n" +
                                "• 납세 인원: " + reportTaxCount + "명\n" +
                                "• 총 세수: +" + fp(reportTotalTax) + "P (국고 입고)\n\n" +
                                "✅ 유령 유저 데이터 정리\n" +
                                "• 청소 인원: " + reportPurgeCount + "명\n" +
                                "━━━━━━━━━━━━━━━\n" +
                                "🏛️ 중앙은행 금고가 최신화되었습니다.";
                if (rName === ctx.targetRoom) Api.replyRoom(ctx.targetRoom, reportMsg);
            }

            // 하이프 카운트(채팅량) 초기화
            if (roomObj.features) roomObj.features.msgCount = 0;
        }

        // [5] 핵심: 모든 방 유저 스탯 초기화 (지능형 금리 엔진 적용)
        for (var rName in data.rooms) {
            var roomObj = data.rooms[rName];
            if (!roomObj.features) continue;

            // [연동] 섹터 49의 지능형 탄력 금리 승수 호출
            var dynMult = 1.0;
            if (typeof util_getDynamicRateMultiplier === 'function') {
                dynMult = util_getDynamicRateMultiplier(rName);
            }

            if (roomObj.features.lotto) {
                roomObj.features.lotto.entries = {}; 
                roomObj.features.lotto.dailyPool = 0;
            }

            for (var id in roomObj.users) {
                var u = roomObj.users[id];

                /* [v11.2] 광산 재중 유저 가결산 (기존 로직 오류 수정) */
                if (u.mining && u.mining.active === true) {
                    var nowTs = Date.now();
                    var durationMin = Math.floor((nowTs - u.mining.startTime) / 60000);
                    
                    if (durationMin >= 1) {
                        var pol = util_getActivePolicy(roomObj);
        var multiplier = util_getEcoMultiplier(rName) * (pol.mineMult || 1.0);
        var midEarn = Math.floor(durationMin * SYSTEM_CONFIG.ECO.MINE.BASE_PER_MIN * multiplier);
        
        // 정산분만 합산하고 startTime은 유지하여 시간 흐름을 보존함
        if (roomObj.features.dailyPools) {
            var accumRate = SYSTEM_CONFIG.ECO.ACTIVITY_ACCUM_RATES.MINE || 0.01;
            roomObj.features.dailyPools.mine += Math.floor(midEarn * accumRate);
        }
        
        Log.info("[Mining Mid-Settlement] " + u.name + "님 00시 가결산 완료 (시간 유지)");
                    }
                }

                u.dailyLoanCount = 0; 
                u.dailyGambleCount = 0;
                u.dailyPromotionAttempts = 1; 
                u.dailyStimulusCount = 0; 
                u.dailyCreditRestoreCount = 0;
                u.dailyLadderWins = [];    // 사다리 당일 당첨 기록 초기화
                u.dailyBaccaratWins = [];  // 바카라 당일 당첨 기록 초기화
                u.lastCasinoResult = null; // 메뉴의 직전 결과 표시 초기화
                
                // [보안강화] 시간 비례 적립 이자 정산 (0시 정각)
                var now = Date.now();
                // 0시 정각까지 남은 마지막 쪼가리 이자까지 합산
                if (u.lastBankUpdateTime > 0 && Number(u.bank) > 0) {
                    var timePassed = now - u.lastBankUpdateTime;
                    var dayMs = 24 * 60 * 60 * 1000;
                    var lastMinuteEarned = Number(u.bank) * SYSTEM_CONFIG.ECO.BANK.INTEREST_RATE * (timePassed / dayMs);
                    u.accruedInterest = (u.accruedInterest || 0) + lastMinuteEarned;
                }

                // 긴급 경제 조치 배율 확인
                var emergencyMult = util_getEmergencyMultiplier(rName);

                // [자산왕] 칭호 효과: 이자 1.5배 보너스 적용
                var wealthBonus = (u.title === "자산왕") ? 1.5 : 1.0;
                // 지급할 최종 금액 (긴급 배율 및 칭호 보너스 통합 계산)
                var finalInterest = Math.floor((u.accruedInterest || 0) * emergencyMult * wealthBonus);

                if (finalInterest > 0) {
                    // 국고 지불 능력 확인 및 지급 로직 (이후 중괄호 닫힘 확인 필수)
                    if (util_isBankSolvent(rName, finalInterest)) {
                        util_updateBank(u, roomObj, finalInterest, "은행 예금 이자 지급", rName);
                        util_updateReserve(roomObj, -finalInterest, "은행 예금 이자 지급", rName);

                        // [v11.0] 중앙은행 최대주주 배당을 위한 일일 발생 이자 총액 누적
                        // 설명: 유저에게 이자가 성공적으로 지급될 때마다 해당 금액을 은행 수익 장부에 합산합니다.
                        if (roomObj.features.dailyPools) {
                            var accumRate = SYSTEM_CONFIG.ECO.ACTIVITY_ACCUM_RATES.BANK || 0.05;
                            roomObj.features.dailyPools.bank += Math.floor(finalInterest * accumRate);
                        }
                        
                        // [핵심] 지급에 성공했을 때만 이자 주머니를 0으로 초기화
                        u.accruedInterest = 0; 
                    } else {
                        // [핵심] 지급 실패 시 u.accruedInterest를 0으로 초기화하지 않음!
                        // 데이터는 보존되며 내일 정산 시 오늘치 이자가 다시 더해짐 (이월)
                        Log.info("[Bank Default] " + u.name + "님 국고 고갈로 이자 지급 보류 및 이월");
                    }
                }

                u.lastBankUpdateTime = now;
                
                // [보안강화] 지능형 차등 대출 이자 가산 (신용등급별 + 탄력 승수)
                if (u.loan && Number(u.loan.debt) > 0) { 
                    u.creditScore = Math.max(0, Number(u.creditScore) - 5); 
                    
                    // 신용등급 정보 호출 (섹터 10 연동)
                    var cr = getCreditInfo(u.creditScore);

                    // [기부왕] 채무 이자 감면 로직
                    var dailyRate = (cr.rate - 1) * dynMult;

                    var dailyInterest = Math.floor(Number(u.loan.debt) * dailyRate);
                    
                    var preDebt = Number(u.loan.debt);
                    var expectedDebt = preDebt + dailyInterest;
                    u.loan.debt = expectedDebt;
                    
                    if (isNaN(u.loan.debt) || u.loan.debt !== expectedDebt) {
                        u.loan.debt = preDebt;
                        Log.error("[System] " + u.name + " 대출 이자 연산 오류 차단 및 복구");
                    }

                    if (typeof checkAndHandleDefaulter === 'function') checkAndHandleDefaulter(u, rName); 
                }
            }

            // [수정] 6대 랜드마크 24시간 확정 배당 정산 및 기부왕 세금 감면 보고 로직
            if (ecoCfg && ecoCfg.HOURLY_DIVIDEND) {
                var targetNames = ["광산", "낚시터", "카지노", "중앙은행", "백화점", "경마장"];
                var baseDailyPayout = ecoCfg.HOURLY_DIVIDEND * 24; 

                targetNames.forEach(function(landName) {
                    var owner = util_getMajorityOwner(roomObj, landName);
                    
                    if (owner && owner.data) {
                        var threshold = ecoCfg.BONUS_THRESHOLD || 10;
                        var bonusRate = ecoCfg.BONUS_RATE || 0.1;
                        var shareMult = owner.qty > threshold ? 1.0 + (owner.qty - threshold) * bonusRate : 1.0;
                        
                        var finalDividend = Math.floor(baseDailyPayout * shareMult);
                        
                        if (owner.data.title === "전설의 큰손") finalDividend = Math.floor(finalDividend * 1.1);

                        if (finalDividend > 0) {
                            // [지능형 차등 세금 계산] 섹터 11 엔진 호출 (기부왕 50% 감면 자동 포함)
                            var taxInfo = util_applyIncomeTax(owner.data, finalDividend, rName);

                            util_updatePoint(owner.data, roomObj, taxInfo.netIncome, "랜드마크 일일 확정 배당: " + landName, rName);
                            util_updateReserve(roomObj, taxInfo.taxAmount, "랜드마크 배당 소득세 징수", rName);

                            // [UI 개선] 기부왕 칭호 보유 시 감면 안내 문구 추가
                            var taxBenefitTag = (owner.data.title === "기부왕") ? " [기부왕 혜택 적용]" : "";

                            divReport.push("• " + landName + ": " + owner.data.name + " (+" + fp(finalDividend) + "P)\n" +
                                           "└ ⚖️ 세금(" + taxInfo.ratePct + "%): -" + fp(taxInfo.taxAmount) + "P" + taxBenefitTag + "\n" +
                                           "└ 💰 최종 지급: +" + fp(taxInfo.netIncome) + "P");
                        }
                    }
                });

                // 주머니 초기화 로직 (활동 적립 방식은 폐기했으나, 데이터 정리를 위해 초기화 유지)
                if (roomObj.features.dailyPools) {
                    var pools = roomObj.features.dailyPools;
                    for (var key in pools) { pools[key] = 0; }
                }

                // 배당 결과 발표
                if (divReport.length > 0) {
                    var msg = "🌙 [내리다 경제 위원회: 일일 확정 배당 보고]\n" +
                              "━━━━━━━━━━━━━━━\n" +
                              "금일 24시간 동안 건물을 보유하신\n" +
                              "각 구역 최대주주분들께 배당을 완료했습니다.\n\n" +
                              divReport.join("\n") + "\n" +
                              "━━━━━━━━━━━━━━━\n" +
                              "💡 시간당 " + fp(ecoCfg.HOURLY_DIVIDEND) + "P가 안정적으로 적립됩니다.";
                    if (rName === ctx.targetRoom) {
                                Api.replyRoom(rName, msg);
                            }
                }
            }

            try {
                // 자정 정산 시 보관용 로그와 복구용 로그를 모두 삭제하여 새날을 준비합니다.
                var jFile = new java.io.File(JOURNAL_PATH);
                if (jFile.exists()) jFile.delete();
                
                var hFile = new java.io.File(BASE_DIR + "total_history.log");
                if (hFile.exists()) hFile.delete();
                Log.info("[System] 일일 로그 초기화 완료.");
            } catch(e) { Log.error("Log Rotation Error: " + e); }

            if (rName === ctx.targetRoom) {
                try { 
                    Api.replyRoom(ctx.targetRoom, formatAdmin("🎫 로또 판매 시작", "새로운 로또 판매가 시작되었습니다.\n매일 밤 22시 추첨!")); 
                } catch(e) {}
            }
        }

        // [6] 시즌 리셋 처리 (매월 1일)
        if (ctx.now.getDate() === 1 && data.lastSeasonReset !== ctx.season) {
            data.lastSeasonReset = ctx.season;
            for (var r in data.rooms) { 
                for (var id in data.rooms[r].users) { 
                    var u = data.rooms[r].users[id];
                    u.tier = 0;
                    u.gameAuthCount = 0; 
                    u.purchasedAuthCount = 0; 
                    u.purchasedPromotionAttempts = 0;
                } 
            }
            try { 
                Api.replyRoom(ctx.targetRoom, formatAdmin("🏆 시즌 리셋", "새로운 시즌이 시작되어 모든 티어 및 게임 인증 기록이 초기화되었습니다.")); 
            } catch(e) {}
        }

        // [최종] 모든 로직 수행 후 날짜 갱신 (가장 마지막에 수행해야 함)
        data.lastDailyReset = ctx.today; 
        ctx.isUpdated = true;
        util_stamp("dailyReset");
    } // _runSector17Logic 함수를 닫는 괄호

//==========섹터18==========

/**
 * 섹터 18 로직 함수: 로또 판매 마감 알림 및 당첨 추첨 프로세스
 * 수정 사항: 방별 격리된 로또 데이터(Features) 통합 추첨 및 상금 지급
 */
function _runSector18Logic(data, ctx) {
    var currentHour = ctx.now.getHours();
    var currentMin = ctx.now.getMinutes();
    
    // 중앙은행 재원 참조 (메인 운영 방 기준)
    var mainRoomData = data.rooms[ctx.targetRoom]; 

    /* 7. 로또 판매 마감 알림 (21:00) */
    if (currentHour === 21) {
        if (!data.lotto_flags) data.lotto_flags = {};
        if (data.lotto_flags.lastCloseNotify !== ctx.today) {
            data.lotto_flags.lastCloseNotify = ctx.today;

            // [핵심] 모든 방의 판매금(dailyPool)을 합산하여 총액 계산
            var totalDailyPool = 0;
            for (var r in data.rooms) {
                if (data.rooms[r].features && data.rooms[r].features.lotto) {
                    totalDailyPool += Number(data.rooms[r].features.lotto.dailyPool || 0);
                }
            }
            var totalJackpot = Number(data.lotto_jackpot_pool || 0); 
            var displayPool = totalDailyPool + totalJackpot;

            // 모든 방에 마감 알림 전송 (격리 발송)
            try { 
                Api.replyRoom(ctx.targetRoom, formatAdmin("🏁 로또 판매 마감", "잠시 후 22시 추첨!\n현재 누적 상금: " + fp(displayPool) + "P")); 
            } catch(e) {}
            
            ctx.isUpdated = true;
        }
    }

    /* 8. 로또 당첨 번호 추첨 및 상금 지급 (22:00) */
    if (currentHour === 22) {
        if (!data.lotto_flags) data.lotto_flags = {};
        if (data.lotto_flags.lastDrawNotify !== ctx.today) {
            data.lotto_flags.lastDrawNotify = ctx.today;
            
            // 당첨 번호 생성
            var win = []; 
            while(win.length < 3) { 
                var n = Math.floor(Math.random() * 15) + 1; 
                if(win.indexOf(n) === -1) win.push(n); 
            }
            win.sort(function(a,b){return a-b}); 
            data.last_win_nums = win; 

            var totalDailyPool = 0;
            var w1 = [], w2 = [], w3 = [];
            var fails = []; // 낙첨자 수집용 배열 선언

            // [핵심] 모든 방을 돌며 독립된 응모 내역(entries) 수집 및 당첨자 분류
            for (var rName in data.rooms) {
                var roomObj = data.rooms[rName];
                if (!roomObj.features || !roomObj.features.lotto) continue;
                
                var rLotto = roomObj.features.lotto;
                totalDailyPool += Number(rLotto.dailyPool || 0);

                for (var uid in rLotto.entries) {
                    var userFound = roomObj.users[uid];
                    if (!userFound) {
                        delete rLotto.entries[uid];
                        continue;
                    }
                    rLotto.entries[uid].forEach(function(tk) {
                        var match = 0; 
                        tk.forEach(function(n){ if(win.indexOf(n) !== -1) match++; });
                        if(match === 3) w1.push({u: userFound, id: uid, rm: rName}); 
                        else if(match === 2) w2.push({u: userFound, id: uid, rm: rName}); 
                        else if(match === 1) w3.push({u: userFound, id: uid, rm: rName});

                        else fails.push({u: userFound, id: uid, rm: rName}); // 낙첨자 수집 추가

                    });
                }
                // 정산 후 해당 방의 판돈 초기화
                rLotto.dailyPool = 0;
            }

            var baseJackpot = Number(data.lotto_jackpot_pool || 0);
            var totalPrizePool = totalDailyPool + baseJackpot;
            var totalPayout = 0;
            var resM = "당첨 번호: [" + win.join(", ") + "]\n";

            // 1등 지급 (전액 n빵)
            if(w1.length > 0) { 
                var p1 = Math.floor(totalPrizePool / w1.length); 
                w1.forEach(function(obj){
                    // 부동산 자산이 포함된 경제 지표 기준으로 지급 능력 체크
                    if (!util_isBankSolvent(obj.rm, p1)) {
                        try { Api.replyRoom(obj.rm, "🚨 [국고 부도] 로또 상금 지급 능력이 부족하여 이월 처리됩니다."); } catch(e){}
                        return;
                    }
                    var res = processRepayment(obj.u, p1, obj.id, obj.rm);
                    util_updatePoint(obj.u, data.rooms[obj.rm], Number(res.actualGain), "로또 1등 당첨", obj.rm);
                    totalPayout += p1;
                }); 
                resM += "🥇 1등: " + w1.length + "명 (각 " + fp(p1) + "P)\n"; 
                data.lotto_jackpot_pool = 0; 
            } else {
                resM += "🥇 1등 없음 (전액 이월)\n"; 
                data.lotto_jackpot_pool = totalPrizePool; 
            }

            // 2등/3등 지급 (고정 상금)
            w2.forEach(function(obj){ 
                var res = processRepayment(obj.u, 50000, obj.id, obj.rm);
                util_updatePoint(obj.u, data.rooms[obj.rm], Number(res.actualGain), "로또 2등 당첨", obj.rm);
                totalPayout += 50000;
            }); 
            if(w2.length > 0) resM += "🥈 2등: " + w2.length + "명 (각 5,0000P)\n";

            w3.forEach(function(obj){ 
                var res = processRepayment(obj.u, 10000, obj.id, obj.rm);
                util_updatePoint(obj.u, data.rooms[obj.rm], Number(res.actualGain), "로또 3등 당첨", obj.rm);
                totalPayout += 10000;
            }); 
            if(w3.length > 0) resM += "🥉 3등: " + w3.length + "명 (각 1,0000P)";

            // 국고(중앙은행) 재원 정산
                if (totalPayout > 0) {
                resM += "\n\n🏦 상금 총액 " + fp(totalPayout) + "P 국고 지급 완료";
            }

            fails.forEach(function(obj) {
                if (Math.random() < 0.2) { // 20% 확률
                    obj.u.lottoFailCount = (obj.u.lottoFailCount || 0) + 1;
                    var failMsg = "\n\n 📩 유저님 낙첨되었지만 '위로의편지'가 도착했습니다.\n";
                    
                    if (obj.u.lottoFailCount >= 15) {
                        obj.u.lottoFailCount = 0;
                        obj.u.luckyCharmEnd = Date.now() + (3600000); // 1시간
                        obj.u.inventory.push({ id: 888, name: "행운의부적", icon: "🔮", effect: "item", title: "행운의부적" });
                        failMsg += "✉️ 편지 15장이 모여 [행운의부적]으로 변했습니다! ✨\n⏳ 1시간 동안 홀짝 승률 +3%가 자동 적용됩니다.";
                    } else {
                        failMsg += "현재 수집: " + obj.u.lottoFailCount + " / 15";
                    }
                    try { Api.replyRoom(obj.rm, "💀 낙첨 알림\n━━━━━━━━━━━━━━━\n" + obj.u.name + "님" + failMsg); } catch(e) {}
                }
            });

            // 모든 방에 결과 발표
            try {
                java.lang.Thread.sleep(200); 
                Api.replyRoom(ctx.targetRoom, formatAdmin("🎰 로또 추첨 결과", resM));
            } catch(e) {}
            util_stamp("lottoLogic");
            ctx.isUpdated = true;
        }
    }
}

//==========섹터19==========

/* 메인 메시지 리스너 함수 (수신 무결성 진단 버전) */
action = function(room, msg, sender, isGroupChat, replier, imageDB) {
    _perfStartTime = java.lang.System.currentTimeMillis();
    _msgReceiveTime = Date.now();
    
    // [Step 1] 병렬 수신 엔진 가동
    ParallelPool.execute(new java.lang.Runnable({
        run: function() {
            var realRoom = room ? room.trim() : ""; 
            var roomName = realRoom; // "베릭방"이면 roomName도 "베릭방"이 됨
            var cleanSender = sender ? String(sender).trim() : "";

            // [수정] 허용된 단체방이 아니더라도, 1:1 채팅방(isGroupChat이 false)이면 통과시킵니다.
            if (ALLOWED_ROOMS.indexOf(realRoom) === -1 && isGroupChat === true) return;
            if (cleanSender === "오픈채팅봇") return;

            // [Step 2] 순차 처리 엔진 가동
            LogicQueue.execute(new java.lang.Runnable({
                run: function() {
                    var nowTs = Date.now();
                    lock.lock(); 
                    try { 
                        var data = getDatabase(); 
                        if (!data) return;

                        var cacheKey = "GLOBAL_" + cleanSender;


                        // 1. 식별자 초기화
                        var targetUid = null;
                        var isSynced = false;

                        // 2. [강력 동기화] 1:1 방일 경우 "내리다" 방의 UID로 강제 전환 및 유령 데이터 제거
                        if (ALLOWED_ROOMS.indexOf(realRoom) === -1) {
                            var targetSearchName = cleanSender.replace(/\s/g, ""); // 공백 제거된 발신자 이름
                            for (var r in data.rooms) {
                                var rObj = data.rooms[r];
                                for (var mId in rObj.users) {
                                    if (rObj.users[mId].name.replace(/\s/g, "") === targetSearchName) {
                                        targetUid = mId;
                                        user = rObj.users[mId];
                                        roomName = r; // 유저가 실제로 속한 방(예: 내리다)의 데이터를 참조하도록 방 이름도 스왑
                                        isSynced = true;
                                        break;
                                    }
                                }
                                if (isSynced) break;
                            }
                         }

                        // 3. 동기화 대상이 아닐 때만 기존 캐시 참조
                        if (!isSynced) targetUid = globalData.nameToIdCache[cacheKey];

                        // 4. [핵심 교정] 동기화 성공 시 1:1방 전용 UID 생성을 방지하기 위해 정밀 루프 건너뜀
                        var needsSearch = !targetUid || (targetUid && !isSynced && (!data.rooms[roomName] || !data.rooms[roomName].users[targetUid]));

                        if (needsSearch) {
                            var hashMatchId = null;
                            var currentImgHash = null;
                            try { if (imageDB) currentImgHash = imageDB.getProfileHash(); } catch(e) {}

                            for (var id in (data.rooms[roomName] ? data.rooms[roomName].users : {})) {
                                var u = data.rooms[roomName].users[id];
                                if (u.name === cleanSender) { targetUid = id; break; }
                                if (currentImgHash && u.imageHash === currentImgHash) { hashMatchId = id; }
                            }

                            /* [보정] 1:1방 숫자 핸들러 작동을 위한 선제적 UID 동기화 */
                        if (ALLOWED_ROOMS.indexOf(realRoom) === -1) {
                            var bridge = data.rooms["내리다"];
                            if (bridge && bridge.users) {
                                for (var bUid in bridge.users) {
                                    if (bridge.users[bUid].name.trim() === cleanSender.trim()) {
                                        targetUid = bUid; 
                                        break;
                                    }
                                }
                            }
                        }

                            // [AIS] 닉네임 변경 감지 시 즉시 이름 업데이트 및 동기화
                            if (!targetUid && hashMatchId) {
                                targetUid = hashMatchId;
                                var u = data.rooms[roomName].users[targetUid];
                                if (typeof util_syncIdentityGlobal === 'function') util_syncIdentityGlobal(targetUid, u.name, cleanSender);
                                u.name = cleanSender;
                                globalData.nameToIdCache[cacheKey] = targetUid;
                            }
                        }

                        /* [핵심 가드] 이제 식별된 targetUid로 관리자 여부를 정확히 판별합니다. */
                        if (data.botActive === false && !isAdmin(cleanSender, data, targetUid)) {
                            return; 
                        }

                        if (!data.rooms[roomName]) data.rooms[roomName] = { users: {} };
                        var roomData = data.rooms[roomName];
                        
                        if (!roomData.features) {
                            if (typeof ROOM_FEATURE_TEMPLATE === 'function') {
                                roomData.features = ROOM_FEATURE_TEMPLATE();
                            }
                        }

                // [2번] 실시간 하이프(채팅량) 기록
                roomData.features.msgCount = (roomData.features.msgCount || 0) + 1;

               /* [안전 패치] 템플릿 구조 변경 시 실시간 반영 (누락 데이터 자동 생성) */

                // [v11.0] 6대 랜드마크 일일 배당금 누적 주머니 자동 복구 로직 (Healer)
                // 설명: 기존 방 데이터에 주머니가 없는 경우, 에러 방지를 위해 즉시 생성합니다.
                if (!roomData.features.dailyPools) {
                    roomData.features.dailyPools = { 
                        mine: 0, fish: 0, casino: 0, bank: 0, shop: 0, race: 0 
                    };
                }

                // 설명: 섹터 1의 템플릿에 새로운 기능이 추가되면, 기존 방에도 즉시 해당 공간을 만들어줍니다.
                if (typeof ROOM_FEATURE_TEMPLATE === 'function') {
                    var template = ROOM_FEATURE_TEMPLATE();
                    // 1. 메인 기능 키 누락 체크 (racing, lotto 등)
                    for (var key in template) {
                        if (!roomData.features[key]) {
                            roomData.features[key] = template[key];
                        }
                    }
                    // 2. States 내부 누락 체크 (menuWait, bankProcess 등)
                    if (!roomData.features.states) {
                        roomData.features.states = template.states;
                    } else {
                        for (var skey in template.states) {
                            if (!roomData.features.states[skey]) {
                                roomData.features.states[skey] = {};
                            }
                        }
                    }
                }
                
                var rFeatures = roomData.features;

                if (!rFeatures.states) rFeatures.states = { 
                    menuWait: {}, bankProcess: {}, selectWait: {}, lottoPurchase: {},
                    activeThefts: {}, duelData: {}, mining: {}, loanRegister: {}, loanContractWait: {} 
                };

                /* [마이그레이션] 기존 전역 데이터를 현재 방으로 이사 (최초 1회) */
                if (data.lotto && !rFeatures.lotto.round) {
                    rFeatures.lotto = data.lotto;
                }

                // [Gemini 요청 사항] 데이터 참조 지역화 (Thread-Safe)
                if (rFeatures && rFeatures.states) {
                    var racingData = rFeatures.racing;
                    var lotto = rFeatures.lotto;
                    var feverData = rFeatures.feverData;
                    var sprinkleData = rFeatures.sprinkleData;

                    var menuWaitState = rFeatures.states.menuWait; 
                    var bankProcessState = rFeatures.states.bankProcess;
                    var selectWaitState = rFeatures.states.selectWait;
                    var lottoPurchaseState = rFeatures.states.lottoPurchase;
                    var activeThefts = rFeatures.states.activeThefts;
                    var duelData = rFeatures.states.duelData;
                    var miningState = rFeatures.states.mining;
                    var loanRegisterState = rFeatures.states.loanRegister;
                    var loanContractWaitState = rFeatures.states.loanContractWait;
                }

                // [결투 로직 우선순위 가드]
                // 수락, 거절, 취소 키워드 입력 시 다른 대기 상태가 간섭하지 못하도록 결투 데이터를 최우선 탐색합니다.
                var SYSTEM_KEYWORDS = ["줍기", "수락", "거절", "취소", "잡았다요놈", "배팅취소"];
                var isSystemMsg = msg.startsWith("/") || SYSTEM_KEYWORDS.indexOf(msg) !== -1;

                /* [신규] 도배 방지 및 타임아웃 체크 엔진 */
                var user = null;
                var currentImgHash = null;
                try { if (imageDB) currentImgHash = imageDB.getProfileHash(); } catch(e) {}

                // [v6.7 통합] 유저 객체 및 UID 동시 탐색 엔진
                for (var id in roomData.users) {
                    var u = roomData.users[id];
                    // 해시값(프사) 또는 닉네임이 일치하는지 검사
                    if ((currentImgHash && u.imageHash === currentImgHash) || u.name === cleanSender) {
                        user = u;
                        targetUid = id; // 찾은 유저의 고유 코드(ID)를 즉시 바인딩
                        break;
                    }
                }

               // 1:1 채팅방일 경우, 시스템이 참조하는 '방 데이터(roomData)' 자체를 메인방으로 바꿔치기합니다.
                // 특정 방 이름을 지정하지 않고, DB에 있는 모든 방을 뒤져서 가장 부자인 계정을 찾아냅니다.
                if (ALLOWED_ROOMS.indexOf(realRoom) === -1) {
                    var bestMatchUser = null;
                    var bestMatchUid = null;
                    var bestMatchRoomData = null;
                    var maxPoints = -1;

                    // 1. DB에 존재하는 모든 방을 순회
                    for (var dbRoomName in data.rooms) {
                        // 현재 1:1 방(자기 자신)은 제외하고 검색
                        if (dbRoomName === realRoom) continue;

                        var rData = data.rooms[dbRoomName];
                        if (!rData || !rData.users) continue;

                        // 2. 해당 방의 유저 목록 스캔
                        for (var mUid in rData.users) {
                            var mUser = rData.users[mUid];
                            
                            // 이름 일치 확인 (공백 제거 후 비교)
                            if (mUser.name.trim() === cleanSender.trim()) {
                                var uPoint = Number(mUser.point || 0);
                                
                                // 동명이인(또는 유령계정) 중 포인트가 가장 많은 '진짜'를 선택
                                if (uPoint > maxPoints) {
                                    maxPoints = uPoint;
                                    bestMatchUser = mUser;
                                    bestMatchUid = mUid;
                                    bestMatchRoomData = rData;
                                }
                            }
                        }
                    }

                    // 3. 찾은 '진짜 계정'으로 1:1방 데이터 덮어쓰기
                    if (bestMatchUser && bestMatchRoomData) {
                        user = bestMatchUser;           // 유저 객체 교체
                        targetUid = bestMatchUid;       // UID 교체
                        roomData = bestMatchRoomData;   // [핵심] 장부를 찾은 방의 장부로 교체
                        
                        // 로그: 연결된 방 이름이 무엇인지 확인하고 싶다면 주석 해제
                        // Log.info("[연동 성공] " + cleanSender + " -> " + bestMatchRoomData.users[bestMatchUid].name);
                    }
                }

                /* [v6.6 딥 헬러] 타입 검증형 자가 치유 엔진 (Deep Healing & Memory Sync) */
                if (user && targetUid) {
                    var isDeepHealed = false;
                    
                    // [교정]: 게이트웨이 및 저널링 식별을 위한 UID 강제 바인딩
                    if (!user.uid || user.uid !== targetUid) {
                        user.uid = targetUid;
                        isDeepHealed = true;
                    }

                    // [교체] 전역 표준 규격 USER_SCHEMA를 호출하여 누락 데이터 수리
                    USER_SCHEMA.forEach(function(item) {
                        var val = user[item.key];
                        
                        // 타입이 맞다면 보존
                        if (val !== undefined && val !== null) {
                            if (typeof val === item.type || (item.type === 'array' && Array.isArray(val))) return;
                        }

                        // 수리: 숫자는 형변환 시도, 그 외는 기본값 주입
                        if (item.type === 'number' && val !== undefined && !isNaN(Number(val))) {
                            user[item.key] = Number(val);
                        } else {
                            user[item.key] = item.default;
                        }
                        isDeepHealed = true;
                    });

                    // 3. [Sync] 수리 발생 시 물리 저장 및 메모리(globalData) 즉시 갱신
                    if (isDeepHealed) {
                        Log.info("[Deep-Healer] " + user.name + "님 구조 최적화 및 동기화 완료.");
                        safeSaveData(data, false);
                        if (typeof globalData !== 'undefined') globalData = data; 
                    }

                    /**
                     * [무역 시스템: 도착 실시간 트리거]
                     * 기능: 항해 시간이 경과한 후 유저가 채팅을 치면 즉시 정산 로직 실행
                     */
                    if (user && user.voyage && user.voyage.active === true) {
    var v = user.voyage;
    if (Date.now() >= (v.arrival || 0)) {

        // [안전장치] 5분 이상 정산이 안 끝났다면 잠금 강제 해제 (자가 치유)
        if (v.isProcessing === true && (nowTs - (v.lastAttemptTime || 0) > 300000)) {
            v.isProcessing = false;
        }

        // 정산 중이 아닐 때만 진입
        if (v.isProcessing !== true) {
            v.lastAttemptTime = nowTs; // 시도 시간 기록
            if (typeof _processTradeArrival === 'function') {
                user.skipHealing = true;
                _processTradeArrival(user, data, replier, roomName, targetUid);
                // 정산 함수 내부에서 처리가 끝난 후 active가 false가 되므로 중복 실행되지 않음
            }
        }
                    }
                }

                // 4. [Spam Guard] 도배 방지 로직 (무역 정산 이후에 실행)
                var now = Date.now();
                    var conf = SYSTEM_CONFIG.SPAM;
                    if (user.timeoutEndTime && now < user.timeoutEndTime) return;

                    user.chatLog.push(now);
                    user.chatLog = user.chatLog.filter(function(time) { return now - time < conf.LIMIT_WINDOW; });

                    if (user.chatLog.length > conf.LIMIT_COUNT) {
                        user.timeoutEndTime = now + conf.TIMEOUT_MS;
                        user.chatLog = [];
                        var expireTime = new Date(user.timeoutEndTime).toLocaleTimeString();
                        var timeoutMsg = "🔇 [도배 감지: 이용 제한]\n" +
                                         "━━━━━━━━━━━━━━━\n" +
                                         "대상: " + getDisplayName(user) + "님\n" +
                                         "사유: 단시간 과도한 채팅 발송\n" +
                                         "제한: " + Math.floor(conf.TIMEOUT_MS / 60000) + "분간 봇 이용 불가\n" +
                                         "━━━━━━━━━━━━━━━\n" +
                                         "💡 해제 시각: " + expireTime;
                        replier.reply(timeoutMsg);
                        safeSaveData(data);
                        return;
                    }
                }

                /* [핵심] 버그 제보 및 진실 판별 시스템 */
                if (msg.startsWith("/버그제보 ")) {
                    var content = msg.substring(6).trim();
                    if (content.length < 2) return replier.reply("내용을 상세히 적어주세요.");
                    
                    if(user) { 
                        var lastAct = user.lastAction;
                        var timeDiff = lastAct ? (Date.now() - lastAct.time) : 99999999;
                        var diagnosis = "";
                        var isConfirmed = false;

                        if (lastAct && timeDiff < 300000) { 
                            if (lastAct.status === "PENDING") { diagnosis = "⚠️ 로직 중단됨(응답없음)"; isConfirmed = true; }
                            else if (lastAct.status === "CRASH") { diagnosis = "🚫 시스템 에러(Crash)"; isConfirmed = true; }
                            else if (lastAct.status === "FAIL") { diagnosis = "📉 데이터 불일치(계산오류)"; isConfirmed = true; }
                            else if (lastAct.status === "SUCCESS") { 
                                replier.reply("🤖 [시스템 진단: 정상]\n직전 작업(" + lastAct.cmd + ")이 성공적으로 완료되었습니다.\n오류가 발견되지 않았습니다.");
                                return;
                            }
                        } else { 
                            diagnosis = "❓ 실행 기록 없음(로직 미진입/오타)"; isConfirmed = true; 
                        }

                        var logTime = new Date().toLocaleString();
                        var logTxt = "[" + logTime + "] " + cleanSender + ": " + content + "\n    ㄴ 판독: " + diagnosis + "\n";
                        FileStream.append(BUG_LOG_PATH, logTxt);
                        
                        if(isConfirmed) replier.reply("✅ [제보 접수]\n판독 결과: " + diagnosis + "\n분석 내용이 버그 리스트에 등록되었습니다.");
                        else replier.reply("📝 제보가 접수되었습니다.");
                    }
                    return;
                }

                /* 관리자용 시스템 제어 */
                if (isAdmin(sender, data)) {
                    if (msg === "/강제재가동") {
                        if (lock.isLocked()) lock.unlock(); 
                        globalData = getDatabase(); 
                        if (globalData) { globalData.botActive = true; safeSaveData(globalData); }
                        replier.reply(formatAdmin("🔄 시스템 재가동", "결과: 락 해제 및 메모리 동기화 완료"));
                        return;
                    }
                }

//==========섹터20-1==========

if (!data) return;
// [수정] 참조 오류 방지를 위한 변수 선언 및 단체방 유저 할당 로직 추가
var currentImgHash = (function(){ try { return imageDB ? imageDB.getProfileHash() : null; } catch(e){ return null; } })();
var isIdentityRecovered = false;
var cacheKey = "GLOBAL_" + cleanSender;

var roomData = (roomName === "베릭방" || ALLOWED_ROOMS.indexOf(roomName) === -1) 
               ? data.rooms["내리다"] 
               : (data.rooms[roomName] || { users: {} });

if (!roomData) roomData = { users: {} };
if (ALLOWED_ROOMS.indexOf(roomName) !== -1 && roomName !== "베릭방") {
    data.rooms[roomName] = roomData;
}

if (ALLOWED_ROOMS.indexOf(roomName) === -1) {
    var mainUsers = (data.rooms["내리다"] && data.rooms["내리다"].users) ? data.rooms["내리다"].users : {};
    var cleanTarget = cleanSender.replace(/\s/g, "");
    var foundMainUser = false;

    for (var mUid in mainUsers) {
        if (mainUsers[mUid].name.replace(/\s/g, "") === cleanTarget) {
            targetUid = mUid;
            user = mainUsers[mUid];
            foundMainUser = true;
            break; 
        }
    }

    if (!foundMainUser) {
        var failMsg = "🚫 [연동 실패: 미가입]\n" +
                      "━━━━━━━━━━━━━━━\n" +
                      "메인 서버('내리다' 단체방)에서 고객님의 정보를 찾을 수 없습니다.\n\n" +
                      "💡 해결 방법:\n" +
                      "1. 단체방에 입장하여 채팅을 한 번 입력하세요.\n" +
                      "2. 단체방 닉네임과 현재 닉네임이 정확히 일치하는지 확인하세요.\n" +
                      "   (띄어쓰기 무관, 특수문자 포함 일치 필요)";
        replier.reply(failMsg);
        return; 
    }

    if (user && !user.hasSeenSyncNotice) {
        replier.reply("🔗 [시스템] 메인 서버 계정(" + user.name + ")과 성공적으로 연동되었습니다.");
        user.hasSeenSyncNotice = true;
    }
} else {
    // [추가] 단체방 접속 시 기존 유저 객체를 'user' 변수에 할당 (참조 오류 해결 핵심)
    if (targetUid && roomData.users[targetUid]) user = roomData.users[targetUid];
}

// [2] 현재 접속한 방(1:1방 포함)의 기능 객체가 없으면 즉시 생성
if (!roomData.features) {
    roomData.features = (typeof ROOM_FEATURE_TEMPLATE === 'function') ? ROOM_FEATURE_TEMPLATE() : {};
}
// 하위 states 구조가 누락된 경우 강제 보강
if (!roomData.features.states) {
    roomData.features.states = { 
        menuWait: {}, bankProcess: {}, selectWait: {}, lottoPurchase: {},
        activeThefts: {}, duelData: {}, mining: {}, loanRegister: {}, loanContractWait: {} 
    };
}

// [3] 1:1방이라면 포인트 관리는 메인방으로, 세션 관리는 현재방으로 분리
if (ALLOWED_ROOMS.indexOf(roomName) === -1) {
    var redirectedData = data.rooms["내리다"];
    if (redirectedData && redirectedData.users[targetUid]) {
        // user 객체는 메인방의 데이터(돈, 템 등)를 참조
        user = redirectedData.users[targetUid];
    }
}

// 추가: 카지노 VIP 안내 가드용 물리 방 상태 저장 (수정)
if (user) user.isGroupChatTemp = isGroupChat;

// 2. [신분 복구] 식별 실패 시 영구 명부(Registry) 대조
var isIdentityRecovered = false;

if (!targetUid) {
    var regKey = roomName + "_" + cleanSender;
    try {
        var regFile = new java.io.File(REGISTRY_PATH);
        if (regFile.exists()) {
            var registry = JSON.parse(FileStream.read(REGISTRY_PATH));
            if (registry[regKey]) {
                targetUid = registry[regKey]; 
                globalData.nameToIdCache[cacheKey] = targetUid; 
                isIdentityRecovered = true;
                Log.info("[Identity Restore] " + cleanSender + "님 신분 복구 완료.");
            }
        }
    } catch(e) { Log.error("Registry Read Error"); }
}

// 3. [신규 생성] 진짜 신규 유저일 경우
if (!targetUid) {
    targetUid = generateUUID();
    globalData.nameToIdCache[cacheKey] = targetUid;
    
    try {
        var regKey = roomName + "_" + cleanSender;
        var regFile = new java.io.File(REGISTRY_PATH);
        var registry = regFile.exists() ? JSON.parse(FileStream.read(REGISTRY_PATH)) : {};
        registry[regKey] = targetUid;
        FileStream.write(REGISTRY_PATH, JSON.stringify(registry));
    } catch(e) {}
}

// [C] UID는 확보되었으나 데이터가 없는 경우 초기화 (1:1 방은 생성 금지)
if (ALLOWED_ROOMS.indexOf(roomName) !== -1 && !roomData.users[targetUid]) {
    var newUser = { uid: targetUid, name: cleanSender, imageHash: currentImgHash, lastDate: "" };

    USER_SCHEMA.forEach(function(item) {
        if (typeof item.default === 'object' && item.default !== null) {
            newUser[item.key] = JSON.parse(JSON.stringify(item.default));
        } else {
            newUser[item.key] = item.default;
        }
    });

    roomData.users[targetUid] = newUser;
    user = newUser; // 새로 생성된 유저 바인딩

    if (typeof util_updatePoint === 'function') {
        util_updatePoint(roomData.users[targetUid], roomData, 100000, "입장 축하 보너스", roomName);
    }
    
    globalData.nameToIdCache[cacheKey] = targetUid;
    
    var welcomeTitle = isIdentityRecovered ? "🎊 [" + cleanSender + "]님 신분 복구 완료!" : "🎊 [" + cleanSender + "]님 환영합니다!";
    var welcomeSub = isIdentityRecovered ? "🛡️ 영구 명부에서 과거 고유 코드를 찾아 연결했습니다." : "🎁 입장 축하 보너스: " + fP(100000) + "P 지급!";
    
    var welcomeMsg = (welcomeTitle + "\n━━━━━━━━━━━━━━━\n" +
                      welcomeSub + "\n" +
                      "🕹️ 미니게임 및 출석체크 기능 제공\n" +
                      "💳 신용 등급: 4등급 (600점) 부여\n\n" + 
                      "📖 이용 전 반드시 '/도움말'을 확인해주세요!");
                      
    replier.reply(welcomeMsg); 
    safeSaveData(data);
}

// [교정] 단체방 기존 유저 데이터 바인딩 (참조 오류 해결 핵심)
if (!user && targetUid && roomData.users[targetUid]) {
    user = roomData.users[targetUid];
}

// 1. 핵심 로직 함수 호출 (모든 인자 누락 없이 전달)
if (user) {
        _processMainLogic(msg, user, data, replier, roomName, targetUid, cleanSender, isGroupChat, realRoom, imageDB, sender, roomData);
    }

// [닫는 괄호] 섹터 19에서 시작된 try 구문을 여기서 닫습니다.
} catch (e) {
        // [Rollback] 에러 발생 시 데이터 복구 및 보고
        if (typeof util_stagingRollback === 'function') util_stagingRollback(user, roomName);
        if (typeof util_reportError === 'function') util_reportError(e, roomName, cleanSender, msg);
        try {
            if (typeof replier !== 'undefined' && typeof formatError === 'function') {
                replier.reply(formatError(user, "시스템 보호 작동", "로직 처리 중 오류가 발생하여 복구되었습니다."));
            }
        } catch (err) { Log.error("🚨 [Critical Error in Catch: " + err); }
    } finally {
        // [Lock Release] 락 해제
        try {
            if (typeof _perfStartTime !== 'undefined') {
                var _pDur = java.lang.System.currentTimeMillis() - _perfStartTime;
                if (typeof PERF_METRICS !== 'undefined') {
                    PERF_METRICS.avgLag = Math.floor((PERF_METRICS.avgLag * 9 + _pDur) / 10);
                    if (_pDur > PERF_METRICS.peakLag) PERF_METRICS.peakLag = _pDur;
                    PERF_METRICS.msgPerMin++;
                }
            }
            if (typeof lock !== 'undefined' && lock !== null && lock.isHeldByCurrentThread()) {
                lock.unlock(); 
            }
        } catch (err) { Log.error("Lock Release Fail: " + err); }
    }

    // [계층 역순 종료] 모든 박스를 여기서 닫습니다.
    } // LogicQueue.run 종료
    })); // LogicQueue.execute 종료
    } // ParallelPool.run 종료
    })); // ParallelPool.execute 종료
}; // action 함수 완전 종료

//==========섹터20-2==========

/* [수정] 인자 리스트에 imageDB, sender를 추가하여 내부 로직 오류를 해결합니다. */
function _processMainLogic(msg, user, data, replier, roomName, targetUid, cleanSender, isGroupChat, realRoom, imageDB, sender, roomData) {

/* [데이터 & 가드 통합 엔진] 1:1방 동기화 및 숫자 핸들러 프리패스 */
// roomData가 유실된 경우를 대비한 안전 장치
if (!roomData) roomData = data.rooms[roomName] || { users: {} };

/* [데이터 & 가드 통합 엔진] 1:1방 동기화 및 숫자 핸들러 프리패스 */
if (ALLOWED_ROOMS.indexOf(realRoom) === -1 || realRoom === "베릭방") {
    // 수정: 중복 가드 로직을 모두 제거하고 '지갑 연결'만 수행 (가드는 섹터 24에서 일괄 처리)
    var mainRoomData = data.rooms["내리다"];
    if (mainRoomData && mainRoomData.users[targetUid]) {
        user = mainRoomData.users[targetUid]; // 지갑(데이터)만 메인방 것으로 교체
    }
} else {
    // 단체방일 경우: 현재 방의 유저 데이터를 그대로 사용
    user = roomData.users[targetUid];
}

/* [v11.0] 주식 -> 랜드마크 데이터 자동 마이그레이션 */
if (user.landHoldings === undefined) {
    // 1. 기존 주식 데이터를 부동산 데이터로 안전하게 이전
    user.landHoldings = user.stockHoldings || {};
    user.landAvg = user.stockAvg || {};
    user.totalLandInvest = user.totalInvestAmount || 0;
    user.landDeedCount = user.stockCertCount || 0;
    
    // 2. 이전 완료 후 구 데이터 필드 삭제 (메모리 최적화 및 중복 이전 방지)
    delete user.stockHoldings;
    delete user.stockAvg;
    delete user.totalInvestAmount;
    delete user.stockCertCount;
}

/* 데이터 구조 보정 및 필수 변수 초기화 */
if (!user.inventory) user.inventory = [];
if (user.landDeedCount === undefined) user.landDeedCount = 0;
if (user.totalLandInvest === undefined) user.totalLandInvest = 0;

if (msg === "줍기") {
    var rFeatures = roomData.features;
    if (rFeatures && rFeatures.sprinkleData && rFeatures.sprinkleData.active) {
        if (typeof _gameActionLogic_Part3 === 'function') {
            _gameActionLogic_Part3(msg, user, data, replier, roomName, targetUid);
            return; // 줍기 처리 시 로직 종료하여 가드 우회 및 하단 로직 중복 방지
        }
    }
}

/* [수정] 데이터 구조 보정 및 초기화 */
if (!user.inventory) user.inventory = [];
if (user.tierGuard === undefined) user.tierGuard = 0;
if (user.gameAuthCount === undefined) user.gameAuthCount = 0;
if (user.purchasedAuthCount === undefined) user.purchasedAuthCount = 0;

/* [신규: Gemini 요청 사항] 경고삭제권 구매 여부 필드 마이그레이션 */
if (user.boughtWarningRemoval === undefined) user.boughtWarningRemoval = false;

/* [개편] 랜덤박스 시스템 관련 변수 안전 초기화 및 자동 마이그레이션 */
if (user.boxFragments === undefined) user.boxFragments = 0;
if (user.boxTickets === undefined) user.boxTickets = 0;

// 1. 기록장(collectedIcons)이 없으면 생성
if (user.collectedIcons === undefined) {
    user.collectedIcons = [];
}

// 2. [Gemini 요청 사항] 기존 보유 아이콘 기록 자동 마이그레이션
// 가방에 있는 아이콘들을 전수 조사하여 한 번이라도 뽑은 기록에 자동 등록합니다.
if (user.inventory && user.inventory.length > 0) {
    user.inventory.forEach(function(it) {
        if (it.effect === "icon" && user.collectedIcons.indexOf(it.icon) === -1) {
            user.collectedIcons.push(it.icon);
        }
    });
}

/* [핵심] 강제 추심 플래그 초기화 및 보정 */
if (user.isTransferred === undefined) user.isTransferred = false;

/* [기능] 기존 아이콘 및 칭호 가방 자동 마이그레이션 */
if (user.inventory) {
    // 1. 아이콘 마이그레이션
    if (user.icon && user.icon !== "") {
        var hasIconInInv = false;
        for (var j = 0; j < user.inventory.length; j++) {
            if (user.inventory[j].icon === user.icon) { hasIconInInv = true; break; }
        }
        if (!hasIconInInv) {
            for (var k = 0; k < SHOP_ITEMS.length; k++) {
                if (SHOP_ITEMS[k].effect === "icon" && SHOP_ITEMS[k].icon === user.icon) {
                    user.inventory.push({
                        id: SHOP_ITEMS[k].id, name: SHOP_ITEMS[k].name, icon: SHOP_ITEMS[k].icon,
                        effect: "icon", title: ""
                    });
                    // 마이그레이션 시 기록장에도 동시 등록
                    if (user.collectedIcons.indexOf(user.icon) === -1) user.collectedIcons.push(user.icon);
                    break;
                }
            }
        }
    }
    
    // 2. 칭호 마이그레이션 (누락분 추가)
    if (user.title && user.title !== "") {
        var hasTitleInInv = false;
        for (var j = 0; j < user.inventory.length; j++) {
            if (user.inventory[j].title === user.title) { hasTitleInInv = true; break; }
        }
        if (!hasTitleInInv) {
            for (var k = 0; k < SHOP_ITEMS.length; k++) {
                if (SHOP_ITEMS[k].effect === "title" && SHOP_ITEMS[k].title === user.title) {
                    user.inventory.push({
                        id: SHOP_ITEMS[k].id, name: SHOP_ITEMS[k].name, icon: SHOP_ITEMS[k].icon || "",
                        effect: "title", title: SHOP_ITEMS[k].title
                    });
                    break;
                }
            }
        }
    }
}

var today = getSimpleDate();
user.point = Number(user.point || 0);

/* 민생지원금 즉시 체크 */
if (user && user.lastDate !== today) {
    checkEconomicStimulus(user, roomName, false);
}

/* [신규] 기존 예금자 이자 엔진 강제 활성화 */
// 예금은 있는데 기준 시간이 0인 경우, 지금 이 순간부터 이자가 쌓이도록 기준점 설정
if (user.bank > 0 && (!user.lastBankUpdateTime || user.lastBankUpdateTime === 0)) {
    user.lastBankUpdateTime = Date.now();
}

// [감시 엔진] 3분 미사용 시 세션 자동 초기화 로직
var nowTs = Date.now();
if (user.lastBotUseTime > 0 && (nowTs - user.lastBotUseTime > 180000)) {
    // 3분(180,000ms) 초과 시 감시 데이터 리셋
    user.casinoAuditStartTime = 0;
    user.casinoAuditStartAssets = 0;
    user.casinoAuditAlertHistory = [];
}
// 모든 활동 시 마지막 봇 사용 시간 갱신 (세션 유지)
user.lastBotUseTime = nowTs;

util_stagingStart(user); 

// [교정] 섹터 25에서 사용할 명령어 처리 확인 변수를 여기서 선언합니다.
var isProcessed = false; 

/**
 * [독립형 함수] 중복 유저 선택 처리 엔진 (전역 원격 관제 v10.5)
 * 설명: 닉네임 검색 시 중복 발생 건에 대한 유저의 숫자 선택을 처리합니다.
 * 반영: 모든 관리자 명령어가 유저가 속한 실제 방(Target Room)의 데이터를 수정하도록 교정.
 */
function _handleSelectionLogic(msg, user, data, replier, roomName, targetUid) {
    var roomData = data.rooms[roomName];
    if (!roomData || !roomData.features || !roomData.features.states.selectWait) return false;

    var selectWaitState = roomData.features.states.selectWait;
    if (!selectWaitState[targetUid]) return false;

    // 1. 시간 초과 체크 (30초)
    if (Date.now() - selectWaitState[targetUid].timestamp > 30000 || msg === "취소") {
        delete selectWaitState[targetUid];
        if (msg === "취소") {
            replier.reply(formatCommand("🚫 선택 취소", user, "작업이 취소되었습니다."));
        } else {
            replier.reply(formatError(user, "선택 시간 초과", "30초 이내에 번호를 선택하지 않아 메뉴가 닫혔습니다."));
        }
        return true;
    }

    // 3. 숫자 선택 및 로직 실행
    var choice = parseInt(msg.replace(/[^0-9]/g, ""));
    if (!isNaN(choice) && choice >= 1 && choice <= selectWaitState[targetUid].results.length) {
        var state = selectWaitState[targetUid];
        var selected = state.results[choice - 1]; // 선택된 검색 결과 (roomName 정보 포함)
        var type = state.type;
        var extra = state.extra;
        var targetUser = selected.data;
        
        // [원격 관제 핵심] 유저가 실제로 상주하는 방의 데이터를 타겟팅
        var targetRoom = selected.roomName || roomName; 
        var targetRoomData = data.rooms[targetRoom];
        
        delete selectWaitState[targetUid]; // 선택 완료 시 세션 삭제

        // 추가: /조작 명령어 중복 유저 선택 시 처리 로직 (수정/추가)
        if (type === "admin_mani_select") {
            var mode = extra.mode;
            if (mode === "ON") {
                targetUser.isManipulated = true;
                targetUser.gambleWinRate = SYSTEM_CONFIG.MANIPULATION.DEFAULT_GAMBLE;
                targetUser.fishLuck = SYSTEM_CONFIG.MANIPULATION.DEFAULT_FISH;
                targetUser.horseWinRate = SYSTEM_CONFIG.MANIPULATION.DEFAULT_RACING;
                targetUser.spittoWinRate = SYSTEM_CONFIG.MANIPULATION.DEFAULT_SPITTO;
                targetUser.skipHealing = true;
                replier.reply(formatAdmin("🎯 조작 가동", "[" + targetRoom + "] " + targetUser.name + "님의 조작을 [기본값]으로 활성화했습니다."));
            } else if (mode === "OFF") {
                targetUser.isManipulated = false;
                targetUser.skipHealing = true;
                replier.reply(formatAdmin("🎯 조작 해제", "[" + targetRoom + "] " + targetUser.name + "님의 모든 조작을 종료했습니다."));
            } else {
                var status = "👤 대상: [" + targetRoom + "] " + targetUser.name + "\n" +
                             "✨ 상태: " + (targetUser.isManipulated ? "🟢 가동 중" : "⚪ 미가동") + "\n\n" +
                             "1. 🎲 홀짝 승률: " + (targetUser.gambleWinRate || 0) + "%\n" +
                             "2. 🎣 낚시 보정: " + (targetUser.fishLuck || 0) + "%\n" +
                             "3. 🏇 경마 보정: " + (targetUser.horseWinRate || 0) + "%\n" +
                             "4. 🧧 스피또 보정: " + (targetUser.spittoWinRate || 0) + "%\n" +
                             "5. ❌ 조작 전체 해제\n\n" +
                             "💡 수정할 번호를 입력하거나 [취소] 하세요.";
                
                var currentMenuWait = data.rooms[roomName].features.states.menuWait;
                currentMenuWait[targetUid] = { 
                    type: 'admin_mani_menu', 
                    time: Date.now(), 
                    extra: { targetId: selected.id, targetRoom: targetRoom } 
                };
                replier.reply(formatAdmin("🎯 조작 설정 센터", status));
            }
        }

        // [추가] 조작 설정/해제 중복 유저 선택 시 실제 데이터 반영부
           if (type === "admin_manipulate_on") {
            targetUser.isManipulated = true;
            var maniCfg = SYSTEM_CONFIG.MANIPULATION;
            var gRate = (extra && extra.gambleRate) ? extra.gambleRate : maniCfg.DEFAULT_GAMBLE;
            var fLuck = (extra && extra.fishLuck) ? extra.fishLuck : maniCfg.DEFAULT_FISH;
            targetUser.gambleWinRate = Math.min(maniCfg.MAX_RATE, Math.max(maniCfg.MIN_RATE, gRate));
            targetUser.fishLuck = Math.min(maniCfg.MAX_RATE, Math.max(maniCfg.MIN_RATE, fLuck));
            targetUser.skipHealing = true;
            replier.reply(formatAdmin("🎯 조작 활성화", "대상: [" + targetRoom + "] " + targetUser.name + "\n🎲 홀짝 승률: " + targetUser.gambleWinRate + "%\n🎣 낚시 보정: " + targetUser.fishLuck + "%"));
        }
        else if (type === "admin_manipulate_off") {
            targetUser.isManipulated = false;
            targetUser.gambleWinRate = 0;
            targetUser.fishLuck = 0;
            targetUser.skipHealing = true;
            replier.reply(formatAdmin("🎯 조작 해제", "대상: [" + targetRoom + "] " + targetUser.name + "\n모든 확률이 정상으로 돌아왔습니다."));
        }
        else if (type === "stock_buy" || type === "stock_sell") {
            var landName = selected; 
            var cmdPrefix = (type === "stock_buy") ? "/투자 " : "/매각 ";
            _gameLandmarkLogic(cmdPrefix + landName + " " + extra.amount, targetUser, data, replier, targetRoom, selected.id);
            return true;
        }
        else if (type === "info") {
            var cr = getCreditInfo(targetUser.creditScore);
            var info = "📍 소속: " + targetRoom + "\n💰 포인트: " + fp(targetUser.point) + "P\n🏦 예금: " + fp(targetUser.bank) + "P\n💳 신용: " + cr.label + " (" + targetUser.creditScore + "점)\n🏅 티어: " + (TIERS[targetUser.tier] || "아이언");
            replier.reply(formatCommand("🔍 유저 상세 정보", targetUser, info, null));
        }
        else if (type === "mining_info") {
            var isMin = (targetUser.mining && targetUser.mining.active === true);
            var dur = isMin ? Math.floor((Date.now() - targetUser.mining.startTime) / 60000) : 0;
            var tot = (targetUser.totalMiningTime || 0) + dur;
            var pol = util_getActivePolicy(targetRoomData);
            var mult = util_getEcoMultiplier(targetRoom) * (pol.mineMult || 1.0);
            if (targetUser.loan && Number(targetUser.loan.debt) > 0) mult *= 1.5;
            var est = isMin ? Math.floor(dur * SYSTEM_CONFIG.ECO.MINE.BASE_PER_MIN * mult) : 0;

            var body = "\n" + (isMin ? "채굴 진행: " + dur + "분째...\n" : "✨ 상태: 현재 휴식 중입니다.\n") +
                       "📈 누적 채굴: " + fp(tot) + "분 경과\n" +
                       "💰 예상 수익: +" + fp(est) + "P\n" +
                       "⚖️ 정책 효과: x" + mult.toFixed(1) + " (적용 중)\n\n" +
                       "✨ 광물 발견 수익은 종료 시 합산됩니다.";
            replier.reply(formatCommand("🔍 유저 광산 진행 현황", targetUser, body, null));
        }
        else if (type === "transfer") {
            if (selected.id === targetUid) return replier.reply(formatError(user, "송금 불가", "자기 자신에게는 송금할 수 없습니다."));
            util_updatePoint(user, roomData, -extra.amount, "송금 보냄", roomName);
            var res = processRepayment(targetUser, extra.amount, selected.id, targetRoom);
            util_updatePoint(targetUser, targetRoomData, Number(res.actualGain), "송금 받음", targetRoom);
            replier.reply(formatCommand("💸 송금 완료", user, "[" + targetRoom + "] " + getDisplayName(targetUser) + "님께 " + fp(extra.amount) + "P 보냈습니다.", "내 잔액: " + fp(user.point) + "P"));
        }
        else if (type === "admin_userdata") { 
            replier.reply(formatAdmin("유저 데이터 조회", JSON.stringify(targetUser, null, 2))); 
        }
        else if (type === "admin_point_give") {
            util_updatePoint(targetUser, targetRoomData, extra.amount, "관리자 지급", targetRoom);
            replier.reply(formatAdmin("포인트 지급 완료", "[" + targetRoom + "] " + getDisplayName(targetUser) + "님: +" + fp(extra.amount) + "P\n(현재: " + fp(targetUser.point) + "P)"));
            try { Api.replyRoom("베릭방", "⚙️ [Admin Action: Selected]\n• 실행자: " + user.name + "\n• 대상: [" + targetRoom + "] " + targetUser.name + "\n• 내용: " + fp(extra.amount) + "P 지급 완료"); } catch(e) {}
        }
        else if (type === "admin_point_take") {
            util_updatePoint(targetUser, targetRoomData, -extra.amount, "관리자 차감", targetRoom);
            replier.reply(formatAdmin("포인트 차감 완료", "[" + targetRoom + "] " + getDisplayName(targetUser) + "님 차감 처리됨"));
        }
        else if (type === "admin_attend_edit") {
            targetUser.totalAttendance = extra.days;
            replier.reply(formatAdmin("출석 수정 완료", "[" + targetRoom + "] " + getDisplayName(targetUser) + "님: " + extra.days + "일"));
        }
        else if (type === "admin_credit_edit") {
            var oldScore = Number(targetUser.creditScore || 600);
            targetUser.creditScore = Math.min(1000, Math.max(0, oldScore + extra.score));
            if (typeof checkAndHandleDefaulter === 'function') checkAndHandleDefaulter(targetUser, targetRoom);
            var crInfo = getCreditInfo(targetUser.creditScore);
            replier.reply(formatAdmin("⚙️ 신용 점수 조정 완료", "대상: [" + targetRoom + "] " + getDisplayName(targetUser) + "\n변동: " + extra.score + "점\n현재: " + targetUser.creditScore + "점 (" + crInfo.label + ")"));
        }
        else if (type === "admin_title_take") {
            var titleToTake = extra.title;
            var inv = targetUser.inventory || [];
            var removed = false;
            targetUser.inventory = inv.filter(function(it) {
                if (it.effect === "title" && (it.title === titleToTake || it.name.indexOf(titleToTake) !== -1)) {
                    removed = true; return false;
                }
                return true;
            });
            if (targetUser.title === titleToTake) { targetUser.title = ""; removed = true; }
            if (removed) {
                replier.reply(formatAdmin("🎖️ 칭호 회수 완료", "[" + targetRoom + "] " + getDisplayName(targetUser) + "님에게서 [" + titleToTake + "] 칭호를 박탈했습니다."));
            } else {
                replier.reply(formatAdmin("회수 실패", "[" + targetRoom + "] " + getDisplayName(targetUser) + "님은 해당 칭호를 보유하고 있지 않습니다."));
            }
        }
        else if (type === "admin_delete") {
            var tName = targetUser.name;
            var targetId = selected.id;
            var refundLog = "";
            var refundCount = 0;
            var totalRefunded = 0;
            // [교정] targetRoomData의 사채 계약 처리
            if (targetRoomData.loanContracts) {
                for (var cid in targetRoomData.loanContracts) {
                    var c = targetRoomData.loanContracts[cid];
                    if (c.borrowerUid === targetId) {
                        var lender = targetRoomData.users[c.lenderUid];
                        if (lender) {
                            var debtAmt = Number(c.currentDebt);
                            util_updatePoint(lender, targetRoomData, debtAmt, "사채 강제 정산", targetRoom);
                            totalRefunded += debtAmt;
                            refundCount++;
                            try { Api.replyRoom(targetRoom, "🚬 [사채 강제 정산]\n" + tName + "님의 데이터 삭제로 인해 " + lender.name + "님께 미수금 " + fp(debtAmt) + "P가 전액 반환되었습니다."); } catch(e){}
                        }
                        delete targetRoomData.loanContracts[cid];
                    }
                }
            }
            if (targetUser.loan && Number(targetUser.loan.debt) > 0) {
                var bankDebt = Number(targetUser.loan.debt);
                util_updateReserve(targetRoomData, bankDebt, "대출금 국고 회수", targetRoom);
                refundLog += "\n\n🏦 은행 대출금 " + fp(bankDebt) + "P가 국고로 자동 회수되었습니다.";
            }
            if (refundCount > 0) refundLog += "\n⚠️ 사채 보전 완료: " + refundCount + "건 (" + fp(totalRefunded) + "P)";
            
            // 캐시 삭제
            if (typeof uidCache !== 'undefined') {
                for (var key in uidCache) { if (uidCache[key] === targetId) delete uidCache[key]; }
            }
            // [교정] 실제 유저가 있는 방에서 삭제
            delete targetRoomData.users[targetId];
            try {
                var regFile = new java.io.File(REGISTRY_PATH);
                if (regFile.exists()) {
                    var regData = JSON.parse(FileStream.read(REGISTRY_PATH));
                    // [교정] 타겟 방 이름 키로 명부 삭제
                    delete regData[targetRoom + "_" + tName];
                    FileStream.write(REGISTRY_PATH, JSON.stringify(regData));
                }
            } catch (e) { Log.error("Registry Delete Error: " + e); }
            replier.reply(formatAdmin("유저 삭제 완료", "[" + targetRoom + "] 방에서 [" + tName + "]님의 데이터를 영구 삭제했습니다." + refundLog));
        }

        else if (type === "admin_land_take") {
            var holdings = targetUser.landHoldings || {};
            var matchedLand = util_findStockByShorthand(holdings, extra.land);
            
            if (matchedLand.length === 0) {
                replier.reply(formatAdmin("🚫 회수 실패", "[" + targetUser.name + "]님은 해당 지분이 없습니다."));
            } else {
                var sName = matchedLand[0];
                var currentQty = Number(holdings[sName] || 0);
                var takeQty = (extra.qty === "전부") ? currentQty : parseInt(extra.qty.replace(/,/g, ""));
                if (takeQty > currentQty) takeQty = currentQty;

                targetUser.skipHealing = true;
                util_updateLandmark(targetUser, sName, -takeQty, "관리자 강제 회수", targetRoom);
                
                if (Number(targetUser.landHoldings[sName]) <= 0) {
                    delete targetUser.landHoldings[sName];
                    if (targetUser.landAvg) delete targetUser.landAvg[sName];
                }
                replier.reply(formatAdmin("⚙️ 부동산 회수 완료", "[" + targetRoom + "] " + targetUser.name + "님의 [" + sName + "] 지분을 회수했습니다."));
            }
        }

        else if (type === "admin_attend_reset") {
            targetUser.lastDate = "";
            replier.reply(formatAdmin("출석 초기화", "[" + targetRoom + "] " + getDisplayName(targetUser) + "님의 오늘 출석 기록을 삭제했습니다."));
        }
        else if (type === "user_restore") {
            var stablePath = BASE_DIR + "backup/last_stable_backup.json";
            var stableFile = new java.io.File(stablePath);

            if (!stableFile.exists() || stableFile.length() === 0) {
                replier.reply(formatAdmin("🚫 복구 실패", "안전 백업 파일(last_stable_backup.json)을 찾을 수 없습니다."));
                return true;
            }

            try {
                var sourceCode = (extra && extra.sourceCode) ? extra.sourceCode : selected.id;
                var targetId = selected.id;
                var fullNick = selected.data.name; 

                var backupContent = FileStream.read(stablePath);
                var backupData = JSON.parse(backupContent);
                var rawBackupUser = null;

                for (var r in backupData.rooms) {
                    if (backupData.rooms[r].users[sourceCode]) {
                        rawBackupUser = backupData.rooms[r].users[sourceCode];
                        break;
                    }
                }

                if (!rawBackupUser) throw new Error("백업본에 해당 데이터(ID:" + sourceCode + ")가 없습니다.");

                // 수정: 백업 데이터 전체 복제 (Deep Clone)
                var backupUser = JSON.parse(JSON.stringify(rawBackupUser));
                
                // 데이터 검증용 실시간 스냅샷 (채팅창 출력용)
                var tInf = backupUser.tradeCount || 0;
                var sInf = backupUser.shipLevel || 1;
                var iInf = (backupUser.collectedIcons && backupUser.collectedIcons.length) || 0;
                var aInf = backupUser.artifactPieces || 0;

                // 스키마에 정의된 모든 필드를 순회하며 누락된 정보 보정
                USER_SCHEMA.forEach(function(item) {
                    if (backupUser[item.key] === undefined) {
                        backupUser[item.key] = (typeof item.default === 'object' && item.default !== null) 
                                               ? JSON.parse(JSON.stringify(item.default)) : item.default;
                    }
                });

                backupUser.name = fullNick;
                backupUser.uid = targetId;
                backupUser.skipHealing = true; // 복구 직후 보안 엔진 간섭 방지

                // 현재 운영 중인 메모리에 백업본 통째로 주입 (다른 유저 영향 없음)
                targetRoomData.users[targetId] = backupUser;

                safeSaveData(data, false);
                if (typeof globalData !== 'undefined') globalData = data;

                // [검증 리포트 구성]
                var debugBody = "👤 대상: " + fullNick + "\n" +
                                 "━━━━━━━━━━━━━━━\n" +
                                 "💰 복구 잔액: " + fp(backupUser.point) + "P\n" +
                                 "🚢 무역 횟수: " + tInf + "회\n" +
                                 "🏗️ 선박 등급: " + sInf + "단계\n" +
                                 "🎒 수집 아이콘: " + iInf + "종\n" +
                                 "🧩 유물 조각: " + aInf + "개\n" +
                                 "━━━━━━━━━━━━━━━\n" +
                                 "💡 만약 위 수치들이 0이라면, 사용하신 백업 파일 자체가 이미 초기화된 이후의 파일입니다. 더 이전 시간대의 백업본을 사용하세요.";

                replier.reply(formatAdmin("✅ 특정 유저 정밀 복원 완료", debugBody));

            } catch (e) {
                replier.reply(formatAdmin("🚫 복구 중단", "복구 처리 중 오류가 발생했습니다.\n사유: " + e.message));
                Log.error("Select Restore Error: " + e);
            }
        }
        else if (type === "admin_nick_log") {
            var hist = data.nickHistory[selected.id] || [];
            if (hist.length === 0) {
                replier.reply(formatAdmin("닉네임 기록", "[" + targetRoom + "] " + getDisplayName(targetUser) + "님은 변경 이력이 없습니다."));
            } else {
                var logMsg = [];
                for(var i=0; i<hist.length; i++) logMsg.push((i+1) + ". " + hist[i].old + " (" + hist[i].date + ")");
                replier.reply(formatAdmin("📋 닉네임 변경 이력", "📍 소속: " + targetRoom + "\n현재: " + targetUser.name + "\n\n[과거 기록]\n" + logMsg.join("\n")));
            }
        }
        else if (type === "admin_blackbox") {
            _executeBlackboxSearch(selected.id, targetUser, replier);
        }
        else if (type === "admin_reg_delete") {
            var targetKey = selected.id; 
            var targetFullNick = selected.data.name;
            try {
                var regFile = new java.io.File(REGISTRY_PATH);
                if (regFile.exists()) {
                    var regData = JSON.parse(FileStream.read(REGISTRY_PATH));
                    delete regData[targetKey];
                    FileStream.write(REGISTRY_PATH, JSON.stringify(regData));
                    replier.reply(formatAdmin("명부 삭제 완료", "찾은 유저: [" + targetFullNick + "]\n관련 식별 코드를 명부에서 파기했습니다."));
                }
            } catch (e) { Log.error("Registry Delete Error: " + e); }
        }

        safeSaveData(data);
        return true; 
    } // if (!isNaN(choice)...) 블록 마감
}

//==========섹터21==========

/**
 * [독립형 함수] 로또 번호 입력 처리 엔진
 */
function _handleLottoInput(msg, user, data, replier, roomName, targetUid) {
    var roomData = data.rooms[roomName];
    if (!roomData || !roomData.features) return false;

    // 방별 독립 상태 저장소 참조
    var lottoPurchaseState = roomData.features.states.lottoPurchase;
    
    // 현재 유저가 로또 구매 대기 중인지 확인
    if (!lottoPurchaseState || !lottoPurchaseState[targetUid]) return false;

    // 1. 시간 초과 및 취소 가드
    if (Date.now() - lottoPurchaseState[targetUid].time > 30000) {
        delete lottoPurchaseState[targetUid];
        replier.reply(formatError(user, "입력 시간 초과", "30초가 지나 구매가 자동 취소되었습니다."));
        return true;
    }
    if (msg === "취소") {
        delete lottoPurchaseState[targetUid];
        replier.reply(formatCommand("🚫 구매 취소", user, "로또 구매가 취소되었습니다."));
        return true;
    }

    // 2. 활동 상태 검증
    var stateRes = util_checkUserState(user, targetUid, roomName);
    if (!stateRes.canAction) {
        delete lottoPurchaseState[targetUid];
        replier.reply(formatError(user, "구매 불가", stateRes.reason));
        return true;
    }

    // 3. 번호 파싱
    var rawNums = msg.match(/\d+/g);
    if (!rawNums || rawNums.length !== 3) {
        replier.reply(formatError(user, "입력 오류", "숫자 3개를 입력해주세요.\n예) 1 5 10"));
        return true;
    }
    
    var nums = rawNums.map(Number).sort(function(a, b) { return a - b; });
    var isInvalid = (nums[0] === nums[1] || nums[1] === nums[2] || nums[0] === nums[2]);
    for (var i = 0; i < 3; i++) { if (nums[i] < 1 || nums[i] > 15) isInvalid = true; }
    
    if (isInvalid) {
        replier.reply(formatError(user, "번호 오류", "1~15 사이의 중복 없는 숫자 3개를 입력하세요."));
        return true;
    }

    // 4. 가격 확인 및 잔액 체크
    var lottoPrice = (lottoPurchaseState[targetUid].price !== undefined) ? lottoPurchaseState[targetUid].price : 2000;
    if (Number(user.point) < lottoPrice) {
         delete lottoPurchaseState[targetUid];
         replier.reply(formatError(user, "잔액 부족", fp(lottoPrice) + "P가 필요합니다."));
         return true;
    }

    // 5. 로또 데이터 등록
    var lotto = roomData.features.lotto;
    if (!lotto.entries) lotto.entries = {};
    if (!lotto.entries[targetUid]) lotto.entries[targetUid] = [];

    lotto.entries[targetUid].push(nums);
    lotto.dailyPool = (Number(lotto.dailyPool) || 0) + lottoPrice;

    // 6. 결제 및 완료
    var prePoint = Number(user.point);
    util_updatePoint(user, roomData, -lottoPrice, "로또 구매", roomName);
    var actualDeducted = prePoint - Number(user.point);

    delete lottoPurchaseState[targetUid];
    
    replier.reply(formatCommand("🎫 로또 구매 완료", user, 
        "선택 번호: [" + nums.join(", ") + "]\n" +
        "차감 금액: " + fp(actualDeducted) + "P\n" +
        "추첨 시간: 매일 밤 22:00", 
        "내 잔액: " + fP(user.point) + "P"
    ));

    safeSaveData(data);
    return true; 
}

/* [채팅 보너스 로직 분리] - 섹터 21 하단에 추가 */
function _runChatBonusLogic(msg, user, data, replier, roomName, targetUid) {

    if (ALLOWED_ROOMS.indexOf(roomName) === -1) return;

    if (msg.indexOf("/") !== 0) {
        user.chatCount = (user.chatCount || 0) + 1;
        user.chatCycleCount = (user.chatCycleCount || 0) + 1;
        
        if (user.chatCycleCount > 13 || !user.chatBonusTarget) {
            user.chatCycleCount = 1; 
            user.chatBonusTarget = Math.floor(Math.random() * 12) + 1;
            user.chatBonusGiven = false; 
        }
        
        if (user.chatCycleCount >= user.chatBonusTarget && !user.chatBonusGiven) {
            // [v5.9] 통합 상태 가드
            var stateRes = util_checkUserState(user, targetUid, roomName);
            if (!stateRes.canAction && stateRes.reason.indexOf("징역") !== -1) return;

            var multiplier = util_getEcoMultiplier(roomName);
            var basePrize = Math.floor(Math.random() * 501) + 1500;
            var prize = Math.floor(basePrize * multiplier);

            // [신규] 신용불량자 페널티: 채팅 보너스 20% 삭감
            var penaltyMsg = "";
            if (Number(user.creditScore || 600) < 500) {
                var penalty = Math.floor(prize * 0.2);
                prize -= penalty;
                penaltyMsg = "\n⚠️ 신용불량 페널티 적용 (-20%)";
            }
            
            var res = processRepayment(user, prize, targetUid, roomName);
            util_updatePoint(user, data.rooms[roomName], Number(res.actualGain), "채팅 보너스", roomName);

            user.creditScore = Math.min(1000, Number(user.creditScore || 600) + 1);
            
            var output = "🎁 채팅 보너스\n━━━━━━━━━━━━━━━\n" + getDisplayName(user) + "님\n" + fp(prize) + "P를 획득했습니다!" + (res.repayMsg ? res.repayMsg : "") + "\n━━━━━━━━━━━━━━━";
            replier.reply(output + "\n내 잔액: " + fP(user.point) + "P");
            
            user.chatBonusGiven = true; 
        }
    }
}

//==========섹터22-1==========

/* [독립형 함수] 통합 업무 처리 핸들러 1단계: 송금, 예금 및 기부 */
function _handleBankStep1(msg, user, data, replier, roomName, targetUid) {
    var bankProcessState = data.rooms[roomName].features.states.bankProcess;
    if (!bankProcessState || !bankProcessState[targetUid]) return false;

    var state = bankProcessState[targetUid];
    var types = ['transfer', 'deposit', 'donate', 'blackjack_bet_input'];
    if (types.indexOf(state.type) === -1) return false; // 내 담당 업무가 아니면 패스

    // 1. 공통 가드 (시간 초과 및 취소)
    if (Date.now() - state.time > 30000 || msg === "취소") {
        delete bankProcessState[targetUid];
        if (msg === "취소") {
            replier.reply(formatCommand("🚫 업무 취소", user, "업무가 취소되었습니다."));
        } else {
            replier.reply(formatError(user, "선택 시간 초과", "30초 이내에 번호를 선택하지 않아 메뉴가 닫혔습니다."));
        }
        return true;
    }
    if (msg.startsWith("/")) return false; // 명령어는 흘려보냄

    // 2. 스마트 가드 (징역)
    if (user.jailReleaseTime && Date.now() < user.jailReleaseTime) {
        delete bankProcessState[targetUid];
        var diff = user.jailReleaseTime - Date.now();
        var remainMin = Math.ceil(diff / (1000 * 60));
        replier.reply(formatError(user, "업무 불가", "현재 징역 중입니다. (" + remainMin + "분 남음)"));
        return true;
    }

    var roomData = data.rooms[roomName];
    if (roomData.bankReserve === undefined) roomData.bankReserve = SYSTEM_CONFIG.ECO.BANK.INITIAL_RESERVE;

    if (state.type === 'blackjack_bet_input') {
        var amt = parseInt(msg.replace(/,/g, ""));
        var minB = SYSTEM_CONFIG.ECO.GAMBLE_MIN || 2000;
        var maxB = SYSTEM_CONFIG.ECO.GAMBLE_MAX || 50000;

        if (isNaN(amt) || amt < minB || amt > maxB) {
            replier.reply(formatError(user, "배팅 금액 오류", fp(minB) + "P ~ " + fp(maxB) + "P 사이를 입력하세요."));
            return true;
        }
        if (Number(user.point) < amt) {
            replier.reply(formatError(user, "잔액 부족", "보유 포인트가 부족합니다."));
            return true;
        }

        delete bankProcessState[targetUid]; // 입력 세션 종료
        // 섹터 52에 정의된 블랙잭 시작 함수 호출
        _startBlackjackGame(user, data, replier, roomName, targetUid, amt);
        return true;
    }

    /* [기능 1] 송금 처리 */
    if (state.type === 'transfer') {
        var ps = msg.split(" ");
        if (ps.length < 2) {
            replier.reply(formatError(user, "입력 오류", "형식: [닉네임] [금액]"));
            return true;
        }
        var am = parseInt(ps.pop().replace(/,/g, ""));
        var tn = ps.join(" ").trim();
        var found = findUserByName(roomData, tn);

        if (found.length === 0) {
            replier.reply(formatError(user, "대상 없음", "[" + tn + "]님을 찾을 수 없습니다."));
        } else if (found.length > 1) {
            handleUserSelection(replier, targetUid, found, "transfer", { amount: am }, user, roomName);
            delete bankProcessState[targetUid];
        } else if (found[0].id === targetUid) {
            replier.reply(formatError(user, "본인 송금 불가", "자신에게는 보낼 수 없습니다."));
        } else if (isNaN(am) || am <= 0) {
            replier.reply(formatError(user, "금액 오류", "정확한 숫자를 입력하세요."));
        } else if (user.point < am) {
            replier.reply(formatError(user, "잔액 부족", "보유 포인트가 부족합니다."));
        } else {
            var rc = found[0].data;
            util_updatePoint(user, roomData, -am, "송금 보냄", roomName);
            var res = processRepayment(rc, am, found[0].id, roomName);
            util_updatePoint(rc, roomData, Number(res.actualGain), "송금 받음", roomName);
            replier.reply(formatCommand("💸 송금 완료", user, getDisplayName(rc) + "님께 " + fp(am) + "P를 보냈습니다." + res.repayMsg, "내 잔액: " + fp(user.point) + "P"));
            delete bankProcessState[targetUid];
            safeSaveData(data);
        }
        return true;
    }

        /* [기능 2] 예금 처리 */
    else if (state.type === 'deposit') {
        var amt = parseInt(msg.replace(/,/g, ""));
        if (isNaN(amt) || amt <= 0) {
            replier.reply(formatError(user, "금액 오류", "예금할 숫자를 입력하세요."));
        } else if (user.point < amt) {
            replier.reply(formatError(user, "포인트 부족", "보유하신 포인트보다 많습니다."));
        } else {
            util_updateBank(user, roomData, amt, "은행 예금", roomName);
            util_updatePoint(user, roomData, -amt, "은행 예금", roomName);
            replier.reply(formatCommand("💰 예금 완료", user, fp(amt) + "P를 통장에 입금했습니다.\n(중앙은행 가용 재원으로 편입됨)", "내 잔액: " + fp(user.point) + "P"));
            delete bankProcessState[targetUid];
            safeSaveData(data);
        }
        return true;
    }

        /* [기능 3] 기부 처리 */
    else if (state.type === 'donate') {
        var amt = parseInt(msg.replace(/,/g, ""));
        if (isNaN(amt) || amt <= 0) {
            replier.reply(formatError(user, "금액 오류", "기부할 금액을 숫자로 정확히 입력하세요."));
        } else if (user.point < amt) {
            replier.reply(formatError(user, "잔액 부족", "보유하신 포인트보다 많은 금액은 기부할 수 없습니다."));
        } else {
            var replierStub = { reply: function(m) { Api.replyRoom(roomName, m); } };
            util_updatePoint(user, roomData, -amt, "은행 기부", roomName);
            var nextDonation = (user.totalDonation || 0) + amt;
            util_setData(user, 'totalDonation', nextDonation, "기부금 누적", roomName);
            
            // 1. [신규] 기부 금액에 따른 신용도 회복 로직 (10,000P당 10점)
            var creditGain = Math.floor(amt / 10000) * 10;
            if (creditGain > 0) {
                var nextScore = Math.min(1000, Number(user.creditScore || 600) + creditGain);
                util_setData(user, 'creditScore', nextScore, "기부 보상 신용 회복", roomName);
                if (typeof checkAndHandleDefaulter === 'function') checkAndHandleDefaulter(user, roomName);
            }

            // 2. [수정] 기부 칭호 조건 및 기부왕 혜택 변경
            var donation = user.totalDonation;
            
            if (donation >= 5000000) {
                util_checkAndAwardTitle(user, replierStub, "기부왕", 5004, "👑", "내리다 사회복지 협의회", "누적 기부 금액 " + fp(5000000) + "P", "[장착 효과]: 모든 종류의 세금(소득세, 무역세, 카지노세)이 50% 상시 감면됩니다.", roomName);
            } else if (donation >= 3000000) {
                util_checkAndAwardTitle(user, replierStub, "자선가", 5003, "✨", "내리다 사회복지 협의회", "누적 기부 금액 " + fp(3000000) + "P", "사회 전반에 걸쳐 선한 영향력을 널리 퍼뜨리고 있습니다.", roomName);
            } else if (donation >= 1000000) {
                util_checkAndAwardTitle(user, replierStub, "기부천사", 5002, "👼", "내리다 사회복지 협의회", "누적 기부 금액 " + fp(1000000) + "P", "어려운 이들에게 희망의 빛을 선사했습니다.", roomName);
            } else if (donation >= 500000) {
                util_checkAndAwardTitle(user, replierStub, "선한손길", 5001, "🌱", "내리다 사회복지 협의회", "누적 기부 금액 " + fp(500000) + "P", "당신의 따뜻한 마음이 사회의 소중한 밀알이 됩니다.", roomName);
            }

            var thanksMsg = "중앙은행에 " + fp(amt) + "P를 기부하셨습니다.\n" +
                            "보내주신 소중한 자산은 국가 경제 위기 극복과 \n" +
                            "전체 유저 복지 향상을 위해 귀하게 사용됩니다.\n\n" +
                            "📈 [신용 회복]: +" + creditGain + "점 상승\n" +
                            "🏦 [국고 입고]: 기부금이 중앙은행 재원으로 귀속됨\n" +
                            "📊 누적 기부액: " + fp(donation) + "P";
                replier.reply(formatCommand("🎁 기부 완료", user, thanksMsg, "(현재 잔액: " + fp(user.point) + "P)"));
                delete bankProcessState[targetUid];
                safeSaveData(data)
            }
        return true;
    }
    return false;
}
            
//==========섹터22-2==========

/* [독립형 함수] 통합 업무 처리 핸들러 2단계: 출금, 대출, 상환 */
function _handleBankStep2(msg, user, data, replier, roomName, targetUid) {
    var bankProcessState = data.rooms[roomName].features.states.bankProcess;
    if (!bankProcessState || !bankProcessState[targetUid]) return false;

    var state = bankProcessState[targetUid];
    var types = ['withdraw', 'loan', 'repay'];
    if (types.indexOf(state.type) === -1) return false;

    // 공통 가드
    if (Date.now() - state.time > 30000) {
        delete bankProcessState[targetUid];
        replier.reply(formatError(user, "입력 시간 초과", "입력 시간이 30초를 초과하여 은행 업무가 자동 취소되었습니다."));
        return true;
    }
    if (msg === "취소") {
        delete bankProcessState[targetUid];
        replier.reply(formatCommand("🚫 업무 취소", user, "요청하신 은행 업무가 취소되었습니다."));
        return true;
    }
    if (msg.startsWith("/")) return false;

    var roomData = data.rooms[roomName];
    if (roomData.bankReserve === undefined) roomData.bankReserve = SYSTEM_CONFIG.ECO.BANK.INITIAL_RESERVE;

    /* [기능 1] 출금 처리 */
    if (state.type === 'withdraw') {
        var amt = parseInt(msg.replace(/,/g, ""));
        if (isNaN(amt) || amt <= 0) {
            replier.reply(formatError(user, "금액 오류", "출금할 숫자를 정확히 입력하세요."));
        } else if (user.bank < amt) {
            replier.reply(formatError(user, "잔고 부족", "통장 잔고보다 많은 금액은 출금할 수 없습니다."));
        } else if (roomData.bankReserve < amt) {
            replier.reply(formatError(user, "은행 지급 불능", "죄송합니다. 현재 은행의 현금 유동성(실재고)이 부족하여 출금이 일시 제한됩니다.\n대출금 회수 및 수수료 적립 시까지 기다려주세요.\n\n🏦 현재 은행 금고: " + fp(roomData.bankReserve) + "P"));
        } else {
           // 1. 은행 잔고 감사 엔진 가동 (- 차감)
            util_updateBank(user, roomData, -amt, "은행 출금", roomName);
            
            // 2. 포인트 게이트웨이 가동 (+ 지급 및 국고 차감 연동)
            util_updatePoint(user, roomData, amt, "은행 출금", roomName);
            
            replier.reply(formatCommand("🏧 출금 완료", user, fp(amt) + "P를 현금으로 출금했습니다.", "보유 포인트: " + fp(user.point) + "P"));
            
            delete bankProcessState[targetUid]; // 상태 해제
            safeSaveData(data); // 즉시 저장
        }
        return true;
    }

        /* [기능 2] 대출 실행 */
    else if (state.type === 'loan') {
        var amt = parseInt(msg.replace(/,/g, ""));
        var cr = getCreditInfo(user.creditScore);
        var bConf = SYSTEM_CONFIG.ECO.BANK;
        var lConf = SYSTEM_CONFIG.ECO.PRIVATE_LOAN;

        var totalDeposits = 0;
        for (var id in roomData.users) { totalDeposits += (roomData.users[id].bank || 0); }
        var requiredReserve = Math.floor(totalDeposits * bConf.RESERVE_RATIO);
        var lendableAmount = roomData.bankReserve - requiredReserve;

        var cr = getCreditInfo(user.creditScore, roomName);

        if (isNaN(amt) || amt <= 0) {
            replier.reply(formatError(user, "금액 오류", "대출받을 숫자를 입력하세요."));
        } else if (amt > lendableAmount) {
            var reserveInfo = "현재 은행의 대출 가능 한도를 초과했습니다.\n(지급준비율 " + (bConf.RESERVE_RATIO * 100) + "% 준수 중)\n\n" + "🏦 현재 금고: " + fp(roomData.bankReserve) + "P\n" + "🛡️ 법정 준비금: " + fp(requiredReserve) + "P\n" + "💰 실제 대출 가능액: " + fp(Math.max(0, lendableAmount)) + "P";
            replier.reply(formatError(user, "은행 자금 동결", reserveInfo));
        } else if ((user.dailyLoanCount || 0) >= lConf.DAILY_LIMIT) {
            delete bankProcessState[targetUid];
            replier.reply(formatError(user, "대출 제한", "대출은 하루에 최대 " + lConf.DAILY_LIMIT + "회까지만 가능합니다."));
        } else if (amt > cr.limit) {
            replier.reply(formatError(user, "한도 초과", cr.label + "의 최대 한도는 " + fp(cr.limit) + "P입니다."));
        } else {
            user.dailyLoanCount = (user.dailyLoanCount || 0) + 1;
            
            // [수정] 대출 실행 시 횟수와 상관없이 즉시 신용점수 -20점 하락 페널티 적용
            user.creditScore = Math.max(0, Number(user.creditScore || 600) - 100);
            checkAndHandleDefaulter(user, roomName);

            var dynMult = (typeof util_getDynamicRateMultiplier === 'function') ? util_getDynamicRateMultiplier(roomName) : 1.0;

            // [기부왕] 실행 시 선이자 30% 감면
            var rateGap = (cr.rate - 1) * dynMult;
            var finalRate = 1 + rateGap;

            var total = Math.floor(amt * finalRate);
            if (!user.loan || typeof user.loan !== 'object') user.loan = { debt: 0, items: [] };
            if (!user.loan.items) user.loan.items = [];

            var isHighValue = (amt >= (cr.limit * 0.8)); 
            
            // 기존 단순 숫자 push 대신 객체 형태로 저장하여 속성 부여
            user.loan.items.push({ 
                amount: Number(total), 
                isHigh: isHighValue,
                date: Date.now() 
            });

            user.loan.debt = Number(user.loan.debt || 0) + Number(total);
            util_updatePoint(user, roomData, amt, "은행 대출 실행", roomName);

            // [추가]: 유저 상태에 따른 자동 상환 비율 판정 및 안내 문구 조립
            var autoRepayRate = user.isTransferred ? "70%" : (user.creditScore < 500 ? "50%" : "30%");
            var successContent = fp(amt) + "P 입금 완료\n(상환 예정액: " + fp(total) + "P)\n\n" +
                                 "📢 [자동 상환 안내]\n" +
                                 "향후 발생하는 모든 수익의 " + autoRepayRate + "가\n" +
                                 "대출금으로 자동 상환됩니다.\n\n" +
                                 "📉 [신용 하락]: 대출 실행으로 점수가 -100점 하락했습니다.";

            replier.reply(formatCommand("🏦 대출 승인", user, successContent, "보유 포인트: " + fp(user.point) + "P"));
            delete bankProcessState[targetUid];
            safeSaveData(data);
        }
        return true;
    }

        /* [기능 3] 상환 처리 */
    else if (state.type === 'repay') {
        var amt = parseInt(msg.replace(/,/g, ""));
        if (isNaN(amt) || amt <= 0) {
            replier.reply(formatError(user, "금액 오류", "상환할 숫자를 입력하세요."));
        } else if (user.point < amt) {
            replier.reply(formatError(user, "포인트 부족", "보유하신 포인트가 상환액보다 적습니다."));
        } else {
            var res = distributeRepayment(user, amt, roomName);
            util_updatePoint(user, roomData, -Number(res.actualRepay), "대출 상환", roomName);
            var currentDebt = (user.loan && user.loan.debt) ? Number(user.loan.debt) : 0;
            var repaySuccessMsg = fp(res.actualRepay) + "P 상환되었습니다.";
            
            // 신용 회복 조건 달성 시에만 문구 삽입
            if (res.creditGain > 0) {
                repaySuccessMsg += "\n📈 신용 점수 +" + res.creditGain + " 상승";
            }
            
            repaySuccessMsg += "\n\n🏦 은행 재원 충전: +" + fp(res.actualRepay) + "P";

            replier.reply(formatCommand("📉 상환 완료", user, repaySuccessMsg, "남은 대출금: " + fp(currentDebt) + "P"));
            delete bankProcessState[targetUid];
            safeSaveData(data);
        }
        return true;
    }
    return false;
}
            
//==========섹터22-3==========

/* [독립형 함수] 통합 업무 처리 핸들러 3단계: 사채 등록 및 빌리기 */
function _handleBankStep3(msg, user, data, replier, roomName, targetUid) {
    var bankProcessState = data.rooms[roomName].features.states.bankProcess;
    if (!bankProcessState || !bankProcessState[targetUid]) return false;

    var state = bankProcessState[targetUid];
    var types = ['p2p_reg_input', 'p2p_borrow_amt'];
    if (types.indexOf(state.type) === -1) return false;

    if (Date.now() - state.time > 30000) {
        delete bankProcessState[targetUid];
        replier.reply(formatError(user, "입력 시간 초과", "입력 시간이 30초를 초과했습니다."));
        return true;
    }
    if (msg === "취소") {
        delete bankProcessState[targetUid];
        replier.reply(formatCommand("🚫 업무 취소", user, "업무가 취소되었습니다."));
        return true;
    }

    var roomData = data.rooms[roomName];

    /* [기능 1] 사채 등록 */
    if (state.type === 'p2p_reg_input') {
        var parts = msg.split(" ");
        if (parts.length < 2) {
            replier.reply(formatError(user, "입력 오류", "형식: [금액] [이율]\n예) 10000 5"));
        } else {
            var amt = parseInt(parts[0]);
            var rate = parseInt(parts[1]);
            var conf = SYSTEM_CONFIG.ECO.PRIVATE_LOAN;

            if (isNaN(amt) || amt < conf.MIN_AMOUNT) {
                replier.reply(formatError(user, "금액 오류", "최소 " + fp(conf.MIN_AMOUNT) + "P 이상 등록 가능합니다."));
            } else if (isNaN(rate) || rate < 5 || rate > conf.MAX_RATE) {
                replier.reply(formatError(user, "이율 오류", "이율은 5% ~ " + conf.MAX_RATE + "% 사이로 설정하세요."));
            } else if (user.point < amt) {
                replier.reply(formatError(user, "포인트 부족", "보유 포인트가 부족합니다."));
            } else {
                util_updatePoint(user, roomData, -amt, "사채 풀 등록", roomName);
                var poolId = generateUUID();
                if (!roomData.loanPools) roomData.loanPools = {};
                roomData.loanPools[poolId] = {
                    lenderUid: targetUid, lenderName: user.name, totalAmount: amt,
                    remainingAmount: amt, rate: rate, time: Date.now()
                };

                // 3. 상태 해제 (중복 입력 방지)
                if (bankProcessState) delete bankProcessState[targetUid];

                // 4. [보안] 물리 저장 전 면제권 부여 및 즉시 저장 집행
                user.skipHealing = true; 
                safeSaveData(data, true); // 비동기 큐를 거치지 않고 즉시 물리 파일 기록

                replier.reply(formatCommand("💰 사채 등록 완료", user, fp(amt) + "P (이자 " + rate + "%/3h) 매물을 올렸습니다.", "남은 잔액: " + fp(user.point) + "P"));
            }
        }
        return true;
    }

        /* [기능 2] 사채 빌리기 */
    else if (state.type === 'p2p_borrow_amt') {
        var amt = parseInt(msg);
        var pool = roomData.loanPools[state.extra.poolId];
        var conf = SYSTEM_CONFIG.ECO.PRIVATE_LOAN;

        if (!pool) {
            replier.reply(formatError(user, "매물 정보 없음", "유효하지 않은 매물입니다."));
        } else if (isNaN(amt) || amt < conf.MIN_BORROW) {
            replier.reply(formatError(user, "금액 오류", "최소 " + fp(conf.MIN_BORROW) + "P 이상 빌려야 합니다."));
        } else if (amt > pool.remainingAmount) {
            replier.reply(formatError(user, "금액 초과", "잔여 금액(" + fp(pool.remainingAmount) + "P)까지만 가능합니다."));
        } else if (pool.lenderUid === targetUid) {
            replier.reply(formatError(user, "계약 불가", "본인 사채는 빌릴 수 없습니다."));
        } else {
            pool.remainingAmount -= amt;
            if (pool.remainingAmount <= 0) delete roomData.loanPools[state.extra.poolId];
            var initialDebt = Math.floor(amt * 1.1);
            var contractId = generateUUID();
            if (!roomData.loanContracts) roomData.loanContracts = {};
            roomData.loanContracts[contractId] = {
                lenderUid: pool.lenderUid, lenderName: pool.lenderName,
                borrowerUid: targetUid, borrowerName: user.name,
                principal: amt, currentDebt: initialDebt, rate: pool.rate,
                startTime: Date.now(), status: 'active'
            };
            util_updatePoint(user, roomData, amt, "사채 빌림 회수 승인", roomName);
            replier.reply(formatCommand("📝 사채 계약 체결", user, pool.lenderName + "님으로부터 " + fp(amt) + "P를 빌렸습니다.\n(선이자 10% 포함 채무: " + fp(initialDebt) + "P)", "내 잔액: " + fp(user.point) + "P"));
            delete bankProcessState[targetUid];
            safeSaveData(data);
        }
        return true;
    }
    return false;
}

//==========섹터22-4==========

/* [독립형 함수] 통합 업무 처리 핸들러 4단계: 사채 상환/회수/수거 */
function _handleBankStep4(msg, user, data, replier, roomName, targetUid) {
    var bankProcessState = data.rooms[roomName].features.states.bankProcess;
    if (!bankProcessState || !bankProcessState[targetUid]) return false;

    var state = bankProcessState[targetUid];
    var types = ['p2p_repay_amt', 'p2p_withdraw_amt', 'p2p_collect_manual'];
    if (types.indexOf(state.type) === -1) return false;

    if (Date.now() - state.time > 30000 || msg === "취소") {
        delete bankProcessState[targetUid];
        if (msg === "취소") replier.reply(formatCommand("🚫 업무 취소", user, "업무가 취소되었습니다."));
        else replier.reply(formatError(user, "입력 시간 초과", "입력 시간이 초과되었습니다."));
        return true;
    }

    var roomData = data.rooms[roomName];

    /* [기능 1] 사채 상환 */
    if (state.type === 'p2p_repay_amt') {
        var amt = parseInt(msg);
        var contract = roomData.loanContracts[state.extra.contractId];
        if (!contract) {
            replier.reply(formatError(user, "계약 정보 없음"));
        } else if (isNaN(amt) || amt <= 0 || user.point < amt) {
            replier.reply(formatError(user, "금액/포인트 오류"));
        } else {
            var actualRepay = Math.min(amt, contract.currentDebt);
            util_updatePoint(user, roomData, -actualRepay, "사채 상환 지불", roomName);
            var lender = roomData.users[contract.lenderUid];
            if (lender) util_updatePoint(lender, roomData, actualRepay, "사채 이자 수입", roomName);
            
            contract.currentDebt -= actualRepay;
            var footerMsg = "남은 빚: " + fp(contract.currentDebt) + "P";
            if (contract.currentDebt <= 0) {
                delete roomData.loanContracts[state.extra.contractId];
                footerMsg = "모든 채무가 변제되었습니다.";
            }
            replier.reply(formatCommand("📉 사채 상환 완료", user, contract.lenderName + "님께 " + fp(actualRepay) + "P를 갚았습니다.\n" + footerMsg, "내 잔액: " + fp(user.point) + "P"));
            delete bankProcessState[targetUid];
            safeSaveData(data);
        }
        return true;
    }

        /* [기능 2] 사채 매물 회수 */
    else if (state.type === 'p2p_withdraw_amt') {
        var amt = (msg === "전액") ? state.extra.max : parseInt(msg);
        var pool = roomData.loanPools[state.extra.poolId];
        if (!pool) {
            replier.reply(formatError(user, "매물 정보 없음"));
        } else if (isNaN(amt) || amt <= 0 || amt > pool.remainingAmount) {
            replier.reply(formatError(user, "금액 오류"));
        } else {
            pool.remainingAmount -= amt;
            util_updatePoint(user, roomData, amt, "사채 풀 직접 수거", roomName);
            if (pool.remainingAmount <= 0) delete roomData.loanPools[state.extra.poolId];
            replier.reply(formatCommand("✅ 사채 회수 완료", user, fp(amt) + "P를 회수했습니다.", "내 잔액: " + fp(user.point) + "P"));
            delete bankProcessState[targetUid];
            safeSaveData(data);
        }
        return true;
    }

        /* [기능 3] 채무자 강제 수거 */
    else if (state.type === 'p2p_collect_manual') {
        var contract = roomData.loanContracts[state.extra.contractId];
        if (!contract) {
            replier.reply(formatError(user, "계약 정보 없음"));
        } else {
            var debtor = roomData.users[contract.borrowerUid];
            if (!debtor) {
                replier.reply(formatError(user, "채무자 정보 없음"));
            } else {
                var collectAmt = Math.min(Number(debtor.point), contract.currentDebt);
                if (collectAmt <= 0) {
                    replier.reply(formatError(user, "수거 실패", "채무자의 지갑이 비어있습니다."));
                } else {
                    util_updatePoint(debtor, roomData, -collectAmt, "사채 강제 수거 당함", roomName);
                    util_updatePoint(user, roomData, collectAmt, "사채 직접 수거 수익", roomName);
                    contract.currentDebt -= collectAmt;
                    var footer = "남은 빚: " + fp(contract.currentDebt) + "P";
                    if (contract.currentDebt <= 0) {
                        delete roomData.loanContracts[state.extra.contractId];
                        footer = "모든 채무가 변제되었습니다.";
                    }
                    replier.reply(formatCommand("🚬 강제 수거 완료", user, debtor.name + "님에게서 " + fp(collectAmt) + "P를 수거했습니다.\n" + footer, "내 잔액: " + fp(user.point) + "P"));
                    safeSaveData(data);
                }
            }
        }
        delete bankProcessState[targetUid];
        return true;
    }
    return false;
}

//==========섹터22-5==========

/* [독립형 함수] 통합 업무 처리 핸들러 5단계: 상점 아이템 구매 및 수량 처리 */
function _handleBankStep5(msg, user, data, replier, roomName, targetUid) {
    var bankProcessState = data.rooms[roomName].features.states.bankProcess;
    if (!bankProcessState || !bankProcessState[targetUid]) return false;

    var state = bankProcessState[targetUid];
    var types = ['shop_buy', 'shop_quantity', 'ship_rename_input', 'ship_rename_confirm'];
    if (types.indexOf(state.type) === -1) return false;

    // [1:1 전용 가드] 상점 및 선박 관리 기능은 1:1방에서 차단 (요청 사항 반영)
    if (ALLOWED_ROOMS.indexOf(roomName) === -1) {
        delete bankProcessState[targetUid];
        replier.reply("🚫 [기능 제한]\n상점 및 선박 이름 변경은 단체방('내리다')에서만 가능합니다.\n\n✅ 1:1 가능: 카지노, 은행, 내정보");
        return true;
    }

    // 공통 네비게이션 바 정의 (중간 단계 안내용)
    var SHOP_NAV = "\n\n↩️ 뒤로 / 🏠 처음으로 / ❎취소";

    // 1. 공통 가드 및 취소 로직
    if (Date.now() - state.time > 30000 || msg === "취소" || msg === "❎취소") {
        delete bankProcessState[targetUid];
        var cancelMsg = state.type.indexOf('ship_') !== -1 ? "선박 명명 절차를 중단했습니다." : "상점 이용을 종료합니다.";
        replier.reply(formatCommand("🚫 작업 취소", user, cancelMsg));
        return true;
    }

    if (msg === "처음으로" || msg === "🏠 처음으로") {
        delete bankProcessState[targetUid];
        return _gameShopLogic("/상점", user, data, replier, roomName, targetUid);
    }

    if (msg === "뒤로" || msg === "↩️ 뒤로") {
        // [수정] 각 상태별로 한 단계 전 메뉴로 돌아가도록 분기 처리
        if (state.type === 'shop_quantity') {
            var prevItems = state.extra.prevItems || [];
            bankProcessState[targetUid] = { type: 'shop_buy', time: Date.now(), extra: { items: prevItems } };
            var list = prevItems.map(function(it, i) { return (i + 1) + ". " + it.icon + " " + it.name + " : " + fp(getItemPrice(it, user, roomName)) + "P"; });
            replier.reply(formatCommand("🛒 상점 물품 목록", user, list.join("\n") + SHOP_NAV, "구매할 번호를 입력하세요."));
        } else if (state.type === 'shop_buy' || state.type === 'ship_rename_input') {
            delete bankProcessState[targetUid];
            return _gameShopLogic("/상점", user, data, replier, roomName, targetUid);
        } else if (state.type === 'ship_rename_confirm') {
            // 확인창에서 뒤로가면 다시 이름 입력창으로 이동
            bankProcessState[targetUid] = { type: 'ship_rename_input', time: Date.now(), extra: state.extra };
            replier.reply(formatCommand("📝 선박 이름 입력", user, "변경하실 선박의 이름을 다시 입력해주세요.\n(2~8자, 띄어쓰기 포함)" + SHOP_NAV, "취소: [취소]"));
        }
        return true;
    }

    // 2. 선박 이름 입력 처리 (띄어쓰기 수용 및 확인 단계로 이동)
    if (state.type === 'ship_rename_input') {
        var inputName = msg.trim(); // 앞뒤 공백만 제거하여 중간 띄어쓰기 보존
        if (inputName.length < 2 || inputName.length > 8) {
            replier.reply(formatError(user, "이름 길이 오류", "2~8글자 사이로 입력해주세요." + SHOP_NAV));
            return true;
        }
        if (!/^[a-zA-Z0-9가-힣\s]+$/.test(inputName)) {
            replier.reply(formatError(user, "사용 불가 문자", "특수문자는 사용할 수 없습니다." + SHOP_NAV));
            return true;
        }
        
        var isDup = false;
        for (var r in data.rooms) { 
            for (var uId in data.rooms[r].users) { 
                if (data.rooms[r].users[uId].shipName === inputName) { isDup = true; break; } 
            } 
            if (isDup) break; 
        }
        if (isDup) { replier.reply(formatError(user, "이름 중복", "이미 사용 중인 이름입니다." + SHOP_NAV)); return true; }

        // 확인 단계(Confirm) 상태로 전이
        bankProcessState[targetUid] = { 
            type: 'ship_rename_confirm', 
            time: Date.now(), 
            extra: { newName: inputName, price: state.extra.price } 
        };
        
        var confirmMsg = "새로운 선박 이름: [" + inputName + "]\n\n이 이름으로 최종 결정하시겠습니까?\n결정 시 이름변경권이 즉시 사용됩니다.\n\n1. 예 (변경 승인)\n2. 아니오 (재입력)" + SHOP_NAV;
        replier.reply(formatCommand("⚓ 선박 명명 확인", user, confirmMsg, "번호를 선택하세요."));
        return true;
    }

    // 3. 선박 이름 최종 확정 (로직 종료 지점 - 대기 삭제 및 네비게이션 제거)
    if (state.type === 'ship_rename_confirm') {
        if (msg === "1" || msg === "예") {
            var finalName = state.extra.newName;
            var cost = state.extra.price || 0;
            
            // [종료 처리] 결제 직전 대기열을 먼저 삭제하여 중복 입력을 차단합니다.
            delete bankProcessState[targetUid];

            if (Number(user.point) < cost) {
                replier.reply(formatError(user, "결제 실패", "잔액이 부족하여 취소되었습니다."));
                return true;
            }
            
            util_updatePoint(user, data.rooms[roomName], -cost, "선박 이름 변경권 사용", roomName);
            user.shipName = finalName;
            
            // [완료 메시지] 끝나는 지점이므로 SHOP_NAV 없이 깔끔하게 출력
            replier.reply(formatCommand("🚢 선박 명명식 완료", user, "성공적으로 [" + finalName + "](으)로 변경되었습니다!", "무역 현황: [/무역]"));
            safeSaveData(data);
        return true; // 로직 종료 명시
        } else if (msg === "2" || msg === "아니오") {
            bankProcessState[targetUid] = { type: 'ship_rename_input', time: Date.now(), extra: state.extra };
            replier.reply(formatCommand("📝 선박 이름 입력", user, "변경하실 이름을 다시 입력해주세요." + SHOP_NAV));
            return true; // 로직 종료 명시
        }
        return true;
    }
    if (msg.startsWith("/")) {
        delete bankProcessState[targetUid];
        return false;
    }

    var roomData = data.rooms[roomName];

    /* [기능 1] 상점 아이템 번호 선택 처리 */
    if (state.type === 'shop_buy') {
        var idx = parseInt(msg.replace(/[^0-9]/g, "")) - 1;
        var filteredItems = (state.extra && state.extra.items) ? state.extra.items : [];

        if (isNaN(idx) || idx < 0 || idx >= filteredItems.length) {
            replier.reply(formatError(user, "번호 오류", "목록에 있는 번호를 입력해주세요." + SHOP_NAV));
        } else {
            var item = filteredItems[idx];

            /* 예외 처리 1: 신용 점수 회복제 일일 제한 */
            if (item.effect === "credit" && (user.dailyCreditRestoreCount || 0) >= 1) {
                delete bankProcessState[targetUid];
                replier.reply(formatError(user, "구매 제한", "신용 점수 회복제는 하루에 1개만 사용 가능합니다."));
                return true;
            }

            /* 예외 처리 2: 경고삭제권 제한 로직 (평생 1회 + 사채 보유 시 불가) */
            if (item.effect === "warnClear") {
                if (user.boughtWarningRemoval === true) {
                    delete bankProcessState[targetUid];
                    replier.reply(formatError(user, "구매 불가", "경고삭제권은 평생 단 1회만 구매 가능합니다."));
                    return true;
                }
                var hasSache = false;
                if (roomData.loanContracts) {
                    for (var cid in roomData.loanContracts) {
                        if (roomData.loanContracts[cid].borrowerUid === targetUid) { hasSache = true; break; }
                    }
                }
                if (hasSache) {
                    delete bankProcessState[targetUid];
                    replier.reply(formatError(user, "구매 제한", "사채를 모두 상환한 후에만 구매가 가능합니다."));
                    return true;
                }
            }

            /* 예외 처리 3: 게임 인증권 시즌 2회 제한 */
            if (item.effect === "gameAuth" && (user.purchasedAuthCount || 0) >= 2) {
                delete bankProcessState[targetUid];
                replier.reply(formatError(user, "구매 한도 초과", "인증권은 시즌당 최대 2회까지만 구매 가능합니다."));
                return true;
            }

            // 수량 입력 단계로 전환 시 현재 아이템 목록을 저장(뒤로가기용)
            if (["promotion", "tierGuard", "randomBox", "spitto", "trade_cargo"].indexOf(item.effect) !== -1) {
                var itemPrice = getItemPrice(item, user, roomName); 
                bankProcessState[targetUid] = { 
                    type: 'shop_quantity', 
                    time: Date.now(), 
                    extra: { item: item, prevItems: filteredItems } // prevItems 추가
                };
                
                var quantityInfo = "구매하실 [" + item.name + "]의 수량을 입력해주세요.\n\n" +
                                   "💵 개당 가격: " + fp(itemPrice) + "P\n" +
                                   "💰 보유 포인트: " + fp(user.point) + "P" + SHOP_NAV;
                                   
                replier.reply(formatCommand("🔢 수량 입력", user, quantityInfo, "취소: [취소]"));
            } else {
                /* 단권 구매 로직 */
                var finalPrice = getItemPrice(item, user, roomName);
                var isUsingTicket = (item.effect === "randomBox" && (user.boxTickets || 0) > 0);

                if (!isUsingTicket && Number(user.point) < finalPrice) {
                    delete bankProcessState[targetUid];
                    replier.reply(formatError(user, "포인트 부족", fp(finalPrice) + "P가 필요합니다."));
                } else {
                    var hasItem = false;
                    if (item.effect === "icon" || item.effect === "title") {
                        var inv = user.inventory || [];
                        for (var i = 0; i < inv.length; i++) { if (inv[i].id === item.id) { hasItem = true; break; } }
                    }

                    if (hasItem) {
                        delete bankProcessState[targetUid];
                        replier.reply(formatError(user, "중복 소유", "이미 보유 중인 아이템입니다."));
                    } else {
                        var isDelayedBilling = (item.effect === "ship_rename");

                       if (!isUsingTicket && !isDelayedBilling) {
                            util_updatePoint(user, roomData, -finalPrice, "상점 구매: " + item.name, roomName);
                        }
                        delete bankProcessState[targetUid];
                        if (typeof _handleShopEffect === 'function') _handleShopEffect(item, user, roomName, replier, data, targetUid, finalPrice, isUsingTicket, 1);
                    } // closes else (M)
                } // closes else (H)
            } // closes else (E/107행) <--- [교정] 이 중괄호가 누락되어 있었습니다!
            return true;
        } // closes if (state.type === 'shop_buy')
    }

    /* [기능 2] 수량 입력 처리 (로직 종료 지점) */
    else if (state.type === 'shop_quantity') {
        var item = (state.extra && state.extra.item) ? state.extra.item : null;
        if (!item) { delete bankProcessState[targetUid]; return true; }

        var qty = parseInt(msg.replace(/[^0-9]/g, ""));
        if (isNaN(qty) || qty <= 0) {
            // 다시 입력을 기다리는 구간은 내비게이션 바 포함
            replier.reply(formatError(user, "입력 오류", "숫자로 수량을 입력해주세요." + SHOP_NAV));
        } else {
            var multiplier = util_getEcoMultiplier(roomName);
            var basePrice = Math.floor(Number(item.price) * multiplier);
            if (user.title === "수집대마왕") basePrice = Math.floor(basePrice * 0.85);
            
            var totalPrice = 0;

            if (item.id === 8) { 
                var count = Number(user.purchasedPromotionAttempts || 0);
                var d = Math.floor(basePrice * 0.10); // 할증 단위 (10%)
                
                // 등차수열의 합 공식: Sn = n/2 * [2a + (n-1)d]
                // a = 현재 살 수 있는 첫 번째 유닛의 가격
                var a = basePrice + (d * count);
                totalPrice = Math.round((qty / 2) * (2 * a + (qty - 1) * d));
            } else {
                totalPrice = getItemPrice(item, user, roomName) * qty; 
            }

            if (Number(user.point) < totalPrice) {

                replier.reply(formatError(user, "포인트 부족", "총 " + fp(totalPrice) + "P가 필요합니다." + SHOP_NAV));
            } else {
                // [종료 처리] 결제가 성공했으므로 대기 상태를 삭제합니다.
                delete bankProcessState[targetUid]; 

                if (item.effect !== "trade_cargo") {
                    util_updatePoint(user, roomData, -totalPrice, "상점 구매: " + item.name + " x" + qty, roomName);
                }
                
                // 최종 효과 발동 (메시지는 섹터 30에서 네비게이션 없이 출력됨)
                if (typeof _handleShopEffect === 'function') {
                    _handleShopEffect(item, user, roomName, replier, data, targetUid, totalPrice, false, qty);
                }
                return true; 
            }
        } 
        return true; 
    } 
    return false;
}

//==========섹터23-1==========

/* [독립형 함수] 메뉴 선택 대기 처리 1단계 (메인 메뉴 분기) */
function _handleMenuStep1(msg, user, data, replier, roomName, targetUid) {
    var menuWaitState = data.rooms[roomName].features.states.menuWait;
    if (!menuWaitState || !menuWaitState[targetUid]) return false;

    var state = menuWaitState[targetUid];
    var now = Date.now();

    // 1. [시간 초과 체크] 30초 통일
    if (now - state.time > 30000) {
        delete menuWaitState[targetUid];
        replier.reply(formatError(user, "입력 시간 초과", "30초 이내에 번호를 선택하지 않아 메뉴가 닫혔습니다."));
        return true;
    }

    // 2. 취소 입력 시 처리
    if (msg === "취소") {
        delete menuWaitState[targetUid];
        replier.reply(formatCommand("🚫 메뉴 선택 취소", user, "작업이 취소되었습니다."));
        return true;
    }

    // 3. [명령어 가드] 명령어(/) 입력 시 대기 상태를 유지하되, 처리는 하위 로직에 위임
    if (msg.startsWith("/")) {
        return false;
    }

    var roomData = data.rooms[roomName];
    // 중앙은행 재원 초기화 (UI 출력용)
    if (roomData.bankReserve === undefined) roomData.bankReserve = SYSTEM_CONFIG.ECO.BANK.INITIAL_RESERVE;

    var choice = msg.trim();
    var bankProcessState = roomData.features.states.bankProcess; // 상태값 할당을 위해 참조

    /* [1단계] 은행 메인 메뉴 선택 처리 (v5.2 기부 선택 추가) */
    if (state.type === 'bank_menu') {
        delete menuWaitState[targetUid]; // 메뉴 선택 완료 시 대기 상태 해제

        if (choice === "1") {
            bankProcessState[targetUid] = { type: 'deposit', time: Date.now() };
            replier.reply(formatCommand("💰 예금 진행", user, "예금할 금액을 입력해주세요.\n(보유: " + fp(user.point) + "P)", "취소: [취소]"));
        } else if (choice === "2") {
            bankProcessState[targetUid] = { type: 'withdraw', time: Date.now() };
            replier.reply(formatCommand("🏧 출금 진행", user, "출금할 금액을 입력해주세요.\n(잔고: " + fp(user.bank) + "P)", "취소: [취소]"));
        } else if (choice === "3") {
            bankProcessState[targetUid] = { type: 'transfer', time: Date.now() };
            replier.reply(formatCommand("💸 송금 진행", user, "받을 사람의 [닉네임]과 [금액]을 띄어쓰기로 입력하세요.\n(예: 홍길동 5000)", "취소: [취소]"));
        } else if (choice === "4") {
            var cr = getCreditInfo(user.creditScore);
            if (cr.limit <= 0) {
                replier.reply(formatError(user, "대출 불가", "신용등급이 너무 낮습니다."));
            } else {
                bankProcessState[targetUid] = { type: 'loan', time: Date.now() };
                var loanMsg = "희망 대출금을 입력해주세요.\n" +
                              "내 한도: " + fp(cr.limit) + "P (이율: " + ((cr.rate - 1) * 100).toFixed(0) + "%)\n" +
                              "🏦 은행 가용 재원: " + fp(roomData.bankReserve) + "P";
                replier.reply(formatCommand("🏦 대출 진행", user, loanMsg, "취소: [취소]"));
            }
        } else if (choice === "5") {
            if (!user.loan || user.loan.debt <= 0) {
                replier.reply(formatError(user, "상환 불가", "갚을 대출금이 없습니다."));
            } else {
                bankProcessState[targetUid] = { type: 'repay', time: Date.now() };
                replier.reply(formatCommand("📉 상환 진행", user, "상환할 금액을 입력해주세요.\n(대출 잔액: " + fp(user.loan.debt) + "P)\n보유 포인트: " + fp(user.point) + "P", "취소: [취소]"));
            }
        } else if (choice === "6") {
            // [중요] 사채 메뉴 선택 시에는 bankProcess가 아닌 menuWaitState를 갱신해야 함 (서브 메뉴 이동)
            menuWaitState[targetUid] = { type: 'p2p_loan_menu', time: Date.now() };
            var p2pMenu = "1. 💰 사채 등록 (매물 올리기)\n" +
                          "2. 📋 사채 목록 (분할 대출 받기)\n" +
                          "3. 📉 사채 상환 (빌린 돈 갚기)\n" +
                          "4. 📥 사채 회수 (등록 매물 회수)\n" +
                          "5. 👥 내 채무자 현황 (직접 수거 가능)";
            replier.reply(formatCommand("🚬 사채 시장 업무 선택", user, p2pMenu, "원하시는 번호를 입력하세요."));
            return true; // 여기서 true 반환하여 종료 (다음 로직 수행 X)
        } else if (choice === "7") {
            bankProcessState[targetUid] = { type: 'donate', time: Date.now() };
            replier.reply(formatCommand("🎁 기부 진행", user, "기부할 금액을 입력해주세요.\n(보유: " + fp(user.point) + "P)", "취소: [취소]"));
        } else {
            // 잘못된 번호 입력 시 다시 메뉴 대기 상태로 복구? 
            // 기획 의도상 메뉴가 닫히는 게 일반적이므로 에러 메시지 후 종료 처리
            replier.reply(formatError(user, "번호 오류", "올바른 메뉴 번호를 선택해주세요."));
        }
        return true;
    }
    return false; // 이 함수에서 처리하지 않은 state.type인 경우 (예: p2p_loan_menu 등)
}

//==========섹터23-2==========

/* [독립형 함수] 메뉴 선택 대기 처리 2단계 (사채 시장 서브 메뉴) */
function _handleMenuStep2(msg, user, data, replier, roomName, targetUid) {
    var menuWaitState = data.rooms[roomName].features.states.menuWait;
    if (!menuWaitState || !menuWaitState[targetUid]) return false;

    var state = menuWaitState[targetUid];
    // 이 함수는 'p2p_loan_menu' 타입만 처리합니다.
    if (state.type !== 'p2p_loan_menu') return false;

    // 1. [시간 초과 및 취소 가드]
    if (Date.now() - state.time > 30000 || msg === "취소") {
        delete menuWaitState[targetUid];
        if (msg === "취소") replier.reply(formatCommand("🚫 사채 업무 취소", user, "작업이 취소되었습니다."));
        else replier.reply(formatError(user, "입력 시간 초과", "30초 이내에 번호를 선택하지 않아 메뉴가 닫혔습니다."));
        
        // 명령어 입력 시에는 false를 반환하여 하위 로직으로 전달
        if (msg.startsWith("/")) return false;
        return true;
    }

    // 2. [명령어 통로]
    if (msg.startsWith("/")) {
        delete menuWaitState[targetUid];
        return false;
    }

    var choice = msg.trim();
    var roomData = data.rooms[roomName];
    var bankProcessState = roomData.features.states.bankProcess;

    // 선택지 처리 시작 (일단 현재 대기 상태 해제)
    delete menuWaitState[targetUid];

    if (choice === "1") {
        bankProcessState[targetUid] = { type: 'p2p_reg_input', time: Date.now() };
        replier.reply(formatCommand("💰 사채 매물 등록", user, "등록할 [금액]과 [이율]을 입력하세요.\n(예: 10000 5)", "취소: [취소]"));
    }
    else if (choice === "2") {
        var pools = Object.keys(roomData.loanPools || {});
        if (pools.length === 0) {
            replier.reply(formatSimple("📋 사채 시장", "현재 등록된 매물이 없습니다.", null));
        } else {
            var list = []; 
            var tempPools = [];
            for(var i=0; i<pools.length; i++) {
                var p = roomData.loanPools[pools[i]];
                list.push((i+1) + ". [" + p.lenderName + "] 잔여: " + fp(p.remainingAmount) + "P (" + p.rate + "%)");
                tempPools.push(pools[i]);
            }
            menuWaitState[targetUid] = { type: 'p2p_select_pool', time: Date.now(), extra: { pools: tempPools } };
            replier.reply(formatCommand("📋 사채 매물 목록", user, list.join("\n"), "빌리고 싶은 매물 번호를 입력하세요."));
        }
    }
    else if (choice === "3") {
        var myContracts = [];
        if (roomData.loanContracts) {
            for(var id in roomData.loanContracts) {
                if(roomData.loanContracts[id].borrowerUid === targetUid) myContracts.push({ id: id, data: roomData.loanContracts[id] });
            }
        }
        if (myContracts.length === 0) {
            replier.reply(formatError(user, "내역 없음", "현재 이 방에서 빌려 쓰고 있는 사채가 없습니다."));
        } else {
            var list = [];
            for(var i=0; i<myContracts.length; i++) {
                var c = myContracts[i].data;
                list.push((i+1) + ". [" + c.lenderName + "] 채무액: " + fp(c.currentDebt) + "P (이율 " + c.rate + "%)");
            }
            menuWaitState[targetUid] = { type: 'p2p_select_repay', time: Date.now(), extra: { contracts: myContracts.map(function(x){return x.id;}) } };
            replier.reply(formatCommand("📉 사채 상환 선택", user, list.join("\n"), "갚을 사채의 번호를 선택하세요."));
        }
    }
    else if (choice === "4") {
        var myPools = [];
        if (roomData.loanPools) {
            for(var id in roomData.loanPools) {
                if(roomData.loanPools[id].lenderUid === targetUid) myPools.push({ id: id, data: roomData.loanPools[id] });
            }
        }
        if (myPools.length === 0) {
            replier.reply(formatError(user, "내역 없음", "이 방에 올려둔 사채 풀이 없습니다."));
        } else {
            var list = [];
            for(var i=0; i<myPools.length; i++) {
                var p = myPools[i].data;
                list.push((i+1) + ". 잔여: " + (p.remainingAmount) + "P (이율 " + p.rate + "%/3h)");
            }
            menuWaitState[targetUid] = { type: 'p2p_select_withdraw', time: Date.now(), extra: { pools: myPools.map(function(x){return x.id;}) } };
            replier.reply(formatCommand("📥 사채 풀 회수", user, list.join("\n"), "회수할 사채 풀 번호를 선택하세요."));
        }
    }
    else if (choice === "5") {
        var myDebtors = [];
        if (roomData.loanContracts) {
            for(var id in roomData.loanContracts) {
                if(roomData.loanContracts[id].lenderUid === targetUid) myDebtors.push({ id: id, data: roomData.loanContracts[id] });
            }
        }
        if (myDebtors.length === 0) {
            replier.reply(formatSimple("👥 내 채무자 현황", "현재 돈을 빌려 간 유저가 없습니다.", null));
        } else {
            var list = [];
            var tempContracts = [];
            for(var i=0; i<myDebtors.length; i++) {
                var d = myDebtors[i].data;
                var status = (Date.now() - d.startTime > 24*60*60*1000) ? " (🚨연체)" : "";
                list.push((i+1) + ". [" + d.borrowerName + "] 빚: " + fp(d.currentDebt) + "P" + status);
                tempContracts.push(myDebtors[i].id);
            }
            menuWaitState[targetUid] = { type: 'p2p_select_collect', time: Date.now(), extra: { contracts: tempContracts } };
            replier.reply(formatCommand("👥 내 채무자 명단", user, list.join("\n"), "강제 수거를 원하시면 유저 번호를 입력하세요."));
        }
    }
    else {
        // 잘못된 번호 입력 처리
        replier.reply(formatError(user, "번호 오류", "올바른 메뉴 번호를 선택해주세요."));
    }

    return true;
}

//==========섹터23-3==========

/* [독립형 함수] 메뉴 선택 대기 처리 3단계 (사채 목록 선택) */
function _handleMenuStep3(msg, user, data, replier, roomName, targetUid) {
    var menuWaitState = data.rooms[roomName].features.states.menuWait;
    if (!menuWaitState || !menuWaitState[targetUid]) return false;

    var state = menuWaitState[targetUid];
    // 이 함수가 처리할 타입 목록 정의 (사채 관련 선택지들)
    var types = ['p2p_select_pool', 'p2p_select_repay', 'p2p_select_withdraw', 'p2p_select_collect'];
    if (types.indexOf(state.type) === -1) return false;

    // 1. [시간 초과 및 취소 가드]
    if (Date.now() - state.time > 30000 || msg === "취소") {
        delete menuWaitState[targetUid];
        if (msg === "취소") replier.reply(formatCommand("🚫 사채 업무 취소", user, "작업이 취소되었습니다."));
        else replier.reply(formatError(user, "입력 시간 초과", "30초 이내에 번호를 선택하지 않아 메뉴가 닫혔습니다."));
        
        if (msg.startsWith("/")) return false;
        return true;
    }

    // 2. [명령어 통로]
    if (msg.startsWith("/")) {
        delete menuWaitState[targetUid];
        return false;
    }

    var choice = msg.trim();
    var roomData = data.rooms[roomName];
    var bankProcessState = roomData.features.states.bankProcess;

    /* [선택 분기 1] 사채 빌리기 매물 선택 */
    if (state.type === 'p2p_select_pool') {
        delete menuWaitState[targetUid];
        var idx = parseInt(choice) - 1;
        var poolId = (state.extra && state.extra.pools) ? state.extra.pools[idx] : null;
        
        if (!poolId || !roomData.loanPools[poolId]) {
            replier.reply(formatError(user, "번호 오류", "목록에 있는 번호를 정확히 입력해주세요."));
        } else {
            bankProcessState[targetUid] = { type: 'p2p_borrow_amt', time: Date.now(), extra: { poolId: poolId } };
            replier.reply(formatCommand("💰 사채 금액 설정", user, "선택 매물: [" + roomData.loanPools[poolId].lenderName + "]\n잔여 금액: " + fp(roomData.loanPools[poolId].remainingAmount) + "P\n\n빌릴 금액을 입력하세요.", "취소: [취소]"));
        }
        return true;
    }

    /* [선택 분기 2] 사채 상환 대상 선택 */
    else if (state.type === 'p2p_select_repay') {
        delete menuWaitState[targetUid];
        var idx = parseInt(choice) - 1;
        var contractId = (state.extra && state.extra.contracts) ? state.extra.contracts[idx] : null;
        
        if (!contractId || !roomData.loanContracts[contractId]) {
            replier.reply(formatError(user, "번호 오류", "상환할 계약 번호를 확인해주세요."));
        } else {
            bankProcessState[targetUid] = { type: 'p2p_repay_amt', time: Date.now(), extra: { contractId: contractId } };
            var contract = roomData.loanContracts[contractId];
            replier.reply(formatCommand("📉 사채 상환액 입력", user, "채권자: [" + contract.lenderName + "]\n남은 빚: " + fp(contract.currentDebt) + "P\n💰 내 잔액: " + fp(user.point) + "P\n\n갚을 금액을 입력하세요.", "취소: [취소]"));
        }
        return true;
    }

    /* [선택 분기 3] 사채 매물 회수 대상 선택 */
    else if (state.type === 'p2p_select_withdraw') {
        delete menuWaitState[targetUid];
        var idx = parseInt(choice) - 1;
        var poolId = (state.extra && state.extra.pools) ? state.extra.pools[idx] : null;
        
        if (!poolId || !roomData.loanPools[poolId]) {
            replier.reply(formatError(user, "번호 오류"));
        } else {
            bankProcessState[targetUid] = { type: 'p2p_withdraw_amt', time: Date.now(), extra: { poolId: poolId, max: roomData.loanPools[poolId].remainingAmount } };
            replier.reply(formatCommand("📥 회수 금액 입력", user, "현재 풀 잔액: " + fp(roomData.loanPools[poolId].remainingAmount) + "P\n\n회수할 금액을 입력하거나 [전액]을 입력하세요.", "취소: [취소]"));
        }
        return true;
    }

    /* [선택 분기 4] 채무자 강제 수거 대상 선택 */
    else if (state.type === 'p2p_select_collect') {
        delete menuWaitState[targetUid];
        var idx = parseInt(choice) - 1;
        var contractId = (state.extra && state.extra.contracts) ? state.extra.contracts[idx] : null;
        
        if (!contractId || !roomData.loanContracts[contractId]) {
            replier.reply(formatError(user, "번호 오류"));
        } else {
            bankProcessState[targetUid] = { type: 'p2p_collect_manual', time: Date.now(), extra: { contractId: contractId } };
            replier.reply(formatCommand("🚬 사채 강제 수거 확인", user, "[" + roomData.loanContracts[contractId].borrowerName + "]님의 지갑에서 자산을 수거하시겠습니까?\n\n진행하시려면 아무 메시지나 입력해주세요.", "취소: [취소]"));
        }
        return true;
    }

    return false;
}

//==========섹터23-4==========

/* [독립형 함수] 메뉴 선택 대기 처리 4단계 (상점/도움말/가이드) */
function _handleMenuStep4(msg, user, data, replier, roomName, targetUid) {
    // [핵심] 숫자 입력 시에는 메인 방이 아니라 '현재 유저가 있는 방(1:1방)'의 대기 상태를 확인해야 함
    var currentRoomData = data.rooms[roomName]; 
    if (!currentRoomData || !currentRoomData.features) return false;
    
    var menuWaitState = currentRoomData.features.states.menuWait;

    if (!menuWaitState || !menuWaitState[targetUid]) return false;

    var state = menuWaitState[targetUid];
    // 처리 가능 타입에 무역(trade) 관련 상태들을 일괄 추가
    var types = [
        'shop_category', 'shop_detail', 'help', 'help_cat', 'help_item', 
        'guide_menu', 'guide_detail', // <-- 가이드 관련 상태 추가
        'trade_main', 'trade_market', 'trade_depart', 'trade_status', 'trade_ship',
        'trade_select_cargo', 'casino_main', 'casino_ladder', 'casino_baccarat',
        'casino_ladder_sub', 'casino_baccarat_sub' 
    ];
    if (types.indexOf(state.type) === -1) return false;

    var NAV_BAR = "\n\n↩️ 뒤로 / 🏠 처음으로 / ❎취소";

    if (Date.now() - state.time > 30000 || msg === "취소" || msg === "❎취소") {
        delete menuWaitState[targetUid];
        if (msg === "취소" || msg === "❎취소") {
            replier.reply(formatCommand("🚫 작업 취소", user, "도움말 및 메뉴 이용을 종료했습니다."));
        } else {
            replier.reply(formatError(user, "선택 시간 초과", "30초 이내에 번호를 선택하지 않아 메뉴가 닫혔습니다."));
        }
        if (msg.startsWith("/")) return false;
        return true;
    }

    // 처음으로 이동
    if (msg === "처음으로" || msg === "🏠 처음으로") {
        if (state.type.startsWith('help')) return _handleHelpEntry(replier, targetUid, menuWaitState);
        if (state.type.startsWith('guide')) return _handleGuideEntry(replier, targetUid, menuWaitState);
        if (state.type.startsWith('shop')) { delete menuWaitState[targetUid]; return _gameShopLogic("/상점", user, data, replier, roomName, targetUid); }
        if (state.type.startsWith('trade')) { delete menuWaitState[targetUid]; return _gameTradeLogic("/무역", user, data, replier, roomName, targetUid); }
    }

    // 뒤로가기 이동
    if (msg === "뒤로" || msg === "↩️ 뒤로") {
        if (state.type === 'trade_select_cargo') {
            var tradeCfg = SYSTEM_CONFIG.TRADE;
            var roomData = data.rooms[roomName];
            state.type = 'trade_depart'; // 상태를 이전 단계로 변경
            state.depth = 2;
            state.time = Date.now();
            _prepareVoyage(user, replier, tradeCfg, roomData); // 목적지 선택 UI 호출
            return true;
        }
        if (state.type === 'help_cat') return _handleHelpEntry(replier, targetUid, menuWaitState);
        if (state.type === 'guide_detail') return _handleGuideEntry(replier, targetUid, menuWaitState);
        if (state.type === 'help_item') {
            var prevCat = state.extra.cat;
            return _handleHelpCategory(replier, user, prevCat, targetUid, menuWaitState, NAV_BAR);
        }
        if (state.type === 'help') { delete menuWaitState[targetUid]; replier.reply("📖 이을 종료했습니다."); return true; }
        // (상점/무역 뒤로가기는 기존 로직 유지)
    }

    // 2. [명령어 통로]
    if (msg.startsWith("/")) {
        delete menuWaitState[targetUid];
        return false;
    }

    var choice = msg.replace(/[^0-9]/g, "").trim();
    var bankProcessState = data.rooms[roomName].features.states.bankProcess;

    /* [기능 1] 상점 카테고리 선택 */
    if (state.type === 'shop_category') {
        var catId = parseInt(choice);
        if (isNaN(catId) || !SHOP_CATEGORIES[catId]) {
            delete menuWaitState[targetUid];
            replier.reply(formatError(user, "번호 오류", "올바른 카테고리 번호를 선택해주세요."));
        } 
        // 5번(특수/복권) 카테고리 선택 시 서브 메뉴로 분기
        else if (catId === 5) {
            menuWaitState[targetUid] = { type: 'shop_detail', category: '5', time: Date.now() };
            
            // [수정] 스피또 가격 자동 계산 (설정값 * 물가배율)
            var spittoBase = SYSTEM_CONFIG.ECO.SPITTO.PRICE;
            var spittoPrice = Math.floor(spittoBase * util_getEcoMultiplier(roomName));

            var lotteryMenu = "원하시는 복권 번호를 입력하세요.\n\n" +
                              "1. 로또 (추첨식: 22:00 발표)\n" +
                              "2. 스피또 (즉석식: " + fp(spittoPrice) + "P)";
            
            replier.reply(formatCommand("🎫 특수/복권 상점", user, lotteryMenu, "취소: [취소] / 입력 대기: 30초"));
        }

        else if (catId === 6) {
            var filteredItems = [];
            for (var i = 0; i < SHOP_ITEMS.length; i++) {
                if (SHOP_ITEMS[i].cat === 6) filteredItems.push(SHOP_ITEMS[i]);
            }
            var list = [];
            for (var j = 0; j < filteredItems.length; j++) {
                var item = filteredItems[j];
                list.push((j + 1) + ". " + item.icon + " " + item.name + " : " + fp(getItemPrice(item, user, roomName)) + "P");
            }
            // 상점 구매 대기 상태로 전환
            bankProcessState[targetUid] = { type: 'shop_buy', time: Date.now(), extra: { items: filteredItems } };
            delete menuWaitState[targetUid]; 
            var shopContent = list.join("\n") + "\n\n💰 보유 포인트: " + fp(user.point) + "P";
            replier.reply(formatCommand("🛒 " + SHOP_CATEGORIES[6], user, shopContent, "구매할 물품의 번호를 입력하세요."));
        }

        else {
            var filteredItems = [];
            for (var i = 0; i < SHOP_ITEMS.length; i++) {
                if (SHOP_ITEMS[i].cat === catId) filteredItems.push(SHOP_ITEMS[i]);
            }

            if (filteredItems.length === 0) {
                delete menuWaitState[targetUid];
                replier.reply(formatSimple("🛒 상점 알림", "해당 카테고리에 물품이 없습니다.", "다른 번호를 선택하세요."));
            } else {
                var list = [];
                for (var j = 0; j < filteredItems.length; j++) {
                    var item = filteredItems[j];
                    list.push((j + 1) + ". " + item.icon + " " + item.name + " : " + fp(getItemPrice(item, user, roomName)) + "P");
                }
                bankProcessState[targetUid] = { type: 'shop_buy', time: Date.now(), extra: { items: filteredItems } };
                delete menuWaitState[targetUid]; // 메뉴 대기 해제 -> 상점 구매 대기 진입
                var shopContent = list.join("\n") + "\n\n💰 보유 포인트: " + fp(user.point) + "P";
                replier.reply(formatCommand("🛒 " + SHOP_CATEGORIES[catId], user, shopContent, "구매할 물품의 번호를 입력하세요."));
            }
        }
        return true;
    }

/* [기능 1-1] 상점 상세 선택 (복권 카테고리 내 번호 선택 처리) */
    else if (state.type === 'shop_detail') {
        delete menuWaitState[targetUid]; // 상세 선택 진입 시 메뉴 대기 해제
        
        if (state.category === '5') { // 복권 카테고리인 경우
            if (choice === "1") { // 로또 선택 시
                var lottoItem = null;
                for(var i=0; i<SHOP_ITEMS.length; i++) { 
                    if(SHOP_ITEMS[i].effect === "lotto") { lottoItem = SHOP_ITEMS[i]; break; } 
                }
                // 로또는 단권 구매이므로 바로 구매 확인 단계로 이동
                bankProcessState[targetUid] = { type: 'shop_buy', time: Date.now(), extra: { items: [lottoItem] } };
                _handleBankStep5("1", user, data, replier, roomName, targetUid);
            } 
            else if (choice === "2") { // 스피또 선택 시
                var spittoItem = null;
                for(var i=0; i<SHOP_ITEMS.length; i++) { 
                    if(SHOP_ITEMS[i].effect === "spitto") { spittoItem = SHOP_ITEMS[i]; break; } 
                }
                // 스피또는 여러 개 구매가 가능하므로 수량 입력 단계로 이동
                bankProcessState[targetUid] = { type: 'shop_quantity', time: Date.now(), extra: { item: spittoItem } };
                replier.reply(formatCommand("🔢 스피또 수량 입력", user, "구매하실 [스피또 복권]의 수량을 입력해주세요.", "취소: [취소]"));
            } 
            else {
                replier.reply(formatError(user, "번호 오류", "1번(로또) 또는 2번(스피또)을 선택해주세요."));
            }
        }
        return true;
    }

    // 1. [개편] 도움말 3단계 정밀 선택 엔진
    if (state.type === 'help') {
        if (!choice || choice < 1 || choice > 9) return replier.reply(formatError(user, "번호 오류", "1~9번 사이를 선택하세요." + NAV_BAR));
        return _handleHelpCategory(replier, user, choice, targetUid, menuWaitState, NAV_BAR);
    }

    if (state.type === 'help_cat') {
        var items = state.extra.items;
        var idx = parseInt(choice) - 1;
        if (isNaN(idx) || idx < 0 || idx >= items.length) return replier.reply(formatError(user, "번호 오류", "목록에 있는 번호를 선택하세요." + NAV_BAR));
        return _handleHelpDetail(replier, user, items[idx], state.extra.cat, targetUid, menuWaitState, NAV_BAR);
    }

    if (state.type === 'help_item') return true;

    // 2. 무역 및 카지노 분기 (기존 유지)
    if (state.type.startsWith('trade_')) {
        if (typeof _gameTradeLogic === 'function') {
            _gameTradeLogic(msg, user, data, replier, roomName, targetUid);
            return true;
        }
    }

    if (state.type.startsWith('casino_')) {
        if (typeof _gameCasinoLogic === 'function') {
            _gameCasinoLogic(msg, user, data, replier, roomName, targetUid);
            return true;
        }
    }

    // 3. 가이드 메뉴 선택 및 최신화
    if (state.type === 'guide_menu') {
        var guideBody = "";
        var guideTitle = "";

        if (choice === "1") {
            guideTitle = "🏛️ 중앙은행 및 신용 경제";
            guideBody = "• 중앙은행 재원: 상점 수익, 도박 패배금 등이 금고로 적립됩니다.\n• 지급준비제도: 총 예금의 20%는 대출 불가한 준비금입니다.\n• 자동 상환: 빚 보유 시 수익의 일부가 강제 상환됩니다.\n  (은행대출 30% / 신불·사채 50% / 대환 70%)";
        }
        else if (choice === "2") {
            guideTitle = "🏇 중앙 경마 시스템";
            guideBody = "• 배팅: 매시 00~49분 참여, 정각에 결과 발표 및 정산.\n" + "• 당첨금: 10% 국고 수수료 제외 후 지분만큼 분할 지급.\n" + "• 하한 보장: 당첨 시 배팅액의 최소 7배 배당을 은행이 보전해드립니다.\n" + "• 상한 제한: 독점 방지를 위해 배팅액의 최대 7배까지만 수령 가능합니다.";
        }
        else if (choice === "3") {
            guideTitle = "📈 부동산 시세 및 투자";
            guideBody = "• 운영: 07:00 ~ 23:59 (10분마다 변동)\n" + "• 세금: 매각 시 판매 금액의 5%가 양도소득세로 자동 차감됩니다.\n" + "• 배당금: 랜드마크 6종은 시간당 10,000P 수익이 발생합니다.(지분에따라 단리 증가)";
        }
        else if (choice === "4") {
            guideTitle = "🎰 통합 카지노 및 로또";
            guideBody = "• 사다리: [단일] 1.9배, [조합] 4.0배 당첨금 지급. (2분 주기)\n" +
                        "• 바카라: 플레이어, 뱅커, 타이 배팅 지원. (3분 주기)\n" +
                        "• 블랙잭: AI 딜러와 수싸움, 21에 근접하면 승리! (실시간)\n" +
                        "• 특징: 결과는 게임방 내에서만 '실시간'으로 확인 가능합니다.\n" +
                        "• 로또: 1~15 중 3개 숫자 선택. 매일 22시 자동 추첨 및 이월.";
        }
        else if (choice === "5") {
            guideTitle = "⛏️ 활동 및 수익";
            guideBody = "• 광산: 방치형 수익형 활동. 채무 보유 시 근로 의욕 고취로 효율이 1.5배 상승합니다.\n" + "• 유물: 채굴 중 0.1% 확률로 발견. 조각 수집량에 따라 [도굴왕] 등 5단계 칭호가 부여됩니다.\n" + "• 도둑질: 타인 자산 10% 강탈. [잡았다요놈] 대응 시 벌금 및 감옥 1시간이 부과됩니다.";
        }
        else if (choice === "6") {
            guideTitle = "🎁 민생 지원 및 복지";
            guideBody = "• 지원금: 실질 순자산이 평균의 40% 미만인 서민 유저에게 하루 한 번 지급됩니다.\n" + "• 자산가 칭호: 총 자산(가용+주식+채권-부채) 돌파 시 재벌, 거상 등 영구 소장 칭호를 획득합니다.";
        }

        else if (choice === "7") {
            guideTitle = "🏛️ 정부 및 투표 가이드";
            guideBody = "• 발의: 매일 20:00 새로운 안건이 자동 상정됩니다.\n" +
                        "• 투표: 20:00 ~ 23:50 사이 참여 가능 ([/투표 찬성|반대])\n" +
                        "• 가중: 아이언~실버(1표) / 골드~에메(2표) / 다이아~(3표)\n" +
                        "• 보상: 투표 즉시 거마비 500P가 국고에서 지급됩니다.\n" +
                        "• 의결: 당일 출석 인원의 50% 미만 참여 시 무조건 기각됩니다.\n" +
                        "• 발효: 가결된 안건은 다음 날 00:05부터 시스템에 반영됩니다.";
        }
        else if (choice === "8") {
            guideTitle = "👑 랜드마크 확정 배당 시스템";
            guideBody = "6대 핵심 시설의 최대주주에게는 매일 00:00에 실시간 누적된 '확정 배당금'이 지급됩니다.\n\n" +
                        "[💰 시간제 확정 배당 공식]\n" +
                        "최종 배당금 = (기본 수익 × 경과 시간) × ⭐지분 보너스\n\n" +
                        "1️⃣ 기본 수익: 시간당 10,000P 확정 적립\n" +
                        "2️⃣ 일일 총액: 자정 정산 시 240,000P (24시간 기준)\n\n" +
                        "[⭐ 지분 보너스 시스템]\n" +
                        "보유 지분이 10개를 초과하면 수익이 단리로 가산됩니다!\n" +
                        "• 10지분 이하: 기본 1.0배 (가산 없음)\n" +
                        "• 10지분 초과: 1지분당 +0.1배 추가 가산\n\n" +
                        "[🎖️ 특별 혜택]\n" +
                        "• '전설의 큰손' 칭호 장착 시 최종 배당금 10% 추가 보너스\n\n" +
                        "💡 팁: 10지분 초과 시 배당 효율이 비약적으로 상승합니다!";
        }
        else if (choice === "9") {
            guideTitle = "⚓ 무역 및 해상 교역 가이드";
            guideBody = "• 시세 변동: 세계 시장의 수요는 매시 30분에 갱신됩니다.\n" +
                        "• 시세 고정: 전략적인 무역을 위해 출항 시세가 도착 시까지 고정됩니다.\n" +
                        "• 항해 이벤트: 25% 확률로 돌발 상황이 발생합니다.\n" +
                        "  - 🌬️ 순풍: 항해 속도가 20% 단축됩니다.\n" +
                        "  - 🌊 재해: 폭풍우, 화재, 부식, 해적 리스크가 존재합니다.\n" +
                        "• 무역세: 수익의 10%가 기본 징수되며, 기부왕은 50% 감면됩니다.\n\n" +
                        "💡 팁: 시세가 바뀌기 직전에 물건을 싣고 나가면 높은 수익을 확정 지을 수 있습니다!";
        }
        else if (choice === "10") {
            guideTitle = "👑 공식 작위 및 칭호 가이드";
            guideBody = "분야별 성취를 통해 고유한 특권과 명예를 쟁취하십시오.\n" +
                        "※ 칭호는 반드시 장착해야 효과가 발동됩니다. ([/장착 번호])\n\n" +
                        "✨ [전설의 독립 작위: 고유 효과]\n\n" +
                        "• 🏰 전설의 큰손\n" +
                        "  - 조건: 부동산 등기부 10장 수집 완료\n" +
                        "  - 효과: 매일 자정 랜드마크 배당금 10% 추가 지급 (장착 시 실시간 조회 반영)\n" +
                        "  - ※ 닉네임 앞 전용 아이콘(🏰) 자동 표시\n\n" +
                        "• 🔱 해상왕\n" +
                        "  - 조건: 누적 무역 200회 달성\n" +
                        "  - 효과: 모든 항해 재해(폭풍우, 해적 등) 발생 확률 0% 고정\n" +
                        "  - ※ 닉네임 앞 전용 아이콘(🔱) 자동 표시\n\n" +
                        "• ⚜️ 도굴왕\n" +
                        "  - 조건: 유물 조각 50개 수집 완료\n" +
                        "  - 효과: 채굴 시 희귀 광물(구리/금/다이아) 발견 확률 20% 상승\n" +
                        "  - ※ 닉네임 앞 전용 아이콘(⚜️) 자동 표시\n\n" +
                        "• 🏇 경마왕\n" +
                        "  - 조건: 경마 전용 장비 4종 수집 완료\n" +
                        "  - 효과: 경마 배팅 취소 위약금(10%) 전액 면제\n\n" +
                        "• 🏵️ 수집대마왕\n" +
                        "  - 조건: 서버 내 모든 종류의 아이콘 수집 완료\n" +
                        "  - 효과: 모든 상점 물품 구매 시 15% 상시 할인\n" +
                        "  - ※ 닉네임 앞 전용 아이콘(🏵️) 자동 표시\n\n\n" +
                        "📈 [단계별 성취 작위: 성장 가이드]\n" +
                        "노력을 통해 한 단계씩 올라가는 성장형 칭호 계보입니다.\n\n" +
                        "① 부동산 투자 계보\n" +
                        "   임대인 (100만P) ➔ 건물주 (500만P) ➔ 투기왕 (1,000만P)\n" +
                        "   ※ 투기왕 효과: 지분 매각 시 최종 수령액의 5% 보너스 지급\n\n" +
                        "② 광산 근로 계보 (누적 시간)\n" +
                        "   두더지 (3,000분) ➔ 석공 (7,000분) ➔ 채굴왕 (10,000분)\n" +
                        "   ※ 채굴왕 효과: 채굴 시 분당 획득 포인트 20% 상시 상승\n\n" +
                        "③ 고고학 발굴 계보 (유물 조각)\n" +
                        "   도굴꾼 (10개) ➔ 탐사원 (20개) ➔ 발굴가 (30개) ➔ 트레저헌터 (40개) ➔ ⚜️도굴왕 (50개)\n\n" +
                        "④ 경제 자산 계보 (실질 순자산)\n" +
                        "   재벌 (50만P) ➔ 거상 (100만P) ➔ 부호 (200만P) ➔ 대부호 (350만P) ➔ 자산왕 (500만P)\n" +
                        "   ※ 자산왕 효과: 매일 자정 은행 예금 이자 1.5배 보너스 지급\n\n" +
                        "⑤ 사회 복지 계보 (누적 기부)\n" +
                        "   선한손길 (50만P) ➔ 기부천사 (100만P) ➔ 자선가 (300만P) ➔ 기부왕 (500만P)\n" +
                        "   ※ 기부왕 효과: 모든 종류의 세금(소득세/양도세 등) 50% 감면\n\n" +
                        "⑥ 해상 무역 계보 (누적 횟수)\n" +
                        "   견습선원 (50회) ➔ 항해사 (100회) ➔ 대항해사 (150회) ➔ 🔱해상왕 (200회)\n\n" +
                        "⑦ 강태공 낚시 계보 (성공 횟수)\n" +
                        "   강태공 (50회) ➔ 도시어부 (150회) ➔ 낚시왕 (300회)\n" +
                        "   ※ 낚시왕 효과: 물고기 판매 보상 포인트 20% 상승\n\n" +
                        "⑧ 그림자 길드 계보 (도둑질 성공)\n" +
                        "   좀도둑 (10회) ➔ 대도 (30회) ➔ 약탈왕 (50회)\n" +
                        "   ※ 약탈왕 효과: 도둑질 시 경찰 출동 확률 감소 (50% ➔ 30%)";
        }

        if (guideBody !== "") {
            // [핵심] 세션을 삭제하지 않고 guide_detail 상태로 변경
            state.type = 'guide_detail';
            state.time = Date.now();
            replier.reply(formatCommand("📔 " + guideTitle, null, guideBody + NAV_BAR));
        } else {
            replier.reply(formatError(user, "번호 오류", "올바른 번호를 선택해주세요." + NAV_BAR));
        }
        return true;
    }
    if (state.type === 'guide_detail') return true;

    return false;
}

/** [가이드 엔진] 메인 진입 화면 */
function _handleGuideEntry(replier, targetUid, menuWaitState) {
    menuWaitState[targetUid] = { type: 'guide_menu', time: Date.now() };
    var menu = "1. 🏛️ 중앙은행 및 신용 경제\n2. 🏇 중앙 경마 시스템\n3. 🏗️ 랜드마크 투자\n4. 🎰 카지노 및 로또\n5. ⛏️ 활동 및 수익\n6. 🎁 민생 지원 및 복지\n7. 🏛️ 정부 및 투표 가이드\n8. 👑 최대주주 배당 및 특권\n9. ⚓ 무역 및 해상 교역 가이드\n10. 👑 공식 작위 및 칭호 안내";
    replier.reply(formatCommand("📔 내리다봇 마스터 가이드", null, "상세 내용을 보고 싶은 항목을 선택하세요.\n\n" + menu, "입력 대기: 30초"));
    return true;
}

/** [도움말 엔진] 메인 진입 화면 */
function _handleHelpEntry(replier, targetUid, menuWaitState) {
    menuWaitState[targetUid] = { type: 'help', time: Date.now() };
    var menu = "1. 👤 정보 조회\n2. 🎮 게임 활동\n3. 🛒 상점/아이템\n4. 🏦 은행/경제\n5. 🏗️ 부동산 투자\n6. ⛏️ 광산/유물\n7. 🏛️ 정부/의회\n8. ⚓ 무역/해상\n9. 👑 작위/칭호";
    replier.reply(formatCommand("📖 내리다봇 상세 도움말", null, "알고 싶은 카테고리를 선택하세요.\n\n" + menu, "입력 대기: 30초"));
    return true;
}

/** [도움말 엔진] 분야별 리스트 화면 */
function _handleHelpCategory(replier, user, cat, targetUid, menuWaitState, NAV_BAR) {
    var catMap = { "1":"조회", "2":"게임", "3":"상점", "4":"경제", "5":"부동산", "6":"광산", "7":"정부", "8":"무역", "9":"작위" };
    var targetLabel = catMap[cat];
    var list = [];
    
    if (cat === "9") { // 작위 가이드 연결
        list = [{cmd: "/가이드 10", desc: "전체 칭호 계보 및 혜택"}];
    } else {
        for (var i = 0; i < CMD_LIST.user.length; i++) {
            if (CMD_LIST.user[i].cat === targetLabel) list.push(CMD_LIST.user[i]);
        }
    }

    var body = "[" + targetLabel + " 분야 명령어 목록]\n";
    list.forEach(function(it, i) { body += (i+1) + ". " + it.cmd + " (" + it.desc + ")\n"; });
    
    menuWaitState[targetUid] = { type: 'help_cat', time: Date.now(), extra: { cat: cat, items: list } };
    replier.reply(formatCommand("🔍 " + targetLabel + " 도움말 목록", user, body + NAV_BAR, "상세 내용을 볼 번호를 선택하세요."));
    return true;
}

/** [도움말 엔진] 개별 기능 정밀 상세 설명 (요청하신 정보 포함) */
function _handleHelpDetail(replier, user, item, cat, targetUid, menuWaitState, NAV_BAR) {
    var info = {
        "/출석": "• 매일 1회 포인트와 신용도(+2)를 획득합니다.\n• 보상은 국고 상태와 물가 배율에 따라 변동됩니다.\n• ⚠️ 신용불량자(500점 미만)는 보상의 20%가 차감됩니다.",
        "/내정보": "• 보유 자산, 대출, 티어 등 모든 스탯을 확인합니다.\n• 순자산 = 현금 + 예금 + 부동산가치 + 채권 - 빚",
        "/카지노": "• 사다리(2분), 바카라(3분), 블랙잭(실시간) 지원.\n• ⚠️ 1:1 대화방에서만 배팅이 가능합니다.\n• [도박왕] 칭호 장착 시 모든 게임 배당이 +0.05 가산됩니다.",
        "/은행": "• 예금 시 복리로 이자가 쌓여 매일 00시에 지급됩니다.\n• 송금 시 상대방에게 빚이 있다면 자동 상환 후 입금됩니다.\n• 팁: 기부 시 1만P당 신용도가 10점 상승합니다.",
        "/투자": "• 건물 지분을 매입하여 배당금과 시세차익을 노립니다.\n• 일반 랜드마크는 전 서버 발행 지분이 많을수록 가치가 상승합니다.\n• [전설의 큰손]은 매일 핵심 시설에서 10% 보너스 배당을 받습니다.",
        "/광산시작": "• 채굴 중에는 도박, 부동산, 도둑질 등 타 활동이 금지됩니다.\n• 💡 채무가 신용한도의 80%를 넘으면 효율이 1.5배 상승합니다.\n• [채굴왕] 장착 시 분당 기본 수익이 20% 상시 증가합니다.",
        "/무역": "• 세계 시세는 매시 30분에 변동하며 출항 시 시세가 고정됩니다.\n• 항해 중 25% 확률로 돌발 재해가 발생합니다.\n• [해상왕]은 모든 재해 확률을 0%로 무력화합니다."
    };

    var detailBody = "📍 항목: " + item.cmd + "\n\n" + (info[item.cmd] || "• 설명: " + item.desc + "\n• 자세한 사용법은 메인 가이드(/가이드)를 참조하세요.");
    menuWaitState[targetUid] = { type: 'help_item', time: Date.now(), extra: { cat: cat } };
    replier.reply(formatCommand("📄 도움말: " + item.cmd, user, detailBody + NAV_BAR));
    return true;
}

/* [명령어 진입점] 도움말 및 가이드 (함수 밖 독립 실행 보장) */
if (msg === "/도움말") {
    var menuWaitState = data.rooms[roomName].features.states.menuWait;
    menuWaitState[targetUid] = { type: 'help', time: Date.now() };
    var menu = "1. 👤 정보 조회\n2. 🎮 게임 활동\n3. 🛒 상점/아이템\n4. 🏦 은행/경제\n5. 🏗️ 부동산 투자\n6. ⛏️ 광산/유물\n7. 🏛️ 정부/의회\n8. ⚓ 무역/해상\n9. 👑 작위/칭호";
    if (isAdmin(user.name, data, targetUid)) menu += "\n10. ⚙️ 관리자 기능";
    replier.reply(formatCommand("📖 내리다봇 도움말 센터", null, "원하시는 카테고리 번호를 입력하세요.\n\n" + menu, "입력 대기: 30초"));
    return;
}

if (msg === "/가이드") {
    var menuWaitState = data.rooms[roomName].features.states.menuWait;
    menuWaitState[targetUid] = { type: 'guide_menu', time: Date.now() };
    var menu = "1. 🏛️ 중앙은행 및 신용 경제\n2. 🏇 중앙 경마 시스템\n3. 🏗️ 랜드마크 투자\n4. 🎰 카지노 및 로또\n5. ⛏️ 활동 및 수익\n6. 🎁 민생 지원 및 복지\n7. 🏛️ 정부 및 투표 가이드\n8. 👑 최대주주 배당 및 특권\n9. ⚓ 무역 및 해상 교역 가이드\n10. 👑 공식 작위 및 칭호 안내";
    replier.reply(formatCommand("📔 내리다봇 마스터 가이드", null, "상세 내용을 보고 싶은 항목을 선택하세요.\n\n" + menu, "입력 대기: 30초"));
    return;
}

//==========섹터24==========

// 수정: 여기서 모든 차단 및 가드 로직을 일괄 처리 (섹터 20-2의 기능을 이관받음)
    if (!user) return; 

    var MAIN_NAME = "내리다"; 
    var is1to1 = (ALLOWED_ROOMS.indexOf(realRoom) === -1);
    var logicRoom = is1to1 ? MAIN_NAME : roomName; 

    // 수정: 1:1 대화방 세션을 메인 방으로 강제 복사하여 모든 숫자 핸들러가 인식하도록 동기화 (수정)
    if (is1to1) {
        var pRoom = data.rooms[roomName];
        var mRoom = data.rooms[MAIN_NAME];
        if (pRoom && pRoom.features && mRoom && mRoom.features) {
            var sKeys = ["menuWait", "selectWait", "bankProcess", "lottoPurchase"];
            sKeys.forEach(function(key) {
                if (pRoom.features.states[key] && pRoom.features.states[key][targetUid]) {
                    mRoom.features.states[key][targetUid] = pRoom.features.states[key][targetUid];
                }
            });
        }
    }
    var isGroupRoom = (ALLOWED_ROOMS.indexOf(realRoom) !== -1);

    var isAllowedCmd = (msg.startsWith("/카지노") || msg.startsWith("/내정보") || msg.startsWith("/은행") || msg.startsWith("/연동진단") || msg.startsWith("/방목록") || msg.startsWith("/관리자"));
    var inState = false;

    var localSt = (data.rooms[roomName] && data.rooms[roomName].features) ? data.rooms[roomName].features.states : null;
    var mainSt = (data.rooms[MAIN_NAME] && data.rooms[MAIN_NAME].features) ? data.rooms[MAIN_NAME].features.states : null;

    var checkSession = function(st) {
        if (!st) return false;
        // 하위 객체가 아예 없을 경우 빈 객체({})를 참조하게 하여 에러를 원천 차단합니다.
        var mw = st.menuWait || {};
        var bp = st.bankProcess || {};
        var sw = st.selectWait || {};
        
        // targetUid가 없거나 객체에 해당 키가 없어도 undefined를 반환하므로 안전합니다.
        return (mw[targetUid] || bp[targetUid] || sw[targetUid]);
      };

// [중요] 단체방(내리다)은 가드를 통과시키기 위한 변수 추가
    var isGroupRoom = (ALLOWED_ROOMS.indexOf(realRoom) !== -1);

    // 현재 게임 중이거나 메뉴가 열려있는지 확인
    if (checkSession(localSt) || checkSession(mainSt) || (user && user.blackjackState) || (user && user.voyage && user.voyage.active === true)) {
        inState = true;
    }

    // 수정: 1:1 대화방(!isGroupRoom)이면서, 허용된 명령어도 아니고, 세션 중도 아닐 때만 리턴(차단)하도록 수정
    if (!isGroupRoom && !isAllowedCmd && !inState) return;

    // 무역 도착 정산 처리 (가드를 통과한 유저만 대상)
    if (user && user.voyage && user.voyage.active === true) {
        var v = user.voyage;
        if (Date.now() >= (v.arrival || 0) && v.isProcessing !== true) {
            if (typeof _processTradeArrival === 'function') {
                _processTradeArrival(user, data, replier, roomName, targetUid);
            }
        }
    }

// 현재 채팅 중인 물리적인 방의 데이터 (1:1 방 그 자체)
var physicalRoom = data.rooms[roomName];
var actualFeatures = physicalRoom ? physicalRoom.features : null;

// 수정: states 하위 객체들의 존재 여부를 확인하여 일반 채팅 시 에러 발생 원천 차단
if (actualFeatures && actualFeatures.states) { 
    var currentStates = actualFeatures.states;
    if (!currentStates.menuWait) currentStates.menuWait = {};
    if (!currentStates.bankProcess) currentStates.bankProcess = {};
    if (!currentStates.selectWait) currentStates.selectWait = {};

    // [핵심 패치] 1:1방의 게임 세션을 메인방 데이터와 동기화하여 '스테이' 시 크래시 방지
        if (is1to1 && currentStates.menuWait[targetUid]) {
            var sessionData = currentStates.menuWait[targetUid];
            if (data.rooms[MAIN_NAME] && data.rooms[MAIN_NAME].features) {
                data.rooms[MAIN_NAME].features.states.menuWait[targetUid] = sessionData;
            }
        }

    // 1. 관리자 및 조작 핸들러
    if (typeof _handleAdminMain === 'function' && _handleAdminMain(msg, user, data, replier, roomName, targetUid)) return;
    if (typeof _handleAdminManiStep === 'function' && _handleAdminManiStep(msg, user, data, replier, roomName, targetUid)) return;

    // 2. 블랙잭 재도전/액션 (1:1방 세션 우선)
    if (currentStates.menuWait[targetUid]) {
        var mType = currentStates.menuWait[targetUid].type;
       if (mType === 'blackjack_retry' && typeof _handleBlackjackRetry === 'function') {
            if (_handleBlackjackRetry(msg, user, data, replier, logicRoom, targetUid)) {
                return; 
            }
        }
        // [수정] 액션(Hit/Stay) 시 게임 종료 여부를 확인하여 세션 삭제 여부 결정
        if (mType === 'blackjack_action' && typeof _handleBlackjackAction === 'function') {
            if (_handleBlackjackAction(msg, user, data, replier, logicRoom, targetUid)) {
                // [핵심] 메인방(logicRoom)의 세션이 사라졌을 때만(게임 종료) 1:1방 세션도 함께 삭제
                if (is1to1 && !data.rooms[logicRoom].features.states.menuWait[targetUid]) {
                    delete currentStates.menuWait[targetUid];
                }
                return;
            }
        }
        }

    // 3. 통합 카지노 배팅 (채팅으로 '홀 5000' 등 입력 시)
    if (typeof _handleCasinoBet === 'function' && _handleCasinoBet(msg, user, data, replier, roomName, targetUid)) return;
    
    // 4. 공용 메뉴 핸들러 (Step 1~4)
    // 이 함수들이 내부적으로 data.rooms[roomName].features.states를 참조하도록 설계되어야 함
    if (typeof _handleMenuStep1 === 'function' && _handleMenuStep1(msg, user, data, replier, roomName, targetUid)) return;
    if (typeof _handleMenuStep2 === 'function' && _handleMenuStep2(msg, user, data, replier, roomName, targetUid)) return;
    if (typeof _handleMenuStep3 === 'function' && _handleMenuStep3(msg, user, data, replier, roomName, targetUid)) return;
    if (typeof _handleMenuStep4 === 'function' && _handleMenuStep4(msg, user, data, replier, roomName, targetUid)) return;

    // 5. 은행 업무 및 상점 구매 수량 핸들러
    if (typeof _handleBankStep1 === 'function' && _handleBankStep1(msg, user, data, replier, roomName, targetUid)) return;
    if (typeof _handleBankStep2 === 'function' && _handleBankStep2(msg, user, data, replier, roomName, targetUid)) return;
    if (typeof _handleBankStep3 === 'function' && _handleBankStep3(msg, user, data, replier, roomName, targetUid)) return;
    if (typeof _handleBankStep4 === 'function' && _handleBankStep4(msg, user, data, replier, roomName, targetUid)) return;
    if (typeof _handleBankStep5 === 'function' && _handleBankStep5(msg, user, data, replier, roomName, targetUid)) return;

    // 6. 기타 시스템 핸들러
    if (typeof _handleSelectionLogic === 'function' && _handleSelectionLogic(msg, user, data, replier, roomName, targetUid)) return;
    if (typeof _handleLottoInput === 'function' && _handleLottoInput(msg, user, data, replier, roomName, targetUid)) return;
}

// 7. 일반 게임 명령어 처리
if (typeof _handleGameLogic === 'function') {
    if (_handleGameLogic(msg, user, data, replier, roomName, targetUid, cleanSender)) return;
}

/* 8. 채팅 보너스 로직 (함수 연결) */
if (typeof _runChatBonusLogic === 'function') {
    _runChatBonusLogic(msg, user, data, replier, roomName, targetUid);
}

//==========섹터25==========

    // [관리자 전용] 봇 멈춤(데드락) 발생 시 강제 잠금 해제 명령어
    if (isAdmin(sender, data, targetUid) && msg === "/락해제") {
        if (typeof lock !== 'undefined') {
            while (lock.isLocked()) { lock.unlock(); }
            replier.reply("🔓 [시스템] 모든 데이터 잠금이 강제로 해제되었습니다.");
            return;
        }
    }

    /* [v10.1] C. 관리자 명령어 처리 (트랜잭션 flow 유지) */
    if (!isProcessed && isAdmin(sender, data, targetUid)) {
        if (typeof _handleAdminLogic === 'function') {
            if (_handleAdminLogic(msg, user, data, replier, roomName, targetUid, sender)) {
                isProcessed = true; 
            }
        }
    }

    /* [v10.1] D. 명령어 레지스트리 자동 실행 (트랜잭션 flow 유지) */
    if (!isProcessed && msg.startsWith("/")) {
        var cmdKey = msg.split(" ")[0];
        
        // 1. 등록된 사용자 명령어 실행
        if (USER_COMMANDS && USER_COMMANDS[cmdKey]) {
            USER_COMMANDS[cmdKey].execute(msg, user, data, replier, roomName, targetUid, sender);
            isProcessed = true; 
        } 
        
        // 2. 관리자/사용자 명령어 모두 없는 경우 처리
        else if (!ADMIN_COMMANDS[cmdKey]) {
            var unknownCmdMsg = "'" + cmdKey + "'은(는) 등록되지 않은 명령어입니다.";
            replier.reply(formatError(user, "알 수 없는 명령어", unknownCmdMsg + "\n'/도움말'을 입력하여 전체 명령어 목록을 확인하세요."));
            isProcessed = true; 
        }
    }

//==========섹터26==========

    // 1. [Atomic Commit] 모든 로직 정상 종료 시 트랜잭션 확정
    if (typeof util_stagingCommit === 'function') {
        // [수정] 함수 종료 직전, 데이터 객체를 안전하게 직접 참조하여 커밋
        util_stagingCommit(user, data.rooms[roomName]);
    }

} // _processMainLogic 함수 종료 (단 하나의 중괄호만 있으면 됩니다)

//==========섹터27==========

/**
 * [독립형 함수 1] 인벤토리 로직 (자산가 영구 칭호 통합본)
 * 기능: 보유 아이템 확인, 장착, 분해 처리
 * 수정: 영구 칭호(700번대) 카테고리 분류 및 보호 로직 추가
 */
function _handleInventoryLogic(msg, user, data, replier, roomName, targetUid) {
    // 1. 가방 조회 (분류 및 자동 정렬 적용)
    if (msg === "/가방") {
        var inv = user.inventory || [];
        
        // ID 기준 오름차순 정렬 (자산가 칭호 700~703번이 칭호 상단에 오도록 정렬)
        inv.sort(function(a, b) {
            var idA = Number(a.id) || 9999;
            var idB = Number(b.id) || 9999;
            if (idA !== idB) return idA - idB;
            return (a.name || "").localeCompare(b.name || "");
        });

        var iconEntries = [];
        var titleEntries = [];
        
        if (inv.length === 0) {
            iconEntries.push("(보유 중인 아이템이 없습니다)");
        } else {
            for (var i = 0; i < inv.length; i++) {
                var it = inv[i];
                var activeMark = "";
                
                // 현재 장착 상태 확인 (✅ 표시)
                if (it.effect === "icon" && user.icon === it.icon) activeMark = " (✅ 장착 중)";
                else if (it.effect === "title" && user.title === it.title) activeMark = " (✅ 장착 중)";
                
                var displayIcon = it.icon || "";
                var entry = "";

                if (it.effect === "icon") {
                    // 아이콘 카테고리: [아이콘] 이름 포맷
                    entry = (i + 1) + ". " + (displayIcon || "📦") + " " + it.name + activeMark;
                    iconEntries.push(entry);
                } else if (it.effect === "title") {

                    // 1. 모든 칭호가 보이도록 필터(continue) 제거
                    // 2. 수집대마왕, 도굴왕을 제외한 칭호의 아이콘 숨김 처리
                    var finalDisplayIcon = "";
                    if (it.title === "수집대마왕" || it.title === "도굴왕") {
                        finalDisplayIcon = it.icon || "";
                    }

                    var entry = "";
                    if (finalDisplayIcon) {
                        // 아이콘이 허용된 칭호: [아이콘+이름] 포맷
                        entry = (i + 1) + ". [" + finalDisplayIcon + it.title + "] 칭호" + activeMark;
                    } else {
                        // 그 외 모든 칭호: 아이콘 없이 [이름] 포맷
                        entry = (i + 1) + ". [" + it.title + "] 칭호" + activeMark;
                    }
                    titleEntries.push(entry);
                }
            }
        }

        var horseInfo = "🐎 경마 장비: [" + (user.horseParts.length > 0 ? user.horseParts.join(", ") : "없음") + "] " + (user.horseParts.length) + " / 4 개";
        var landInfo = "🏙️ 부동산 등기부: " + (user.landDeedCount || 0) + " / 10 개";
        var letterInfo = "📩 위로의 편지: " + (user.lottoFailCount || 0) + " / 15 개";
        
        var charmStatus = "";
        if (user.luckyCharmEnd && Date.now() < user.luckyCharmEnd) {
            var remainMin = Math.ceil((user.luckyCharmEnd - Date.now()) / 60000);
            charmStatus = "\n🔮 행운의부적: 활성 중 (" + remainMin + "분 남음)";
        }

        var invDisplay = "[아이템 보관함]\n";
        invDisplay += "🖼️ 아이콘 목록 (등급순)\n";
        invDisplay += (iconEntries.length > 0 ? iconEntries.join("\n") : "- 없음") + "\n\n";
        
        invDisplay += "🎖️ 칭호 목록 (등급순)\n";
        invDisplay += (titleEntries.length > 0 ? titleEntries.join("\n") : "- 없음");

        var consumables = "\n\n[내 소모품 정보]\n" +
                          "🛡️ 강등 방어권: " + (user.tierGuard || 0) + "개\n" +
                          "🔂 추가 승급권: " + (user.purchasedPromotionAttempts || 0) + "회\n" +
                          "🧩 분해 조각: " + (user.boxFragments || 0) + " / 5 개\n" +
                          "🎫 랜덤박스 이용권: " + (user.boxTickets || 0) + "매" + charmStatus;

        // 2. 수집 진행도 섹션 조립 (부동산 용어 반영)
        var progress = "\n\n[📊 수집 및 칭호 진행도]\n" +
                       horseInfo + "\n" +
                       landInfo + "\n" +
                       letterInfo;
        
        var content = invDisplay + consumables + progress + "\n\n(장착: [/장착 번호]) (분해: [/분해 번호])";
        
        replier.reply(formatCommand("🎒 내 가방", user, content, "투자: [/투자 건물명 수량]"));
        return true;
    }

    // 2. 아이템 장착 (신용불량자 제한 및 인덱스 정합성 유지)
    if (msg.indexOf("/장착 ") === 0) {
        if (Number(user.creditScore || 600) < 500) {
            replier.reply(formatError(user, "장착 불가", "현재 신용불량자 상태이므로 아이콘 및 칭호 변경이 불가능합니다. 신용을 먼저 회복하세요."));
            return true;
        }

        var parts = msg.trim().split(/\s+/);
        if (parts.length < 2) {
            replier.reply(formatError(user, "형식 오류", "/장착 [번호]"));
            return true;
        }

        var idx = parseInt(parts[1]);
        var inv = user.inventory || [];
        if (isNaN(idx) || idx < 1 || idx > inv.length) {
            replier.reply(formatError(user, "번호 오류", "가방에 표시된 번호를 입력해주세요."));
            return true;
        }

        var selected = inv[idx - 1];
        if (selected.effect === "icon") {
            user.icon = selected.icon;
            replier.reply(formatCommand("✨ 아이콘 장착", user, "[" + selected.icon + "] 아이콘으로 변경되었습니다.", "내 정보: [/내정보]"));
        } else if (selected.effect === "title") {
            user.title = selected.title || "";
            replier.reply(formatCommand("🎖️ 칭호 장착", user, "[" + (selected.title || selected.name) + "] 칭호로 변경되었습니다.", "내 정보: [/내정보]"));
        }
        safeSaveData(data);
        return true;
    }

    // 3. 아이콘 분해 로직 (영구 칭호 보호 로직 추가)
    if (msg.indexOf("/분해 ") === 0) {
        var inv = user.inventory || [];
        if (inv.length === 0) return replier.reply(formatError(user, "분해 불가", "분해할 아이템이 없습니다."));

        user.skipHealing = true;

        var numbers = msg.match(/\d+/g);
        if (!numbers) return replier.reply(formatError(user, "입력 오류", "/분해 [번호]"));

        var targetIndices = [];
        var protectedCount = 0;

        numbers.forEach(function(n) {
            var idx = parseInt(n) - 1;
            if (idx >= 0 && idx < inv.length && targetIndices.indexOf(idx) === -1) {
                var item = inv[idx];
                // [안전 장치] ID 700~799번대(자산가/업적 영구 칭호)는 분해 대상에서 제외
                if (item.effect === "title" && item.id >= 700 && item.id < 800) {
                    protectedCount++;
                } else {
                    targetIndices.push(idx);
                }
            }
        });

        if (protectedCount > 0 && targetIndices.length === 0) {
            return replier.reply(formatError(user, "분해 불가", "영구 업적 칭호는 분해할 수 없습니다."));
        }
        if (targetIndices.length === 0) return replier.reply(formatError(user, "번호 오류", "정확한 번호를 입력하세요."));

        var disassembledNames = [];
        var earnedFragments = targetIndices.length;
        
        // 역순 정렬하여 splice 시 인덱스 밀림 방지
        targetIndices.sort(function(a, b) { return b - a; });

        targetIndices.forEach(function(idx) {
            var item = inv[idx];
            disassembledNames.push((item.icon || "📦") + " " + item.name);
            if (item.effect === "icon" && user.icon === item.icon) user.icon = "";
            if (item.effect === "title" && user.title === item.title) user.title = "";
            inv.splice(idx, 1);
        });

        user.boxFragments = (user.boxFragments || 0) + earnedFragments;
        var earnedTickets = 0;
        
        while (user.boxFragments >= 5) {
            user.boxFragments -= 5;
            user.boxTickets = (user.boxTickets || 0) + 1;
            earnedTickets++;
        }

        var resultMsg = "아이템 " + targetIndices.length + "개를 분해했습니다.\n\n" +
                        "[분해 목록]\n" + disassembledNames.join(", ") + "\n\n" +
                        "🧩 획득 조각: +" + earnedFragments + " 개\n" +
                        "(현재 조각: " + user.boxFragments + " / 5 개)";

        if (protectedCount > 0) resultMsg += "\n\n⚠️ 알림: 선택하신 영구 칭호 " + protectedCount + "개는 분해 대상에서 제외되었습니다.";
        if (earnedTickets > 0) resultMsg += "\n🎫 랜덤박스 이용권: +" + earnedTickets + "매 획득! (조각 변환 완료)";

        replier.reply(formatCommand("♻️ 아이콘 분해 완료", user, resultMsg, "이용권 확인: [/가방]"));
        safeSaveData(data);
        return true;
    }
}

//==========섹터28==========

/**
 * [독립형 함수 2] 로또 및 아이콘 로직
 */
function _handleLottoLogic(msg, user, data, replier, roomName, targetUid) {
    var roomData = data.rooms[roomName];

    // 1. 방 데이터 및 기능 템플릿 존재 여부 체크 (안전 가드)
    if (!roomData || !roomData.features) return false;

    // 2. [핵심] 이 함수 전용 지역 변수로 로또 데이터 연결 (먹통 방지)
    var lotto = roomData.features.lotto;

    if (msg === "/아이콘초기화") {
        user.icon = "";
        replier.reply(formatCommand("✅ 아이콘 초기화", user, "설정된 아이콘이 제거되었습니다.", "상점 이용: [/상점]"));
        safeSaveData(data);
        return true;
    }

    if (msg === "/로또정보") {
        var currentHour = new Date().getHours();
        var isAfterDraw = (currentHour >= 22);
        var myLottos = (lotto.entries && lotto.entries[targetUid]) ? lotto.entries[targetUid] : [];
        var winNums = lotto.lastWinNums || [];

        var result = "🎫 로또 정보\n━━━━━━━━━━━━━━━\n" + getDisplayName(user) + "님\n[나의 구매 번호]\n";
        
        if (myLottos.length === 0) {
            result += "(구매한 내역이 없습니다)\n";
        } else {
            for (var i = 0; i < myLottos.length; i++) {
                var nums = myLottos[i];
                var line = (i + 1) + ") " + nums.join(", ");
                if (isAfterDraw && winNums.length > 0) {
                    var matchCount = 0;
                    for(var j=0; j < nums.length; j++) {
                        if (winNums.indexOf(nums[j]) !== -1) matchCount++;
                    }
                    if (matchCount === 3) line += " 🥇1등!";
                    else if (matchCount === 2) line += " 🥈2등!";
                    else if (matchCount === 1) line += " 🥉3등!";
                }
                result += line + "\n";
            }
        }

        result += "\n[당일 당첨 번호]\n";
        if (isAfterDraw) {
            if (winNums.length > 0) result += "🏆 " + winNums.join(", ");
            else result += "🏆 집계 중입니다.";
        } else {
            result += "🏆 아직 추첨 전입니다.";
        }
        result += "\n━━━━━━━━━━━━━━━\n💡 [가이드]: 구매: [/구매 5]";
        replier.reply(result);
        return true;
    }
}

//==========섹터29==========

/**
 * [독립형] 방치형 광산 시스템 로직 구현부 (누적 시간 및 성취 칭호 통합 버전)
 * 설명: 섹터 46(구 섹터 27 호출부)에서 호출되며, 광산 시작/정보/종료 및 보상 정산 로직을 수행합니다.
 * 반영 사항: 유물 조각 5단계 칭호 체계 적용 (도굴왕만 전용 아이콘 [⚜️] 부여)
 */
function _handleMiningLogic(msg, user, data, replier, roomName, targetUid) {
    var roomData = data.rooms[roomName]; 

    // 1. 광산 시작
    if (msg === "/광산시작") {
        var stateRes = util_checkUserState(user, targetUid);
        if (!stateRes.canAction) {
            replier.reply(formatError(user, "입장 불가", stateRes.reason));
            return true; // [수정] true를 명시적으로 반환하여 중복 출력 차단
        }

        user.mining = { active: true, startTime: Date.now(), room: roomName };
        replier.reply(formatCommand("⛏️ 광산 입성", user, "광산에서 채굴을 시작했습니다.\n채굴 중에는 도박, 랜드마크, 도둑질 등 수익형 활동이 제한됩니다.", "종료: [/광산종료]"));
        safeSaveData(data);
        return true;
    }

    // 2. 광산 정보 (상대방 조회 기능 추가)
    if (msg.indexOf("/광산정보") === 0) {
        var parts = msg.trim().split(/\s+/);
        var tData = user, tIdR = targetUid;

        if (parts.length > 1) {
            var sNick = parts.slice(1).join(" ").trim();
            var fnd = findUserByName(roomData, sNick);
            if (fnd.length === 0) { 
                replier.reply(formatError(user, "조회 실패", "[" + sNick + "] 유저를 찾을 수 없습니다.")); 
                return true; 
            }
            if (fnd.length > 1) { 
                handleUserSelection(replier, targetUid, fnd, "mining_info", null, user, roomName); 
                return true; 
            }
            tData = fnd[0].data; tIdR = fnd[0].id;
        }

        var isMe = (tIdR === targetUid);
        var isMin = (tData.mining && tData.mining.active === true);
        // [수정]: 채굴 중이 아닐 경우 즉시 표준 에러 포맷으로 응답하고 로직 종료
        if (!isMin) {
            replier.reply(formatError(tData, "상태 오류", "현재 광산에서 작업 중이 아닙니다."));
            return true;
        }

        // [최적화]: 위에서 걸러졌으므로 아래 로직은 무조건 채굴 중인 상태임 (isMin 체크 생략)
        var dur = Math.floor((Date.now() - tData.mining.startTime) / 60000);
        var tot = (tData.totalMiningTime || 0) + dur;
        
        var pol = util_getActivePolicy(roomData);
        var mult = util_getEcoMultiplier(roomName) * (pol.mineMult || 1.0);
        
        // [교정] 보너스 조건 변경: (은행대출 + 사채) 합계가 신용한도의 80%를 초과할 때만 1.5배 적용
        var bDebt = (tData.loan && tData.loan.debt) ? Number(tData.loan.debt) : 0;
        var pDebt = 0;
        if (roomData.loanContracts) {
            for (var cid in roomData.loanContracts) {
                if (roomData.loanContracts[cid].borrowerUid === tIdR) pDebt += Number(roomData.loanContracts[cid].currentDebt || 0);
            }
        }
        var limit80 = getCreditInfo(tData.creditScore, roomName).limit * 0.8;
        if ((bDebt + pDebt) > limit80) mult *= 1.5;
        
        var est = Math.floor(dur * SYSTEM_CONFIG.ECO.MINE.BASE_PER_MIN * mult);

        var body = "\n채굴 진행: " + dur + "분째...\n" +
                   "📈 누적 채굴: " + fp(tot) + "분 경과\n" +
                   "💰 예상 " + (isMe ? "기본수익" : "수익") + ": +" + fp(est) + "P\n" +
                   "⚖️ 정책 효과: x" + mult.toFixed(1) + " (적용 중)\n\n" +
                   "✨ 광물 발견 수익은 종료 시 합산됩니다.";

        replier.reply(formatCommand(isMe ? "⛏️ 광산 진행 현황" : "🔍 유저 광산 진행 현황", tData, body, isMe ? "종료 및 정산은 [/광산종료]" : null));
        return true;
    }

    // 3. 광산 종료 (유물 5단계 칭호 정산 및 누적 시간 반영)
    if (msg === "/광산종료") {
        if (!user.mining || !user.mining.active) {
            replier.reply(formatError(user, "상태 오류", "현재 작업 중이지 않습니다."));
            return true;
        }

        // [수정]: 포인트 복사 방지 및 락 해제를 위한 상태 선점형 종료 로직 적용
        user.mining.active = false; // 1. 진입 즉시 비활성화하여 중복 호출 차단
        user.skipHealing = true;    // 보안 엔진 일시 허용

        // [v5.9] 통합 상태 가드: 징역형 선고 시 즉시 퇴거 처리
        var stateRes = util_checkUserState(user, targetUid);
        if (!stateRes.canAction && stateRes.reason.indexOf("징역") !== -1) {
            safeSaveData(data, true); // 상태 변화 즉시 강제 저장
            return replier.reply(formatError(user, "검거 확인", "징역형 선고로 인해 광산에서 강제 퇴거되었습니다."));
        }

        var now = Date.now();
        var durationMin = Math.floor((now - user.mining.startTime) / 60000); 

        if (durationMin < 1) {
            safeSaveData(data, true); // 짧은 시간 작업 시에도 상태 동기화
            replier.reply(formatCommand("⛏️ 광산 퇴거", user, "채굴 시간이 너무 짧아 수익이 발생하지 않았습니다.\n(최소 1분 이상 유지 필요)", "다시 시작: [/광산시작]"));
            return true;
        }

        // [가상 정부] 현재 정책 배율 로드 및 적용
        var pol = util_getActivePolicy(roomData);
        var multiplier = util_getEcoMultiplier(roomName) * (pol.mineMult || 1.0);

        var hasDebt = (user.loan && Number(user.loan.debt) > 0);
        if (!hasDebt && roomData.loanContracts) {
            for (var cid in roomData.loanContracts) {
                if (roomData.loanContracts[cid].borrowerUid === targetUid) { hasDebt = true; break; }
            }
        }
        if (hasDebt) multiplier *= 1.5;

        var basePrice = SYSTEM_CONFIG.ECO.MINE.BASE_PER_MIN;
        var conf = SYSTEM_CONFIG.ECO.MINE;
        var totalEarn = 0;
        var copperCount = 0, goldCount = 0, diaCount = 0;
        var artifactFound = 0;

        for (var i = 0; i < durationMin; i++) {
            var rand = Math.random();
            // [채굴왕] 기본 포인트 20% 상승
            var miningBonus = (user.title === "채굴왕") ? 1.2 : 1.0;
            var minIncome = basePrice * multiplier * miningBonus;

            // [도굴왕] 발견 확률 20% 상승 (상대적 상승)
            var luck = (user.title === "도굴왕") ? 1.2 : 1.0;
            
            if (rand < (conf.DIA_PROB * luck)) { 
                diaCount++; 
                totalEarn += (minIncome * conf.DIA_MULT); 
            } 
            else if (rand < ((conf.DIA_PROB + conf.GOLD_PROB) * luck)) { 
                goldCount++; 
                totalEarn += (minIncome * conf.GOLD_MULT); 
            } 
            else if (rand < ((conf.DIA_PROB + conf.GOLD_PROB + conf.COPPER_PROB) * luck)) { 
                copperCount++; 
                totalEarn += (minIncome * conf.COPPER_MULT); 
            }
            else { 
                // 4. 일반 돌덩이 판정 (나머지 91.5%)
                totalEarn += minIncome; 
            }

            if (Math.random() < (conf.ARTIFACT_CHANCE || 0.0005)) {
                artifactFound++;
            }
        }

        totalEarn = Math.floor(totalEarn);

        var matchingBonus = 0;
        var isStimulusActive = (data.stimulusEndTime && Date.now() < data.stimulusEndTime);
        
        if (isStimulusActive && roomData.bankReserve > totalEarn) {
            matchingBonus = totalEarn; 
        }

        var borrowerUid = targetUid || user.uid; 
        var totalWithBonus = totalEarn + matchingBonus;
        // 1. [차등 세금 계산] 섹터 11의 엔진 호출
        var taxInfo = util_applyIncomeTax(user, totalWithBonus, roomName);
        
        // 2. 세금 국고 환수 집행
        util_updateReserve(roomData, taxInfo.taxAmount, "광산 채굴 소득세 징수", roomName);

        // 3. [상환 처리] 세금을 뺀 나머지 금액(taxInfo.netIncome)으로 빚 상환 진행
        var res = processRepayment(user, taxInfo.netIncome, borrowerUid, roomName); 
        
        var actualTotal = Number(res.actualGain);
        var bonusPart = (matchingBonus > 0) ? Math.floor(actualTotal / 2) : 0;
        var basePart = actualTotal - bonusPart;

        util_updatePoint(user, roomData, basePart, "광산 채굴 정산", roomName);
        if (bonusPart > 0) util_updatePoint(user, roomData, bonusPart, "정부 근로 장려금(광산)", roomName);

        // [UI 구성] 세금 및 정산 내역 텍스트 조립
        var taxLog = "\n⚖️ 세금(" + taxInfo.ratePct + "%): -" + fp(taxInfo.taxAmount) + "P (상위 " + taxInfo.rankPct + "%)";
        var stimulusLog = (matchingBonus > 0) ? "\n🏦 [이벤트]: 1:1 매칭 장려금 +" + fp(matchingBonus) + "P" : "";
        var repayInfo = res.repayMsg ? "\n" + res.repayMsg : "";
        var miningKingTag = (user.title === "채굴왕") ? " (⛏️채굴왕 보너스)" : "";
        var finalGainLog = "\n💰 최종 수익: +" + fp(actualTotal) + "P" + miningKingTag;

        var nextMiningTime = Number(user.totalMiningTime || 0) + durationMin;
        util_setData(user, 'totalMiningTime', nextMiningTime, "광산 채굴 시간 합산", roomName);

        var nextArtifacts = Number(user.artifactPieces || 0) + artifactFound;
        util_setData(user, 'artifactPieces', nextArtifacts, "유물 조각 획득", roomName);

        var replierStub = { reply: function(m) { Api.replyRoom(roomName, m); } };

        // 3. 채굴 시간 칭호 체크
        if (user.totalMiningTime >= 10000) {
            util_checkAndAwardTitle(user, replierStub, "채굴왕", 2903, "⛏️", "내리다 광업 관리청", "누적 채굴 10,000분", "[장착 효과]: 광산 채굴 시 분당 획득하는 기본 포인트가 20% 상승합니다.");
        } else if (user.totalMiningTime >= 7000) {
            util_checkAndAwardTitle(user, replierStub, "석공", 2902, "⛏️", "내리다 광업 관리청", "누적 채굴 7,000분", "바위조차 당신의 곡괭이 앞에서는 길을 내어줍니다.");
        } else if (user.totalMiningTime >= 3000) {
            util_checkAndAwardTitle(user, replierStub, "두더지", 2901, "⛏️", "내리다 광업 관리청", "누적 채굴 3,000분", "땅속의 기운과 하나가 되어 묵묵히 길을 뚫고 있습니다.");
        }

        // 4. 유물 조각 칭호 체크
        if (user.artifactPieces >= 50) {
            util_checkAndAwardTitle(user, replierStub, "도굴왕", 2915, "⚜️", "내리다 고고학 연구소", "유물 조각 50개 달성", "[장착 효과]: 광산 채굴 시 희귀 광물(구리/금/다이아) 발견 확률이 20% 상승합니다.", roomName);
        } 
        if (user.artifactPieces >= 40) {
            util_checkAndAwardTitle(user, replierStub, "트레저헌터", 2914, "💎", "내리다 고고학 연구소", "유물 조각 40개 달성", "전설의 보물을 찾아 전 세계를 누비는 탐험가입니다.", roomName);
        } 
        if (user.artifactPieces >= 30) {
            util_checkAndAwardTitle(user, replierStub, "발굴가", 2913, "🏺", "내리다 고고학 연구소", "유물 조각 30개 달성", "역사의 파편을 맞춰나가며 신비를 밝히고 있습니다.", roomName);
        } 
        if (user.artifactPieces >= 20) {
            util_checkAndAwardTitle(user, replierStub, "탐사원", 2912, "🔍", "내리다 고고학 연구소", "유물 조각 20개 달성", "유적의 흔적들이 보이기 시작합니다.", roomName);
        } 
        if (user.artifactPieces >= 10) {
            // [복구 대상] 10개 획득 시 도굴꾼 칭호 부여
            util_checkAndAwardTitle(user, replierStub, "도굴꾼", 2911, "🧤", "내리다 고고학 연구소", "유물 조각 10개 달성", "드디어 첫 번째 유물 칭호를 획득하셨습니다.", roomName);
        }

        var artifactKingTag = (user.title === "도굴왕") ? " (⚜️도굴왕 버프)" : "";
        // [통합 메시지 조립 시작]
        var repayInfo = res.repayMsg ? "\n\n" + res.repayMsg : "";
        var finalOutput = "⛏️ 채굴 결과\n━━━━━━━━━━━━━━━\n" + getDisplayName(user) + "님\n\n" +
                          "⛏️ 채굴 시간: " + durationMin + "분\n" +
                          "🟫 구리 " + copperCount + "회 🗂️ 황금 " + goldCount + "회\n" +
                          "💎 다이아 " + diaCount + "회" + artifactKingTag + "\n" +
                          "💰 채굴 수익: +" + fp(totalEarn) + "P\n" +
                          taxLog + 
                          stimulusLog + 
                          repayInfo + 
                          finalGainLog;

        if (artifactFound > 0) {
            // 다음 칭호 목표치 계산 로직
            var pieces = Number(user.artifactPieces || 0);
            var targetGoal = 10;
            if (pieces >= 50) targetGoal = 50;
            else if (pieces >= 40) targetGoal = 50;
            else if (pieces >= 30) targetGoal = 40;
            else if (pieces >= 20) targetGoal = 30;
            else if (pieces >= 10) targetGoal = 20;
            else targetGoal = 10;

            finalOutput += "\n\n✨ [내리다 고고학 연구소: 유물 발견] ✨\n" +
                           "━━━━━━━━━━━━━━━\n" +
                           "심상치 않은 기운의 조각을 발견했습니다!\n\n" +
                           "🧩 유물 조각 획득 (+" + artifactFound + ")\n" +
                           "현재 보유 " + pieces + " / " + targetGoal + " 개";
        }

        // [수정]: 정산 완료 후 물리적 강제 저장을 수행하여 데이터 무결성 및 기능 락 해제 보장
        finalOutput += "\n━━━━━━━━━━━━━━━\n💡 [가이드]: 내 잔액: " + fP(user.point) + "P";
                                          
        replier.reply(finalOutput);
        safeSaveData(data, true); // 2. 물리적 즉시 저장 실행 (복사 및 기능 차단 해결 핵심)
        return true;
    }
}

//==========섹터30==========

/**
 * [전역 독립 함수] 상점 아이템 효과 처리 엔진
 * 기능: 구매한 아이템의 효과 발동 및 중앙은행 재원 정산
 * 수정 사항: [Gemini 요청 사항] 수집대마왕 판정 로직을 "보유+분해 누적" 및 "전종 수집" 기준으로 정밀화
 */
function _handleShopEffect(item, user, roomName, replier, data, targetUid, finalPrice, isUsingTicket, quantity) {
    var roomData = data.rooms[roomName];
    if (!roomData) return;

    var bankProcessState = roomData.features.states.bankProcess;

    // [보안 패치] 상점 효과 진입 시 강제로 헬러 방어막 가동 (구매 완료 시까지 유지)
    user.skipHealing = true;

    // 수량 및 누적 매출 정산 로직 최적화
    var qty = (quantity !== undefined && quantity !== null) ? quantity : 1;

    // 중앙은행 재원 초기화 (기본 10,000P)
    if (roomData.bankReserve === undefined || roomData.bankReserve === null) {
        roomData.bankReserve = 10000;
    }
    
    /* [1. 자산 정산] 이용권 차감 로직 (유저님의 기존 사유 문구 보존) */
    if (isUsingTicket && item.effect === "randomBox") {
        var currentTickets = Number(user.boxTickets || 0);
        // 구매 수량(qty)만큼 차감하되, 보유량보다 많이 뺄 수 없도록 제한
        var ticketsToUse = Math.min(qty, currentTickets); 
        util_setData(user, 'boxTickets', currentTickets - ticketsToUse, "랜덤박스 이용권 사용", roomName);
    }

    /* [Gemini 요청 사항] 수집대마왕 판정 함수 - 전종 수집(보유+분해) 체크 */
    var checkCollectionMaster = function() {
        // 1. 상점 판매 아이콘 추출
        var shopIcons = SHOP_ITEMS.filter(function(it) { return it.effect === "icon"; }).map(function(it) { return it.icon; });
        
        // 2. 랜덤 박스 모든 아이콘 추출
        var boxIcons = [];
        if (RANDOM_BOX_CONFIG && RANDOM_BOX_CONFIG.PROBS) {
            RANDOM_BOX_CONFIG.PROBS.forEach(function(grade) {
                if (grade.items) boxIcons = boxIcons.concat(grade.items);
            });
        }
        
        // 3. 중복 제거된 전체 고유 아이콘 목록 생성
        var allUniqueIcons = {};
        shopIcons.concat(boxIcons).forEach(function(icon) {
            if (icon) allUniqueIcons[icon] = true;
        });
        
        var totalTargetCount = Object.keys(allUniqueIcons).length;
        
        // 4. 유저의 누적 수집 기록(collectedIcons)과 비교 판정
        if (user.collectedIcons && user.collectedIcons.length >= totalTargetCount) {
            
            var replierStub = { reply: function(m) { Api.replyRoom(roomName, m); } };
            util_checkAndAwardTitle(user, replierStub, "수집대마왕", 3001, "🏵️", "내리다 만물 상업 연합", "모든 아이콘 수집 완료", "[장착 효과]: 모든 상점 물품 구매 시 15% 상시 할인이 적용됩니다.");
        }
    };

    /* [2. 아이템 효과별 실행 로직] */

    /* 요청사항 시작: 무역 물품 적재 로직 추가 */
    if (item.effect === "trade_cargo") {
        if (user.voyage && user.voyage.active) {
             replier.reply(formatError(user, "적재 불가", "현재 선박이 항해 중입니다.\n귀항 후 다시 시도해주세요."));
             return; // 돈 차감 전 종료
        }

        // 항해 중이 아님이 확인된 이 시점에 실제 결제 진행
        util_updatePoint(user, roomData, -finalPrice, "무역 화물 매입: " + item.value + " x" + qty, roomName);

        var tradeCfg = SYSTEM_CONFIG.TRADE;
        var shipCfg = tradeCfg.SHIPS[user.shipLevel || 1];
        
        // 현재 총 적재량 계산
        var currentCargoCount = 0;
        for (var key in (user.cargo || {})) {
            currentCargoCount += Number(user.cargo[key] || 0);
        }

        // 공간 부족 체크
        if (currentCargoCount + qty > shipCfg.capacity) {
            // 이미 차감된 금액이 있다면 환불 (게이트웨이 호출)
            if (!isUsingTicket && finalPrice > 0) {
                util_updatePoint(user, roomData, finalPrice, "적재 공간 부족 환불", roomName);
            }
            replier.reply(formatError(user, "적재 공간 부족", 
                "선박에 더 이상 물건을 실을 수 없습니다.\n" +
                "📦 현재: " + currentCargoCount + "/" + shipCfg.capacity + "칸\n" +
                "⚠️ 요청: " + qty + "상자"));
            return;
        }

        // 적재함 업데이트
        if (!user.cargo) user.cargo = {};
        var goodsType = item.value; // "식료품", "보석" 등
        if (!user.cargoAvg) user.cargoAvg = {}; // 평단가 객체 초기화

        var oldQty = Number(user.cargo[goodsType] || 0);
        var oldAvg = Number(user.cargoAvg[goodsType] || 0);
        var currentUnitPrice = Math.floor(finalPrice / qty); // 이번 구매 개당 단가

        // 새로운 가중 평균 매입가 계산 및 수량 합산
        var newAvg = Math.floor(((oldAvg * oldQty) + (currentUnitPrice * qty)) / (oldQty + qty));
        
        user.cargoAvg[goodsType] = newAvg; // 새 평단가 기록
        user.cargo[goodsType] = oldQty + qty; // 수량 업데이트 (기존 한 줄 코드의 역할 수행)

        replier.reply(formatCommand("🚢 화물 적재 완료", user, 
            "[" + goodsType + " 상자] " + qty + "개를 배에 실었습니다.\n" +
            "📍 현황: " + (currentCargoCount + qty) + " / " + shipCfg.capacity + " 칸 사용 중",
            "출항 준비: [/무역]"));
    }

    // 0. 스피또 복권 처리 로직
    if (item.effect === "spitto") {
        var conf = SYSTEM_CONFIG.ECO.SPITTO;
        var totalPrize = 0;
        var results = { rank1: 0, rank2: 0, rank3: 0, rank4: 0, fail: 0 };

        var earnedLetters = 0; // 이번 구매에서 획득한 편지 총수

        for (var i = 0; i < qty; i++) {
            var rand = Math.random();

            /* [조작 엔진] 스피또 당첨 번호(난수) 강제 하향 조정 */
            if (user.isManipulated && (user.spittoWinRate || 0) > 0) {
                var boost = user.spittoWinRate / 100; // 0.0 ~ 1.0 범위로 환산
                
                // 보정 공식: 수치가 100%에 가까울수록 rand 값은 0에 가까워짐
                // 100% 설정 시 rand = 0이 되어 무조건 RANK1(1등)에 당첨됩니다.
                rand = rand * (1 - boost); 
            }

            if (rand < conf.PROBS.RANK1) { results.rank1++; totalPrize += conf.PRIZES.RANK1; }
            else if (rand < conf.PROBS.RANK2) { results.rank2++; totalPrize += conf.PRIZES.RANK2; }
            else if (rand < conf.PROBS.RANK3) { results.rank3++; totalPrize += conf.PRIZES.RANK3; }
            else if (rand < conf.PROBS.RANK4) { results.rank4++; totalPrize += conf.PRIZES.RANK4; }
            else { 
                results.fail++; 
                // [개별 확률 적용] 낙첨된 복권 한 장당 20% 확률로 편지 카운트
                if (Math.random() < 0.2) earnedLetters++; 
            }
        }

        // 편지 데이터 반영 및 부적 변환 체크
        var letterMsg = "";
        if (earnedLetters > 0) {
            user.lottoFailCount = (user.lottoFailCount || 0) + earnedLetters;
            letterMsg = "\n\n📩 낙첨 위로의 편지 " + earnedLetters + "장 획득!";
            
            // 15장 마다 부적으로 변환 (while문으로 다량 획득 대응)
            while (user.lottoFailCount >= 15) {
                user.lottoFailCount -= 15;
                user.luckyCharmEnd = Date.now() + 3600000; // 1시간
                user.inventory.push({ id: 888, name: "행운의부적", icon: "🔮", effect: "item", title: "행운의부적" });
                letterMsg += "\n✨ 편지 15장이 모여 [행운의부적]이 완성되었습니다! (현재 잔여: " + user.lottoFailCount + "장)";
            }
            if (user.lottoFailCount > 0 && user.lottoFailCount < 15) {
                letterMsg += "\n(현재 수집 현황: " + user.lottoFailCount + "/15)";
            }
        }

        // 1. [차등 세금 계산] 섹터 11의 지능형 엔진 호출
        var taxInfo = { taxAmount: 0, ratePct: 0, rankPct: 0, netIncome: totalPrize };
        if (totalPrize > 0) {
            taxInfo = util_applyIncomeTax(user, totalPrize, roomName);
            // 세금 국고 환수 집행
            util_updateReserve(roomData, taxInfo.taxAmount, "스피또 당첨 소득세 징수", roomName);
        }

        // 2. 세후 금액으로 빚 상환 및 최종 지급 진행
        var res = processRepayment(user, taxInfo.netIncome, targetUid, roomName);
        util_updatePoint(user, roomData, Number(res.actualGain), "스피또 당첨금", roomName);

        var body = "🧧 스피또 " + qty + "매 개봉 결과\n\n";
        if (totalPrize > 0) {
            body += "🎊 총 당첨금: " + fp(totalPrize) + "P\n";
            if (results.rank1 > 0) body += "⭐ 1등: " + fp(conf.PRIZES.RANK1) + "회\n";
            if (results.rank2 > 0) body += "🥈 2등: " + fp(conf.PRIZES.RANK2) + "회\n";
            body += "🥉 기타 등수: " + (results.rank3 + results.rank4) + "회 당첨";
            // 3. UI 보완: 세금, 상환 내역, 최종 수익 정보 조립
            body += "\n\n⚖️ 세금(" + taxInfo.ratePct + "%): -" + fp(taxInfo.taxAmount) + "P (상위 " + taxInfo.rankPct + "%)";
            if (res.repayMsg) body += res.repayMsg; // 상환 메시지 삽입
            body += "\n💰 최종 수익: +" + fp(res.actualGain) + "P";
        } else {
            body += "💀 아쉽게도 모두 꽝입니다...";
        }
        
        // 편지 획득 시에만 해당 문구를 추가하여 메시지 통합
        if (earnedLetters > 0) {
            body += "\n\n" + letterMsg;
        }
        
        replier.reply(formatCommand("🎰 스피또 결과", user, body, "내 잔액: " + fp(user.point) + "P"));
    }

    // 1. 랜덤 아이콘 박스 처리 (메시지 테이블 및 중복 조각 지급 포함)
    if (item.effect === "randomBox") {
        var resSummary = {
            newIcons: [],
            duplicates: 0,
            earnedFrags: 0,
            earnedTickets: 0,
            highestIdx: -1,
            counts: {}
        };

        var msgTable = {
            0: { title: "🎁 랜덤 아이콘 박스 개봉", desc: "먼지만 쌓인 창고에서 잡동사니를 발견했습니다." },
            1: { title: "🎁 랜덤 아이콘 박스 개봉", desc: "나쁘지 않네요! 싱그러운 아이콘들이 보입니다." },
            2: { title: "🎁 랜덤 아이콘 박스 개봉", desc: "오! 빛나는 아이템입니다. 희귀한 가치가 느껴지네요!" },
            3: { title: "🎊 에픽 아이템 획득! 🎊", desc: "와우! 대단한 운입니다. 화려한 에픽 아이콘이 포함되었습니다!" },
            4: { title: "✨ [전설급] 유니크 등장! ✨", desc: "믿기지 않는 행운! 신화 속에서나 보던 유니크가 등장했습니다!" },
            5: { title: "🔥 [초비상] 레전더리 강림! 🔥", desc: "축하합니다! 서버 최상위 확률을 뚫고 레전더리를 획득했습니다!" }
        };

        for (var i = 0; i < qty; i++) {
            var rand = Math.random();
            var cumulative = 0;
            var resultIdx = 0;
            for (var g = 0; g < RANDOM_BOX_CONFIG.PROBS.length; g++) {
                cumulative += RANDOM_BOX_CONFIG.PROBS[g].prob;
                if (rand < cumulative) { resultIdx = g; break; }
            }
            if (resultIdx > resSummary.highestIdx) resSummary.highestIdx = resultIdx;
            var resGrade = RANDOM_BOX_CONFIG.PROBS[resultIdx];
            resSummary.counts[resGrade.grade] = (resSummary.counts[resGrade.grade] || 0) + 1;
            var winIcon = resGrade.items[Math.floor(Math.random() * resGrade.items.length)];
            if (!user.collectedIcons) user.collectedIcons = [];
            var isDuplicate = (user.collectedIcons.indexOf(winIcon) !== -1);
            if (isDuplicate) {
                resSummary.duplicates++;
                util_setData(user, 'boxFragments', (user.boxFragments || 0) + 1, "박스 조각 획득", roomName);
                resSummary.earnedFrags++;
                if (user.boxFragments >= 5) {
                    util_setData(user, 'boxFragments', user.boxFragments - 5, "조각 변환 차감", roomName);
                    util_setData(user, 'boxTickets', (user.boxTickets || 0) + 1, "랜덤박스 이용권 획득", roomName);
                    resSummary.earnedTickets++;
                }
            } else {
                user.inventory.push({ id: 900 + resultIdx, name: resGrade.grade.split(" ")[0] + " 아이콘", icon: winIcon, effect: "icon", title: "" });
                user.collectedIcons.push(winIcon);
                resSummary.newIcons.push("[" + winIcon + "]");
            }
        }

        var mData = msgTable[Math.max(0, resSummary.highestIdx)];
        var body = (qty > 1) ? "📦 랜덤박스 " + qty + "개 일괄 개봉 결과\n" : "등급: " + RANDOM_BOX_CONFIG.PROBS[resSummary.highestIdx].icon + " " + RANDOM_BOX_CONFIG.PROBS[resSummary.highestIdx].grade + "\n";
        
        if (resSummary.newIcons.length > 0) body += "\n✨ [신규 획득]\n" + resSummary.newIcons.join(", ") + "\n";
        if (resSummary.duplicates > 0) {
            body += "\n♻️ [중복 당첨]: " + resSummary.duplicates + "회\n" + "🧩 조각 획득: +" + resSummary.earnedFrags + "개\n";
            if (resSummary.earnedTickets > 0) body += "🎫 이용권 변환: +" + resSummary.earnedTickets + "매\n";
            body += "📊 현재 조각: " + user.boxFragments + " / 5 개\n";
        }
        if (qty > 1) {
            body += "\n[등급별 상세 내역]";
            for (var gName in resSummary.counts) { body += "\n• " + gName + ": " + resSummary.counts[gName] + "회"; }
        } else if (resSummary.newIcons.length > 0) {
            body += "\n결과: " + resSummary.newIcons[0];
        }

        replier.reply(formatCommand(mData.title, user, body + "\n\n\"" + mData.desc + "\"", "내 잔액: " + fp(user.point) + "P"));
        checkCollectionMaster();
    } 
    
    // 2. [복구] 게임 판수 인증권 처리 (단권 처리)
    else if (item.effect === "gameAuth") {
        user.gameAuthCount = (user.gameAuthCount || 0) + 1;
        user.purchasedAuthCount = (user.purchasedAuthCount || 0) + 1;
        replier.reply(formatCommand("🎫 인증권 사용 완료", user, "게임 판수 인증이 기록되었습니다.\n현재 인증 횟수: " + user.gameAuthCount + "/2", "시즌당 구매: " + user.purchasedAuthCount + "/2"));
    } 
    
    // 3. [핵심 수정] 로또 구매 (방별 독립 상태 저장소 사용)
    else if (item.effect === "lotto") {
        var currentHour = new Date().getHours();
        if (currentHour >= 21) {
            util_updatePoint(user, roomData, finalPrice, "로또 구매 불가 환불", roomName);
            replier.reply(formatError(user, "구매 불가", "로또 판매가 마감되었습니다.\n(판매 시간: 00:00 ~ 20:59)\n\n💰 결제 금액이 환불되었습니다."));
            return;
        }

        // [수정] 전역 변수가 아닌 roomData 내의 states에 접근하여 할당
        if (roomData.features && roomData.features.states) {
            roomData.features.states.lottoPurchase[targetUid] = { time: Date.now(), price: finalPrice };
            var lottoBody = "1~15 사이의 숫자 3개를 입력해주세요.\n(예: 1 5 10)\n\n↩️ 뒤로 / 🏠 처음으로 / ❎취소";
            replier.reply(formatCommand("🎫 로또 번호 입력", user, lottoBody, "취소: [취소]"));
        } else {
            replier.reply(formatError(user, "시스템 오류", "로또 상태 저장소를 찾을 수 없습니다."));
        }
    }
    
    // 4. 상점 일반 아이콘 구매 처리
    else if (item.effect === "icon") {
        user.inventory.push({ id: item.id, name: item.name, icon: item.icon, effect: item.effect, title: "" });
        
        var isNewIcon = false;
        if (!user.collectedIcons) user.collectedIcons = [];
        if (user.collectedIcons.indexOf(item.icon) === -1) {
            user.collectedIcons.push(item.icon);
            isNewIcon = true;
        }
        user.icon = item.icon;
        replier.reply(formatCommand("🛒 구매 완료", user, item.name + " 구매 및 장착 성공!", "장착 변경: [/가방]"));

        /* [신규 수집 발생] 칭호 판정 호출 (Gemini 요청 사항 반영) */
        if (isNewIcon) checkCollectionMaster();
    }
    
    // 5. 기타 소모성 아이템 처리 (수량 qty 반영)
    else if (item.effect === "promotion") {
        user.purchasedPromotionAttempts = (user.purchasedPromotionAttempts || 0) + qty;
        replier.reply(formatCommand("🛒 구매 완료", user, item.name + " x" + qty + " 구매 성공!", "남은 승급 기회: " + (user.dailyPromotionAttempts + user.purchasedPromotionAttempts)));
    } else if (item.effect === "tierGuard") {
        user.tierGuard = (user.tierGuard || 0) + qty;
        replier.reply(formatCommand("🛒 구매 완료", user, item.name + " x" + qty + " 구매 성공!", "보유 방어권: " + user.tierGuard + "개"));
    } else if (item.effect === "credit") {
        var totalRestore = 20; 
        user.creditScore = Math.min(1000, (user.creditScore || 600) + totalRestore);
        user.dailyCreditRestoreCount = (user.dailyCreditRestoreCount || 0) + 1;
        
        if (typeof checkAndHandleDefaulter === 'function') checkAndHandleDefaulter(user, roomName);
        
        replier.reply(formatCommand("🛒 구매 완료", user, item.name + " 사용 성공! (신용 +" + totalRestore + ")", "현재 점수: " + user.creditScore + "점"));
    }

    /* [신규: Gemini 요청 사항] 경고삭제권(warnClear) 구매 완료 처리 */
    else if (item.effect === "warnClear") {
        user.boughtWarningRemoval = true;
        // 실제 경고(경고 카운트 등)가 존재한다면 여기서 초기화 로직을 수행합니다.
        if (user.warningCount !== undefined) user.warningCount = 0; 
        
        replier.reply(formatCommand("🎫 경고삭제권 사용 완료", user, "경고삭제권 구매 및 사용이 성공적으로 완료되었습니다.\n(평생 1회 사용 기록 완료)", "내 잔액: " + fp(user.point) + "P"));
    }

    // 6. 선박 이름변경권 효과 처리
    if (item.effect === "ship_rename") {
       bankProcessState[targetUid] = { type: 'ship_rename_input', time: Date.now(), extra: { price: finalPrice } };
        var renameBody = "새로운 선박의 이름을 입력해주세요.\n(2~8자, 띄어쓰기 인식 가능)\n\n" + "↩️ 뒤로 / 🏠 처음으로 / ❎취소";
        replier.reply(formatCommand("📝 선박 이름 변경", user, renameBody, "취소: [취소]"));
    }

    safeSaveData(data);
}

//==========섹터31==========

/**
 * [관리자 명령어 분배기] (Admin Logic Dispatcher - Registry Refactored)
 * 설명: 관리자 명령어의 통합 진입점입니다. 
 * 섹터 1의 ADMIN_COMMANDS 레지스트리를 참조하여 등록된 로직을 자동으로 매핑 및 실행합니다.
 */
function _handleAdminLogic(msg, user, data, replier, roomName, targetUid, sender) {
    // 1. 명령어 첫 단어 추출 (예: "/재원수정 1000" -> "/재원수정")
    var cmd = msg.split(" ")[0]; 

    // 2. 관리자 명령어 레지스트리(ADMIN_COMMANDS)에서 해당 명령어 검색
    // 섹터 6에서 등록된 매핑 정보를 바탕으로 최적화된 O(1) 탐색을 수행합니다.
    if (ADMIN_COMMANDS[cmd] && typeof ADMIN_COMMANDS[cmd].execute === 'function') {
        
        // 3. 등록된 하위 로직 함수(섹터 35~38 등)를 즉시 실행 및 결과 반환
        // 실행 시 필요한 모든 컨텍스트 객체를 인자로 전달합니다.
        return ADMIN_COMMANDS[cmd].execute(msg, user, data, replier, roomName, targetUid, sender);
    }

    // 4. 처리된 명령어가 없거나 등록되지 않은 경우 false 반환
    return false; 
}

//==========섹터32==========

/**
 * [관리자 하위 모듈 1] 시스템 기본 제어 및 권한 관리
 * 기능: 도움말, 봇구동, 강제재가동, 도박제한, 관리자 등록/해제
 */
function _adminSystemLogic(msg, user, data, replier, roomName, targetUid, sender) {

    /* 관리자 도움말 */
    if (msg === "/관리자") {
        var list = [];
        for(var i=0; i<ADMIN_CMD_LIST.length; i++) {
            list.push(ADMIN_CMD_LIST[i]);
        }
        replier.reply(formatAdmin("관리자 명령어 목록", list.join("\n")));
        return true;
    }

    /* [v10.8] 전역 공지 발송 명령어 (하단 문구 변경 버전) */
    if (msg.indexOf("/공지 ") === 0) {
        var content = msg.substring(4).trim();
        if (content.length < 1) {
            replier.reply(formatAdmin("오류", "공지 내용을 입력해주세요."));
            return true;
        }

        var noticeMsg = "📢 [내리다봇 전체 공지]\n" +
                        "━━━━━━━━━━━━━━━\n\n" +
                        content + "\n\n" +
                        "━━━━━━━━━━━━━━━\n" +
                        "📜 내리다봇 운영 정책에 따른 공식 알림";

        try {
            Api.replyRoom("내리다", noticeMsg);
            replier.reply(formatAdmin("공지 전송 완료", "'내리다' 방으로 공지를 정상 발송했습니다."));
        } catch (e) {
            replier.reply(formatAdmin("🚫 전송 실패", "사유: " + e.message));
        }
        return true;
    }

    /* 시스템 구동 제어 (온/오프) */
    if (msg.indexOf("/봇구동") === 0) {
        var parts = msg.trim().split(/\s+/);
        if (parts.length < 2) {
            replier.reply(formatAdmin("시스템 설정", "사용법: /봇구동 [온|오프]"));
            return true;
        }
        
        var state = parts[1];
        if (state === "온") {
            data.botActive = true;
            replier.reply(formatAdmin("시스템 설정", "✅ 시스템 가동을 시작합니다. (Online)"));
        } else if (state === "오프") {
            data.botActive = false;
            replier.reply(formatAdmin("시스템 설정", "🛑 시스템 가동을 중단합니다. (Offline)"));
        } else {
            replier.reply(formatAdmin("오류", "올바른 상태(온/오프)를 입력하세요."));
        }
        
        safeSaveData(data);
        return true;
    }

    /* 시스템 강제 재가동 (락 해제) */
    if (msg === "/강제재가동") {
        if (lock.isLocked()) lock.unlock();
        replier.reply(formatAdmin("완료", "시스템 락 해제 및 동기화 완료"));
        return true;
    }

    /* 도박 제한 설정 */
    if (msg.indexOf("/도박제한 ") === 0) {
        var sw = msg.split(" ")[1]; 
        data.gambleLimit = (sw === "온");
        safeSaveData(data);
        replier.reply(formatAdmin("설정", "도박 제한 상태: [" + sw + "]"));
        return true;
    }

    /* 관리자 등록 */
    if (msg.indexOf("/관리자등록 ") === 0) {
        var target = msg.substring(7).trim();
        if (!data.admins) data.admins = ["관리자"];
        if (data.admins.indexOf(target) !== -1) { 
            replier.reply(formatAdmin("관리자 등록 알림", "이미 관리자로 등록되어 있는 닉네임입니다.")); 
            return true; 
        }
        data.admins.push(target);
        safeSaveData(data);
        replier.reply(formatAdmin("관리자 등록 완료", "[" + target + "]님을 부관리자로 등록했습니다."));
        return true;
    }

    /* 관리자 해제 */
    if (msg.indexOf("/관리자해제 ") === 0) {
        var target = msg.substring(7).trim();
        if (target === "95 남 광어") { 
            replier.reply(formatAdmin("오류", "최상위 관리자 권한은 해제할 수 없습니다.")); 
            return true; 
        }
        if (!data.admins) data.admins = ["관리자"];
        var idx = data.admins.indexOf(target);
        if (idx === -1) { 
            replier.reply(formatAdmin("오류", "해당 닉네임을 관리자 명단에서 찾을 수 없습니다.")); 
            return true; 
        }
        data.admins.splice(idx, 1);
        safeSaveData(data);
        replier.reply(formatAdmin("관리자 해제 완료", "[" + target + "]님을 관리자 권한에서 제외했습니다."));
        return true;
    }

    /* 관리자 목록 */
    if (msg === "/관리자목록") {
        var list = data.admins || ["관리자"];
        replier.reply(formatAdmin("현재 관리자 명단", "• " + list.join("\n• ")));
        return true;
    }

    return false; // 처리된 명령어가 없음
}

//==========섹터33==========

/**
 * [관리자 하위 모듈 2] 로그 및 제보 관리
 * 기능: 버그 제보 확인/삭제, 오류 로그 확인/삭제, 관리자 활동 로그 조회
 */
function _adminLogLogic(msg, user, data, replier) {

    /* 버그 제보 목록 확인 */
    if (msg === "/제보목록") {
        var list = FileStream.read(BUG_LOG_PATH);
        if (!list || list.trim() === "") replier.reply(formatAdmin("제보 내역", "접수된 버그 제보가 없습니다."));
        else replier.reply(formatAdmin("📂 버그 제보 목록", list.trim()));
        return true;
    }

    /* 버그 제보 초기화 */
    if (msg === "/제보초기화") {
        FileStream.remove(BUG_LOG_PATH);
        replier.reply(formatAdmin("완료", "버그 제보 내역을 모두 삭제했습니다."));
        return true;
    }

    /* 오류 로그 확인 */
    if (msg === "/오류로그") {
        var list = FileStream.read(ERROR_LOG_PATH);
        if (!list || list.trim() === "") replier.reply(formatAdmin("오류 로그", "기록된 시스템 오류가 없습니다."));
        else replier.reply(formatAdmin("⚠️ 시스템 오류 로그", list.trim()));
        return true;
    }

    /* 오류 로그 초기화 */
    if (msg === "/오류초기화") {
        FileStream.remove(ERROR_LOG_PATH);
        replier.reply(formatAdmin("완료", "오류 로그를 모두 삭제했습니다."));
        return true;
    }

    /* 관리자 활동 로그 */
    if (msg === "/관리자로그") {
        var logs = data.adminLogs || [];
        replier.reply(formatAdmin("활동 로그", logs.slice(-10).join("\n") || "기록 없음"));
        return true;
    }

    return false;
}

//==========섹터34==========

/**
 * [관리자 하위 모듈 3] 유저 데이터 관리
 * 기능: 유저 조회, 수정, 삭제, 복원, 데이터 이전, 닉네임 기록, 신용 조정, 칭호 회수
 * 수정 사항: [Gemini 요청 사항] 오류 지급 칭호 박탈을 위한 /칭호회수 명령어 추가
 */
function _adminUserManageLogic(msg, user, data, replier, roomName, targetUid, sender) {

   /* [신규] 데이터 전수조사 (명부 무시하고 DB 전체에서 닉네임 검색) */
    if (msg.indexOf("/데이터전수조사 ") === 0) {
        var targetNick = msg.substring(9).trim();
        var report = ["📂 [" + targetNick + "] 전수 조사 결과"];
        var foundCount = 0;

        for (var r in data.rooms) {
            var users = data.rooms[r].users;
            for (var uid in users) {
                if (users[uid].name.indexOf(targetNick) !== -1) {
                    var u = users[uid];
                    report.push("📍 방: " + r + "\n💰 자산: " + fp(u.point) + "P / " + fp(u.bank) + "P\n🔑 UID: " + uid);
                    foundCount++;
                }
            }
        }
        if (foundCount === 0) return replier.reply(formatAdmin("조회 결과", "DB 내에 해당 닉네임과 일치하는 데이터가 전무합니다."));
        replier.reply(formatAdmin("시스템 전수 스캔", report.join("\n\n")));
        return true;
    }

    /* [신규] 명부 강제 등록 (특정 닉네임을 특정 UID로 강제 바인딩) */
    if (msg.indexOf("/명부강제등록 ") === 0) {
        var ps = msg.split(" ");
        if (ps.length < 3) return replier.reply(formatAdmin("오류", "사용법: /명부강제등록 [닉네임] [UID]"));
        var inputId = ps.pop().trim();
        var inputNick = ps.slice(1).join(" ").trim();

        var regKey = "내리다_" + inputNick;
        var regFile = new java.io.File(REGISTRY_PATH);
        var regData = regFile.exists() ? JSON.parse(FileStream.read(REGISTRY_PATH)) : {};
        
        regData[regKey] = inputId;
        FileStream.write(REGISTRY_PATH, JSON.stringify(regData));
        
        // 캐시도 즉시 갱신
        if (!globalData.nameToIdCache) globalData.nameToIdCache = {};
        globalData.nameToIdCache["GLOBAL_" + inputNick] = inputId;

        replier.reply(formatAdmin("✅ 명부 강제 교정 완료", "[" + inputNick + "]님을\nID: [" + inputId + "]로 강제 연결했습니다.\n\n이제 해당 계정으로 연동됩니다."));
        return true;
    }


   // 수정: /조작 명령어에서 findUserGlobal 호출 시 roomName 인자 추가
   if (msg.indexOf("/조작 ") === 0) {
        var ps = msg.trim().split(/\s+/);
        if (ps.length < 2) {
            replier.reply(formatAdmin("오류", "사용법: /조작 [닉네임] 또는 /조작 [닉네임] 온/오프"));
            return true;
        }

        var lastArg = ps[ps.length - 1];
        var targetNick = "";
        var mode = "VIEW"; 

        if (lastArg === "온") { mode = "ON"; ps.pop(); }
        else if (lastArg === "오프") { mode = "OFF"; ps.pop(); }
        
        targetNick = ps.slice(1).join(" ").trim();
        var found = findUserGlobal(targetNick, roomName);

        if (!found.length) { replier.reply(formatAdmin("오류", "유저를 찾을 수 없습니다.")); return true; }
        if (found.length > 1) { 
            handleUserSelection(replier, targetUid, found, "admin_mani_select", { mode: mode }, user, roomName); 
            return true; 
        }

        var targetUser = found[0].data;
        var tRoom = found[0].roomName;
        var targetId = found[0].id;

        if (mode === "ON") {
            targetUser.isManipulated = true;
            targetUser.gambleWinRate = SYSTEM_CONFIG.MANIPULATION.DEFAULT_GAMBLE;
            targetUser.fishLuck = SYSTEM_CONFIG.MANIPULATION.DEFAULT_FISH;
            targetUser.horseWinRate = SYSTEM_CONFIG.MANIPULATION.DEFAULT_RACING;
            targetUser.spittoWinRate = SYSTEM_CONFIG.MANIPULATION.DEFAULT_SPITTO;
            targetUser.skipHealing = true;
            replier.reply(formatAdmin("🎯 조작 가동", targetUser.name + "님의 조작을 [기본값]으로 활성화했습니다."));
        } else if (mode === "OFF") {
            targetUser.isManipulated = false;
            replier.reply(formatAdmin("🎯 조작 해제", targetUser.name + "님의 모든 조작을 종료했습니다."));
        } else {
            // [VIEW 모드] 상태 브리핑 및 메뉴 출력
            var status = "👤 대상: [" + tRoom + "] " + targetUser.name + "\n" +
                         "✨ 상태: " + (targetUser.isManipulated ? "🟢 가동 중" : "⚪ 미가동") + "\n\n" +
                         "1. 🎲 홀짝 승률: " + (targetUser.gambleWinRate || 0) + "%\n" +
                         "2. 🎣 낚시 보정: " + (targetUser.fishLuck || 0) + "%\n" +
                         "3. 🏇 경마 보정: " + (targetUser.horseWinRate || 0) + "%\n" +
                         "4. 🧧 스피또 보정: " + (targetUser.spittoWinRate || 0) + "%\n" +
                         "5. ❌ 조작 전체 해제\n\n" +
                         "💡 수정할 번호를 입력하거나 [취소] 하세요.";
            
            var menuWaitState = data.rooms[roomName].features.states.menuWait;
            menuWaitState[targetUid] = { 
                type: 'admin_mani_menu', 
                time: Date.now(), 
                extra: { targetId: targetId, targetRoom: tRoom } 
            };
            replier.reply(formatAdmin("🎯 조작 설정 센터", status));
        }
        safeSaveData(data);
        return true;
    }

    // [관리자 기능] 전체 방 목록 및 유저 수 스캔 (데이터 위치 추적용)
            if (msg === "/방목록") {
                if (!user.isAdmin) return; // 관리자 권한 확인

                var list = "📋 [데이터베이스 방 목록]\n━━━━━━━━━━━━━━━\n";
                var count = 0;
                var totalUsers = 0;
                
                for (var rName in data.rooms) {
                    var roomObj = data.rooms[rName];
                    var uCount = 0;
                    if (roomObj && roomObj.users) {
                        uCount = Object.keys(roomObj.users).length;
                    }
                    
                    list += (count + 1) + ". " + rName + " (유저: " + uCount + "명)\n";
                    count++;
                    totalUsers += uCount;
                }
                
                list += "━━━━━━━━━━━━━━━\n";
                list += "📊 총 " + count + "개 방 / " + totalUsers + "명 데이터 로드됨";
                
                replier.reply(formatAdmin("💾 DB 데이터 현황", list));
                return;
            }

    if (msg === "/연동진단") {
        var targetRoom = "내리다"; // 메인 방 이름 (정확해야 함)
        var mainData = data.rooms[targetRoom];
        
        // [수정] sender 대신 user.name 사용 (참조 오류 해결)
        var myName = user.name.trim(); 

        var report = "🔍 [시스템 데이터 정밀 진단]\n━━━━━━━━━━━━━━━\n";

        // 1. 방 데이터 존재 여부 검사
        if (!mainData) {
            report += "❌ [치명적] '" + targetRoom + "' 방 데이터가 없습니다.\n";
            report += "💡 현재 저장된 방 목록:\n[" + Object.keys(data.rooms).join(", ") + "]";
        } else {
            report += "✅ '" + targetRoom + "' 방 데이터가 존재합니다.\n";
            
            // 2. 유저 매칭 시도
            var exactMatch = null;
            var trimMatch = null;
            var similarList = [];

            for (var uid in mainData.users) {
                var uName = mainData.users[uid].name;
                
                if (uName === user.name) exactMatch = uid;
                if (uName.trim() === myName) trimMatch = uid;
                
                // 디버깅용: 내 이름이 포함된 유저가 있는지 확인
                if (uName.indexOf(myName) !== -1 || myName.indexOf(uName) !== -1) {
                    similarList.push("[" + uName + "]");
                }
            }

            report += "\n👤 유저 찾기 결과:\n";
            if (exactMatch) {
                report += "✅ 완벽 일치 성공! (UID: " + exactMatch + ")\n";
                report += "💰 보유 포인트: " + fp(mainData.users[exactMatch].point) + "P";
            } else if (trimMatch) {
                report += "⚠️ 공백 제거 후 일치 성공 (UID: " + trimMatch + ")\n";
                report += "👉 원본: [" + mainData.users[trimMatch].name + "] / 나: [" + user.name + "]\n";
                report += "💡 해결책: 닉네임의 띄어쓰기를 확인하세요.";
            } else {
                report += "❌ 일치하는 닉네임 없음.\n";
                report += "👉 현재 내 닉네임: [" + user.name + "] (길이:" + user.name.length + ")\n";
                if (similarList.length > 0) {
                    report += "❓ 혹시 이 닉네임인가요?: " + similarList.join(", ");
                } else {
                    report += "💡 메인방에 접속 기록이 아예 없습니다.";
                }
            }
        }

        replier.reply(report);
    }

    if (msg.indexOf("/진단 ") === 0) {
        var tn = msg.substring(4).trim();
        var roomData = data.rooms[roomName];
        var found = findUserByName(roomData, tn);

        if (found.length === 0) {
            replier.reply("❌ [" + tn + "] 유저를 찾을 수 없습니다.");
            return true;
        }

        // [식별 개선] 검색된 유저가 여러 명일 경우 목록과 ID를 먼저 출력
        if (found.length > 1) {
            var multiList = found.map(function(f, i) { 
                return (i+1) + ". " + f.data.name + " (" + fp(f.data.point) + "P)\n   └ ID: " + f.id; 
            }).join("\n\n");
            replier.reply(formatAdmin("🔍 중복 유저 식별", "방 안에 동일 닉네임 데이터가 " + found.length + "개 발견되었습니다.\n상세 진단은 정확한 풀네임을 입력하세요.\n\n" + multiList));
            return true;
        }

        var t = found[0].data;
        var tId = found[0].id;
        var rFeatures = roomData.features;
        var st = rFeatures.states;
        var now = Date.now();

        var report = "🔍 [" + tn + "] 유저 정밀 진단 보고서\n" +
                     "📌 고유 ID: " + tId + "\n" + // ID 상단 배치
                     "━━━━━━━━━━━━━━━\n\n";
        
        // 1. 스팸 분석
        var isSpam = (t.timeoutEndTime && now < t.timeoutEndTime);
        report += "[🚫 스팸 및 시스템 제한]\n" +
                  "• 필터: " + (isSpam ? "차단됨 (제한 중)" : "정상") + " (Timeout: " + (isSpam ? Math.ceil((t.timeoutEndTime - now)/1000) : 0) + ")\n\n";

        // 2. 활동 분석
        report += "[⛓️ 구속 및 강제 활동]\n" +
                  "• 징역: " + (t.jailReleaseTime && now < t.jailReleaseTime ? "수감 중 (" + Math.ceil((t.jailReleaseTime - now)/60000) + "분)" : "정상 (잔여: 0분)") + "\n\n";

        // 3. 논리적 대기 상태 (모든 State 주머니 스캔)
        report += "[⏳ 논리적 대기 상태]\n";
        report += "• 메뉴: " + (st.menuWait[tId] ? "선택 대기 중" : "없음") + "\n";
        report += "• 은행/상점: " + (st.bankProcess[tId] ? "수량 입력 대기 중 (꼬임 발생 가능!)" : "없음") + "\n";
        report += "• 로또: " + (st.lottoPurchase[tId] ? "번호 입력 중" : "없음") + "\n";
        report += "• 중복선택: " + (st.selectWait[tId] ? "유저 선택 대기 중 (확인 필요)" : "없음") + "\n";
        report += "• 사채등록: " + (st.loanRegister[tId] ? "등록 절차 진행 중" : "없음") + "\n\n";

        // 4. 데이터 무결성 점검
        report += "[🛠️ 데이터 무결성 점검]\n";
        var isInvOk = Array.isArray(t.inventory);
        var isLoanOk = (t.loan && typeof t.loan === 'object');
        var lastStat = t.lastAction ? t.lastAction.status : "NONE";
        
        // NaN/Infinite 연산 결함 체크 (추가 꼬임 방지)
        var isCalcOk = (!isNaN(t.point) && isFinite(t.point) && !isNaN(t.bank));

        report += "• 인벤토리: " + (isInvOk ? "정상 (Array 확인)" : "❗파손") + "\n";
        report += "• 대출객체: " + (isLoanOk ? "정상 (Object 확인)" : "❗누락") + "\n";
        report += "• 직전작업: " + lastStat + " (" + (t.lastAction ? t.lastAction.cmd : "로직 중단 의심") + ")\n";
        report += "• 연산결함: " + (isCalcOk ? "정상 (NaN/Infinite 없음)" : "❗결함발견") + "\n";

        report += "━━━━━━━━━━━━━━━\n" +
                  "💡 진단: ";
        
        if (isSpam) report += "스팸 필터 작동 중.";
        else if (st.menuWait[tId] || st.bankProcess[tId] || st.selectWait[tId]) report += "입력 대기 로직에 갇혀 있습니다. [취소]를 입력하게 하세요.";
        else if (lastStat === "PENDING") report += "로직이 수행 중 멈췄습니다. 시스템 재가동을 권장합니다.";
        else if (!isCalcOk) report += "포인트 변수가 오염되었습니다. 관리자 수정이 필요합니다.";
        else report += "데이터상 정상입니다. 특정 유저만 안 된다면 식별 캐시를 확인하세요.";

        replier.reply(report);
        return true;
    }

    if (msg.indexOf("/무역복구 ") === 0) {
    var tn = msg.substring(6).trim();
    var found = findUserGlobal(tn);

    if (found.length === 0) {
        replier.reply(formatAdmin("🚫 대상 없음", "[" + tn + "] 유저를 찾을 수 없습니다."));
        return true;
    }
    
    var tUser = found[0].data;
    if (!tUser.voyage || tUser.voyage.active !== true) {
        replier.reply(formatAdmin("❌ 복구 불가", "해당 유저는 현재 항해 중이 아닙니다."));
        return true;
    }

    // 강제 락 해제 및 정산 가능 상태로 초기화
    tUser.voyage.isProcessing = false;
    tUser.voyage.isAlerted = false;
    tUser.voyage.arrival = Date.now() - 1000; // 도착 시간을 과거로 돌려 즉시 정산 유도
    tUser.skipHealing = true;

    safeSaveData(data, true);
    replier.reply(formatAdmin("⚓ 무역 정산 락 해제 완료", tUser.name + "님의 정산 대기 상태를 초기화했습니다.\n이제 해당 유저가 채팅을 치면 즉시 정산됩니다."));
    return true;
}

    /* 상세 유저 데이터 조회 */
    if (msg.indexOf("/유저데이터 ") === 0) {
        var tn = msg.substring(7).trim();
        var roomData = data.rooms[roomName];
        var found = findUserByName(roomData, tn);
        if (!found.length) replier.reply(formatAdmin("오류", "유저를 찾을 수 없습니다."));
        else if (found.length > 1) handleUserSelection(replier, targetUid, found, "admin_userdata", null, user, roomName);
        else replier.reply(formatAdmin("유저 데이터 조회", JSON.stringify(found[0].data, null, 2)));
        return true;
    }

    /* 닉네임 변경 이력 */
    if (msg.indexOf("/닉네임기록 ") === 0) {
        var tn = msg.substring(7).trim();
        var roomData = data.rooms[roomName];
        var found = findUserByName(roomData, tn);
        if (!found.length) { replier.reply(formatAdmin("오류", "유저를 찾을 수 없습니다.")); return true; }
        if (found.length > 1) { handleUserSelection(replier, targetUid, found, "admin_nick_log", null, user, roomName); return true; }
        var targetId = found[0].id;
        var history = data.nickHistory[targetId] || [];
        if (history.length === 0) { replier.reply(formatAdmin("닉네임 기록", getDisplayName(found[0].data) + "님은 변경 이력이 없습니다.")); return true; }
        var logMsg = [];
        for(var i=0; i<history.length; i++) logMsg.push((i+1) + ". " + history[i].old + " (" + history[i].date + ")");
        replier.reply(formatAdmin("📋 닉네임 변경 이력", "현재: " + found[0].data.name + "\n\n[과거 기록]\n" + logMsg.join("\n")));
        return true;
    }

    /* [신규] 신용 점수 직접 조정 (v5.2) */
    if (msg.indexOf("/신용조정 ") === 0) {
        var ps = msg.split(" ");
        if (ps.length < 3) {
            replier.reply(formatAdmin("오류", "형식: /신용조정 [닉네임] [점수]\n예) /신용조정 홍길동 -50"));
            return true;
        }
        var scoreChange = parseInt(ps.pop());
        var targetName = ps.slice(1).join(" ").trim();
        var roomData = data.rooms[roomName];
        var found = findUserByName(roomData, targetName);

        if (isNaN(scoreChange)) { replier.reply(formatAdmin("오류", "조정할 점수를 숫자로 입력하세요.")); return true; }
        if (!found.length) { replier.reply(formatAdmin("오류", "유저를 찾을 수 없습니다.")); return true; }
        if (found.length > 1) { 
            handleUserSelection(replier, targetUid, found, "admin_credit_edit", { score: scoreChange }, user, roomName);
        return true; 
    }

        var targetUser = found[0].data;
        var oldScore = Number(targetUser.creditScore || 600);
        targetUser.creditScore = Math.min(1000, Math.max(0, oldScore + scoreChange));
        
        if (typeof checkAndHandleDefaulter === 'function') {
            checkAndHandleDefaulter(targetUser, roomName);
        }

        safeSaveData(data);
        var crInfo = getCreditInfo(targetUser.creditScore);
        var resText = "대상: " + getDisplayName(targetUser) + "님\n" +
                      "변동: " + (scoreChange > 0 ? "+" : "") + scoreChange + "점\n" +
                      "현재: " + targetUser.creditScore + "점 (" + crInfo.label + ")";
        
        replier.reply(formatAdmin("⚙️ 신용 점수 조정 완료", resText));
        return true;
    }

    /* [Gemini 요청 사항] 관리자 전용 칭호 회수 로직 (오류 지급분 박탈용) */
    if (msg.indexOf("/칭호회수 ") === 0) {
        var ps = msg.split(" ");
        if (ps.length < 3) {
            replier.reply(formatAdmin("오류", "형식: /칭호회수 [닉네임] [칭호명]"));
            return true;
        }
        var titleToTake = ps.pop().trim();
        var targetName = ps.slice(1).join(" ").trim();
        var roomData = data.rooms[roomName];
        var found = findUserByName(roomData, targetName);

        if (!found.length) { replier.reply(formatAdmin("오류", "유저를 찾을 수 없습니다.")); return true; }
    if (found.length > 1) {
        handleUserSelection(replier, targetUid, found, "admin_title_take", { title: titleToTake }, user, roomName);
        return true;
    }

        var targetUser = found[0].data;
        var inv = targetUser.inventory || [];
        var removed = false;

        // 1. 인벤토리(가방)에서 해당 칭호 삭제
        targetUser.inventory = inv.filter(function(it) {
            if (it.effect === "title" && (it.title === titleToTake || it.name.indexOf(titleToTake) !== -1)) {
                removed = true;
                return false;
            }
            return true;
        });

        // 2. 현재 장착 중인 경우 해제
        if (targetUser.title === titleToTake) {
            targetUser.title = "";
            removed = true;
        }

        if (removed) {
            safeSaveData(data);
            replier.reply(formatAdmin("🎖️ 칭호 회수 완료", getDisplayName(targetUser) + "님에게서 [" + titleToTake + "] 칭호를 박탈했습니다."));
        } else {
            replier.reply(formatAdmin("회수 실패", getDisplayName(targetUser) + "님은 해당 칭호를 보유하고 있지 않습니다."));
        }
        return true;
    }

    /* 출석 초기화 */
    if (msg.indexOf("/출석초기화 ") === 0) {
        var tn = msg.substring(7).trim();
        var roomData = data.rooms[roomName];
        var found = findUserByName(roomData, tn);
        if (!found.length) { replier.reply(formatAdmin("오류", "유저를 찾을 수 없습니다.")); return true; }
        if (found.length > 1) { handleUserSelection(replier, targetUid, found, "admin_attend_reset", null, user, roomName); return true; }
        found[0].data.lastDate = "";
        safeSaveData(data);
        replier.reply(formatAdmin("출석 초기화 완료", getDisplayName(found[0].data) + "님의 오늘 출석 기록을 삭제했습니다."));
        return true;
    }

    /* 출석 일수 수정 */
    if (msg.indexOf("/출석일수수정 ") === 0) {
        var ps = msg.split(" "), days = parseInt(ps.pop()), tn = ps.slice(1).join(" ");
        var roomData = data.rooms[roomName];
        var found = findUserByName(roomData, tn);
        if (!found.length) { replier.reply(formatAdmin("오류", "대상 없음")); return true; }
        if (found.length > 1) { handleUserSelection(replier, targetUid, found, "admin_attend_edit", { days: days }, user, roomName); return true; }
        found[0].data.totalAttendance = days; safeSaveData(data);
        replier.reply(formatAdmin("수정 완료", getDisplayName(found[0].data) + ": " + days + "일"));
        return true;
    }

    /* 전체 출석 수정 */
    if (msg.indexOf("/전체출석수정 ") === 0) {
        var days = parseInt(msg.split(" ")[1]);
        for (var r in data.rooms) {
            for (var id in data.rooms[r].users) { data.rooms[r].users[id].totalAttendance = days; }
        }
        safeSaveData(data);
        replier.reply(formatAdmin("완료", "전체 출석 " + days + "일로 고정"));
        return true;
    }

    /* 데이터 이전 */
    if (msg.indexOf("/데이터이전 ") === 0) {
        if (msg.indexOf(" > ") === -1) { replier.reply(formatAdmin("오류", "형식이 올바르지 않습니다.\n예) /데이터이전 구닉네임 > 신닉네임")); return true; }
        var names = msg.substring(7).split(" > ");
        var oldName = names[0].trim();
        var newName = names[1].trim();
        var roomData = data.rooms[roomName];
        
        var oldFound = findUserByName(roomData, oldName);
        var newFound = findUserByName(roomData, newName);

        if (oldFound.length === 0) { replier.reply(formatAdmin("오류", "구 닉네임을 찾을 수 없습니다.")); return true; }
        if (newFound.length === 0) { replier.reply(formatAdmin("오류", "신 닉네임을 찾을 수 없습니다.")); return true; }
        if (oldFound.length > 1 || newFound.length > 1) { replier.reply(formatAdmin("오류", "중복 닉네임이 존재합니다. 정확한 풀네임을 입력해주세요.")); return true; }

        var oldId = oldFound[0].id;
        var oldData = oldFound[0].data;
        var newData = newFound[0].data;

        newData.point = oldData.point;
        newData.bank = oldData.bank;
        newData.tier = oldData.tier;
        newData.creditScore = oldData.creditScore;
        newData.totalAttendance = oldData.totalAttendance;
        newData.loan = oldData.loan;
        newData.stockHoldings = oldData.stockHoldings;
        newData.stockAvg = oldData.stockAvg;
        newData.icon = oldData.icon;
        newData.title = oldData.title;

        if (typeof uidCache !== 'undefined') {
            for (var key in uidCache) {
                if (uidCache[key] === oldId) delete uidCache[key];
            }
        }
        delete roomData.users[oldId];
        safeSaveData(data);
        replier.reply(formatAdmin("데이터 이전 성공", oldName + " ➔ " + newName + "\n모든 자산 및 등급이 이전되었습니다."));
        return true;
    }

    /* [v11.6] 유저 삭제 (UID/닉네임 통합 및 중복 방지 강화) */
    if (msg.indexOf("/유저삭제 ") === 0) {
        var input = msg.substring(6).trim();
        var roomData = data.rooms[roomName];
        var targetId = null;
        var targetData = null;

       // [수정]: 현재 방이 "내리다"인 경우, 전역 스캔을 하지 않고 현재 방의 UID만 체크합니다.
        if (roomName === "내리다") {
            if (roomData.users[input]) {
                targetId = input;
                targetData = roomData.users[input];
                targetRoomName = "내리다";
            }
        } else {
            // 관제센터(베릭방) 등에서는 전역 스캔 유지
            for (var rName in data.rooms) {
                if (data.rooms[rName].users && data.rooms[rName].users[input]) {
                    targetId = input;
                    targetData = data.rooms[rName].users[input];
                    targetRoomName = rName;
                    break;
                }
            }
        }

        // 2순위 - 닉네임 검색 시에도 현재 방 정보를 넘겨 필터링 작동 유도
        if (!targetId) {
            var found = findUserGlobal(input, roomName);
            
            if (found.length === 0) {
                replier.reply(formatAdmin("🚫 대상 없음", "[" + input + "] 유저를 찾을 수 없습니다.\n(UID가 정확한지 확인하세요)"));
                return true;
            }
            
            // 중복 닉네임 발견 시 선택 창 호출
            if (found.length > 1) {
                handleUserSelection(replier, targetUid, found, "admin_delete", null, user, roomName);
                return true;
            }
            
            targetId = found[0].id;
            targetData = found[0].data;
            targetRoomName = roomName;
        }

        // 실제 데이터가 위치한 방의 객체 참조
        var actualRoomData = data.rooms[targetRoomName];
        var tName = targetData.name;
        var refundLog = "";
        var refundCount = 0;
        var totalRefunded = 0;

        // 1. 사채 계약 정산 및 보전 (실제 데이터가 있는 방 기준)
        if (actualRoomData.loanContracts) {
            for (var cid in actualRoomData.loanContracts) {
                var c = actualRoomData.loanContracts[cid];
                if (c.borrowerUid === targetId) {
                    var lender = actualRoomData.users[c.lenderUid];
                    if (lender) {
                        var debtAmt = Number(c.currentDebt);
                        util_updatePoint(lender, actualRoomData, debtAmt, "사채 강제 정산", targetRoomName);
                        totalRefunded += debtAmt;
                        refundCount++;
                        try { Api.replyRoom(targetRoomName, "🚬 [사채 강제 정산]\n" + tName + "님의 데이터 삭제로 인해 " + lender.name + "님께 미수금 " + fp(debtAmt) + "P가 전액 반환되었습니다."); } catch(e){}
                    }
                    delete actualRoomData.loanContracts[cid];
                }
            }
        }

        // 2. 은행 대출금 국고 회수
        if (targetData.loan && Number(targetData.loan.debt) > 0) {
            var bankDebt = Number(targetData.loan.debt);
            util_updateReserve(actualRoomData, bankDebt, "대출금 국고 회수", targetRoomName);
            refundLog += "\n🏦 은행 대출금 " + fp(bankDebt) + "P가 국고로 자동 회수되었습니다.";
        }

        if (refundCount > 0) refundLog += "\n⚠️ 사채 보전 완료: " + refundCount + "건 (" + fp(totalRefunded) + "P)";

        // 3. 캐시 및 메모리 파기
        if (typeof uidCache !== 'undefined') {
            for (var key in uidCache) { if (uidCache[key] === targetId) delete uidCache[key]; }
        }
        if (globalData.nameToIdCache) {
            delete globalData.nameToIdCache["GLOBAL_" + tName];
        }

        // 4. 데이터베이스 및 영구 명부 삭제
        delete actualRoomData.users[targetId];
        try {
            var regFile = new java.io.File(REGISTRY_PATH);
            if (regFile.exists()) {
                var regData = JSON.parse(FileStream.read(REGISTRY_PATH));
                // 명부에서 [방이름_유저이름] 조합 키를 찾아 삭제
                delete regData[targetRoomName + "_" + tName];
                FileStream.write(REGISTRY_PATH, JSON.stringify(regData));
            }
        } catch (e) { Log.error("Registry Delete Error: " + e); }

        safeSaveData(data);
        replier.reply(formatAdmin("유저 삭제 완료", "📍 소속: [" + targetRoomName + "]\n[" + tName + "]님의 데이터를 영구 삭제하고 명부에서 파기했습니다." + refundLog));
        return true;
        }

    if (msg.indexOf("/채굴시간복구 ") === 0) {
        var ps = msg.split(" "), addMin = parseInt(ps.pop()), tn = ps.slice(1).join(" ");
        var roomData = data.rooms[roomName];
        var found = findUserByName(roomData, tn);
        
        if (!found.length) { replier.reply(formatAdmin("오류", "대상을 찾을 수 없습니다.")); return true; }
        if (isNaN(addMin)) { replier.reply(formatAdmin("오류", "복구할 분(Min)을 숫자로 입력하세요.")); return true; }

        var targetUser = found[0].data;
        var oldMin = targetUser.totalMiningTime || 0;
        targetUser.totalMiningTime = oldMin + addMin;
        targetUser.skipHealing = true; // 보안 엔진 예외 허용
        
        safeSaveData(data);
        replier.reply(formatAdmin("⏳ 채굴 시간 복구 완료", 
            "대상: " + targetUser.name + "\n" +
            "기존: " + oldMin + "분\n" +
            "추가: +" + addMin + "분\n" +
            "최종: " + targetUser.totalMiningTime + "분"));
        return true;
    }

if (msg === "/전체채굴복구") {
        var backupPath = BACKUP_DIR + "last_stable_backup.json";
        var backupFile = new java.io.File(backupPath);
        var logFile = new java.io.File(JOURNAL_PATH);

        if (!backupFile.exists()) {
            replier.reply(formatAdmin("🚫 복구 불가", "2월 2일자 백업 파일이 없습니다."));
            return true;
        }

        try {
            var backupData = JSON.parse(FileStream.read(backupPath));
            var revokeKeywords = ["광산", "가결산", "채굴", "복구"];
            var pointRevoked = 0, titleRevoked = 0, totalFixed = 0;

            // [Step 1] 오늘(00시 이후) 잘못 지급된 포인트 로그 전수 조사
            var blackListProfits = {}; // { uid: amount }
            if (logFile.exists()) {
                var logs = FileStream.read(JOURNAL_PATH).split("\n");
                logs.forEach(function(line) {
                    if (!line.trim()) return;
                    var p = line.split("|");
                    if (p.length < 5) return;
                    
                    var reason = p[4];
                    var isTargetReason = revokeKeywords.some(function(k) { return reason.indexOf(k) !== -1; });
                    
                    // 오늘 날짜이면서 광산 관련으로 '지급(+)'된 내역만 합산
                    if (isTargetReason && Number(p[2]) > 0) {
                        blackListProfits[p[0]] = (blackListProfits[p[0]] || 0) + Number(p[2]);
                    }
                });
            }

            for (var rName in data.rooms) {
                var currentRoom = data.rooms[rName];
                var backupRoom = backupData.rooms[rName];
                if (!backupRoom) continue;

                for (var uid in currentRoom.users) {
                    var u = currentRoom.users[uid];
                    var bu = backupRoom.users[uid];

                    if (bu && bu.mining) {
                        u.skipHealing = true;

                        // 1. 부당 포인트 회수 및 국고 환수
                        if (blackListProfits[uid]) {
                            var amt = blackListProfits[uid];
                            u.point = Number(u.point) - amt;
                            currentRoom.bankReserve = (currentRoom.bankReserve || 0) + amt;
                            pointRevoked++;
                        }

                        // 2. 누적 데이터 롤백 (백업 시점의 순수 누적치로 고정)
                    u.totalMiningTime = Number(bu.totalMiningTime || 0);
                    u.artifactPieces = Number(bu.artifactPieces || 0);

                    // 3. [교정] 시간 축 정상화: 현재 채굴 중이라면 '지금 이 순간'부터 다시 시작
                    // 과거 startTime으로 소급하면 현재 세션 시간이 비정상적으로 합산되는 버그가 발생함
                    if (u.mining && u.mining.active === true) {
                        u.mining.startTime = Date.now(); 
                        u.mining.active = true;
                    }

                        // 4. 자격 미달 칭호 전수 회수 (채굴왕 정밀 삭제)
                        if (u.totalMiningTime < 10000) {
                            var hasTitle = false;
                            u.inventory = u.inventory.filter(function(it) {
                                if (it.title === "채굴왕" || it.name.indexOf("채굴왕") !== -1) {
                                    hasTitle = true;
                                    return false;
                                }
                                return true;
                            });
                            if (u.title === "채굴왕") u.title = "";
                            if (hasTitle) titleRevoked++;
                        }
                        totalFixed++;
                    }
                }
            }

            safeSaveData(data, true);
            if (typeof globalData !== 'undefined') globalData = data;

            var report = "🛰️ [광산 시계열 통합 및 정화 완료]\n" +
                         "━━━━━━━━━━━━━━━\n" +
                         "• 대상 인원: " + totalFixed + "명\n" +
                         "• 포인트 환수: " + pointRevoked + "명 (정산금 회수)\n" +
                         "• 칭호 박탈: " + titleRevoked + "명 (자격미달 제거)\n" +
                         "━━━━━━━━━━━━━━━\n" +
                         "💡 00시 리셋 이전의 시작 시간으로 소급되었습니다.\n" +
                         "이제 모든 유저는 어제부터 이어온 상태로 채굴됩니다.";
            replier.reply(formatAdmin("시스템 타임라인 복구 보고", report));

        } catch (e) {
            Log.error("Mining Timeline Merge Error: " + e);
            replier.reply(formatAdmin("🚫 오류 발생", "로그 분석 및 데이터 병합 중 결함 발생"));
        }
        return true;
    }

    if (msg === "/배당금강제정산") {
        data.lastDailyReset = ""; 
        _runSector17Logic(data, { today: getSimpleDate(), now: new Date(), targetRoom: roomName, season: getSimpleSeason() });
        replier.reply(formatAdmin("🚀 배당금 수동 지급 완료", "현재 주머니의 수익을 배당하고 00시 정산을 강제 완료했습니다."));
        return true;
    }

    /* [신규] 지능형 거래 역추적 명령어 */
    if (msg.indexOf("/블랙박스 ") === 0) {
        var tn = msg.substring(6).trim();
        var roomData = data.rooms[roomName];
        var found = findUserByName(roomData, tn);

        if (found.length === 0) {
            replier.reply(formatAdmin("🚫 대상 없음", "[" + tn + "] 유저를 찾을 수 없습니다."));
        } else if (found.length > 1) {
            handleUserSelection(replier, targetUid, found, "admin_blackbox", null, user, roomName);
        } else {
            _executeBlackboxSearch(found[0].id, found[0].data, replier);
        }
        return true;
    }

    /* 블랙박스 파일 분석 및 출력 엔진 */
    function _executeBlackboxSearch(uid, targetUser, replier) {
    try {
        var logs = [];
        var filesToRead = [JOURNAL_PATH, BASE_DIR + "total_history.log"];

        filesToRead.forEach(function(path) {
            var file = new java.io.File(path);
            if (file.exists() && file.length() > 0) {
                var lines = FileStream.read(path).split("\n");
                lines.forEach(function(line) {
                    if (!line.trim()) return;
                    var parts = line.split("|");
                    if (parts[0] === uid) {
                        var delta = Number(parts[2]);
                        var sign = delta > 0 ? "➕" : "➖";
                        // 최신순 정렬을 위해 배열 앞에 추가
                        logs.unshift("• [" + parts[4] + "] " + sign + fp(Math.abs(delta)) + "P");
                    }
                });
            }
        });

        var readMore = "\u200b".repeat(500); // 전체보기 유도용 공백
        var resultBody = "👤 대상: " + targetUser.name + "\n" +
                         "🆔 ID: " + uid + "\n" +
                         "━━━━━━━━━━━━━━━" + readMore + "\n" +
                         (logs.length > 0 ? logs.join("\n") : "오늘 거래 내역이 없습니다.") + "\n" +
                         "━━━━━━━━━━━━━━━\n" +
                         "💰 현재 잔액: " + fp(targetUser.point) + "P";

        replier.reply(formatAdmin("📋 유저 당일 전체 블랙박스", resultBody));
    } catch (e) {
        replier.reply(formatAdmin("🚫 분석 실패", "로그 분석 중 오류 발생: " + e));
    }
}

    /* [개인 복구] 4대 보안 가드가 적용된 지능형 유저 복구 (Smart User Restore v5.9.1) */
    if (msg.indexOf("/유저복원 ") === 0) {
    var fullInput = msg.substring(6).trim();
    var roomData = data.rooms[roomName];

    var words = fullInput.split(/\s+/);
    var lastWord = words[words.length - 1];
    var isUUID = (lastWord.split("-").length >= 5 && lastWord.length >= 36);

    var targetNick = "";
    var sourceCode = "";

    if (isUUID) {
        sourceCode = lastWord;
        targetNick = fullInput.substring(0, fullInput.lastIndexOf(lastWord)).trim();
    } else {
        targetNick = fullInput;
        sourceCode = ""; 
    }

    // [수정]: 삭제된 유저도 복구할 수 있도록 현재 방 검색 로직을 유연하게 변경
    var currentFound = findUserByName(roomData, targetNick);
    if (currentFound.length > 1) { 
        handleUserSelection(replier, targetUid, currentFound, "user_restore", { sourceCode: sourceCode }, user, roomName);
        return true; 
    }

    // 1순위: 입력된 UID 사용 / 2순위: 현재 방에서 찾은 ID 사용 / 3순위: null (백업 전체 검색)
    var targetId = isUUID ? sourceCode : (currentFound.length > 0 ? currentFound[0].id : null);
    var stablePath = BACKUP_DIR + "last_stable_backup.json";
    var stableFile = new java.io.File(stablePath);

    if (!stableFile.exists()) {
        replier.reply(formatAdmin("🚫 복구 불가", "안전 백업 파일이 존재하지 않습니다."));
        return true;
    }

    try {
        var backupContent = FileStream.read(stablePath);
        var backupData = JSON.parse(backupContent);
        var backupUser = null;
        var finalUid = targetId;

        // [A] UID가 있는 경우 해당 데이터 추출
        if (finalUid) {
            for (var r in backupData.rooms) {
                if (backupData.rooms[r].users[finalUid]) {
                    backupUser = JSON.parse(JSON.stringify(backupData.rooms[r].users[finalUid]));
                    break;
                }
            }
        } 
        
        // [B] UID가 없거나 못 찾은 경우 백업 파일 전 구역에서 닉네임으로 검색
        if (!backupUser) {
            for (var r in backupData.rooms) {
                for (var uid in backupData.rooms[r].users) {
                    if (backupData.rooms[r].users[uid].name === targetNick) {
                        backupUser = JSON.parse(JSON.stringify(backupData.rooms[r].users[uid]));
                        finalUid = uid;
                        break;
                    }
                }
                if (backupUser) break;
            }
        }

        if (!backupUser) throw new Error("백업본에서도 [" + targetNick + "] 유저를 찾을 수 없습니다.");

        // 데이터 이식: 현재 방의 유저 목록에 강제 삽입
        var fullNick = backupUser.name;
        roomData.users[finalUid] = backupUser;
        roomData.users[finalUid].skipHealing = true;

        // 명부(Registry) 복구: 1:1방 연동을 위해 필수
        var regFile = new java.io.File(REGISTRY_PATH);
        var regData = regFile.exists() ? JSON.parse(FileStream.read(REGISTRY_PATH)) : {};
        regData[roomName + "_" + fullNick] = finalUid;
        FileStream.write(REGISTRY_PATH, JSON.stringify(regData));

        // 식별 캐시 복구
        if (globalData.nameToIdCache) {
            globalData.nameToIdCache["GLOBAL_" + fullNick] = finalUid;
        }

        safeSaveData(data, false);
        if (typeof globalData !== 'undefined') globalData = data; 

        replier.reply(formatAdmin("✅ 데이터 복원 성공", 
            "현재 대상: " + fullNick + "\n" +
            "ID: " + finalUid + "\n" +
            "━━━━━━━━━━━━━━━\n" +
            "💰 최종 복구 잔액: " + fp(backupUser.point) + "P\n\n" +
            "💡 삭제 전 마지막 백업 시점의 데이터로 복원 및 명부 재연결이 완료되었습니다."));
    } catch (e) {
        replier.reply(formatAdmin("🚫 복구 중단", "사유: " + e.message));
        Log.error("Restore Error: " + e);
    }
    return true;
    }

    return false;
}

//==========섹터35==========

/**
 * [관리자 하위 모듈 4] 경제 및 포인트 관리
 * 기능: 경제지표, 데이터교정, 물가조정, 포인트 지급/차감/뿌리기, 각종 초기화, 재원수정 및 충전, 자가복원
 */
function _adminEconomyLogic(msg, user, data, replier, roomName, targetUid, sender) {

    /* [테스트] 자정 리셋 로직 강제 실행 */
    if (msg === "/자정테스트") {
        // 1. 오늘 리셋 기록을 지워 로직이 실행 가능하게 만듬
        data.lastDailyReset = "2000-01-01"; 
        
        // 2. 가상 컨텍스트 생성 (현재 시간 기준)
        var testCtx = {
            today: getSimpleDate(),
            now: new Date(),
            targetRoom: roomName,
            season: getSimpleSeason()
        };

        // 3. 리셋 로직 강제 호출
        _runSector17Logic(data, testCtx);
        
        replier.reply(formatAdmin("🧪 자정 로직 테스트", "자정 리셋 로직을 강제로 실행했습니다.\n로그와 광산 상태를 확인하세요."));
        return true;
    }

    /* [1] 은행 가용 재원 수동 수정 (강제 설정) */
    if (msg.indexOf("/재원수정 ") === 0) {
        var val = parseInt(msg.split(" ")[1].replace(/,/g, ""));
        if (isNaN(val)) {
            replier.reply(formatAdmin("오류", "수정할 금액을 숫자로 입력하세요.\n예) /재원수정 3000"));
            return true;
        }

        var roomData = data.rooms[roomName];
        if (!roomData) return true;

        // [보안 교체] 직접 할당 대신 보안 엔진을 통한 차액(delta) 계산 및 적용
        var currentRes = Number(roomData.bankReserve || 0);
        var delta = val - currentRes;
        util_updateReserve(roomData, delta, "재원 수정", roomName);
        
        roomData.bankReserve = val;
        safeSaveData(data);
        
        replier.reply(formatAdmin("🏦 은행 재원 수정 완료", 
            "현재 방의 가용 재원이 수정되었습니다.\n\n" +
            "💰 설정 금액: " + fp(val) + "P\n" +
            "📢 이제 유저들이 이 금액 내에서 대출 가능합니다."));
        return true;
    }

   if (msg === "/국고로그") {
    try {
        var logs = [];
        var filesToRead = [JOURNAL_PATH, BASE_DIR + "total_history.log"];

        filesToRead.forEach(function(path) {
            var file = new java.io.File(path);
            if (file.exists() && file.length() > 0) {
                var content = FileStream.read(path).split("\n");
                logs = logs.concat(content);
            }
        });

        var filteredLogs = [];
        // 오늘 발생한 모든 국고 변동 추출 (최신순)
        for (var i = logs.length - 1; i >= 0; i--) {
            var line = logs[i].trim();
            if (!line) continue;
            var parts = line.split("|");
            if (parts.length < 5) continue;

            var brDelta = Number(parts[3]);
            if (!isNaN(brDelta) && brDelta !== 0) {
                var sign = brDelta > 0 ? "➕" : "➖";
                var uName = "알 수 없음";
                for (var r in data.rooms) {
                    if (data.rooms[r].users[parts[0]]) {
                        uName = data.rooms[r].users[parts[0]].name;
                        break;
                    }
                }
                filteredLogs.push("• [" + parts[4] + "] " + uName + " | " + sign + fp(Math.abs(brDelta)) + "P");
            }
        }

        var readMore = "\u200b".repeat(500); // 전체보기 유도용 공백
        var targetZone = (roomName === "베릭방" || ALLOWED_ROOMS.indexOf(roomName) === -1) ? "내리다" : roomName;
        var roomData = data.rooms[targetZone];
        var resultBody = "🏦 현재 금고 잔액: " + fp(roomData.bankReserve) + "P\n" +
                         "━━━━━━━━━━━━━━━" + readMore + "\n" +
                         (filteredLogs.length > 0 ? filteredLogs.join("\n") : "금일 국고 변동 기록이 없습니다.");

        replier.reply(formatAdmin("🏛️ 오늘 국고 전체 변동 장부", resultBody));
    } catch (e) {
        replier.reply(formatAdmin("🚫 조회 실패", "로그 통합 분석 오류: " + e));
    }
    return true;
}

    /* [신규] 은행 긴급 재원 충전 (기존 잔액에 추가 합산) */
    if (msg.indexOf("/재원충전 ") === 0) {
        var val = parseInt(msg.split(" ")[1].replace(/,/g, ""));
        if (isNaN(val) || val <= 0) {
            replier.reply(formatAdmin("오류", "충전할 금액을 양의 숫자로 입력하세요.\n예) /재원충전 100000"));
            return true;
        }
        var roomData = data.rooms[roomName];
        if (!roomData) return true;

        // [보안 교체] 직접 합산(+=) 대신 보안 엔진 호출
        util_updateReserve(roomData, val, "재원 충전", roomName);
        
        safeSaveData(data);
        
        var resMsg = "결과: 국고 보충 완료\n" +
                     "수혈 금액: +" + fp(val) + "P\n" +
                     "🏦 현재 금고 총액: " + fp(roomData.bankReserve) + "P";
        
        replier.reply(formatAdmin("⚙️ 중앙은행 긴급 재원 수혈", resMsg));
        return true;
    }

   /* [신규] 누락된 오늘치 배당금 강제 합산 명령어 */
    if (msg === "/배당복구") {
        var count = util_restoreDailyPoolsFromHistory(data, roomName);
        safeSaveData(data);
        replier.reply(formatAdmin("✅ 배당금 소급 적용 완료", 
            "백업 파일에서 오늘 발생한 " + count + "건의 거래를 분석하여\n" +
            "메모리 배당 주머니에 합산을 완료했습니다.\n\n" +
            "💡 이제 /배당현황에서 정확한 금액을 확인하세요."));
        return true;
    }

    /* [신규] 배당 항목 수동 초기화 명령어 */
    if (msg.indexOf("/배당초기화 ") === 0) {
        var roomData = data.rooms[roomName];
        if (!roomData || !roomData.features || !roomData.features.dailyPools) return true;

        var targetKey = msg.substring(7).trim(); // "카지노", "광산" 등
        var keyMap = { "카지노": "casino", "광산": "mine", "낚시터": "fish", "은행": "bank", "백화점": "shop", "경마장": "race" };
        var engKey = keyMap[targetKey];

        if (!engKey) {
            replier.reply(formatAdmin("🚫 초기화 실패", "올바른 항목을 입력하세요.\n(카지노, 광산, 낚시터, 은행, 백화점, 경마장)"));
            return true;
        }

        // 해당 항목 0으로 리셋
        roomData.features.dailyPools[engKey] = 0;
        safeSaveData(data);
        
        replier.reply(formatAdmin("✅ 배당 초기화 완료", "[" + targetKey + "] 항목의 배당 주머니를 0P로 비웠습니다.\n이제 다시 [/배당복구]를 실행하여 깨끗하게 합산할 수 있습니다."));
        return true;
    }

   /* [2] 특정 매물 신규 등록/부활 명령어 */
    if (msg.indexOf("/매물추가 ") === 0) {
        var parts = msg.split(" ");
        if (parts.length < 3) {
            replier.reply(formatAdmin("오류", "형식: /매물추가 [건물명] [가격] [타입번호(선택)]\n1: 랜드마크 / 2: 비즈니스타워 / 3: 상가"));
            return true;
        }
        var name = parts[1];
        var price = parseInt(parts[2].replace(/,/g, ""));
        var typeNum = parts[3] || "1"; // 기본값 1번

        var typeMap = { "1": "normal", "2": "bluechip", "3": "hotspot" };
        var selectedType = typeMap[typeNum] || "normal";
        var trait = SYSTEM_CONFIG.ECO.LANDMARK.TRAITS[selectedType];

        data.landmarkMarket[name] = {
            price: price, 
            lastPrice: price, 
            type: selectedType, 
            delistTick: 0, 
            delistLimit: 9999, 
            trend: "none", 
            trendTick: 0, 
            openPrice: price
        };

        replier.reply(formatAdmin("🏙️ 매물 수동 등록 완료", 
            "건물명: " + trait.icon + " " + name + "\n" +
            "유형: " + trait.label + " (변동성: x" + trait.volatility + ")\n" +
            "시가: " + fp(price) + "P"));

             safeSaveData(data);
        return true;
    }

    /* [신규] 특정 매물 강제 상폐 및 삭제 */
    if (msg.indexOf("/매물삭제 ") === 0) {
        var name = msg.substring(6).trim();
        if (!data.landmarkMarket[name]) {
            replier.reply(formatAdmin("오류", "[" + name + "] 매물을 찾을 수 없습니다."));
            return true;
        }

        // 유저들의 보유 지분도 함께 삭제 (데이터 무결성)
        for (var r in data.rooms) {
            for (var uid in data.rooms[r].users) {
                var u = data.rooms[r].users[uid];
                if (u.landHoldings && u.landHoldings[name]) {
                    delete u.landHoldings[name];
                    if (u.landAvg) delete u.landAvg[name];
                }
            }
        }

        delete data.landmarkMarket[name];
        safeSaveData(data);
        replier.reply(formatAdmin("🏙️ 매물 삭제 완료", "[" + name + "] 건물이 시장에서 완전히 제거되었습니다."));
        return true;
    }

    /* [관리자] 특정 매물 이름 및 시세 수정 */
    if (msg.indexOf("/매물수정 ") === 0) {
        var parts = msg.split(" ");
        if (parts.length < 4) {
            replier.reply(formatAdmin("오류", "형식: /매물수정 [기존이름] [새이름] [새가격]"));
            return true;
        }
        var oldName = parts[1];
        var newName = parts[2];
        var newPrice = parseInt(parts[3].replace(/,/g, ""));

        if (!data.landmarkMarket[oldName]) {
            replier.reply(formatAdmin("오류", "[" + oldName + "] 매물을 찾을 수 없습니다."));
            return true;
        }

        var landData = data.landmarkMarket[oldName];
        var oldPrice = Number(landData.price);
        var ratio = oldPrice / newPrice;

        landData.price = newPrice;
        landData.lastPrice = newPrice;
        landData.openPrice = newPrice;

        var fixCount = 0;
        for (var r in data.rooms) {
            var users = data.rooms[r].users;
            for (var uid in users) {
                var u = users[uid];
                if (u.landHoldings && u.landHoldings[oldName] !== undefined) {
                    u.skipHealing = true;
                    var oldQty = Number(u.landHoldings[oldName]);
                    var oldAvg = Number(u.landAvg[oldName] || oldPrice);

                    var newQty = Math.max(1, Math.round(oldQty * ratio));
                    var newAvg = Math.floor(oldAvg / ratio);

                    u.landHoldings[newName] = newQty;
                    u.landAvg[newName] = newAvg;

                    if (oldName !== newName) {
                        delete u.landHoldings[oldName];
                        if (u.landAvg[oldName]) delete u.landAvg[oldName];
                    }
                    fixCount++;
                }
            }
        }

        if (oldName !== newName) {
            data.landmarkMarket[newName] = landData;
            delete data.landmarkMarket[oldName];
        }

        safeSaveData(data);
        replier.reply(formatAdmin("🏙️ 부동산 매물 교정 완료", "대상: " + oldName + " ➔ " + newName + "\n가격: " + fp(oldPrice) + "P ➔ " + fp(newPrice) + "P\n유저 " + fixCount + "명의 자산 가치 보존 완료"));
        return true;
    }

    /* [3] 유저 보유 자산 기반 부동산 시장 재건 */
    if (msg === "/부동산자산복구") {
        var roomData = data.rooms[roomName];
        if (!roomData) return true;
        var pumpCount = 0;
        var healthyPrice = 175000; 

        for (var lName in data.landmarkMarket) {
            var oldPrice = data.landmarkMarket[lName].price;
            if (oldPrice < 52500) {
                var ratio = oldPrice / healthyPrice; 
                for (var r in data.rooms) {
                    for (var uid in data.rooms[r].users) {
                        var u = data.rooms[r].users[uid];
                        if (u.landHoldings && u.landHoldings[lName]) {
                            u.skipHealing = true; 
                            u.landHoldings[lName] = Math.max(1, Math.floor(u.landHoldings[lName] * ratio));
                            u.landAvg[lName] = healthyPrice; 
                        }
                    }
                }
                data.landmarkMarket[lName].price = healthyPrice;
                data.landmarkMarket[lName].lastPrice = healthyPrice;
                data.landmarkMarket[lName].delistTick = 0;
                pumpCount++;
            }
        }
        safeSaveData(data);
        replier.reply(formatAdmin("🏙️ 부동산 시장 정상화 완료", "보정 매물: " + pumpCount + "개\n시세 재설정: " + fp(healthyPrice) + "P"));
        return true;
    }

    /* [4] 경제 지표 상세 조회 */
    if (msg === "/경제정보") {
        // [수정] 베릭방이나 1:1방에서 조회 시, 메인 구역('내리다')의 경제 데이터를 로드
        var targetZone = (roomName === "베릭방" || ALLOWED_ROOMS.indexOf(roomName) === -1) ? "내리다" : roomName;

        var eco = calculateEconomy(data, targetZone);
        var rData = data.rooms[targetZone];
        var base = rData.economyBase || 0;
        
        var multiplier = 1.0;
        if (base > 0) {
            var rawRatio = eco.total / base;
            var damping = (data.economyDamping !== undefined) ? data.economyDamping : 0.5;
            multiplier = 1 + (rawRatio - 1) * damping;
            if (multiplier < 0.5) multiplier = 0.5;
        }

        var ecoMsg = "💰 [방별 독립 경제 리포트]\n" +
                     "📍 대상 구역: " + roomName + "\n" +
                     "━━━━━━━━━━━━━━━\n" +
                     "💵 총자산: " + fp(eco.total) + "P\n" +
                     "🏦 은행재고: " + fp(rData.bankReserve || 0) + "P\n" +
                     "⚖️ 물가기준: " + (base > 0 ? fp(base) + "P" : "설정 없음") + "\n" +
                     "📈 물가배율: x" + multiplier.toFixed(2) + "\n" +
                     "👥 활성유저: " + eco.count + "명\n" +
                     "💎 평균자산: " + fp(eco.average) + "P";

        replier.reply(formatAdmin("실시간 경제 상황", ecoMsg));
        return true;
    }

   // [긴급] 부동산 데이터 정밀 수리 로직
    if (msg === "/시장데이터교정") {
        var fixUserCount = 0;
        var healthyPrice = 175000; 

        for (var r in data.rooms) {
            for (var uid in data.rooms[r].users) {
                var u = data.rooms[r].users[uid];
                if (!u.landHoldings) continue;

                var isUserFixed = false;
                for (var lName in u.landHoldings) {
                    var land = data.landmarkMarket[lName];
                    var curQty = Number(u.landHoldings[lName]);
                    if (land && land.price >= 150000 && curQty > 5) {
                        u.skipHealing = true; 
                        var estimatedOldValue = curQty * 1000; 
                        u.landHoldings[lName] = Math.max(1, Math.round(estimatedOldValue / land.price));
                        if (!u.landAvg) u.landAvg = {};
                        u.landAvg[lName] = land.price;
                        isUserFixed = true;
                    }
                }
                if (isUserFixed) fixUserCount++;
            }
        }
        safeSaveData(data, false); 
        replier.reply(formatAdmin("🛠️ 부동산 지분 정밀 수리", "대상 인원: " + fixUserCount + "명\n조치: 비정상 고액 지분 강제 압축 완료"));
        return true;
    }

    /* [v11.0] 전 구역 유저 부동산 보유 현황 총괄 조회 */
    if (msg === "/전체부동산") {
        var targetRoomData = (roomName === "베릭방") ? data.rooms["내리다"] : data.rooms[roomName];
        var allUsers = [];
        var totalMarketValue = 0;
        var ownerCount = 0;

        for (var r in data.rooms) {
            var roomUsers = data.rooms[r].users;
            for (var uid in roomUsers) {
                var u = roomUsers[uid];
                var holdings = u.landHoldings || {};
                var keys = Object.keys(holdings);
                
                if (keys.length > 0) {
                    var userTotalValue = 0;
                    var holdingList = [];
                    
                    for (var i = 0; i < keys.length; i++) {
                        var lName = keys[i];
                        var qty = Number(holdings[lName]);
                        if (qty <= 0) continue;
                        
                        var land = data.landmarkMarket[lName];
                        var curPrice = land ? Number(land.price) : 0;
                        var trait = (land && land.type && SYSTEM_CONFIG.ECO.LANDMARK.TRAITS[land.type]) 
                                    ? SYSTEM_CONFIG.ECO.LANDMARK.TRAITS[land.type] : {icon: "🏢"};
                        
                        userTotalValue += (qty * curPrice);
                        holdingList.push("• " + trait.icon + " " + lName + " : " + qty + "지분");
                    }

                    if (holdingList.length > 0) {
                        allUsers.push({
                            name: getDisplayName(u),
                            list: holdingList.join("\n"),
                            total: userTotalValue
                        });
                        totalMarketValue += userTotalValue;
                        ownerCount++;
                    }
                }
            }
        }

        if (allUsers.length === 0) {
            replier.reply(formatAdmin("조회 결과", "현재 부동산 지분을 보유한 유저가 없습니다."));
            return true;
        }

        var body = allUsers.map(function(u) {
            return "👤 " + u.name + "님\n" + u.list + "\n💰 자산가치: " + fp(u.total) + "P";
        }).join("\n\n");

        var summary = "📈 전체 통계 요약\n" +
                      "• 부동산 보유 유저: " + ownerCount + "명\n" +
                      "• 전 구역 지분 총액: " + fp(totalMarketValue) + "P";

        replier.reply(formatAdmin("📊 전 구역 부동산 보유 현황", body + "\n━━━━━━━━━━━━━━━\n" + summary));
        return true;
    }

   /* [v11.0] 유저 부동산 지분 강제 회수 로직 */
    if (msg.indexOf("/부동산회수 ") === 0) {
        var ps = msg.trim().split(/\s+/);
        if (ps.length < 4) {
            replier.reply(formatAdmin("오류", "형식: /부동산회수 [닉네임] [건물명] [수량|전부]"));
            return true;
        }

        var qtyInput = ps.pop(); // 마지막 인자: 수량 또는 '전부'
        var landInput = ps.pop(); // 중간 인자: 건물명
        var targetNick = ps.slice(1).join(" ").trim(); // 나머지: 닉네임

        var roomData = data.rooms[roomName];
        var found = findUserByName(roomData, targetNick);

        if (found.length === 0) {
            replier.reply(formatAdmin("🚫 대상 없음", "[" + targetNick + "] 유저를 찾을 수 없습니다."));
        } else if (found.length > 1) {
            handleUserSelection(replier, targetUid, found, "admin_land_take", { land: landInput, qty: qtyInput }, user, roomName);
        } else {
            var f = found[0];
            var tUser = f.data; // 정확히 1명의 데이터만 참조
            var tRoom = f.roomName;
            var holdings = tUser.landHoldings || {};
            
            var matchedLand = util_findStockByShorthand(holdings, landInput);
            if (matchedLand.length === 0) {
                replier.reply(formatAdmin("🚫 보유 정보 없음", "[" + tUser.name + "]님은 [" + landInput + "] 지분이 없습니다."));
                return true;
            }
            
            var sName = matchedLand[0];
            var currentQty = Number(holdings[sName] || 0);
            var takeQty = (qtyInput === "전부") ? currentQty : parseInt(qtyInput.replace(/,/g, ""));
            if (takeQty > currentQty) takeQty = currentQty;

            tUser.skipHealing = true;
            // 해당 유저(tUser)의 지분만 수정
            util_updateLandmark(tUser, sName, -takeQty, "관리자 강제 회수", tRoom);
            
            if (Number(tUser.landHoldings[sName]) <= 0) {
                delete tUser.landHoldings[sName];
                if (tUser.landAvg) delete tUser.landAvg[sName];
            }

            replier.reply(formatAdmin("⚙️ 부동산 강제 회수 완료", "대상: " + tUser.name + "\n건물: " + sName + "\n수량: " + takeQty + "지분 회수"));
            safeSaveData(data);
            return true;
        }
    }

    /* [v11.5] 6대 핵심 랜드마크 실시간 배당 현황 조회 (문법 오류 수정본) */
    if (msg === "/배당현황") {
        var targetZone = (roomName === "베릭방" || ALLOWED_ROOMS.indexOf(roomName) === -1) ? "내리다" : roomName;
        var roomData = data.rooms[targetZone];
        if (!roomData || !roomData.features || !roomData.features.dailyPools) return true;

        // 1. 시간 및 환경 변수 안전 로드
        var now = new Date();
        var startOfDay = new Date(now.getFullYear(), now.getMonth(), now.getDate());
        var hoursPassed = (now - startOfDay) / 3600000; 

        // SYSTEM_CONFIG가 정의되지 않았을 경우를 대비한 하드코딩 백업
        var baseHourly = 10000;
        var threshold = 10;
        var bonusRate = 0.1;

        if (typeof SYSTEM_CONFIG !== 'undefined' && SYSTEM_CONFIG.ECO) {
            baseHourly = SYSTEM_CONFIG.ECO.HOURLY_DIVIDEND || 10000;
            threshold = SYSTEM_CONFIG.ECO.BONUS_THRESHOLD || 10;
            bonusRate = SYSTEM_CONFIG.ECO.BONUS_RATE || 0.1;
        }

        // 2. 내부 전용 숫자 포맷터 (fp 함수가 정의되지 않았을 경우 대비)
        var formatP = function(val) {
            if (isNaN(val)) return "0";
            return String(Math.floor(val)).replace(/\B(?=(\d{3})+(?!\d))/g, ",");
        };

        // 3. 내부 전용 이름 추출기 (getDisplayName 함수가 정의되지 않았을 경우 대비)
        var getName = function(u) {
            if (!u) return "알 수 없음";
            return u.name || "이름없음";
        };

        var targets = [
            { name: "광산", icon: "⛏️" }, { name: "낚시터", icon: "🎣" },
            { name: "카지노", icon: "🎰" }, { name: "중앙은행", icon: "🏦" },
            { name: "백화점", icon: "🏢" }, { name: "경마장", icon: "🏇" }
        ];

        targets.sort(function(a, b) { return a.name.localeCompare(b.name); });

        var report = [];
        targets.forEach(function(t) {
            var owner = util_getMajorityOwner(roomData, t.name);
            var ownerTag = "⚠️ 주인 없음";
            var finalDividend = 0;
            var landlordBonusTag = "";

            // [수정]: 칭호명을 '전설의 큰손'으로 변경하고 실시간 보너스 계산 및 안내 태그 추가
            var landlordBonusTag = "";

            if (owner && owner.data) {
                var nameTag = getName(owner.data);
                ownerTag = "👑 " + nameTag + " (" + owner.qty + "지분)";
                
                // 보너스 배율 계산 (10지분 초과 시 10% 가산)
                var shareMult = owner.qty > threshold ? 1.0 + (owner.qty - threshold) * bonusRate : 1.0;
                finalDividend = Math.floor(baseHourly * hoursPassed * shareMult);
                
                // [착용 효과]: '전설의 큰손' 칭호 장착 시 실시간 조회 수치에 1.1배 즉시 반영
                if (owner.data.title === "전설의 큰손") {
                    finalDividend = Math.floor(finalDividend * 1.1);
                    landlordBonusTag = " (🏰전설의 큰손 효과 적용)";
                }
            }

            report.push(t.icon + " " + t.name + "\n  💰 현재까지 적립: " + formatP(finalDividend) + "P" + landlordBonusTag + "\n  👤 현재 주주: " + ownerTag);
        });

        var header = "📊 실시간 랜드마크 배당 현황\n━━━━━━━━━━━━━━━\n※ 시간당 " + formatP(baseHourly) + "P 확정 수익 모델";
        var footer = "━━━━━━━━━━━━━━━\n✨ 오늘 총 경과 시간: " + hoursPassed.toFixed(1) + "시간\n💡 자정(00:00) 정산 시점에 자동 지급됩니다.";

        replier.reply(formatAdmin("배당 리포트", header + "\n\n" + report.join("\n\n") + "\n" + footer));
        return true;
    }

    if (msg === "/경제전체리셋") {
        var roomData = data.rooms[roomName];
        if (!roomData) return true;
        
        var userCount = 0;
        var setPoint = 100000; // 설정된 현금 10만
        var setBank = 100000;  // 설정된 예금 10만

        for (var r in data.rooms) {
            for (var uid in data.rooms[r].users) {
                var u = data.rooms[r].users[uid];
                
                // 1. 헬러 방어막 가동 (급감 복구 차단)
                u.skipHealing = true; 
                
                // 2. 모든 자산 및 부채 청산
                u.point = setPoint;
                u.bank = setBank;
                u.loan = { debt: 0, items: [] }; // 빚 탕감
                u.stockHoldings = {};           // 랜드마크 전량 몰수
                u.stockAvg = {};
                u.isTransferred = false;        // 대환 채무 삭제
                u.isDefaulter = false;          // 신불자 해제
                u.creditScore = 600;            // 신용점수 초기화
                u.tier = 0;                     // 티어 리셋 (선택 사항)
                
                userCount++;
            }
        }

        // 3. 중앙은행 재원 정상화 (물가 기준점의 30% 수준으로 수혈)
        var roomBase = roomData.economyBase || 3953977;
        roomData.bankReserve = Math.floor(roomBase * 0.3);

        safeSaveData(data, true); // 강제 백업 동시 수행
        
        var resMsg = "🚨 [국가 경제 대공황 및 강제 리셋 완료]\n" +
                     "━━━━━━━━━━━━━━━\n" +
                     "• 대상 인원: " + userCount + "명 전체\n" +
                     "• 공통 지급: 현금 10만 + 예금 10만\n" +
                     "• 특별 조치: 빚 탕감 / 랜드마크 초기화 / 신불 해제\n" +
                     "• 국고 상태: " + fp(roomData.bankReserve) + "P (수혈 완료)\n" +
                     "━━━━━━━━━━━━━━━\n" +
                     "💡 모든 유저가 동일한 출발선에서 다시 시작합니다.";
        replier.reply(formatAdmin("경제 시스템 재시작", resMsg));
        return true;
    }

    if (msg === "/지분현황") {
        var landMarket = data.landmarkMarket;
        var landNames = Object.keys(landMarket);
        var report = [];
        
        // 정렬 우선순위 정의 (1:고정, 2:비즈니스, 3:상가)
        var getPriority = function(name, type) {
            if (["광산", "낚시터", "카지노", "중앙은행", "백화점", "경마장"].indexOf(name) !== -1) return 1;
            if (type === "bluechip") return 2;
            if (type === "hotspot") return 3;
            return 4;
        };

        landNames.sort(function(a, b) {
            var priA = getPriority(a, landMarket[a].type);
            var priB = getPriority(b, landMarket[b].type);
            if (priA !== priB) return priA - priB;
            return a.localeCompare(b);
        });

        landNames.forEach(function(landName) {
            var owners = [];
            var totalLandShares = 0;
            for (var r in data.rooms) {
                for (var uId in data.rooms[r].users) {
                    var u = data.rooms[r].users[uId];
                    if (u.landHoldings && u.landHoldings[landName]) {
                        var q = Number(u.landHoldings[landName]);
                        if (q > 0) { owners.push(u.name + "(" + q + ")"); totalLandShares += q; }
                    }
                }
            }
            var ownerText = owners.length > 0 ? owners.join(", ") : "소유자 없음";
            report.push("🏢 [" + landName + "] (총 " + totalLandShares + "지분)\n   👤 " + ownerText);
        });
        
        replier.reply(formatAdmin("🏗️ 전 구역 부동산 지분 장부", report.join("\n\n")));
        return true;
    }

    /* [보안] 유저 고유 코드 명부 조회 (Ghost Filter 적용) */
    if (msg === "/명부확인") {
        try {
            var regFile = new java.io.File(REGISTRY_PATH);
            if (!regFile.exists() || regFile.length() === 0) {
                replier.reply(formatAdmin("📜 유저 명부", "등록된 데이터가 없습니다."));
                return true;
            }

            var registry = JSON.parse(FileStream.read(REGISTRY_PATH));
            var list = [];
            for (var key in registry) {
                // [핵심] "내리다_"로 시작하는 키값만 리스트에 포함 (유령방 데이터 은폐)
                if (key.indexOf("내리다_") !== 0) continue;

                var parts = key.split("_");
                var rName = parts[0]; 
                var uName = parts.slice(1).join("_"); 
                var uid = registry[key];

                var uData = (data.rooms[rName] && data.rooms[rName].users[uid]) ? data.rooms[rName].users[uid] : null;
                var statusTag = uData ? " [" + fp(uData.point) + "P]" : " [데이터 유실]";
                
                list.push("• " + uName + statusTag + "\n  └ " + uid);
            }

            if (list.length === 0) {
                replier.reply(formatAdmin("📜 유저 명부", "조회된 실사용 유저가 없습니다."));
            } else {
                replier.reply(formatAdmin("📜 내리다 구역 실사용자 명부", list.join("\n\n")));
            }
        } catch (e) {
            replier.reply(formatAdmin("🚫 조회 오류", "명부 로드 실패"));
        }
        return true;
    }

    /* [보안] 특정 닉네임 명부 강제 삭제 */
    if (msg.indexOf("/명부삭제 ") === 0) {
        var targetNick = msg.substring(6).trim();
        var regFile = new java.io.File(REGISTRY_PATH);
        if (!regFile.exists()) return replier.reply(formatAdmin("오류", "명부 파일이 없습니다."));

        var regData = JSON.parse(FileStream.read(REGISTRY_PATH));
        var matches = [];
        for (var key in regData) {
            var nickPart = key.substring(key.indexOf("_") + 1);
            if (nickPart.indexOf(targetNick) !== -1) {
                // 공통 엔진 규격에 맞춰 데이터 포맷팅
                matches.push({ id: key, data: { name: nickPart } });
            }
        }

        if (matches.length === 0) {
            replier.reply(formatAdmin("삭제 실패", "명부에서 [" + targetNick + "]이(가) 포함된 유저를 찾을 수 없습니다."));
        } else if (matches.length > 1) {
            // 섹터 11의 공통 중복 선택 엔진 호출 (이제 숫자가 작동합니다!)
            handleUserSelection(replier, targetUid, matches, "admin_reg_delete", null, user, roomName);
        } else {
            // 1명일 때는 즉시 삭제 실행
            var targetKey = matches[0].id;
            var targetFullNick = matches[0].data.name;
            delete regData[targetKey];
            FileStream.write(REGISTRY_PATH, JSON.stringify(regData));
            replier.reply(formatAdmin("명부 삭제 완료", "찾은 유저: [" + targetFullNick + "]\n관련 식별 코드를 명부에서 파기했습니다."));
        }
        return true;
    }

    /* [보안] 명부 일괄 최적화 (유령 데이터 전량 제거) */
    if (msg === "/명부업데이트") {
        var newRegistry = {};
        var count = 0;
        
        // 현재 메모리에 로드된(실제 존재하는) 유저들로만 명부를 새로 만듭니다.
        for (var rName in data.rooms) {
            var users = data.rooms[rName].users;
            for (var uid in users) {
                var regKey = rName + "_" + users[uid].name;
                newRegistry[regKey] = uid;
                count++;
            }
        }

        FileStream.write(REGISTRY_PATH, JSON.stringify(newRegistry));
        replier.reply(formatAdmin("✅ 명부 최적화 완료", "현재 존재하는 " + count + "명의 유저 정보로 명부를 새로 고침했습니다.\n(유령 데이터 전량 제거됨)"));
        return true;
    }

    /* [5] 데이터 교정 및 무결성 검사 */
    if (msg.trim() === "/데이터교정") {
        var fixCount = 0;
        var refundCount = 0;
        var totalRefunded = 0;

        for (var r in data.rooms) {
            var currentRoom = data.rooms[r];
            if (!currentRoom.loanPools) currentRoom.loanPools = {};
            if (!currentRoom.loanContracts) currentRoom.loanContracts = {};

            for (var id in currentRoom.users) {
                var u = currentRoom.users[id];
                if (!u) continue;

                if (Number(u.totalAttendance || 0) <= 3) {
                    for (var cid in currentRoom.loanContracts) {
                        var c = currentRoom.loanContracts[cid];
                        if (c.borrowerUid === id) {
                            var lender = currentRoom.users[c.lenderUid];
                            if (lender) {
                                lender.point = Number(lender.point) + Number(c.currentDebt);
                                totalRefunded += Number(c.currentDebt);
                                refundCount++;
                            }
                            delete currentRoom.loanContracts[cid];
                        }
                    }
                }
                u.point = Math.floor(Number(u.point || 0));
                u.bank = Math.floor(Number(u.bank || 0));
                u.creditScore = Math.min(1000, Math.max(0, Number(u.creditScore || 600)));
                u.isDefaulter = (u.creditScore < 500);
                if (!u.loan) u.loan = { debt: 0, items: [] };
                if (!u.stockHoldings) u.stockHoldings = {};

                // 교정 시점에 예금자가 기준 시간이 없다면 현재 시간으로 강제 주입
                if (u.bank > 0 && (!u.lastBankUpdateTime || u.lastBankUpdateTime === 0)) {
                    u.lastBankUpdateTime = Date.now();
                }

                fixCount++;
            }
        }
        
        safeSaveData(data);
        var resMsg = "전체 유저 " + fixCount + "명 동기화 완료\n" +
                     "📉 사채 환수: " + refundCount + "건 (" + fp(totalRefunded) + "P 반환)";
        replier.reply(formatAdmin("데이터 교정 및 분리 완료", resMsg));
        return true;
    }

    /* [6] 물가 조정 */
    if (msg.indexOf("/물가조정") === 0) {
        var args = msg.split(" ");
        var currentEco = calculateEconomy(data, roomName); 
        if (args[1] === "초기화") { data.rooms[roomName].economyBase = 0; safeSaveData(data); replier.reply(formatAdmin("⚖️ 물가 초기화", "기본가로 고정됩니다.")); return true; }
        var oldBase = data.rooms[roomName].economyBase || currentEco.total;
        var newBase = (args.length > 1 && !isNaN(parseInt(args[1]))) ? parseInt(args[1]) : Math.floor(Math.sqrt(oldBase * currentEco.total));
        data.rooms[roomName].economyBase = newBase;
        safeSaveData(data);
        replier.reply(formatAdmin("⚖️ 물가 조정 완료", "새 기준: " + fp(newBase) + "P"));
        return true;
    }

    /* [7] 물가 완충 비율 설정 */
    if (msg.indexOf("/물가완충") === 0) {
        var val = parseFloat(msg.split(" ")[1]);
        if (isNaN(val) || val < 0.0 || val > 1.0) { replier.reply(formatAdmin("오류", "0.0 ~ 1.0 사이의 소수를 입력하세요.")); return true; }
        data.economyDamping = val;
        safeSaveData(data);
        replier.reply(formatAdmin("🛡️ 물가 완충 설정 완료", "적용 비율: " + (val*100) + "%"));
        return true;
    }

    /* [8] 전역 포인트 지급 */
    if (msg.indexOf("/포인트지급 ") === 0) {
        var parts = msg.trim().split(/\s+/);
        if (parts.length < 3) return replier.reply(formatError(user, "형식 오류", "/포인트지급 [닉네임] [금액]"));
        var am = parseInt(parts.pop());
        var tn = parts.slice(1).join(" ").trim();
        
        var found = findUserGlobal(tn, roomName);
        if (!found.length) { replier.reply(formatError(user, "대상 없음", "유저를 찾을 수 없습니다.")); return true; }
        if (found.length > 1) { handleUserSelection(replier, targetUid, found, "admin_point_give", { amount: am }, user, roomName); return true; }
        
        var f = found[0];
        util_updatePoint(f.data, data.rooms[f.roomName], am, "관리자 전역 지급", f.roomName);
        replier.reply(formatAdmin("지급 완료", "[" + f.roomName + "] " + f.data.name + "님: +" + fp(am) + "P"));
        try { Api.replyRoom("베릭방", "⚙️ [Admin Action]\n• 실행자: " + sender + "\n• 내용: " + msg); } catch(e) {}
        safeSaveData(data);
        return true;
    }

    /* [9] 전역 포인트 차감 */
    if (msg.indexOf("/포인트차감 ") === 0) {
        var parts = msg.trim().split(/\s+/);
        if (parts.length < 3) return replier.reply(formatError(user, "형식 오류", "/포인트차감 [닉네임] [금액]"));
        var am = parseInt(parts.pop());
        var tn = parts.slice(1).join(" ").trim();
        
        var found = findUserGlobal(tn);
        if (!found.length) { replier.reply(formatError(user, "대상 없음", "유저를 찾을 수 없습니다.")); return true; }
        if (found.length > 1) { handleUserSelection(replier, targetUid, found, "admin_point_take", { amount: am }, user, roomName); return true; }
        
        var f = found[0];
        util_updatePoint(f.data, data.rooms[f.roomName], -am, "관리자 전역 차감", f.roomName);
        replier.reply(formatAdmin("차감 완료", "[" + f.roomName + "] " + f.data.name + "님 차감 처리됨"));
        safeSaveData(data);
        return true;
    }

    /* [10] 전체 포인트 지급 */
    if (msg.indexOf("/전체포인트지급 ") === 0) {
        var amt = parseInt(msg.split(" ")[1]);
        if (isNaN(amt)) return true;
        var count = 0;
        for (var r in data.rooms) {
            for (var id in data.rooms[r].users) {
                util_updatePoint(data.rooms[r].users[id], data.rooms[r], amt, "전체 포인트 지급", r);
                count++;
            }
        }
        safeSaveData(data);
        replier.reply(formatAdmin("전체 지급 완료", "총 " + count + "명에게 " + fp(amt) + "P 지급 완료"));
        return true;
    }

    /* [신규: Gemini 요청 사항] 경마 이월금 수동 조정 명령어 */
    if (msg.indexOf("/이월금수정 ") === 0) {
        var val = parseInt(msg.split(" ")[1].replace(/,/g, ""));
        if (isNaN(val)) {
            replier.reply(formatAdmin("오류", "수정할 이월 금액을 숫자로 입력하세요."));
            return true;
        }
        // 메인 운영 방("내리다")의 경마 이월금 강제 수정
        var targetRoom = data.rooms["내리다"];
        if (targetRoom && targetRoom.features && targetRoom.features.racing) {
            targetRoom.features.racing.carryOver = val;
            safeSaveData(data);
            replier.reply(formatAdmin("🏇 경마 이월금 수정 완료", "현재 적립된 이월금을 " + fp(val) + "P로 변경했습니다."));
        }
        return true;
    }

    /* [11] 포인트 뿌리기 (방별 독립 주머니 연동 - 먹통 해결 핵심) */
    if (msg === "/뿌리기") {
        var roomData = data.rooms[roomName];
        var sprinkleData = roomData.features.sprinkleData; // 방별 데이터 연결

        if (sprinkleData.active) { 
            replier.reply(formatAdmin("오류", "이미 뿌리기가 진행 중입니다.")); 
            return true; 
        }
        
        var count = Math.floor(Math.random() * 3) + 2; 
        var multiplier = util_getEcoMultiplier(roomName);
        
        var portions = [];
        var totalSprinkle = 0;
        for(var i=0; i<count; i++) {
            // 기본 범위를 5000 ~ 8000P로 상향
            var baseP = Math.floor(Math.random() * 3001) + 4000; 
            var finalP = Math.floor(baseP * multiplier);
            portions.push(finalP);
            totalSprinkle += finalP;
        }

        // [v5.9 수정] 전역 sprinkleData가 아닌 현재 방의 rFeatures.sprinkleData에 할당
        sprinkleData.active = true;
        sprinkleData.totalPoint = totalSprinkle;
        sprinkleData.remainingPoint = totalSprinkle;
        sprinkleData.limit = count;
        sprinkleData.currentWinners = 0;
        sprinkleData.winners = [];
        sprinkleData.portions = portions;

        Api.replyRoom(roomName, formatAdmin("🎉 포인트 뿌리기 시작!", "선착순 " + count + "명!\n채팅창에 [줍기]를 입력하세요!\n💰 총 배정: " + fp(totalSprinkle) + "P"));
        
        // 1분 후 자동 종료 타이머 (방 이름을 클로저로 전달)
        (function(targetRoom, targetData) {
            setTimeout(function() { 
                var rData = targetData.rooms[targetRoom];
                if (rData && rData.features.sprinkleData.active) { 
                    rData.features.sprinkleData.active = false; 
                    Api.replyRoom(targetRoom, formatAdmin("🏁 뿌리기 시간 초과", "이벤트가 종료되었습니다.")); 
                    safeSaveData(targetData);
                } 
            }, 60000);
        })(roomName, data);
        
        safeSaveData(data);
        return true;
    }

    /* [12] 시스템 초기화 세트 */
    if (msg === "/로또데이터초기화") {
        lotto = { round: (lotto.round || 0) + 1, entries: {}, dailyPool: 0, jackpot: 0, lastWinNums: [] };
        safeSaveData(data);
        replier.reply(formatAdmin("완료", "로또 시스템 리셋 완료"));
        return true;
    }
    if (msg === "/승급횟수초기화") {
        for (var r in data.rooms) {
            for (var id in data.rooms[r].users) {
                data.rooms[r].users[id].dailyPromotionAttempts = 1;
                data.rooms[r].users[id].purchasedPromotionAttempts = 0;
            }
        }
        safeSaveData(data);
        replier.reply(formatAdmin("완료", "전체 승급 기회 초기화"));
        return true;
    }

//==========섹터36==========

    if (msg.trim() === "/시즌강제종료") {
        var resetCount = 0;
        for (var r in data.rooms) {
            var rObj = data.rooms[r];
            if (!rObj.users) continue;
            for (var id in rObj.users) {
                var u = rObj.users[id];
                
                // 1. 티어 및 명예의 전당 초기화
                u.tier = 0; 
                u.challengerCount = 0; 
                u.challengerIconSeason = ""; 

                // 2. [핵심] 승급권 구매 횟수 초기화 (가격을 다시 2,000P로 복구)
                u.purchasedPromotionAttempts = 0; 

                // 3. 시즌 한정 소모품/인증 초기화
                u.gameAuthCount = 0; 
                u.purchasedAuthCount = 0; 

                // 4. 보안 엔진(Healer)의 강제 복구 일시 차단
                u.skipHealing = true; 
                
                resetCount++;
            }
        }
        
        // 변경 사항 즉시 저장 및 백업
        safeSaveData(data, true); 
        
        var resMsg = "시즌을 강제 종료하고 모든 기록을 리셋했습니다.\n\n" +
                     "• 대상 유저: " + resetCount + "명\n" +
                     "• 초기화 항목: 티어, 명예의전당, 승급권 할증가\n" +
                     "• 상태: 새 시즌 준비 완료";
        
        replier.reply(formatAdmin("🏆 시즌 강제 종료 완료", resMsg));
        return true;
    }

    /* [보안] 데이터 보호 엔진 자가진단 명령어 (v6.0 정밀 진단형) */
   if (msg === "/보안점검") {
        var st = function(ok) { return ok ? "🟢 가동" : "🔴 점검"; };
        
        // 1. 게이트웨이 체크 (Logic)
        var gw = {
            p: (typeof util_updatePoint === 'function'),
            u: (typeof util_setData === 'function'),
            r: (typeof util_updateReserve === 'function'),
            s: (typeof util_updateLandmark === 'function'),
            b: (typeof util_updateBank === 'function'),
            g: (typeof util_checkUserState === 'function')
        };

        // 2. 인프라 및 영속성 체크 (Infra)
        var infra = {
            lock: (typeof lock !== 'undefined' && !lock.isLocked()) || true,
            save: (typeof SaveExecutor !== 'undefined'),
            spam: (SYSTEM_CONFIG.SPAM !== undefined),
            backup: (SYSTEM_CONFIG.BACKUP.DISCORD_WEBHOOK_URL && SYSTEM_CONFIG.BACKUP.DISCORD_WEBHOOK_URL.indexOf("http") === 0),
            atomic: (new java.io.File(FILE_PATH).exists()),
            reg: (new java.io.File(REGISTRY_PATH).exists()),
            // [추가] 블랙박스 로그 기록 가능 여부 체크
            journal: (function() { try { return new java.io.File(BASE_DIR).canWrite(); } catch(e){return false;} })()
        };

        var report = "🛡️ [보안 관제 센터] v6.0\n" +
                     "━━━━━━━━━━━━━━━\n" +
                     "📁 [데이터 게이트웨이]\n" +
                     "• 포인트: " + st(gw.p) + " | 범용: " + st(gw.u) + "\n" +
                     "• 국고재원: " + st(gw.r) + " | 랜드마크: " + st(gw.s) + "\n" +
                     "• 은행잔고: " + st(gw.b) + " | 상태: " + st(gw.g) + "\n\n" +
                     "⚙️ [실시간 방어 및 엔진]\n" +
                     "• 동기화 락: " + st(infra.lock) + " (Lock)\n" +
                     "• 비동기 저장: " + st(infra.save) + " (Save)\n" +
                     "• 신분 복구: " + st(infra.reg) + " (Registry)\n\n" +
                     "📦 [영속성 및 백업]\n" +
                     "• 블랙박스: " + st(infra.journal) + " (Journal)\n" + // 블랙박스 추가
                     "• 파손 방지: " + st(infra.atomic) + " (Atomic)\n" +
                     "• 원격 백업: " + st(infra.backup) + " (Discord)\n" +
                     "• 자가 치유: 🟢 활성화 (Healer)\n" +
                     "━━━━━━━━━━━━━━━\n" +
                     "✅ 모든 시스템이 보호되고 있습니다.";
        
        replier.reply(report);
        return true;
    }

    /* [신규] 보안 엔진 단계별 파괴 시뮬레이션 (Stress Test) */
    if (msg.indexOf("/보안테스트 ") === 0) {
        var step = msg.split(" ")[1];
        var roomData = data.rooms[roomName];

        if (step === "1") { // [1단계: 딥헬러 검증]
            replier.reply("🧪 [테스트 1: 딥헬러]\n내 메모리 데이터의 '가방'과 '은행' 필드를 강제로 삭제합니다...");
            delete user.inventory;
            delete user.bank;
            replier.reply("⚠️ 필드 삭제 완료. 이제 아무 메시지나 입력하여 '딥헬러'가 스키마를 복구하는지 확인하세요.\n(복구 성공 시 /가방 조회 가능)");
        } 
        
        else if (step === "2") { // [2단계: 게이트웨이 검증]
            replier.reply("🧪 [테스트 2: 게이트웨이]\n포인트에 숫자가 아닌 '오염된 문자열' 주입을 시도합니다...");
            util_updatePoint(user, roomData, "BAD_DATA", "보안 테스트 공격", roomName);
            replier.reply("✅ 결과: 게이트웨이가 오염된 연산을 차단했습니다. 상단 로그(Log.error) 또는 블랙박스 기록을 확인하세요.");
        } 

        else if (step === "3") { // [3단계: 최종 검역소 검증]
            replier.reply("🧪 [테스트 3: 최종 검역소]\n내 포인트를 강제로 'NaN(비숫자)'으로 오염시킨 뒤 저장을 시도합니다...");
            user.point = NaN; 
            safeSaveData(data, false);
            replier.reply("🛡️ 결과: '데이터 자가 치유' 알림이 뜨며 파일 저장이 차단되었는지 확인하세요.");
        }
        
        return true;
    }

    if (msg.trim() === "/시스템자가복원") {
        // 1. 휘발성 상태값 및 활동 락(Lock) 일괄 해제
        lottoPurchaseState = {}; 
        sprinkleData = { active: false, winners: [] };
        activeThefts = {}; 
        duelData = {}; 
        selectWaitState = {};
        bankProcessState = {}; 
        menuWaitState = {};
        miningState = {}; // 광산 활동 초기화

        // 2. UID 캐시 초기화 (메모리 정리)
        if (typeof uidCache !== 'undefined') {
            for (var k in uidCache) delete uidCache[k];
        }

        // 3. 시스템 핵심 경제 지표 복구
        if (!data.marketOpenPrice || data.marketOpenPrice <= 0) data.marketOpenPrice = 1000;
        marketOpenPrice = data.marketOpenPrice; // 전역 변수 동기화

        // 4. 전 유저 데이터 수치 정규화 및 방별 독립 상태 초기화
        var fixCount = 0;
        for (var r in data.rooms) {
            var roomObj = data.rooms[r];
            
            // [핵심 해결] /서버진단 수치에 반영되는 방별 states 주머니 강제 비우기
            if (roomObj.features && roomObj.features.states) {
                var st = roomObj.features.states;
                for (var sKey in st) { st[sKey] = {}; }
            }
            
            // 중앙은행 재원 누락 시 복구
            if (roomObj.bankReserve === undefined || roomObj.bankReserve === null) {
                roomObj.bankReserve = (SYSTEM_CONFIG && SYSTEM_CONFIG.ECO.BANK.INITIAL_RESERVE) ? SYSTEM_CONFIG.ECO.BANK.INITIAL_RESERVE : 10000;
            }
            // 위기 알림 상태 리셋
            roomObj.lastBankAlert = "normal";

            for (var id in roomObj.users) {
                var u = roomObj.users[id];
                if (!u) continue;
                u.point = Math.floor(Number(u.point || 0));
                u.bank = Math.floor(Number(u.bank || 0));
                u.creditScore = Math.min(1000, Math.max(0, Number(u.creditScore || 600)));
                
                if (!u.loan) u.loan = { debt: 0, items: [] };
                if (!u.stockHoldings) u.stockHoldings = {};
                fixCount++;
            }
        }

        // 5. 파일 시스템 락(Lock) 강제 해제 시도
        if (lock.isLocked()) {
            try { lock.unlock(); } catch(e) {}
        }

        safeSaveData(data);
        replier.reply(formatAdmin("⚙️ 시스템 자가 복원 완료", 
            "1. 모든 입력 대기 및 활동 상태 초기화 (방별 독립 상태 포함)\n" +
            "2. 중앙은행 재원 및 랜드마크 시세 지표 복구\n" +
            "3. 국가 위기 알림 엔진 리셋\n" +
            "4. 유저 " + fixCount + "명의 데이터 정수화 완료"));
        return true;
    }

    /* [신규] 모든 명령어 응답 무결성 점검 로직 */
    if (msg === "/명령어점검") {
        var statusReport = [];
        var totalCmds = CMD_LIST.user.concat(CMD_LIST.admin);
        var brokenCount = 0;

        statusReport.push("🔎 [전체 명령어 연결 상태 점검]\n");

        for (var i = 0; i < totalCmds.length; i++) {
            var c = totalCmds[i];
            var cmdName = c.cmd;
            var funcName = c.func;
            
            // 1. 레지스트리 등록 확인 및 2. 함수 객체 존재 여부 확인
            var isRegistered = (USER_COMMANDS[cmdName] || ADMIN_COMMANDS[cmdName]);
            var functionExists = false;
            try { functionExists = (typeof eval(funcName) === 'function'); } catch(e) {}

            if (isRegistered && functionExists) {
                // 정상적으로 연결된 경우 (출력 생략 가능하나 확인을 위해 표시)
                // statusReport.push("✅ " + cmdName + " : 정상");
            } else {
                // 연결이 끊겼거나 함수를 찾을 수 없는 경우
                var reason = !isRegistered ? "등록누락" : "로직실패";
                statusReport.push("❌ " + cmdName + " : " + reason + " (확인 필요)");
                brokenCount++;
            }
        }

        if (brokenCount === 0) {
            statusReport.push("✅ 모든 명령어의 로직 연결이 정상입니다.\n(응답 불가 현상 없음)");
        } else {
            statusReport.push("\n⚠️ 총 " + brokenCount + "개의 명령어가 작동하지 않을 수 있습니다.");
        }

        replier.reply(formatAdmin("🛰️ 명령어 무결성 리포트", statusReport.join("\n")));
        return true;
    }

    /* [v10.0 IPM] 지능형 서버 상태 대시보드 */
    if (msg === "/서버상태") {
        // 1. 상태 아이콘 판별
        var statusIcon = (PERF_METRICS.avgLag < 200) ? "🟢 쾌적" : (PERF_METRICS.avgLag < 450 ? "🟡 보통" : "🔴 과부하");
        
        // 2. 로그 용량 계산 (MB)
        var logFile = new java.io.File(JOURNAL_PATH);
        var logMB = (logFile.exists() ? (logFile.length() / (1024 * 1024)).toFixed(2) : "0.00");
        
        // 3. 리포트 본문 (관리자님 원본 양식 100% 적용 및 data 변수 참조 교정)
        var report = "⚙️ [시스템 실시간 건강 진단]\n" +
                     "━━━━━━━━━━━━━━━\n" +
                     "📊 퍼포먼스 상태: " + statusIcon + "\n" +
                     "• 평균 응답: " + PERF_METRICS.avgLag + "ms\n" +
                     "• 최고 지연: " + PERF_METRICS.peakLag + "ms\n\n" +
                     "📂 자원 사용량\n" +
                     "• 블랙박스 로그: " + logMB + " / 1.50 MB\n" +
                     "• 분당 처리량: " + PERF_METRICS.msgPerMin + " msg/min\n" +
                     "• 식별 캐시: " + Object.keys(data.nameToIdCache || {}).length + " 건\n" +
                     "━━━━━━━━━━━━━━━\n" +
                     "💡 시스템이 스스로 최적화 중입니다.";
                     
        replier.reply(formatAdmin("지능형 감시 센터", report));
        return true;
    }

    /* [긴급] 지능형 전체 데이터 복구 (Smart Restore v5.9+) */
    if (msg.startsWith("/전체복원")) {
        var stablePath = BACKUP_DIR + "last_stable_backup.json";
        var stableFile = new java.io.File(stablePath);

        if (!stableFile.exists() || stableFile.length() === 0) {
            replier.reply(formatAdmin("🚫 복구 실패", "안전 백업 파일(last_stable_backup.json)을 찾을 수 없습니다."));
            return true;
        }

        try {
            var content = FileStream.read(stablePath);
            if (!content) throw new Error("파일 내용이 비어있음");

            // 1. 메모리 교체 및 메인 파일 물리적 동기화
            var backupObj = JSON.parse(content);
            globalData = backupObj;
            FileStream.write(FILE_PATH, content);

            // 2. [핵심] 실시간 블랙박스(Journal) 병합
            // 백업 시점 이후부터 현재까지 발생한 모든 포인트 변동을 소급 적용합니다.
            if (typeof recoverFromJournal === 'function') {
                recoverFromJournal(globalData);
            }

            // 3. 최종 정화된 데이터를 세션에 반영하고 즉시 저장
            safeSaveData(globalData, false);

            var resBody = "✅ 지능형 데이터 복구 완료\n" +
                          "━━━━━━━━━━━━━━━\n" +
                          "• 소스: last_stable_backup.json\n" +
                          "• 병합: 실시간 블랙박스 로그 통합\n" +
                          "• 상태: 오염 데이터 정화 성공";

            replier.reply(formatAdmin("🛠️ 시스템 복구 보고", resBody));

        } catch (e) {
            Log.error("Restore Logic Crash: " + e);
            replier.reply(formatAdmin("🚫 복구 중단", "데이터 파싱 중 오류가 발생했습니다.\n사유: " + e.message));
        }
        return true;
    }

    return false;
}

//==========섹터37==========

/**
 * [게임 명령어 분배기] (Game Logic Dispatcher - Registry Refactored)
 * 설명: 유저들의 게임/경제 활동 명령어를 각 전문 담당 함수로 연결합니다.
 * 섹터 1의 USER_COMMANDS 레지스트리를 참조하여 등록된 로직을 자동으로 매핑 및 실행합니다.
 */
function _handleGameLogic(msg, user, data, replier, roomName, targetUid, sender) {
    var roomData = data.rooms[roomName];
    if (!roomData || !roomData.features || !roomData.features.states) return false;
    var duelData = roomData.features.states.duelData || {};
    
    // 1. 명령어 첫 단어 추출
    var cmd = msg.split(" ")[0];

    // [가상 정부 시스템] 정책 및 투표 명령어 분기 처리
    if (cmd === "/의회" || cmd === "/투표") {
        if (typeof _gameGovernmentLogic === 'function') {
            return _gameGovernmentLogic(msg, user, data, replier, roomName, targetUid);
        }
    }

    // 2. 유저 명령어 레지스트리 검색
    if (USER_COMMANDS[cmd] && typeof USER_COMMANDS[cmd].execute === 'function') {
        
        // [결투 키워드 가드] localized duelData 사용
        if (cmd === "수락" || cmd === "거절" || cmd === "취소") {
            var hasDuel = false;
            if (duelData[targetUid]) hasDuel = true;
            else {
                for (var d in duelData) {
                    if (duelData[d].challengerUid === targetUid) { hasDuel = true; break; }
                }
            }
            if (!hasDuel) return false;
        }
        
        // 3. 검증된 명령어만 하위 로직 함수(섹터 40~44 등)로 실행 위임
        return USER_COMMANDS[cmd].execute(msg, user, data, replier, roomName, targetUid);
    }

    // 4. 등록되지 않은 명령어이거나 처리할 로직이 없는 경우 false 반환
    return false;
}

//==========섹터38==========

/**
 * [게임 하위 모듈 1] 은행 및 사채 관리
 * 기능: 은행 메뉴 호출, 대출금 직접 상환
 * 설명: 메뉴 UI에 기부 항목을 추가하고, 상환 시 중앙은행 재고로 환수되도록 연동함.
 */
function _gameBankLogic(msg, user, data, replier, roomName, targetUid) {
    // 1. 기초 데이터 및 경제 구역 선언 (참조 오류 방지 핵심)
    var currentRoom = data.rooms[roomName]; 
    var economyRoomName = (ALLOWED_ROOMS.indexOf(roomName) === -1) ? "내리다" : roomName;
    var economyRoomData = data.rooms[economyRoomName];

    // 2. 하단 로직 호환성을 위해 roomData 정의 (1:1방이면 메인방 데이터를 참조)
    var roomData = (ALLOWED_ROOMS.indexOf(roomName) === -1) ? economyRoomData : currentRoom;

    // 데이터가 없으면 중단 (장애 방지)
    if (!roomData || !roomData.features) return false;

    // 3. 세션 저장소(States) 초기화
    if (!currentRoom.features) {
        if (typeof ROOM_FEATURE_TEMPLATE === 'function') currentRoom.features = ROOM_FEATURE_TEMPLATE();
        else currentRoom.features = { states: { menuWait: {}, bankProcess: {} } };
    }
    
    var menuWaitState = currentRoom.features.states.menuWait;
    var bankProcessState = currentRoom.features.states.bankProcess;

    /* [기능 1] 은행 시스템 진입 (v5.2 기부 메뉴 추가) */
    if (msg === "/은행") {
        var crTargetRoom = (ALLOWED_ROOMS.indexOf(roomName) === -1) ? "내리다" : roomName;
        var cr = getCreditInfo(user.creditScore, crTargetRoom);
        
        menuWaitState[targetUid] = { type: 'bank_menu', time: Date.now() };

        var bankMenu = "1. 💰 예금 (포인트 ➔ 은행)\n" +
                       "2. 🏧 출금 (은행 ➔ 포인트)\n" +
                       "3. 💸 송금 (타인에게 이체)\n" +
                       "4. 🏦 대출 (한도: " + fp(cr.limit) + "P)\n" + // 메뉴에 실시간 한도 직접 표시
                       "5. 📉 상환 (대출금 갚기)\n" +
                       "6. " + (SYSTEM_CONFIG.MSG.PREFIX.LOAN || "🚬") + " 사채 시장 (P2P 대출)\n" +
                       "7. 🎁 기부 (국고 후원)";
        
        var myPoint = Number(user.point || 0);
        var myBank = Number(user.bank || 0);
        
        var content = bankMenu + "\n\n" +
               "🏦 은행 잔고 : " + fp(roomData.bankReserve) + "P\n\n" +
               "보유: " + fp(myPoint) + "P / 예금: " + fp(myBank) + "P\n" +
               "(번호를 선택해주세요)";

        // formatCommand를 호출하여 최종 메시지 조립
        replier.reply(formatCommand("🏦 은행 업무 선택", user, content, "입력 대기: 30초"));
        return true;
    }

    /* [기능 2] 대출금 상환 (직접 명령어) */
    if (msg.indexOf("/상환 ") === 0) {
        var myDebt = (user.loan && user.loan.debt) ? Number(user.loan.debt) : 0;
        if (myDebt <= 0) { 
            replier.reply(formatError(user, "상환 불가", "갚아야 할 은행 대출금이 존재하지 않습니다.")); 
            return true; 
        }

        var parts = msg.split(" ");
        // 쉼표가 포함된 입력도 처리 가능하도록 개선
        var amt = parseInt(parts[1].replace(/,/g, "")); 
        
        if (isNaN(amt) || amt <= 0) { 
            replier.reply(formatError(user, "금액 오류", "정확한 상환 금액을 입력하세요.")); 
            return true; 
        }
        
        var myPoint = Number(user.point || 0);
        if (myPoint < amt) { 
            replier.reply(formatError(user, "포인트 부족", "보유 포인트가 부족합니다.")); 
            return true; 
        }
        
        // 분산 상환 로직 호출 (섹터 13 정의) - 메인 방 기준으로 신용점수 계산
        var targetRoomName = (ALLOWED_ROOMS.indexOf(roomName) === -1) ? "내리다" : roomName;
        var res = distributeRepayment(user, amt, targetRoomName);
        
        /* [중앙은행 연동] 통합 포인트 함수 사용 */
        // 유저 포인트 차감과 동시에 차감된 금액(res.actualRepay)이 bankReserve에 자동 입금됨.
        // 로그 기록 시 1:1 방 이름이 아닌 실제 메인 방 이름으로 기록되게 함
        util_updatePoint(user, roomData, -Number(res.actualRepay), "대출 상환", targetRoomName);
        
        var remainingDebt = (user.loan && user.loan.debt) ? Number(user.loan.debt) : 0;
        replier.reply(formatCommand("📉 상환 완료", user, fp(res.actualRepay) + "P 상환되었습니다.\n(신용 점수 +" + res.creditGain + ")", "남은 대출: " + fp(remainingDebt) + "P / 잔액: " + fp(user.point) + "P"));
        
        safeSaveData(data);
        return true;
    }

    return false;
}

//==========섹터39==========

/**
 * [게임 하위 모듈 2] 정보 및 랭킹 조회 (UI 최적화 및 출석 상태 추가)
 * 기능: 내정보, 유물도감, 신용등급, 대출한도, 명예의전당, 순위, 유저정보, 경마조회
 * 수정 사항: 도굴왕 달성 시 특별 축하 멘트 적용 및 유물 도감 UI 최종 최적화
 */
function _gameInfoLogic(msg, user, data, replier, roomName, targetUid) {
    // [1:1 연동 핵심] 데이터 소스 리다이렉트
    var targetRoomData = null;
    if (ALLOWED_ROOMS.indexOf(roomName) === -1) {
        var linkedRoom = data.rooms["내리다"];
        if (linkedRoom) {
            targetRoomData = linkedRoom;
        } else {
            return false;
        }
    } else {
        targetRoomData = data.rooms[roomName];
    }
    
    var roomData = targetRoomData; // 변수명 통일

    // 1. 방 데이터 및 기능 템플릿 존재 여부 체크 (안전 가드)
    if (!roomData || !roomData.features) return false;

    // 2. [핵심 고정] 전역 변수가 아닌 이 함수 전용 지역 변수로 데이터 연결
    // 이 코드가 있어야 /경마, /로또 등의 명령어가 먹통이 되지 않습니다.
    var racingData = roomData.features.racing;
    var rConf = (SYSTEM_CONFIG.ECO && SYSTEM_CONFIG.ECO.RACING) ? SYSTEM_CONFIG.ECO.RACING : (SYSTEM_CONFIG.RACING || {});
    
    // 만약 상수가 아예 로드되지 않았을 경우를 대비한 최소한의 기본값 보정
    if (!rConf.MIN_BET) {
        rConf.MIN_BET = 10000;
        rConf.MAX_BET = 30000;
        rConf.TAX_RATE = 0.1;
        rConf.CANCEL_FEE = 0.1;
    }

    /* [Gemini 요청 사항] 경마 정보 실시간 브리핑 기능 통합 (내 배팅 정보 포함) */
    if (msg === "/경마") {
        if (!racingData.isOperating) {
            replier.reply(formatSimple("🏇 경마장 휴장 안내", "현재 경마 운영 시간이 아닙니다.\n(운영시간: 09:00 ~ 23:59)", "오전 9시 정각에 개장합니다."));
            return true;
        }

        var hList = racingData.horses.map(function(h) {
            var horseBetSum = 0;
            for (var uid in racingData.bets) {
                if (racingData.bets[uid].horseId === h.id) horseBetSum += Number(racingData.bets[uid].amount);
            }
            return h.id + ". " + h.name + " [" + h.icon + "]\n    └ 현 배팅액: " + fp(horseBetSum) + "P";
        }).join("\n");

        var now = new Date();
        var nowMin = now.getMinutes();
        var remainMin = 49 - nowMin;
        var remainSec = 59 - now.getSeconds();
        if (remainMin < 0) { remainMin = 0; remainSec = 0; }

        var myBet = racingData.bets[targetUid];
        var myBetInfo = "";
        if (myBet) {
            var myHorse = racingData.horses[myBet.horseId - 1]; 
            myBetInfo = "👤 내 배팅: " + myBet.horseId + "번 " + myHorse.name + " (" + fp(myBet.amount) + "P)";
        } else {
            myBetInfo = "👤 내 배팅: 참여 내역 없음";
        }

        var raceHeader = (nowMin >= 50) ? "🏁 배팅 마감 및 정산 중" : "제 " + racingData.round + "회차 경기 배팅 진행 중";
        var totalPrizePool = racingData.totalPool + racingData.carryOver;
        var racingBody = raceHeader + "\n\n" +
                         "[🏇 출전마 라인업]\n" + hList + "\n\n" +
                         myBetInfo + "\n" +
                         "💰 현재 총 배당금: " + fp(totalPrizePool) + "P\n" +
                         (racingData.carryOver > 0 ? "✨ 이월 적립금: " + fp(racingData.carryOver) + "P 포함\n" : "") +
                         "🕒 배팅 마감: " + remainMin + "분 " + remainSec + "초 남음";

        replier.reply(formatCommand("🏇 내리다 중앙 경마장", user, racingBody, "배팅: [/배팅 번호 금액]"));
        return true;
    }

    /* [신규] 봇 응답 속도 체크 */
    if (msg === "/핑") {
        var ping = Date.now() - _msgReceiveTime;
        var status = ping < 150 ? "🚀 매우 쾌적" : (ping < 400 ? "🟢 양호" : (ping < 800 ? "🟡 지연" : "🔴 과부하"));
        replier.reply(formatSimple("🏓 퐁! (Pong)", "⏱️ 응답 속도: " + ping + "ms\n📊 현재 상태: " + status, "서버의 처리 지연 시간을 측정합니다."));
        return true;
    }

    /* [기능 3] 내 정보 조회 */
    if (msg === "/내정보") {
        var crTargetRoom = (ALLOWED_ROOMS.indexOf(roomName) === -1) ? "내리다" : roomName;
        var cr = getCreditInfo(user.creditScore, crTargetRoom);
        var authInfo = "🎮 게임 인증: " + (user.gameAuthCount || 0) + "/2 (시즌)";
        
        var bankDebt = (user.loan && user.loan.debt) ? Math.floor(Number(user.loan.debt)) : 0;
        var sacheDebt = 0;
        var sacheClaims = 0; 
        var overdueSache = 0;

        if (roomData && roomData.loanContracts) {
            for (var cid in roomData.loanContracts) {
                var c = roomData.loanContracts[cid];
                if (c.borrowerUid === targetUid) {
                    sacheDebt += Math.floor(c.currentDebt);
                    if (c.status === 'overdue') overdueSache += Math.floor(c.currentDebt);
                }
                if (c.lenderUid === targetUid) {
                    sacheClaims += Math.floor(c.currentDebt);
                }
            }
        }

        var todayStr = getSimpleDate();
        var attendMark = (user.lastDate === todayStr) ? " (✅)" : " (⏳)";
        var totalPromotion = (Number(user.dailyPromotionAttempts) || 0) + (Number(user.purchasedPromotionAttempts) || 0);

        var currentAccrued = Number(user.accruedInterest || 0);
        if (user.lastBankUpdateTime > 0 && Number(user.bank) > 0) {
            var passed = Date.now() - user.lastBankUpdateTime;
            currentAccrued += Number(user.bank) * SYSTEM_CONFIG.ECO.BANK.INTEREST_RATE * (passed / 86400000);
        }

        var infoBody = authInfo + "\n" +
                       "💰 보유 포인트: " + fp(user.point) + "P\n" +
                       "🏦 예금: " + fp(user.bank) + "P\n" +
                       "🧧 지급 예정 이자: " + fp(Math.floor(currentAccrued)) + "P\n" +
                       (sacheClaims >= 1 ? "🤝 미수 채권: " + fp(sacheClaims) + "P\n" : "") +
                       "💳 신용 등급: " + cr.label + " (" + user.creditScore + "점)\n" +
                       "🏅 현재 티어: " + (TIERS[user.tier] || "아이언") + "\n" +
                       "📅 누적 출석: " + (user.totalAttendance || 0) + "일" + attendMark + "\n" +
                       "🔂 승급 기회: " + totalPromotion + "회";
        
        if (bankDebt > 0) {
            var transferTag = user.isTransferred ? " (🚨대환 채무: 70% 강제상환)" : "";
            infoBody += "\n🏦 미상환 대출: " + fp(bankDebt) + "P" + transferTag;
        }

        if (sacheDebt > 0) {
            infoBody += "\n🚬 미상환 사채: " + fp(sacheDebt) + "P";
            if (overdueSache > 0) infoBody += "\n🚨 사채 연체: " + fp(overdueSache) + "P (50% 자동상환)";
        }
        
        replier.reply(formatCommand("📌 내 상세 정보", user, infoBody, "아이템 구매: [/상점]")); 
        return true;
    }

    /* [Gemini 요청 사항] 유물 도감 조회 UI 가변 처리 자동화 */
    if (msg === "/유물도감") {
        var pieces = Number(user.artifactPieces || 0);
        
        // 1. 현재 조각 수에 따른 다음 목표치와 목표 칭호 설정
        var targetGoal = 10;
        var nextTitle = "도굴꾼";

        if (pieces >= 50) { 
            targetGoal = 50; 
            nextTitle = "도굴왕 ⚜️"; 
        } else if (pieces >= 40) { 
            targetGoal = 50; 
            nextTitle = "도굴왕 ⚜️"; 
        } else if (pieces >= 30) { 
            targetGoal = 40; 
            nextTitle = "트레저헌터"; 
        } else if (pieces >= 20) { 
            targetGoal = 30; 
            nextTitle = "발굴가"; 
        } else if (pieces >= 10) { 
            targetGoal = 20; 
            nextTitle = "탐사원"; 
        } else { 
            targetGoal = 10; 
            nextTitle = "도굴꾼"; 
        }

        // 2. 달성 상태 텍스트 판별
        var statusTxt = (pieces >= 50) ? "전설 등극!" : "진행 중...";
        
        // 3. UI 바디 구성
        var statusContent = "✨ 유물 조각\n" +
                            "🧩 보유: " + pieces + " / " + targetGoal + " 개\n\n" +
                            "📊 상태: " + statusTxt + "\n\n" +
                            "🎁 수집 달성 보상\n" +
                            "🎖️ 칭호: [" + nextTitle + "] (" + statusTxt + ")";
        
        // 4. 가이드 문구 가변 처리
        var guideText = (pieces >= 50) 
            ? "🎉 축하합니다! 고대의 신비를 모두 풀어낸 당신은 이 시대의 진정한 전설, 도굴왕이십니다!" 
            : "광산에서 0.1% 확률로 조각이 발견됩니다. " + targetGoal + "개를 모으면 자동으로 칭호가 부여됩니다.";
        
        replier.reply(formatCommand("🏺 유물 도감", user, statusContent, guideText));
        return true;
    }

    /* [기능 4] 신용 등급 및 대출 한도 조회 */
    if (msg === "/신용등급" || msg === "/대출한도") {
        // 1. 섹터 10의 통합 엔진 호출 (이미 승수와 신불자가 계산되어 있음)
        // [수정] 강제로 '내리다' 방 기준 계산
        var targetRoomName = (ALLOWED_ROOMS.indexOf(roomName) === -1) ? "내리다" : roomName;
        var limitTable = getCreditLimitTable(targetRoomName);
        var cr = getCreditInfo(user.creditScore, targetRoomName);
        
        // 2. 현재 시장 승수 확인 (메시지 상단 상태 표시용)
        var dynMult = 1.0;
        if (typeof util_getDynamicRateMultiplier === 'function') {
            dynMult = util_getDynamicRateMultiplier(targetRoomName);
        }

        // 3. 시장 상황 텍스트 판별
        var marketStatus = "🟢 경제 안정";
        if (dynMult > 1.2) marketStatus = "🚨 국고 위기 (고금리)";
        else if (dynMult < 0.8) marketStatus = "✅ 유동성 풍부 (저금리)";

        // 4. 최종 메시지 조립 (중복 루프 제거)
        var creditPolicy = "\n\n[📊 신용 변동 수치]\n" +
                           "• 대출실행: -100점 | 상환: +80점\n" +
                           "• 대환집행: -120점 | 회복제: +20점\n" +
                           "• 기부: 10,000P당 +10점\n\n" +
                           "[🚢 등급별 무역 수익 배율]\n" +
                           "• 1등급: 90% | 2등급: 85% | 3등급: 80%\n" +
                           "• 4등급: 75% | 5등급: 70% | 신불자: 60%";

        var header = "🌐 시장 상황: " + marketStatus + " (x" + dynMult.toFixed(2) + ")\n\n" +
                     limitTable + 
                     creditPolicy;

        var myAppliedRate = ((cr.rate - 1) * 100 * dynMult).toFixed(1);
        var myCredit = "\n\n[내 실시간 적용 상태]\n" +
                       "• 신용점수: " + user.creditScore + "점 (" + cr.label + ")\n" +
                       "• 적용이율: " + myAppliedRate + "%\n" +
                       "• 가능액수: " + fp(cr.limit) + "P";

        replier.reply(formatCommand("💳 신용 등급 및 실시간 한도", user, header + myCredit, "대출 실행: [/은행]"));
        return true;
    }

    /* [기능 5] 명예의 전당 */
    if (msg === "/명예의전당") {

        var targetZone = (roomName === "베릭방" || ALLOWED_ROOMS.indexOf(roomName) === -1) ? "내리다" : roomName;
        var targetRoomData = data.rooms[targetZone];

        var challengers = [];
        var roomUsers = roomData.users;
        for (var id in roomUsers) {
            var u = roomUsers[id];
            if (u && u.tier === 9) {
                var count = Math.max(1, u.challengerCount || 0);
                challengers.push("🏆 " + u.name + " (누적 " + count + "회)");
            }
        }
        var content = challengers.length > 0 ? challengers.join("\n") : "현재 이 방에 등록된 챌린저가 없습니다.";
        replier.reply(formatSimple("🏅 명예의 전당", content, "최고 티어 달성 시 등록됩니다."));
        return true;
    }

    /* [기능 5-1] 계정 확인 및 연동 */
    // [기능 1] 내 고유 복구 코드 확인
    if (msg === "/코드확인") {
        var codeMsg = "당신의 고유 복구 코드입니다.\n닉네임과 프사를 동시에 바꿀 경우를 대비해 반드시 따로 저장해두세요.\n\n🔑 코드: " + targetUid;
        replier.reply(formatCommand("🔐 보안 복구 코드", user, codeMsg, "연동 방법: [/계정연동 코드]"));
        return true;
    }

    // [기능 2] 계정 연동 및 데이터 복구 (완전 결함 제거 버전)
    if (msg.indexOf("/계정연동") === 0) {
        var parts = msg.split(" ");
        if (parts.length < 2) return replier.reply(formatError(user, "입력 오류", "/계정연동 [복구코드]"));

        var inputCode = parts[1].split("-").join("").toLowerCase().trim();
        var oldUser = null;

        // 1. 전체 데이터베이스에서 소스 계정 탐색
        for (var rName in data.rooms) {
            var roomUsers = data.rooms[rName].users;
            for (var uid in roomUsers) {
                if (String(uid).split("-").join("").toLowerCase() === inputCode) {
                    oldUser = roomUsers[uid];
                    break;
                }
            }
            if (oldUser) break;
        }

        if (!oldUser) return replier.reply(formatError(user, "복구 실패", "일치하는 코드를 찾을 수 없습니다."));
        if (inputCode === String(targetUid).split("-").join("").toLowerCase()) return replier.reply(formatError(user, "작업 무효", "현재 접속 중인 코드와 동일합니다."));

        try {
            // 2. 데이터 정밀 복사 (Deep Copy)
            // 현재 유저의 고유 ID(targetUid)와 이름은 유지한 채 알맹이만 과거 데이터로 교체
            var backupData = JSON.parse(JSON.stringify(oldUser));
            
            // 필수 필드 선별 복사 (현재 닉네임과 ID 보존)
            var preservedName = user.name;
            var preservedHash = user.imageHash;

            // 수정: 무역, 경마부품, 칭호진행도 등 USER_SCHEMA의 모든 정보를 누락 없이 복사
            USER_SCHEMA.forEach(function(item) {
                var f = item.key;
                if (backupData[f] !== undefined) {
                    // 객체나 배열인 경우 참조 끊기(Deep Copy) 적용
                    user[f] = (typeof backupData[f] === 'object' && backupData[f] !== null) 
                              ? JSON.parse(JSON.stringify(backupData[f])) : backupData[f];
                }
            });

            user.name = preservedName;
            user.imageHash = preservedHash;

            safeSaveData(data);
            
            var resBody = "과거 자산 정보를 현재 계정으로 안전하게 복사해왔습니다.\n\n" +
                         "💰 복제 잔액: " + fp(user.point) + "P\n" +
                         "🏅 복제 티어: " + (TIERS[user.tier] || "아이언") + "\n" +
                         "📦 인벤토리: " + (user.inventory ? user.inventory.length : 0) + "개 항목 이관";

            replier.reply(formatCommand("✅ 데이터 정밀 복제 완료", user, resBody, "고유 코드는 현재 코드를 그대로 유지합니다."));
        } catch (e) {
            replier.reply(formatError(user, "시스템 오류", "복제 중 기술적 결함 발생: " + e));
        }
        return true;
    }

    /* [기능 6] 자산 순위 */
    if (msg === "/출석순위") {
        var targetZone = (roomName === "베릭방" || ALLOWED_ROOMS.indexOf(roomName) === -1) ? "내리다" : roomName;
        var targetRoomData = data.rooms[targetZone];
        var users = [];
        var roomUsers = roomData.users;
        for (var id in roomUsers) {
            var u = roomUsers[id];
            var netWorth = util_calculateNetWorth(u, roomData);
            if (netWorth >= 1) users.push({ data: u, total: netWorth });
        }
        users.sort(function(a, b) { return b.total - a.total; });
        var rankList = [];
        for (var i = 0; i < Math.min(10, users.length); i++) {
            rankList.push((i + 1) + ". " + getDisplayName(users[i].data) + " (" + fp(users[i].total) + "P)");
        }
        var rankMsg = (rankList.length > 0 ? rankList.join("\n") : "순위 데이터가 없습니다.");
        replier.reply(formatSimple("자산 랭킹 (실질 순자산 기준)", rankMsg, "내 정보: [/내정보]"));
        return true;
    }

    /* [기능 7] 유저 정보 상세 조회 */
    if (msg.indexOf("/유저정보") === 0) {
        var tn = msg.substring(5).trim(); 
        if (tn === "") {
            replier.reply(formatError(user, "입력 오류", "조회할 유저의 닉네임을 입력하세요."));
            return true;
        }
        var found = findUserGlobal(tn, roomName);
        if (found.length === 0) { 
            replier.reply(formatError(user, "대상 없음", "[" + tn + "]님을 찾을 수 없습니다.")); 
            return true; 
        }
        if (found.length === 1) {
            var targetUser = found[0].data;
            var targetIdInside = found[0].id;
            var cr = getCreditInfo(targetUser.creditScore);
            
            var sDebt = 0;
            var sClaims = 0;
            if (roomData.loanContracts) {
                for (var cid in roomData.loanContracts) {
                    var c = roomData.loanContracts[cid];
                    if (c.borrowerUid === targetIdInside) sDebt += Math.floor(c.currentDebt);
                    if (c.lenderUid === targetIdInside) sClaims += Math.floor(c.currentDebt);
                }
            }

            var info = "💰 포인트: " + fp(targetUser.point) + "P\n" +
                       "🏦 예금: " + fp(targetUser.bank) + "P\n" +
                       (sClaims >= 1 ? "🤝 미수 채권: " + fp(sClaims) + "P\n" : "") +
                       "💳 신용: " + cr.label + " (" + targetUser.creditScore + "점)\n" +
                       "🏅 티어: " + (TIERS[targetUser.tier] || "아이언") + "\n" +
                       "📅 출석: " + (targetUser.totalAttendance || 0) + "일";
            
            var bDebt = (targetUser.loan && targetUser.loan.debt) ? Math.floor(Number(targetUser.loan.debt)) : 0;
            if (bDebt > 0) info += "\n🏦 미상환 대출: " + fp(bDebt) + "P";
            if (sDebt > 0) info += "\n🚬 미상환 사채: " + fp(sDebt) + "P";

            replier.reply(formatCommand("🔍 유저 상세 정보", targetUser, info, null));
        } else {
            handleUserSelection(replier, targetUid, found, "info", null, user, roomName);
        }
        return true;
    }

    return false;
}

//==========섹터40==========

/**
 * [게임 하위 모듈 3] 액션 및 도박 통합 분배기
 * 설명: 섹터 39(전체 분배기)로부터 호출받아, 실제 세부 로직(42-1 ~ 42-3)으로 연결합니다.
 * 이 구조를 통해 각 기능별로 독립적인 수정 및 관리가 가능해집니다.
 */
function _gameActionLogic(msg, user, data, replier, roomName, targetUid) {
    var cmd = msg.split(" ")[0]; // 명령어 첫 단어 추출
    
    // 1. 홀짝, 승급, 경마 관련 로직 (섹터 40 위임)
    // [수정]: /배팅 및 배팅취소 조건을 추가하여 Part1 함수가 실행될 수 있도록 입구를 개방함
    if (cmd === "/홀짝" || cmd === "/승급" || cmd === "/배팅" || cmd === "배팅취소") {
        return _gameActionLogic_Part1(msg, user, data, replier, roomName, targetUid);
    }
    
    // 2. 결투 로직 (섹터 41 위임)
    if (cmd === "/결투" || cmd === "수락" || cmd === "거절" || cmd === "취소") {
        return _gameActionLogic_Part2(msg, user, data, replier, roomName, targetUid);
    }
    
    // 3. 도둑질 및 줍기 로직 (섹터 42 위임)
    if (cmd === "/도둑질" || cmd === "잡았다요놈" || cmd === "줍기") {
        return _gameActionLogic_Part3(msg, user, data, replier, roomName, targetUid);
    }
    
    return false; // 해당되는 명령어가 없음
}

//==========섹터41==========

/**
 * [게임 하위 모듈 3-1] 액션 및 도박 게임 (홀짝 & 승급 & 경마 액션)
 * v5.9: 통합 엔진(7, 9, 11) 연결 완료
 */
function _gameActionLogic_Part1(msg, user, data, replier, roomName, targetUid) {
    var roomData = data.rooms[roomName];
    if (!roomData) return false;

    var racingData = roomData.features.racing;

    var rConf = SYSTEM_CONFIG.ECO.RACING; 

    /* [연결] 1. 경마 배팅 액션 (/배팅 [번호] [금액]) */
    if (msg.indexOf("/배팅 ") === 0) {
        if (util_isBankruptcy(roomName)) {
            replier.reply(formatError(user, "시스템 동결", "국가 부도 선포 상태에서는 경마 배팅이 금지됩니다.\n(회복 기준: 국고 50%)"));
            return true;
        }
        if (!racingData.isOperating) {
            replier.reply(formatError(user, "경마장 휴장", "현재 운영 시간이 아닙니다. (09:00 ~ 23:59)"));
            return true;
        }

        var nowMin = new Date().getMinutes();
        if (nowMin >= 50) {
            replier.reply(formatError(user, "배팅 마감", "현재 제 " + racingData.round + "회차 경기가 마감되어 정산 중입니다."));
            return true;
        }

        // [엔진 연결] 통합 상태 가드 체크 (징역/광산 등)
        var stateRes = util_checkUserState(user, targetUid);
        if (!stateRes.canAction) {
            replier.reply(formatError(user, "배팅 불가", stateRes.reason));
            return true;
        }

        var ps = msg.trim().split(/\s+/);
        if (ps.length < 3) { 
            replier.reply(formatError(user, "형식 오류", "/배팅 [말번호] [금액]")); 
            return true; 
        }
        
        var hId = parseInt(ps[1]);
        var betAmt = parseInt(ps[2].replace(/,/g, ""));

        if (isNaN(hId) || hId < 1 || hId > racingData.horses.length) {
            replier.reply(formatError(user, "번호 오류", "1~" + racingData.horses.length + "번 사이의 말을 선택하세요."));
            return true;
        }

        // [엔진 연결] 물가 배율 엔진 적용
        var minLimit = rConf.MIN_BET; 
        var maxLimit = rConf.MAX_BET;

        if (isNaN(betAmt) || betAmt < minLimit) {
            replier.reply(formatError(user, "금액 미달", "최소 " + fp(minLimit) + "P 이상 배팅해야 합니다."));
            return true;
        }
        if (betAmt > maxLimit) {
            replier.reply(formatError(user, "한도 초과", "최대 " + fp(maxLimit) + "P까지 배팅 가능합니다."));
            return true;
        }
        if (Number(user.point) < betAmt) {
            replier.reply(formatError(user, "포인트 부족", "보유 포인트가 부족합니다."));
            return true;
        }

        if (racingData.bets[targetUid]) {
            replier.reply(formatError(user, "중복 배팅 불가", "이미 배팅하셨습니다. [배팅취소] 후 다시 시도하세요."));
            return true;
        }

        // [엔진 연결] 게이트웨이를 통한 안전 차감 및 국고 입고
        util_updatePoint(user, roomData, -betAmt, "경마 배팅", roomName);
        
        var selectedHorse = racingData.horses[hId - 1];
        racingData.bets[targetUid] = { uid: targetUid, horseId: hId, amount: betAmt, name: user.name };
        racingData.totalPool += betAmt;

        // [v11.0] 중앙경마장 최대주주 배당을 위한 일일 배팅금액 누적
        if (roomData.features.dailyPools) {
            var accumRate = SYSTEM_CONFIG.ECO.ACTIVITY_ACCUM_RATES.RACING || 0.02;
            roomData.features.dailyPools.race += Math.floor(betAmt * accumRate);
        }

        var betSuccessContent = "🏇 선택: " + selectedHorse.id + "번 " + selectedHorse.name + "\n💰 금액: " + fp(betAmt) + "P 배팅 성공!";

        if (Math.random() < 0.1) { // 10% 확률
            var allParts = ["안장", "등자", "고삐", "채찍"];
            if (!user.horseParts) user.horseParts = [];
            var missingParts = allParts.filter(function(p) { return user.horseParts.indexOf(p) === -1; });
            
            if (missingParts.length > 0) {
                var newPart = missingParts[Math.floor(Math.random() * missingParts.length)];
                user.horseParts.push(newPart);
                betSuccessContent += "\n\n 🐎 경마장을 지나다 '" + newPart + "'을 발견했습니다!\n(보유 아이템: " + user.horseParts.join(", ") + " / 남은 부품: " + (missingParts.length - 1) + "개)";
                
                if (user.horseParts.length === 4) {
                    betSuccessContent += "\n\n 🐎 모든 장비가 갖춰져 [경마왕] 자격을 얻었습니다!";
                    util_checkAndAwardTitle(user, replier, "경마왕", 777, "🏇", "내리다 경마 협회", "경마 장비 4종 수집", "[장착 효과]: 경마 배팅 취소 시 발생하는 위약금(10%)이 전액 면제됩니다.", roomName);
                }
            }
        }

        replier.reply(formatCommand("✅ [경마 배팅 완료]", user, betSuccessContent, "🏇 선택: " + selectedHorse.id + "번 " + selectedHorse.name + "\n💰 금액: " + fp(betAmt) + "P 배팅 성공!", "내 잔액: " + fp(user.point) + "P"));
        safeSaveData(data);
        return true;
    }

    /* [연결] 2. 경마 배팅 취소 (배팅취소) */
    if (msg === "배팅취소") {
        if (!racingData.isOperating) return false;
        var nowMin = new Date().getMinutes();
        if (nowMin >= 50) {
            replier.reply(formatError(user, "취소 불가", "정산 중에는 취소가 불가능합니다."));
            return true;
        }

        var myBet = racingData.bets[targetUid];
        if (!myBet) {
            replier.reply(formatError(user, "내역 없음", "이번 회차 배팅 기록이 없습니다."));
            return true;
        }

       var isOwner = (user.title === "경마왕");
        var feeRate = isOwner ? 0 : rConf.CANCEL_FEE;
        var fee = Math.floor(myBet.amount * feeRate);
        var refund = myBet.amount - fee;

        var cancelMsg = "경마 배팅을 철회했습니다.\n\n💰 원래 배팅금: " + fp(myBet.amount) + "P\n";
        if (isOwner) {
            cancelMsg += "👑 [경마왕] 칭호 효과 적용!\n⚖️ 취소 위약금: 0P (전액 면제)\n";
        } else {
            cancelMsg += "⚖️ 취소 위약금(10%): -" + fp(fee) + "P\n";
        }
        cancelMsg += "🎁 최종 환불액: " + fp(refund) + "P";

        // [엔진 연결] 게이트웨이를 통한 환불 (수수료 제외)
        util_updatePoint(user, roomData, refund, "경마 배팅 취소", roomName);
        
        racingData.totalPool -= myBet.amount;

        // [v11.0] 배팅 취소 시 일일 누적 금액에서 차감 (실제 유효 배팅액 반영)
        if (roomData.features.dailyPools) {
            roomData.features.dailyPools.race -= myBet.amount;
        }

        delete racingData.bets[targetUid];

        var cancelMsg = "경마 배팅을 철회했습니다.\n\n💰 원래 배팅금: " + fp(myBet.amount) + "P\n⚖️ 취소 위약금(10%): -" + fp(fee) + "P\n🎁 최종 환불액: " + fp(refund) + "P";
        replier.reply(formatCommand("🚫 배팅 취소 완료", user, cancelMsg, "내 잔액: " + fp(user.point) + "P"));
        safeSaveData(data);
        return true;
    }

    /* [연결] 3. 홀짝 시스템 통합 안내 (/홀짝) */
    /**
     * 설명: 기존 홀짝 시스템을 폐기하고 통합 카지노(/카지노)로 유도합니다.
     */
    if (msg.indexOf("/홀짝") === 0) {
        var notice = "기존 홀짝 도박 시스템이 [내리다 중앙 카지노]로 통합되었습니다.\n\n" +
                     "🪜 사다리 (단일 1.9배 / 조합 4.0배)\n" +
                     "🃏 바카라 (P 2.0배 / B 1.95배 / T 8.0배)\n\n" +
                     "더욱 정교해진 시스템에서 실시간 배팅을 즐겨보세요!";
        
        replier.reply(formatCommand("🌓 시스템 통합 안내", user, notice, "명령어: [/카지노]"));
        return true;
    }

    /* [기존 로직 유지] 4. 티어 승급 (/승급) */
    if (msg === "/승급") {
        var totalAttempts = Number(user.dailyPromotionAttempts || 0) + Number(user.purchasedPromotionAttempts || 0);
        if (totalAttempts <= 0) { replier.reply(formatError(user, "기회 없음", "상점에서 승급권을 구매하세요.")); return true; }
        if (user.tier >= 9) { replier.reply(formatError(user, "최고 등급", "이미 챌린저 등급입니다.")); return true; }

        var usedDaily = false;
        if (Number(user.dailyPromotionAttempts) > 0) { 
            util_setData(user, 'dailyPromotionAttempts', user.dailyPromotionAttempts - 1, "일일 승급 기회 차감", roomName);
            usedDaily = true; 
        }
        else { 
            util_setData(user, 'purchasedPromotionAttempts', user.purchasedPromotionAttempts - 1, "구매 승급권 차감", roomName);
        }

        var prob = TIER_PROBS[user.tier] || { up: 50, stay: 40, down: 10 };
        var rand = Math.random() * 100;
        var isSundayFever = (new Date().getDay() === 0);
        if (isSundayFever) rand -= 5; 

        startTracking(user, "승급 도전");

        if (rand < prob.up) { 
            // 1. 차세대 티어 계산 및 게이트웨이 검증
            var nextTier = Number(user.tier || 0) + 1;
            util_setData(user, 'tier', nextTier, "승급 성공", roomName);

            var successBody = "티어: [" + TIERS[nextTier] + "]\n\n";
            
            if (nextTier === 9) { // 챌린저 도달 판정
                // 챌린저 횟수 통계도 게이트웨이로 보호
                util_setData(user, 'challengerCount', (user.challengerCount || 0) + 1, "챌린저 달성", roomName);
                user.challengerIconSeason = getSimpleSeason();
                successBody += "🎊 축하합니다! 챌린저 등급 도달! 명예의 전당에 기록되었습니다.";
            } else {
                // 승급 성공 보너스 기회 증가도 게이트웨이로 보호
                if (usedDaily) {
                    util_setData(user, 'dailyPromotionAttempts', (user.dailyPromotionAttempts || 0) + 1, "승급 성공 보너스", roomName);
                } else {
                    util_setData(user, 'purchasedPromotionAttempts', (user.purchasedPromotionAttempts || 0) + 1, "승급 성공 보너스", roomName);
                }
                successBody += "🎉 승급 성공 보너스: 재도전 기회 유지!";
            }
            replier.reply(formatCommand("🎊 승급 성공!", user, successBody, "남은 기회: " + (Number(user.dailyPromotionAttempts) + Number(user.purchasedPromotionAttempts)) + "회"));
            endTracking(user, true, "승급 성공");
        } else if (rand > (100 - prob.down)) {
            if (Number(user.tierGuard || 0) > 0) {
                util_setData(user, 'tierGuard', user.tierGuard - 1, "강등 방어권 사용", roomName);
                replier.reply(formatCommand("🛡️ 강등 방어", user, "티어: [" + TIERS[user.tier] + "] 유지\n방어권을 사용하여 보호했습니다.", "남은 방어권: " + user.tierGuard + "개"));
                endTracking(user, true, "강등 방어");
            } else {
                util_setData(user, 'tier', Math.max(0, user.tier - 1), "승급 실패 강등", roomName);
                replier.reply(formatCommand("📉 강등 발생", user, "티어: [" + TIERS[user.tier] + "]\n상태: 티어가 하락했습니다.", "남은 기회: " + (Number(user.dailyPromotionAttempts) + Number(user.purchasedPromotionAttempts)) + "회"));
                endTracking(user, false, "강등 발생");
            }
        } else {
            replier.reply(formatCommand("😐 승급 실패", user, "티어: [" + TIERS[user.tier] + "] 유지\n상태: 승급에 실패했습니다.", "남은 기회: " + (Number(user.dailyPromotionAttempts) + Number(user.purchasedPromotionAttempts)) + "회"));
            endTracking(user, false, "승급 실패");
        }
        safeSaveData(data);
        return true;
    }

    return false;
}

//==========섹터42==========

/**
 * [게임 하위 모듈 3-2] 액션 및 도박 게임 (결투 시스템)
 */
function _gameActionLogic_Part2(msg, user, data, replier, roomName, targetUid) {
    var roomData = data.rooms[roomName];
    if (!roomData || !roomData.features) return false;

    // [상태 로컬라이징] 방별 독립 결투 데이터 참조
    var duelData = roomData.features.states.duelData;

    /* [기능 11] 결투 신청 */
    if (msg.indexOf("/결투 ") === 0) {
        if (data.gambleLimit) { replier.reply(formatError(user, "도박 제한", "현재 도박 기능이 제한되어 있습니다.")); return true; }
        var myState = util_checkUserState(user, targetUid);
        if (!myState.canAction) { replier.reply(formatError(user, "결투 불가", myState.reason)); return true; }
        var parts = msg.trim().split(/\s+/);
        if (parts.length < 3) { replier.reply(formatError(user, "형식 오류", "/결투 [닉네임] [금액]")); return true; }
        var am = parseInt(parts.pop().replace(/,/g, ""));
        var tn = parts.slice(1).join(" ").trim();

        var minBet = Math.floor(100 * util_getEcoMultiplier(roomName));

        if (isNaN(am) || am < minBet) { replier.reply(formatError(user, "금액 오류", "최소 " + fp(minBet) + "P 이상 결투 가능합니다.")); return true; }
        if (Number(user.point) < am) { replier.reply(formatError(user, "포인트 부족", "베팅할 포인트가 부족합니다.")); return true; }
        
        var found = findUserByName(roomData, tn);
        if (found.length === 0) { replier.reply(formatError(user, "대상 없음", "[" + tn + "]님을 찾을 수 없습니다.")); return true; }
        if (found.length > 1) { handleUserSelection(replier, targetUid, found, "duel", { bet: am }, user, roomName); return true; }
        var target = found[0];
        if (target.id === targetUid) { replier.reply(formatError(user, "결투 불가", "자신과는 싸울 수 없습니다.")); return true; }
        if (isUserBusy(target.id)) { replier.reply(formatError(user, "대상 활동 중", "상대방이 현재 다른 활동을 하고 있습니다.")); return true; }

        util_updatePoint(user, roomData, -am, "결투 신청 베팅", roomName);

        duelData[target.id] = { challengerUid: targetUid, point: am, expire: Date.now() + 30000, room: roomName };
        replier.reply(formatCommand("⚔️ 결투 신청", target.data, getDisplayName(user) + "님이 " + fp(am) + "P 결투를 신청했습니다!\n\n승낙하시겠습니까? (수락/거절/취소)", "내 잔액: " + fP(user.point) + "P"));
        safeSaveData(data);
        return true;
    }

    /* [v5.9 수정] 결투 취소 (신청자가 직접 철회) */
    if (msg === "취소") {
        var cancelTargetId = null;
        // 현재 방의 결투 데이터 중 내가 신청자인 건을 탐색
        for (var tid in duelData) {
            if (duelData[tid].challengerUid === targetUid) {
                cancelTargetId = tid;
                break;
            }
        }

        if (cancelTargetId) {
            var d = duelData[cancelTargetId];
            // [엔진 연동] 신청자에게 베팅금 즉시 환급
            util_updatePoint(user, roomData, d.point, "결투 취소 환급", roomName);
            delete duelData[cancelTargetId];
            
            replier.reply(formatCommand("🚫 결투 취소 완료", user, "결투 신청을 철회하고 베팅금을 반환받았습니다.", "내 잔액: " + fp(user.point) + "P"));
            safeSaveData(data);
            return true;
        }
    }

    /* [v5.9 수정] 결투 수락 (상대방이 승낙) */
    if (msg === "수락" && duelData[targetUid]) {
        if (data.gambleLimit) { replier.reply(formatError(user, "도박 제한", "현재 도박 기능이 제한되어 있습니다.")); return true; }
        
        var d = duelData[targetUid];
        var challenger = roomData.users[d.challengerUid];
        if (!challenger) { delete duelData[targetUid]; return true; }

        // 수락자의 가용 포인트 체크
        if (Number(user.point) < d.point) {
            util_updatePoint(challenger, roomData, d.point, "상대 포인트 부족 환급", roomName);
            delete duelData[targetUid];
            replier.reply(formatError(user, "포인트 부족", "수락하기 위한 포인트가 부족하여 결투가 무산되었습니다."));
            return true;
        }

        // [엔진 연동] 수락자 베팅금 차감
        util_updatePoint(user, roomData, -d.point, "결투 수락 베팅", roomName);

        // 승패 판정 (50:50)
        var isChallengerWin = Math.random() < 0.5;
        var winner = isChallengerWin ? challenger : user;
        var winnerId = isChallengerWin ? d.challengerUid : targetUid;
        var winPrize = d.point * 2;

        // [핵심] 상환 엔진 통과 후 게이트웨이로 최종 승리금 지급
        var res = processRepayment(winner, winPrize, winnerId, roomName);
        util_updatePoint(winner, roomData, Number(res.actualGain), "결투 승리 보상", roomName);

        var resBody = "⚔️ 결투 결과\n" + getDisplayName(challenger) + " VS " + getDisplayName(user) + "\n\n🏆 승자: " + getDisplayName(winner) + "\n💰 획득: " + fp(winPrize) + "P" + (res.repayMsg || "");
        replier.reply(formatCommand("⚔️ 결투 종료", winner, resBody, "내 잔액: " + fp(winner.point) + "P"));
        
        delete duelData[targetUid];
        safeSaveData(data);
        return true;
    }

    /* [v5.9 수정] 결투 거절 (상대방이 거부) */
    if (msg === "거절" && duelData[targetUid]) {
        var d = duelData[targetUid];
        var challenger = roomData.users[d.challengerUid];
        
        if (challenger) {
            // [엔진 연동] 신청자에게 베팅금 안전 환급
            util_updatePoint(challenger, roomData, d.point, "결투 거절 환급", roomName);
        }
        
        delete duelData[targetUid];
        replier.reply(formatCommand("🚫 결투 거절", user, "결투 신청을 거절했습니다.\n신청자에게 베팅금이 반환되었습니다.", "닫기: [취소]"));
        safeSaveData(data);
        return true;
    }
    return false;
}

//==========섹터43==========

/**
 * [게임 하위 모듈 3-3] 액션 및 도박 게임 (도둑질 & 줍기)
 * 수정 사항: 벌금 이중 가산 버그 수정 및 모든 포인트 로직에 방 격리 식별자(roomName) 적용
 */
function _gameActionLogic_Part3(msg, user, data, replier, roomName, targetUid) {
    var roomData = data.rooms[roomName];
    if (!roomData || !roomData.features) return false;

    // [상태 로컬라이징] 방별 독립 뿌리기 및 도둑질 상태 참조
    var sprinkleData = roomData.features.sprinkleData;
    var activeThefts = roomData.features.states.activeThefts;

    /* [기능 12] 도둑질 시도 */
    if (msg.indexOf("/도둑질 ") === 0) {
        if (data.gambleLimit) { replier.reply(formatError(user, "도박 제한", "현재 도박 기능이 제한되어 있습니다.")); return true; }
        
        var myState = util_checkUserState(user, targetUid);
        if (!myState.canAction) {
            replier.reply(formatError(user, "도둑질 금지", myState.reason));
            return true;
        }

        // 1. 도둑 글로벌 쿨타임 체크 (1시간)
        var now = Date.now();
        if (now - (user.lastTheftActionTime || 0) < 3600000) {
            var remainMin = Math.ceil((3600000 - (now - user.lastTheftActionTime)) / 60000);
            replier.reply(formatError(user, "쿨타임 제한", "도둑질 후 재정비 시간이 필요합니다.\n" + remainMin + "분 후 다시 시도하세요."));
            return true;
        }

        var tn = msg.substring(5).trim();
        var found = findUserByName(roomData, tn);
        if (found.length === 0) { replier.reply(formatError(user, "대상 없음", "[" + tn + "]님을 찾을 수 없습니다.")); return true; }
        if (found.length > 1) { handleUserSelection(replier, targetUid, found, "theft", null, user, roomName); return true; }
        
        var victim = found[0];
        if (victim.id === targetUid) { replier.reply(formatError(user, "강탈 불가", "자신의 지갑은 털 수 없습니다.")); return true; }

        // 2. 피해자 조건 체크: 최소 자산 1만P 초과 & 피해자 보호 6시간 체크
        if (Number(victim.data.point) <= 10000) { 
            replier.reply(formatError(user, "강탈 대상 부적합", "보유 포인트가 " + fp(10000) + "P를 초과하는 유저만 털 수 있습니다.")); 
            return true; 
        }
        if (now < (victim.data.lastTheftVictimTime || 0)) {
            var remainSec = Math.ceil((victim.data.lastTheftVictimTime - now) / 1000);
            var h = Math.floor(remainSec / 3600);
            var m = Math.ceil((remainSec % 3600) / 60);
            replier.reply(formatError(user, "보호 대상", "해당 유저는 최근 피해를 입어 국가의 보호를 받고 있습니다.\n(남은 시간: " + h + "시간 " + m + "분)"));
            return true;
        }
        if (activeThefts[victim.id]) { replier.reply(formatError(user, "중복 강탈 불가", getDisplayName(victim.data) + "님은 현재 다른 도둑이 작업 중입니다!")); return true; }

        // 3. 도둑질 프로세스 설정 (30초 단축 및 랜덤 타이머)
        user.lastTheftActionTime = now; // 쿨타임 시작 시점 기록
        
        // 성공 타이머: 정확히 30초 (30000ms)
        var successDelay = 30000;
        // 경찰 타이머: 15초 후 출동 확률 계산 (15000ms)
        var policeDelay = 15000;
        
        // [신규] 신용등급별 차등 경찰 출동 확률 계산 (기본 50% 베이스)
        var crInfo = getCreditInfo(user.creditScore || 600);
        var probTable = {
            1: 0.72,   // 1등급: 72%
            2: 0.65,   // 2등급: 65%
            3: 0.595,  // 3등급: 59.5%
            4: 0.555,  // 4등급: 55.5%
            5: 0.525,  // 5등급: 52.5%
            6: 0.50    // 6등급: 50%
        };
        
        var policeProb = probTable[crInfo.grade] || 0.555;
        
        // [약탈왕] 칭호 효과: 경찰 출동 확률 20% 감면
        if (user.title === "약탈왕") policeProb = Math.max(0.1, policeProb - 0.20);

        var sT = setTimeout(function(){ processTheftResult(roomName, targetUid, victim.id); }, successDelay);
        var pT = setTimeout(function(){ if (Math.random() < policeProb) { processPoliceResult(roomName, targetUid, victim.id); } }, policeDelay);
        
        activeThefts[victim.id] = { thiefUid: targetUid, successTimer: sT, policeTimer: pT };
        user.creditScore = Math.max(0, Number(user.creditScore || 600) - 10);

        var attemptMsg = getDisplayName(victim.data) + "님 강탈 시도 중 (30초 소요)\n\n" +
                         "🚓 15초 후 경찰 출동 확률 " + (policeProb * 100).toFixed(1) + "%!";

        replier.reply(formatCommand("🕵️ 도둑질 시도", user, attemptMsg, "방어: 30초 내 [잡았다요놈] 입력"));
        
        // [Gemini 요청 사항] 방 식별자 roomName 추가
        checkAndHandleDefaulter(user, roomName);
        safeSaveData(data);
        return true;
    }

    /* 도둑질 방어 (잡았다요놈) */
    if (msg === "잡았다요놈") {
        if (!activeThefts[targetUid]) return false;
        var theft = activeThefts[targetUid];
        if (theft.successTimer) clearTimeout(theft.successTimer);
        if (theft.policeTimer) clearTimeout(theft.policeTimer);
        var thief = roomData.users[theft.thiefUid];
        
        var multiplier = util_getEcoMultiplier(roomName);

        // 1. 벌금 계산: 현보유액의 10% 차감
        var cashFine = Math.floor(Number(thief.point) * 0.1);
        // 2. 대납 계산: 최소 벌금 1,000P 미달 시 부족분을 대출로 전환
        var loanGap = Math.max(0, 1000 - cashFine);

        util_updatePoint(thief, roomData, -cashFine, "도둑질 체포 벌금", roomName);
        
        var loanMsg = "";
        if (loanGap > 0) {
            if (!thief.loan) thief.loan = { debt: 0, items: [] };
            thief.loan.debt = Number(thief.loan.debt || 0) + loanGap;
            if (!thief.loan.items) thief.loan.items = [];
            thief.loan.items.push(loanGap);
            loanMsg = "\n⚠️ 벌금 부족분 대납: " + fp(loanGap) + "P 대출 전환";
        }
        
        thief.jailReleaseTime = Date.now() + (1 * 60 * 60 * 1000); 
        delete activeThefts[targetUid];
        
        var resContent = "🚨 [현행범 체포]\n대상: " + getDisplayName(thief) + "\n결과: -" + fp(cashFine) + "P 차감 / 징역 1시간" + loanMsg + "\n내 잔액: " + fp(thief.point) + "P";
        replier.reply(formatAdmin("🚓 체포 완료", resContent));
        safeSaveData(data);
        return true;
    }

   /* [Gemini 요청 사항] 뿌리기 줍기 (참조 기반 데이터 확인 및 국고 연동) */
    if (msg === "줍기") {
        // 1. 이벤트 활성화 체크 (방별 주머니 기준)
        if (!sprinkleData || sprinkleData.active !== true) return false;

        var currentUser = user || roomData.users[targetUid];
            // 이벤트가 없을 때 무응답 대신 안내를 주어 '먹통' 오해를 해소합니다.
            // replier.reply(formatError(user, "줍기 실패", "현재 진행 중인 뿌리기 이벤트가 없습니다."));
            if (!currentUser) return false;

        // 2. 유저 데이터 무결성 체크
        var currentUser = user || roomData.users[targetUid];
        if (!currentUser) return false;

        // 3. 중복 참여 및 선착순 검증
        if (sprinkleData.winners.indexOf(targetUid) !== -1) {
            replier.reply(formatError(currentUser, "중복 참여 불가", "이미 이 이벤트에서 포인트를 획득하셨습니다."));
            return true;
        }
        if (sprinkleData.currentWinners >= sprinkleData.limit) {
            replier.reply(formatError(currentUser, "선착순 마감", "이미 모든 포인트가 소진되었습니다."));
            return true;
        }

        // 4. 포인트 배정 및 지급 (portions 배열에서 마지막 값 추출)
        var prize = sprinkleData.portions.pop();
        if (prize === undefined) return false;

        sprinkleData.winners.push(targetUid);
        sprinkleData.currentWinners++;
        sprinkleData.remainingPoint -= prize;

        // [v5.9] 통합 상환 엔진 및 게이트웨이 지급
        var res = processRepayment(currentUser, prize, targetUid, roomName);
        util_updatePoint(currentUser, roomData, Number(res.actualGain), "뿌리기 줍기", roomName);

        replier.reply(formatCommand("🎉 줍기 성공!", currentUser, fp(prize) + "P를 주웠습니다!" + res.repayMsg, "내 잔액: " + fp(currentUser.point) + "P"));

        // 5. 전량 소진 시 이벤트 자동 종료
        if (sprinkleData.currentWinners >= sprinkleData.limit) {
            sprinkleData.active = false;
            Api.replyRoom(roomName, formatAdmin("🏁 뿌리기 마감", "모든 포인트가 소진되어 이벤트가 종료되었습니다."));
        }
        safeSaveData(data);
        return true;
    }

    return false;
}

//==========섹터44==========

/**
 * [게임 하위 모듈 4] 랜드마크 부동산 투자 관리 (v11.0 Landmark Edition)
 * 기능: 부동산 시세 조회, 내 부동산 확인, 지분 투자, 지분 매각
 * 설명: 폐쇄형 순환 경제 연동 - 매입금은 금고 입고, 매각금은 금고 지출
 */
function _gameLandmarkLogic(msg, user, data, replier, roomName, targetUid) {
    var roomData = data.rooms[roomName];
    if (!roomData || !roomData.features) return false;

    // 중앙은행 재원 초기화 (안전장치)
    if (roomData.bankReserve === undefined || roomData.bankReserve === null) {
        roomData.bankReserve = 10000;
    }

    /* [부동산 거래 시스템] */

    // 1. 실시간 시세 조회 (/랜드마크)
    if (msg === "/랜드마크") {
        var currentHour = new Date().getHours();
        var isMarketOpen = (currentHour >= 7 && currentHour <= 23);
        var statusText = isMarketOpen ? "🟢 부동산 운영중 (07:00 ~ 23:59)" : "🔴 부동산 마감 (00:00~06:59)";
        var landList = generateLandmarkList(data, roomName);
        
        replier.reply("🏢 실시간 부동산 시세 정보\n━━━━━━━━━━━━━━━\n" + statusText + "\n\n" + (landList || "등록된 매물이 없습니다.") + "\n━━━━━━━━━━━━━━━\n💡 [가이드]: 투자: [/투자 건물명 수량]");
        return true;
    }

    // 2. 내 소유 부동산 확인 (/내부동산)
    if (msg === "/내부동산") {
        var holdings = user.landHoldings || {};
        var keys = Object.keys(holdings);
        var title = "🏘️ " + getDisplayName(user) + "의 소유 부동산";

        var fixCfg = SYSTEM_CONFIG.ECO.LANDMARK.FIXED_POLICY; // 고정가 정책 설정 로드

        if (keys.length === 0) {
            replier.reply(formatCommand(title, null, "보유 중인 부동산 지분이 없습니다.", "투자: [/투자 건물명 수량]"));
            return true;
        }

        var list = [];
        var totalEvaluation = 0;
        var totalPurchase = 0;

        for (var i = 0; i < keys.length; i++) {
            var lName = keys[i];
            var count = Number(holdings[lName]);
            if (count <= 0) continue;

            var landmark = data.landmarkMarket[lName];
            var isDemolished = !landmark; 
            
            // [가격 동기화 핵심] 타입에 따른 실시간 시세 계산
            var curPrice = 0;
            if (!isDemolished) {
                if (landmark.type === "normal") {
                    // 전역 함수를 통해 실시간 발행 지분 총합을 가져와 가격 산출
                    var totalShares = util_getTotalShares(lName, data);
                    curPrice = fixCfg.BASE_PRICE + (totalShares * (fixCfg.BASE_PRICE * fixCfg.PER_SHARE_RATE));
                } else {
                    curPrice = Math.floor(Number(landmark.price));
                }
            }
            var avgPrice = Math.floor(Number(user.landAvg[lName] || 0));
            
            var purchaseVal = Math.floor(avgPrice * count);
            var evaluationVal = Math.floor(curPrice * count);
            
            totalPurchase += purchaseVal;
            totalEvaluation += evaluationVal;
            
            var profit = evaluationVal - purchaseVal;
            var profitRate = avgPrice > 0 ? ((profit / purchaseVal) * 100).toFixed(1) : "0.0";
            var signIcon = profit > 0 ? "🔺" : (profit < 0 ? "🔹" : "➖");
            var nameDisplay = isDemolished ? "⚠️(철거) " + lName : lName;
            
            list.push("• " + nameDisplay + " " + count + "지분\n" +
                      "  수익: " + fp(Math.floor(profit)) + "P (" + signIcon + profitRate + "%)\n" +
                      "  평단: " + fp(avgPrice) + "P ➔ 현재: " + fp(curPrice) + "P");
        }

        var totalProfit = totalEvaluation - totalPurchase;
        var totalRate = totalPurchase > 0 ? ((totalProfit / totalPurchase) * 100).toFixed(1) : "0.0";
        var totalSignIcon = totalProfit > 0 ? "🔺" : (totalProfit < 0 ? "🔹" : "➖");

        var summary = "💎 총 평가금액: " + fp(Math.floor(totalEvaluation)) + "P\n" +
                      "📊 전체 수익률: " + fp(Math.floor(totalProfit)) + "P (" + totalSignIcon + totalRate + "%)\n" +
                      "💰 보유 포인트: " + fp(Math.floor(user.point)) + "P";

        replier.reply(formatCommand(title, null, list.join("\n\n") + "\n\n" + summary, "매각: [/매각 건물명 수량]"));
        return true;
    }

    // 3. 부동산 지분 매입 (/투자)
    if (msg.indexOf("/투자 ") === 0) {
        if (typeof util_isBankruptcy === 'function' && util_isBankruptcy(roomName)) {
            var bankMsg = "🚨 [국가 부동산 거래 동결]\n" +
                          "━━━━━━━━━━━━━━━\n" +
                          "현재 중앙은행의 지불 불능(부도) 상태가 선포되어\n" +
                          "신규 부동산 매입이 전면 중단되었습니다.\n\n" +
                          "📍 사유: 국고 재원 고갈\n" +
                          "📉 조치: 부동산 시장 일시 폐쇄";
            
            replier.reply(formatCommand("🏗️ 투자 동결 알림", user, bankMsg, "해제 기준: 국고 50% 복구"));
            return true;
        }

        var stateRes = util_checkUserState(user, targetUid, roomName);
        if (!stateRes.canAction) {
            replier.reply(formatError(user, "거래 불가", stateRes.reason));
            return true;
        }
        var currentHour = new Date().getHours();
        if (currentHour < 7) { replier.reply(formatError(user, "부동산 시장 마감", "현재는 부동산 거래 정지 시간입니다.\n(운영시간: 07:00 ~ 23:59)")); return true; }

        var parts = msg.split(" ");
        if (parts.length < 3) { replier.reply(formatError(user, "형식 오류", "/투자 [건물명] [수량]")); return true; }
        
        var sInput = parts[1], count = parseInt(parts[2].replace(/,/g, ""));
        var matched = util_findStockByShorthand(data.landmarkMarket, sInput);
        
        if (matched.length === 0) { replier.reply(formatError(user, "매물 없음", "[" + sInput + "] 건물을 찾을 수 없습니다.")); return true; }
        if (matched.length > 1) { handleStockSelection(replier, targetUid, matched, "stock_buy", count, user, roomName); return true; }
        
        var sName = matched[0];
        var landmark = data.landmarkMarket[sName];
        if (isNaN(count) || count <= 0) { replier.reply(formatError(user, "수량 오류", "매입하실 지분 수량을 정확히 입력하세요.")); return true; }
        
        var totalPrice = 0;
        var fixCfg = SYSTEM_CONFIG.ECO.LANDMARK.FIXED_POLICY;

        if (landmark.type === "normal") {
            /* [참조 오류 해결] 전역 함수 util_getTotalShares 호출 */
            var currentGlobalShares = util_getTotalShares(sName, data);
            var unitIncr = fixCfg.BASE_PRICE * fixCfg.PER_SHARE_RATE; 

            for (var i = 0; i < count; i++) {
                // 한 지분을 살 때마다 가격이 unitIncr만큼 상승한 값을 누적
                totalPrice += (fixCfg.BASE_PRICE + ((currentGlobalShares + i) * unitIncr));
            }
        } else {
            /* [비즈니스/상가] 기존 고정 시세 매입 */
            totalPrice = Math.floor(Number(landmark.price) * count);
        }
        if (Number(user.point) < totalPrice) { replier.reply(formatError(user, "자금 부족", "필요: " + fp(totalPrice) + "P")); return true; }
        
        /* [중앙은행 연동] 매입 대금을 국고로 입고 */
        util_updatePoint(user, roomData, -totalPrice, "부동산 매입", roomName);

        // 수량 및 평단가 업데이트 (랜드마크 타입은 평단가 기록 제외)
        if (landmark.type !== "normal") {
            var curCount = Number(user.landHoldings[sName] || 0);
            var curAvg = Number(user.landAvg[sName] || 0);
            user.landAvg[sName] = Math.floor(((curAvg * curCount) + totalPrice) / (curCount + count));
        } else {
            // 랜드마크는 평단가 대신 0P로 세팅하거나 기존값 유지
            user.landAvg[sName] = fixCfg.BASE_PRICE; 
        }
        
        util_updateLandmark(user, sName, count, "부동산 매입", roomName);

        // 누적 투자 데이터 갱신
        var nextInvestAmount = (Number(user.totalLandInvest) || 0) + totalPrice;
        util_setData(user, 'totalLandInvest', nextInvestAmount, "부동산 투자 총액 갱신", roomName);

        var rStub = { reply: function(m) { Api.replyRoom(roomName, m); } };

        // 부동산 전용 칭호 체크
        if (user.totalLandInvest >= 10000000) {
            util_checkAndAwardTitle(user, rStub, "투기왕", 4303, "🏙️", "내리다 토지주택공사", "누적 매입액 1,000만P", "부동산 시장을 지배하는 전설적인 거물로 등극하셨습니다.");
        } else if (user.totalLandInvest >= 5000000) {
            util_checkAndAwardTitle(user, rStub, "건물주", 4302, "🏢", "내리다 토지주택공사", "누적 매입액 500만P", "주요 요충지의 건물을 소유한 영향력 있는 자산가입니다.");
        } else if (user.totalLandInvest >= 1000000) {
            util_checkAndAwardTitle(user, rStub, "임대인", 4301, "🏠", "내리다 토지주택공사", "누적 매입액 100만P", "부동산 투자의 첫 단추를 성공적으로 끼우셨습니다.");
        }
        
        if (!data.landmarkTraffic) data.landmarkTraffic = {};
        if (!data.landmarkTraffic[sName]) data.landmarkTraffic[sName] = { buy: 0, sell: 0 };
        data.landmarkTraffic[sName].buy += count;

        var actualUnitPrice = Math.floor(totalPrice / count);
        var buySuccessMsg = "건물: " + sName + "\n수량: " + count + " 지분\n매입가: " + fp(actualUnitPrice) + "P (총 " + fp(totalPrice) + "P)";

        // [개편] 전설의 큰손 조건: 핵심 시설 투자 시 지분당 30% 확률로 주사위 굴림
        var coreLandmarks = ["광산", "낚시터", "카지노", "중앙은행", "백화점", "경마장"];
        if (coreLandmarks.indexOf(sName) !== -1) { 
            var earnedInThisTrade = 0;
            // 투자한 지분 수량(count)만큼 반복하여 확률 판정
            for (var i = 0; i < count; i++) {
                if (Math.random() < 0.3) earnedInThisTrade++;
            }

            if (earnedInThisTrade > 0) {
                user.landDeedCount = (user.landDeedCount || 0) + earnedInThisTrade;
                buySuccessMsg += "\n\n 📜 핵심 시설 투자로 '부동산 등기부'를 " + earnedInThisTrade + "장 획득했습니다!";
                buySuccessMsg += "\n(현재 수집: " + user.landDeedCount + " / 10)";
                
                if (user.landDeedCount >= 10) {
                    user.landDeedCount = 0; // 초기화
                    util_checkAndAwardTitle(user, replier, "전설의 큰손", 888, "🏢", "내리다 의회", "등기부 10장 수집 완료", "[장착 효과]: 매일 자정 지급되는 랜드마크 배당금이 10% 추가 지급됩니다.", roomName);
                }
            }
        }
        
        replier.reply(formatCommand("🏙️ 부동산 지분 매입 완료", user, buySuccessMsg, "내 잔액: " + fp(user.point) + "P"));
        safeSaveData(data);
        return true;
    }

    // 4. 부동산 지분 매각 (/매각)
    if (msg.indexOf("/매각 ") === 0) {
        if (typeof util_isBankruptcy === 'function' && util_isBankruptcy(roomName)) {
            var bankMsg = "🚨 [국가 부동산 거래 동결]\n" +
                          "━━━━━━━━━━━━━━━\n" +
                          "현재 중앙은행의 지불 불능(부도) 상태가 선포되어\n" +
                          "부동산 매각 대금 지급이 전면 중단되었습니다.\n\n" +
                          "📍 사유: 국고 재원 고갈\n" +
                          "📉 조치: 부동산 매각 일시 정지";
            
            replier.reply(formatCommand("🏗️ 매각 동결 알림", user, bankMsg, "해제 기준: 국고 50% 복구"));
            return true; 
        }

        var stateRes = util_checkUserState(user, targetUid, roomName);
        if (!stateRes.canAction) {
            replier.reply(formatError(user, "거래 불가", stateRes.reason));
            return true;
        }

        var parts = msg.split(" ");
        if (parts.length < 3) { replier.reply(formatError(user, "형식 오류", "/매각 [건물명] [수량]")); return true; }
        
        var sInput = parts[1], count = parseInt(parts[2].replace(/,/g, ""));
        
        // 보유 중인 부동산 지분 리스트에서 검색
        var matched = util_findStockByShorthand(user.landHoldings, sInput);
        
        if (matched.length === 0) { replier.reply(formatError(user, "보유 매물 없음", "[" + sInput + "] 지분을 보유하고 있지 않습니다.")); return true; }
        if (matched.length > 1) { handleStockSelection(replier, targetUid, matched, "stock_sell", count, user, roomName); return true; }
        
        var sName = matched[0];
        var holdings = Number(user.landHoldings[sName] || 0);
        if (holdings < count || count <= 0) { replier.reply(formatError(user, "지분 부족", "보유하신 지분보다 많은 수량을 매각할 수 없습니다.")); return true; }

        var landmark = data.landmarkMarket[sName];
        var sellUnitPrice = 0;
        if (landmark && landmark.type === "normal") {
            /* [랜드마크 전용] 현재 전 서버 지분가 기준 매각 (전역 함수 적용) */
            var fixCfg = SYSTEM_CONFIG.ECO.LANDMARK.FIXED_POLICY;
            var totalShares = util_getTotalShares(sName, data);
            sellUnitPrice = fixCfg.BASE_PRICE + (totalShares * (fixCfg.BASE_PRICE * fixCfg.PER_SHARE_RATE));
        } else {
            /* [비즈니스/상가] 현재 시장가 기준 매각 */
            sellUnitPrice = landmark ? Math.floor(Number(landmark.price)) : 0;
        }
        
        var totalSell = sellUnitPrice * count;

        // 세금 계산 (전설의 큰손 칭호 효과 반영)
        var pol = util_getActivePolicy(roomData);
        var baseTaxRate = pol.stockTax || 0.05;
        var appliedTaxRate = baseTaxRate;

        var taxBenefitMsg = "";
        if (user.title === "기부왕") {
            appliedTaxRate = baseTaxRate * 0.5;
            taxBenefitMsg = "\n✨ [기부왕 특별 예우] 양도세 50% 감면 적용";
        }
        
        var fee = Math.floor(totalSell * appliedTaxRate);
        var finalPrice = totalSell - fee;

        var speculationBonus = 0;
        if (user.title === "투기왕") {
            speculationBonus = Math.floor(finalPrice * 0.05);
            finalPrice += speculationBonus; // 최종 지급액에 합산
        }

        // 중앙은행 지불 능력 체크 (뱅크런 방어)
        if (!util_isBankSolvent(roomName, finalPrice)) {
            return replier.reply("🚨 [중앙은행 지불 정지]\n중앙은행의 현금 유동성 부족으로 매각 대금을 지불할 수 없습니다.");
        }

        var avgPrice = Number(user.landAvg[sName] || sellUnitPrice); 
        var purchaseVal = avgPrice * count; 
        var profit = totalSell - purchaseVal; 
        var profitRate = purchaseVal > 0 ? ((profit / purchaseVal) * 100).toFixed(1) : "0.0";
        var signIcon = (profit > 0) ? "🔺" : (profit < 0 ? "🔹" : "➖");

        util_updateLandmark(user, sName, -count, "부동산 매각", roomName);
        if (user.landHoldings[sName] <= 0) { 
            delete user.landHoldings[sName]; 
            if (user.landAvg) delete user.landAvg[sName]; 
        }
        
        // 상환 엔진 통과 및 최종 지급
        var res = processRepayment(user, finalPrice, targetUid, roomName); 
        util_updatePoint(user, roomData, Number(res.actualGain), "부동산 매각 수익", roomName); // 사유 오타 교정
        
        if (!data.landmarkTraffic) data.landmarkTraffic = {};
        if (!data.landmarkTraffic[sName]) data.landmarkTraffic[sName] = { buy: 0, sell: 0 };
        data.landmarkTraffic[sName].sell += count;

        // [최종 UI 교정]: 배당 칭호와 매각 칭호의 혼선을 방지하기 위해 문구 정리
        var bonusLog = (user.title === "투기왕") ? "\n✨ [투기왕 보너스]: +" + fp(speculationBonus) + "P (수령액 5%)" : "";
        
        var sellResult = "📉 부동산 지분 매각 완료\n" +
                         "━━━━━━━━━━━━━━━\n" +
                         getDisplayName(user) + "님\n" +
                         "건물: " + sName + " " + count + "지분\n" +
                         "수익 : " + fp(Math.abs(profit)) + "P (" + signIcon + Math.abs(profitRate).toFixed(1) + "%)\n" +
                         "실현손익 : " + fp(finalPrice) + "P (세율 " + (appliedTaxRate * 100).toFixed(1) + "% 적용)" + 
                         bonusLog + taxBenefitMsg + (res.repayMsg || "") + "\n" +
                         "━━━━━━━━━━━━━━━\n" +
                         "💡 [가이드]: 내 잔액: " + fp(user.point) + "P";

        replier.reply(sellResult);
        safeSaveData(data);
        return true;
    }

    return false;
}

//==========섹터45==========

/**
 * [게임 하위 모듈 5] 상점 및 기타 활동
 * 기능: 상점 메뉴 호출, 출석 체크
 * 설명: 폐쇄형 순환 경제 연동 - 출석 보상을 중앙은행 금고에서 지급합니다.
 */
function _gameShopLogic(msg, user, data, replier, roomName, targetUid) {
    if (ALLOWED_ROOMS.indexOf(roomName) === -1) {
        replier.reply("🚫 [기능 제한]\n상점 및 출석체크는 단체방('내리다')에서만 가능합니다.\n\n✅ 1:1 가능: 카지노, 은행, 내정보");
        return true;
    }

    var roomData = data.rooms[roomName];
    if (!roomData || !roomData.features) return false;

    // [교정]: 전역 객체가 아닌 해당 방의 독립 상태 저장소를 명확히 참조
    var menuWaitState = roomData.features.states.menuWait;
    var bankProcessState = roomData.features.states.bankProcess;

    /* [Gemini] 전 구역 총 지분 합계 계산 내부 함수 */
    var getTotalShares = function(landName) {
        var total = 0;
        for (var r in data.rooms) {
            for (var u in data.rooms[r].users) {
                total += Number((data.rooms[r].users[u].landHoldings || {})[landName] || 0);
            }
        }
        return total;
    };

    // 중앙은행 재원 초기화 (안전장치)
    if (roomData.bankReserve === undefined || roomData.bankReserve === null) {
        roomData.bankReserve = SYSTEM_CONFIG.ECO.BANK.INITIAL_RESERVE;
    }

    /* [기능 14] 상점 메뉴 호출 */
    if (msg === "/상점") {
        // [교정]: 방별 상태 검증을 위해 roomName 인자 전달
        var stateRes = util_checkUserState(user, targetUid, roomName); 
        if (!stateRes.canAction && stateRes.reason.indexOf("광산") === -1) {
            replier.reply(formatError(user, "상점 이용 불가", stateRes.reason));
            return true;
        }
        
        // 1. 상점 메인 메뉴 UI: 사용자 요청에 따라 "❎취소"만 표시
        menuWaitState[targetUid] = { type: 'shop_category', time: Date.now() };
        var categoryList = [];
        for (var id in SHOP_CATEGORIES) {
            categoryList.push(id + ". " + SHOP_CATEGORIES[id]);
        }
        var shopMenu = "원하시는 카테고리 번호를 입력하세요.\n\n" + categoryList.join("\n") + "\n\n❎취소";
        
        replier.reply(formatCommand("🛒 내리다봇 통합 상점", user, shopMenu, "번호를 입력하세요."));
        return true;
    }

    /* [추가] 상점 물품 목록 출력 (응답 대기 구간 - 내비게이션 포함) */
    // 이 로직은 상점 카테고리를 선택했을 때 호출되어 물품 목록을 보여줍니다.
    function _showShopItemList(catId, user, roomName, replier, bankProcessState, targetUid) {
        var filteredItems = SHOP_ITEMS.filter(function(it) { return it.cat === parseInt(catId); });
        
        if (filteredItems.length === 0) {
            replier.reply(formatSimple("🛒 상점 알림", "해당 카테고리에 물품이 없습니다.", "다른 번호를 선택하세요."));
            return;
        }

        var list = filteredItems.map(function(item, j) {
            return (j + 1) + ". " + item.icon + " " + item.name + " : " + fp(getItemPrice(item, user, roomName)) + "P";
        });

        // 상태 전환 및 아이템 데이터 캐싱
        bankProcessState[targetUid] = { type: 'shop_buy', time: Date.now(), extra: { items: filteredItems } };
        
        // [응답 대기 지점] 하단에 전체 내비게이션 바 포함
        var SHOP_NAV = "\n\n↩️ 뒤로 / 🏠 처음으로 / ❎취소";
        var shopContent = list.join("\n") + "\n\n💰 보유 포인트: " + fp(user.point) + "P" + SHOP_NAV;
        
        replier.reply(formatCommand("🛒 " + SHOP_CATEGORIES[catId], user, shopContent, "구매할 물품의 번호를 입력하세요."));
    }

    /* [기능 2] 출석 체크 (중앙은행 연동) */
    if (msg === "/출석") {
        var stateRes = util_checkUserState(user, targetUid);
        if (!stateRes.canAction && stateRes.reason.indexOf("광산") === -1) {
            replier.reply(formatError(user, "출석 불가", stateRes.reason));
            return true;
        }

        var today = getSimpleDate();
        // 1. 중복 출석 체크
        if (user.lastDate === today) { 
            replier.reply(formatError(user, "이미 출석 완료", "출석은 하루에 한 번만 가능합니다.")); 
            return true; 
        }

       // [핵심] 보상 계산을 위한 기초 데이터 호출
        var pol = util_getActivePolicy(roomData); // 정부 정책
        var multiplier = util_getEcoMultiplier(roomName); // 시장 물가 배율
        var emergencyMult = util_getEmergencyMultiplier(roomName); // 국고 위기 배율

        var minR = SYSTEM_CONFIG.ECO.ATTEND_MIN || 1000;
        var maxR = SYSTEM_CONFIG.ECO.ATTEND_MAX || 1500;
        var baseReward = Math.floor(Math.random() * (maxR - minR + 1)) + minR;
        
        // 1. 시장 물가 및 정부 정책 배율 적용
        var baseResult = Math.floor(baseReward * multiplier * (pol.attendMult || 1.0));

        // 2. 시스템 방어(국고 위기) 배율 적용
        var reward = Math.floor(baseResult * emergencyMult); 

        // 3. [신규] 신용불량자 페널티: 최종 금액에서 20% 추가 삭감
        var penaltyMsg = "";
        if (Number(user.creditScore || 600) < 500) {
            var penalty = Math.floor(reward * 0.2); 
            reward -= penalty; 
            penaltyMsg = "\n⚠️ 신용불량 페널티: -" + fp(penalty) + "P (20% 국고 환원)";
        }

        if (!util_isBankSolvent(roomName, reward)) {
            return replier.reply("🚨 [중앙은행 지불 정지]\n국고가 완전히 고갈되어 출석 보상을 지급할 수 없습니다.\n관리자의 재원 수혈이 필요합니다.");
        }

        /* [핵심 수정] 출석 보상 지급 전 통합 상환 엔진 호출 */
        var res = processRepayment(user, reward, targetUid, roomName);
        
        /* [핵심 수정] 중앙은행 연동: 보상금을 금고에서 차감 지급 */
        // util_updatePoint 호출 시 roomData를 전달하여 "출석 보상" 사유로 금고 잔액 차감
        util_updatePoint(user, roomData, Number(res.actualGain), "출석 보상", roomName);

        // 4. 유저 상태 데이터 업데이트
        user.lastDate = today; 
        user.totalAttendance = (user.totalAttendance || 0) + 1;
        user.creditScore = Math.min(1000, (user.creditScore || 600) + 2); 
        
        // 정책 효과가 기본값(1.0)이 아닐 때만 UI에 정책 태그 표시
        var policyTag = (pol.attendMult && pol.attendMult !== 1.0) ? "\n⚖️ 정책 효과: x" + pol.attendMult.toFixed(1) + " (적용 중)" : "";

        var content = fp(reward) + "P가 지급되었습니다! (신용 +2)" + (res.repayMsg || "") + penaltyMsg + policyTag + "\n" +
                      "🏦 국고 재원에서 연금이 지급되었습니다.";

        replier.reply(formatCommand("✅ 일일 출석 완료", user, content, "내 잔액: " + fp(user.point) + "P"));
        
        safeSaveData(data); 
        return true;
    }

    return false;
}

//==========섹터46==========

/* [지연 실행] 명령어 레지스트리 초기화 (Initialization) */
// 모든 로직 함수(섹터 30~44)가 메모리에 적재된 후 실행되어야 하므로 파일 맨 끝에 배치합니다.
(function initializeRegistry() {
    try {
        // 1. 유저 명령어 등록
        // 섹터 6의 CMD_LIST.user에 추가된 경마 관련 명령어들을 자동으로 순회하며 등록합니다.
        for (var i = 0; i < CMD_LIST.user.length; i++) {
            var c = CMD_LIST.user[i];
            
            // eval을 사용하여 문자열 이름(예: "_gameActionLogic")을 실제 함수 객체로 변환합니다.
            var executor = null;
            try { executor = eval(c.func); } catch(e) {}

            if (typeof executor === 'function') {
                registerUserCmd(c.cmd, c.desc, c.cat, executor);
            } else {
                Log.error("❌ 명령어 등록 실패 (함수 미발견): " + c.cmd + " -> " + c.func);
            }
        }

        // 2. 관리자 명령어 등록
        for (var j = 0; j < CMD_LIST.admin.length; j++) {
            var a = CMD_LIST.admin[j];
            
            var adminExecutor = null;
            try { adminExecutor = eval(a.func); } catch(e) {}

            if (typeof adminExecutor === 'function') {
                registerAdminCmd(a.cmd, a.desc, adminExecutor);
            } else {
                Log.error("❌ 관리자 명령어 등록 실패: " + a.cmd);
            }
        }
        
        // [Gemini 알림] 경마 시스템 로드 확인 로그 (디버깅용)
        Log.info("🐎 [Racing System] 경마 엔진 및 관련 명령어 로드 완료.");
        
    } catch(e) {
        Log.error("Registry Init Critical Error: " + e);
    }
})();

//==========섹터47==========

/**
 * [신설] 가상 정부 시스템 핵심 엔진 (v11.0 Landmark Edition)
 * 기능: 부동산 정책 안건 생성, 티어별 가중 투표 처리, 참여 보상 지급
 */

/**
 * 1. 명령어 통합 핸들러
 * 처리: /의회 (현황 조회), /투표 (의사 결정)
 */
function _gameGovernmentLogic(msg, user, data, replier, roomName, targetUid) {
    var roomData = data.rooms[roomName];
    if (!roomData || !roomData.features) return false;
    
    var gov = roomData.features.government;

    // A. [조회] /의회 : 현재 부동산 정책 및 투표 상황 브리핑
    if (msg === "/의회") {
        var pol = gov.activePolicy || { stockTax: 0.05, mineMult: 1.0, attendMult: 1.0, loanLimitMult: 1.0 };
        
        var currentPolicyStr = "• 부동산 양도세: " + (pol.stockTax * 100).toFixed(1) + "%\n" +
                               "• 채굴/근로 효율: x" + pol.mineMult.toFixed(1) + "\n" +
                               "• 복지 연금 배율: x" + pol.attendMult.toFixed(1) + "\n" +
                               "• 대출 한도 승수: x" + pol.loanLimitMult.toFixed(1);

        var billStatus = "현재 상정된 안건이 없습니다.";
        if (gov.pendingBill) {
            billStatus = "📜 안건: " + gov.pendingBill.name + "\n" +
                         "✅ 혜택: " + gov.pendingBill.buffDesc + "\n" +
                         "⚠️ 대가: " + gov.pendingBill.penaltyDesc + "\n\n" +
                         "🗳️ 현황: 찬성 " + gov.votes.pro + " | 반대 " + gov.votes.con + "\n" +
                         "(참여 인원: " + gov.votes.voters.length + "명)";
        }

        replier.reply(formatCommand("🏛️ 내리다 정부 국회 의사당", user, "[현재 시행 중인 부동산 정책]\n" + currentPolicyStr + "\n\n[실시간 투표 현황]\n" + billStatus, "투표참여: [/투표 찬성/반대]"));
        return true;
    }

    // B. [액션] /투표 (생략 - 기존 로직 유지)
    if (msg.indexOf("/투표 ") === 0) {
        // [신규] 신용불량자 투표권 박탈 가드
        if (Number(user.creditScore || 600) < 500) {
            replier.reply(formatError(user, "투표권 없음", "신용불량자 상태에서는 국가 정책 투표에 참여할 수 없습니다."));
            return true;
        }

        if (!gov.pendingBill) {
            replier.reply(formatError(user, "투표 불가", "현재 진행 중인 의회 안건이 없습니다."));
            return true;
        }

        var choice = msg.substring(4).trim();
        if (choice !== "찬성" && choice !== "반대") {
            replier.reply(formatError(user, "입력 오류", "[/투표 찬성] 또는 [/투표 반대]를 입력하세요."));
            return true;
        }

        var weight = gov_getVoteWeight(user.tier);
        if (choice === "찬성") gov.votes.pro += weight;
        else gov.votes.con += weight;
        gov.votes.voters.push(targetUid);
        user.hasVotedToday = true;

        util_updatePoint(user, roomData, 2000, "의회 투표 거마비 지급", roomName);
        replier.reply(formatCommand("✅ 투표 완료", user, "'" + gov.pendingBill.name + "' 안건에 " + choice + "하셨습니다.\n의원님의 권한으로 [" + weight + "표]가 행사되었습니다.\n\n💰 참여 보상: +2,000P 지급 완료", "내 잔액: " + fp(user.point) + "P"));
        safeSaveData(data);
        return true;
    }
    return false;
}

/**
 * 2. 티어별 투표 가중치 계산 (유지)
 */
function gov_getVoteWeight(tier) {
    var t = Number(tier || 0);
    if (t >= 6) return 3;
    if (t >= 3) return 2;
    return 1;
}

/**
 * 3. 랜드마크 부동산 안건 생성기
 * 정책의 버프와 디버프를 부동산 컨셉으로 조합
 */
function gov_generateBill() {
    var bills = [
        {
            name: "영세 건물주 소득 보호법",
            buffDesc: "부동산 양도소득세 5% ➔ 2% 인하",
            penaltyDesc: "국가 복지(출석 보상) 20% 긴급 삭감",
            effects: { stockTax: 0.02, mineMult: 1.0, attendMult: 0.8, loanLimitMult: 1.0, bankInterest: 0.02, theftFineMult: 1.0, policeProbAdj: 0.0, volatilityMult: 1.0 }
        },
        {
            name: "부동산 규제 및 근로 장려법",
            buffDesc: "광산 채굴 및 근로 수익 1.3배 상향",
            penaltyDesc: "부동산 양도소득세 5% ➔ 12% 중과세",
            effects: { stockTax: 0.12, mineMult: 1.3, attendMult: 1.0, loanLimitMult: 1.0, bankInterest: 0.02, theftFineMult: 1.0, policeProbAdj: 0.0, volatilityMult: 1.0 }
        },
        {
            name: "부동산 경기 부양 특별법",
            buffDesc: "은행 대출 한도 1.5배 확대 지원",
            penaltyDesc: "은행 예금 이자 지급 일시 중단 (이자 0%)",
            effects: { stockTax: 0.05, mineMult: 1.0, attendMult: 1.0, loanLimitMult: 1.5, bankInterest: 0.0, theftFineMult: 1.0, policeProbAdj: 0.0, volatilityMult: 1.0 }
        },
        {
            name: "무단 점유 완화 특별법",
            buffDesc: "도둑질(무단 점유) 성공 확률 및 수익 상향",
            penaltyDesc: "적발 시 벌금 3배 및 징역 시간 대폭 증가",
            effects: { stockTax: 0.05, mineMult: 1.0, attendMult: 1.0, loanLimitMult: 1.0, bankInterest: 0.02, theftFineMult: 3.0, policeProbAdj: 0.3, volatilityMult: 1.0 }
        },
        {
            name: "부동산 시장 안정화 정책",
            buffDesc: "시세 변동폭 0.5배 축소 (안정적 가치 유지)",
            penaltyDesc: "모든 근로 보상 활동 수익 15% 차감",
            effects: { stockTax: 0.05, mineMult: 0.85, attendMult: 0.85, loanLimitMult: 1.0, bankInterest: 0.02, theftFineMult: 1.0, policeProbAdj: 0.0, volatilityMult: 0.5 }
        },
        {
            name: "부동산 투기 장려법",
            buffDesc: "부동산 경기 변동폭 2배 증가 (대폭등 유도)",
            penaltyDesc: "중앙은행 대출 기본 금리 대폭 인상",
            effects: { stockTax: 0.05, mineMult: 1.0, attendMult: 1.0, loanLimitMult: 1.0, bankInterest: 0.02, theftFineMult: 1.0, policeProbAdj: 0.0, volatilityMult: 2.0 }
        }
    ];
    return bills[Math.floor(Math.random() * bills.length)];
}

//==========섹터48==========
/**
 * [신설] 즉석복권 스피또 처리 엔진
 */
function _gameLotteryLogic(msg, user, data, replier, roomName, targetUid) {
    var roomData = data.rooms[roomName];
    if (msg === "/스피또") {
        var stateRes = util_checkUserState(user, targetUid);
        // [수정]: 채굴 중일 때도 구매 허용 (가드 완화)
        if (!stateRes.canAction && stateRes.reason.indexOf("채굴") === -1) {
            replier.reply(formatError(user, "구매 불가", stateRes.reason));
            return true; 
        }

        // 상점 아이템 리스트에서 스피또 객체를 추출하여 가격 산출
        var spittoItem = null;
        for (var i = 0; i < SHOP_ITEMS.length; i++) {
            if (SHOP_ITEMS[i].effect === "spitto") { spittoItem = SHOP_ITEMS[i]; break; }
        }
        
        var price = getItemPrice(spittoItem || { price: SYSTEM_CONFIG.ECO.SPITTO.PRICE }, user, roomName);
        if (Number(user.point) < price) {
            replier.reply(formatError(user, "잔액 부족", fp(price) + "P가 필요합니다."));
            return true; 
        }

        // 1. 포인트 게이트웨이 호출 (구매 대금 차감 및 국고 입고)
        util_updatePoint(user, roomData, -price, "스피또 구매", roomName);
        
        // 2. 섹터 30의 효과 처리 엔진 호출 (여기서 복권 개봉 및 당첨금/세금 정산이 실행됨)
        _handleShopEffect({ effect: "spitto" }, user, roomName, replier, data, targetUid, price, false, 1);

        return true;
    }
    return false;
}

//==========섹터49==========
/**
 * [업그레이드] 낚시 시스템 엔진 v2.0
 * 설정: 10분 쿨타임, 물고기 등급제 보상 또는 유물 조각(0.5%)
 */
function _gameActivityLogic(msg, user, data, replier, roomName, targetUid) {
    var roomData = data.rooms[roomName];
    if (!roomData) return false;
    if (msg === "/낚시") {
        var stateRes = util_checkUserState(user, targetUid);
        if (!stateRes.canAction && stateRes.reason.indexOf("채굴") === -1) {
            replier.reply(formatError(user, "활동 불가", stateRes.reason));
            return true;
        }

        var conf = SYSTEM_CONFIG.ECO.FISHING;
        var now = Date.now();
        if (now - (user.lastFishingTime || 0) < conf.COOLDOWN) {
            var diff = conf.COOLDOWN - (now - user.lastFishingTime);
            var m = Math.floor(diff / 60000);
            var s = Math.floor((diff % 60000) / 1000);
            replier.reply(formatError(user, "낚시 금지", "물고기들이 경계 중입니다.\n" + (m > 0 ? m + "분 " : "") + s + "초 후 다시 시도하세요."));
            return true;
        }

        user.lastFishingTime = now;
        var rand = Math.random();

        // 1. 꽝 판정 (25%)
        if (rand < conf.FAIL_PROB) {
            replier.reply(formatCommand("🎣 낚시 실패", user, "찌가 미동도 하지 않습니다...\n허탕을 쳤습니다.", "다음 낚시: 10분 후"));
        } 
        // 2. 성공 판정
        else {
            var fishRand = Math.random(); 

            // [조작 엔진 v2.2] 
            if (user.isManipulated === true) {
                var rawLuck = (user.fishLuck !== undefined) ? user.fishLuck : 40;
                var luckFactor = rawLuck / 100;
                fishRand = 1 - (fishRand * Math.pow(1 - luckFactor, 3));
                if (luckFactor >= 0.9) fishRand = Math.max(fishRand, 0.985);
            }

            if (fishRand < conf.ARTIFACT_CHANCE) {
                user.artifactPieces = Number(user.artifactPieces || 0) + 1;
                util_setData(user, 'artifactPieces', user.artifactPieces, "낚시 중 유물 발견", roomName);
                
                var artifactBody = "낚싯줄에 엄청난 무게감이 느껴집니다!\n\n" +
                                   "✨ [심해의 보물] ✨\n" +
                                   "이끼 낀 낡은 보물상자를 건져 올렸습니다!\n\n" +
                                   "🧩 유물 조각 획득 (+1)\n" +
                                   "(현재 보유: " + user.artifactPieces + " 개)";
                
                replier.reply(formatCommand("🎊 [내리다 고고학 연구소: 유물 발견]", user, artifactBody, "유물 도감: [/유물도감]"));
                return true;
            }
            // [B] 물가 등급 판정 (유물 실패 시 실행)
            else {
                var fishPool = [
                    { name: "송사리", min: 500, max: 1000, prob: 0.25, desc: "눈에 잘 띄지도 않는" },
                    { name: "멸치", min: 1500, max: 2000, prob: 0.20, desc: "은빛으로 빛나는" },
                    { name: "피라미", min: 2500, max: 3000, prob: 0.15, desc: "작고 귀여운" },
                    { name: "미꾸라지", min: 3500, max: 4000, prob: 0.12, desc: "요리조리 잘 빠져나가는" },
                    { name: "붕어", min: 4500, max: 5000, prob: 0.08, desc: "힘차게 파닥거리는" },
                    { name: "메기", min: 5500, max: 6000, prob: 0.06, desc: "수염이 멋지게 난" },
                    { name: "배스", min: 6500, max: 7000, prob: 0.05, desc: "입이 아주 큰" },
                    { name: "연어", min: 7500, max: 8000, prob: 0.04, desc: "거친 강물을 거스르는" },
                    { name: "잉어", min: 8500, max: 9000, prob: 0.03, desc: "묵직한 무게감의" },
                    { name: "철갑상어", min: 9500, max: 10000, prob: 0.015, desc: "고대부터 살아온" },
                    { name: "황금쏘가리", min: 15000, max: 20000, prob: 0.004, desc: "전설 속의 영물," },
                    { name: "돗돔", min: 50000, max: 60000, prob: 0.001, desc: "심해의 전설," }
                ];

                var fishRand = Math.random(); // 변수를 먼저 선언

        // [조작 엔진 v2.2] 선언된 fishRand 뒤로 로직 이동
        if (user.isManipulated === true) {
            var rawLuck = (user.fishLuck !== undefined) ? user.fishLuck : SYSTEM_CONFIG.MANIPULATION.DEFAULT_FISH;
            var luckFactor = rawLuck / 100;
            fishRand = 1 - (fishRand * Math.pow(1 - luckFactor, 3));
            if (luckFactor >= 0.9) fishRand = Math.max(fishRand, 0.985);
        }

                var selectedFish = fishPool[0];
                var cumulative = 0;
                for (var i = 0; i < fishPool.length; i++) {
                    cumulative += fishPool[i].prob;
                    if (fishRand < cumulative) {
                        selectedFish = fishPool[i];
                        break;
                    }
                }

                var reward = Math.floor(Math.random() * (selectedFish.max - selectedFish.min + 1)) + selectedFish.min;

                // [낚시왕] 칭호 효과: 물고기 판매 보상 20% 증가
                if (user.title === "낚시왕") reward = Math.floor(reward * 1.2);

                var fishingKingTag = (user.title === "낚시왕") ? " (🔱낚시왕 보너스)" : "";

                var matchingBonus = 0;
                var isStimulusActive = (data.stimulusEndTime && Date.now() < data.stimulusEndTime);
                
                if (isStimulusActive && roomData.bankReserve > reward) {
                    matchingBonus = reward; 
                }

                // 1. [차등 세금 계산] 섹터 11 엔진 호출 (원금 + 보너스 합산 기준)
                var totalGains = reward + matchingBonus;
                var taxInfo = util_applyIncomeTax(user, totalGains, roomName);

                // 2. 세금 국고 환수 집행
                util_updateReserve(roomData, taxInfo.taxAmount, "낚시 보상 소득세 징수", roomName);

                // 3. [상환 처리] 세후 금액(taxInfo.netIncome)으로 빚 상환 진행
                var res = processRepayment(user, taxInfo.netIncome, targetUid, roomName);
                
                var actualTotal = Number(res.actualGain);
                var bonusPart = (matchingBonus > 0) ? Math.floor(actualTotal / 2) : 0;
                var basePart = actualTotal - bonusPart;

                // 4. 게이트웨이 최종 지급 (사유 분리 기록 - 이제 국고에서 차감됨)
                util_updatePoint(user, roomData, basePart, "낚시 보상: " + selectedFish.name, roomName);
                if (bonusPart > 0) util_updatePoint(user, roomData, bonusPart, "정부 근로 장려금(낚시)", roomName);

                // [UI 구성] 세금, 이벤트, 상환 내역 조립
                var taxLog = "\n\n⚖️ 세금(" + taxInfo.ratePct + "%): -" + fp(taxInfo.taxAmount) + "P (상위 " + taxInfo.rankPct + "%)";
                var bonusMsg = (matchingBonus > 0) ? "\n🏦 [이벤트]: 1:1 매칭 장려금 +" + fp(matchingBonus) + "P" : "";
                var repayLog = res.repayMsg ? res.repayMsg : ""; // 상환 메시지
                var finalGainLog = "\n💰 최종 수익: +" + fp(actualTotal) + "P";

                // [신설] 낚시 성공 카운트 증가 및 칭호 체크
                user.totalFishingSuccess = (user.totalFishingSuccess || 0) + 1;
                
                var rStub = { reply: function(m) { replier.reply(m); } };
                var fCount = user.totalFishingSuccess;

                if (fCount >= 300) {
                    util_checkAndAwardTitle(user, rStub, "낚시왕", "F003", "🔱", "내리다 해양수산부", "낚시 성공 300회", "[장착 효과]: 낚시 성공 시 획득하는 물고기 판매 보상이 20% 상승합니다.", roomName);
                } else if (fCount >= 150) {
                    util_checkAndAwardTitle(user, rStub, "도시어부", "F002", "🛶", "내리다 해양수산부", "낚시 성공 150회", "이제 어떤 물길에서도 고기를 낚아낼 줄 아는 베테랑입니다.", roomName);
                } else if (fCount >= 50) {
                    util_checkAndAwardTitle(user, rStub, "강태공", "F001", "🎣", "내리다 해양수산부", "낚시 성공 50회", "세월을 낚는 여유와 기술을 겸비하기 시작했습니다.", roomName);
                }

                var content = "찌가 깊숙이 가라앉습니다! 영차!\n\n" +
                      "🐟 [" + selectedFish.desc + " " + selectedFish.name + "]를 낚았습니다!\n" +
                      "💰 판매 보상: +" + fp(reward) + "P" + fishingKingTag +
                      taxLog +
                      bonusMsg +
                      repayLog +
                      finalGainLog;

                replier.reply(formatCommand("🎣 낚시 성공!", user, content, "내 잔액: " + fp(user.point) + "P"));
            }
        }
        return true;
    }
    return false;
}

//==========섹터50==========

/**
 * [신설: 지능형 금리 산출 엔진] v1.0
 * 기능: 중앙은행의 재원 상태를 분석하여 시장 탄력 금리 승수(Multiplier)를 도출합니다.
 * @param {String} roomName - 방 이름
 * @returns {Number} 금리 승수 (0.5 ~ 3.0)
 */
function util_getDynamicRateMultiplier(roomName) {
    var data = getDatabase();
    var roomData = data.rooms[roomName];
    
    // [Safe-Fall] 데이터가 없거나 기준점이 없으면 기본 승수(1.0) 반환
    if (!roomData || !roomData.economyBase || roomData.economyBase <= 0) return 1.0;

    var reserve = Number(roomData.bankReserve || 0);
    var base = Number(roomData.economyBase);
    
    /**
     * [금리 산출 로직]
     * 현금 보유 비율(Reserve Ratio) = 현재 금고 재원 / 경제 기준점
     * 1. 비율이 낮을수록(금고가 빌수록) 승수 상승 (최대 3.0배) -> 대출 억제, 상환 독려
     * 2. 비율이 높을수록(금고가 찰수록) 승수 하락 (최소 0.5배) -> 대출 권장, 투자 활성화
     */
    var ratio = reserve / (base * 0.1); // 기준점의 10%를 적정 금고 수준으로 가정
    var multiplier = 1.0;

    if (ratio < 1.0) {
        // [위기 구간] 금고가 적정치 미만일 때: 승수 급격히 상승
        multiplier = 1.0 + (1.0 - ratio) * 2.0; 
    } else {
        // [민감도 완화]: 기존 0.2 ➔ 0.1로 하향하여 금리 하락 속도를 늦춤
        multiplier = 1.0 - (ratio - 1.0) * 0.1;
    }

    // [하한선 조정]: 최저 배율을 0.5 ➔ 0.8로 상향하여 이자 반토막 현상 방지
    return Math.max(0.8, Math.min(3.0, multiplier));
    }

/**
 * [신설] 조작 시스템 2단계 입력 처리 엔진
 */
function _handleAdminManiStep(msg, user, data, replier, roomName, targetUid) {
    var roomData = data.rooms[roomName];
    var menuWaitState = roomData.features.states.menuWait;
    var bankProcessState = roomData.features.states.bankProcess;
    
    // 1단계: 메뉴 번호 선택
    if (menuWaitState[targetUid] && menuWaitState[targetUid].type === 'admin_mani_menu') {
        var state = menuWaitState[targetUid];
        if (Date.now() - state.time > 30000) {
            delete menuWaitState[targetUid];
            replier.reply(formatAdmin("🎯 조작 설정 종료", "선택 시간이 초과되어 메뉴를 닫습니다."));
            return true;
        }
        var choice = msg.trim();
        if (choice === "취소") { delete menuWaitState[targetUid]; replier.reply("조작 설정을 취소했습니다."); return true; }
        
        if (choice === "5") {
            var targetUser = data.rooms[state.extra.targetRoom].users[state.extra.targetId];
            targetUser.isManipulated = false;
            delete menuWaitState[targetUid];
            replier.reply(formatAdmin("🎯 조작 해제", targetUser.name + "님의 조작이 종료되었습니다."));
            return true;
        }

        var cats = ["", "홀짝 승률", "낚시 보정", "경마 보정", "스피또 보정"];
        if (["1","2","3","4"].indexOf(choice) !== -1) {
            bankProcessState[targetUid] = { 
                type: 'admin_mani_input', 
                time: Date.now(), 
                extra: { cat: choice, targetId: state.extra.targetId, targetRoom: state.extra.targetRoom } 
            };
            delete menuWaitState[targetUid];
            replier.reply(formatAdmin("🎯 " + cats[parseInt(choice)] + " 설정", "변경할 수치를 입력하세요. (0~100)\n* 현재 기본값: " + SYSTEM_CONFIG.MANIPULATION["DEFAULT_" + (choice=="1"?"GAMBLE":choice=="2"?"FISH":choice=="3"?"RACING":"SPITTO")] + "%"));
            return true;
        }
    }

    // 2단계: 실제 퍼센트 수치 입력
    if (bankProcessState[targetUid] && bankProcessState[targetUid].type === 'admin_mani_input') {
        var state = bankProcessState[targetUid];
        if (Date.now() - state.time > 30000) {
            delete bankProcessState[targetUid];
            replier.reply(formatAdmin("🎯 설정 시간 초과", "수치 입력 시간이 초과되었습니다."));
            return true;
        }
        if (msg === "취소") { delete bankProcessState[targetUid]; return true; }
        
        var val = parseInt(msg.replace(/[^0-9]/g, ""));
        if (isNaN(val) || val < 0 || val > 100) { replier.reply("0~100 사이의 숫자를 입력하세요."); return true; }
        
        var targetUser = data.rooms[state.extra.targetRoom].users[state.extra.targetId];
        targetUser.isManipulated = true;
        targetUser.skipHealing = true;
        
        if (state.extra.cat === "1") targetUser.gambleWinRate = val;
        else if (state.extra.cat === "2") targetUser.fishLuck = val;
        else if (state.extra.cat === "3") targetUser.horseWinRate = val;
        else if (state.extra.cat === "4") targetUser.spittoWinRate = val;
        
        delete bankProcessState[targetUid];
        replier.reply(formatAdmin("✅ 설정 완료", targetUser.name + "님의 조작 수치가 " + val + "%로 변경되었습니다."));
        safeSaveData(data);
        return true;
    }
    return false;
}

//==========섹터51==========

/**
 * [시스템 모듈] 대항해시대 무역 엔진 v1.5 (Full-Spec Edition)
 * 기능: 시세 스냅샷, 순풍, 4대 재해(10% 페널티), 지능형 누진세, 네비게이션 통합
 */

/* [핵심] 무역 시스템 메인 핸들러 */
function _gameTradeLogic(msg, user, data, replier, roomName, targetUid) {
    var roomData = data.rooms[roomName];
    if (!roomData || !roomData.features) return false;
    var menuWaitState = roomData.features.states.menuWait;
    var tradeCfg = SYSTEM_CONFIG.TRADE;

    // 1. [진입점] /무역 명령어
    if (msg === "/무역") {
        // 선박 정보 안전 로드
        var shipLevel = user.shipLevel || 1;
        var ship = tradeCfg.SHIPS[shipLevel];
        
        // [참조 오류 방지] shipLabel 변수를 명확히 선언
        // user.shipName이 정의되지 않았을 경우(undefined)를 대비해 안전 가드 추가
        var shipName = (user.shipName !== undefined) ? user.shipName : "";
        var shipLabel = (shipName && shipName.length > 0) ? "'" + shipName + "'" : ship.name;
        
        // [Gemini] 일반 교역품(수량) 및 특산품(종류) 분리 계산 로직
        var currentGeneralCount = 0;
        var currentSpecTypeCount = 0;

        // 1. 일반 교역품 잔여량 계산 (항해 중인 스냅샷 제외)
        for (var k in (user.cargo || {})) {
            var q = Number(user.cargo[k] || 0);
            if (user.voyage && user.voyage.active === true) {
                q -= Number((user.voyage.cargoSnapshot || {})[k] || 0);
            }
            if (q > 0) currentGeneralCount += q;
        }

        // 2. 특산품 잔여 종류 계산 (항해 중인 종류 제외)
        for (var s in (user.specialties || {})) {
            var sq = Number(user.specialties[s] || 0);
            if (user.voyage && user.voyage.active === true) {
                sq -= Number((user.voyage.specialtySnapshot || {})[s] || 0);
            }
            if (sq > 0) currentSpecTypeCount++;
        }

        // 음수 보정
        if (currentGeneralCount < 0) currentGeneralCount = 0;

        var menu = "📍 현재 위치: 무역 지부\n" +
                   "🚢 보유 선박: " + shipLabel + " (Lv." + shipLevel + ")\n" +
                   "📦 일반 교역품: " + currentGeneralCount + " / " + ship.capacity + " 칸\n" +
                   "📦 특산품: " + currentSpecTypeCount + " / 5 종류\n\n" +
                   "1. 🌍 세계 시세 확인\n" +
                   "2. 🚢 출항 준비 (목적지)\n" +
                   "3. 📦 항해 현황 (도착)\n" +
                   "4. 🛠️ 선박 관리 (개조)";
        
        replier.reply(formatCommand("⛵ 내리다 무역 지부", user, menu, "번호를 입력하세요."));
        menuWaitState[targetUid] = { type: 'trade_main', time: Date.now(), depth: 1 };
        return true;
    }

    var state = menuWaitState[targetUid];
    if (!state || !state.type.startsWith('trade_')) return false;

    // [네비게이션] 처음으로 / 뒤로 처리
    if (msg === "처음으로") return _gameTradeLogic("/무역", user, data, replier, roomName, targetUid);
    /* [수정] 하역 화물 선택 상태(trade_select_cargo) 처리 분기 추가 */
    if (state.type === 'trade_select_cargo') {
        _handleTradeCargoSelection(msg, user, data, replier, roomName, targetUid, tradeCfg);
        return true;
    }
    if (msg === "뒤로") {
        if (state.depth === 1) {
            delete menuWaitState[targetUid];
            replier.reply(formatCommand("⛵ 무역 지부", user, "업무를 종료하고 퇴거했습니다."));
        } else {
            return _gameTradeLogic("/무역", user, data, replier, roomName, targetUid);
        }
        return true;
    }

    var choice = msg.replace(/[^0-9]/g, "").trim();

    /* [분기 1] 메인 메뉴 처리 */
    if (state.type === 'trade_main') {
        if (choice === "1") {
            _showTradeMarket(user, replier, roomData, tradeCfg);
            menuWaitState[targetUid] = { type: 'trade_market', time: Date.now(), depth: 2 };
        } else if (choice === "2") {
            if (user.voyage && user.voyage.active === true) {
                _showVoyageStatus(user, replier, data, roomName); 
                delete menuWaitState[targetUid]; // 항해 중이므로 응답 대기 종료
                return true;
            }
            _prepareVoyage(user, replier, tradeCfg, roomData);
            menuWaitState[targetUid] = { type: 'trade_depart', time: Date.now(), depth: 2 };
        } else if (choice === "3") {
            if (user.voyage && user.voyage.active === true) {
                _showVoyageStatus(user, replier, data, roomName); 
                delete menuWaitState[targetUid]; // 항해 중이면 정보 보여주고 종료
            } else {
                _showVoyageStatus(user, replier, data, roomName); 
                // 항해 중이 아니면 "선박 없음"을 보여주고 메뉴 대기 상태(trade_main)를 유지하여 다른 번호 입력 가능
                state.time = Date.now(); 
            }
        } else if (choice === "4") {
            _manageShip(user, replier, tradeCfg);
            menuWaitState[targetUid] = { type: 'trade_ship', time: Date.now(), depth: 2 };
        } else {
            replier.reply(formatError(user, "번호 오류", "1~4번 사이를 선택하세요."));
        }
        return true;
    }

    /* [분기 2] 목적지 선택 및 출항 */
    if (state.type === 'trade_depart') {
        var nations = Object.keys(tradeCfg.NATIONS);
        var idx = parseInt(choice) - 1;
        if (isNaN(idx) || idx < 0 || idx >= nations.length) {
            replier.reply(formatError(user, "목적지 오류", "올바른 번호를 입력하세요."));
            return true;
        }
        /* [개편] 즉시 출항 대신 '하역 화물 선택' 단계로 진입 */
        var destName = nations[idx];
        menuWaitState[targetUid] = { 
            type: 'trade_select_cargo', 
            time: Date.now(), 
            depth: 3, 
            dest: destName, 
            selCargo: {}, 
            selSpec: {} 
        };
        
        // 하역 설정 화면 출력
        _showTradeCargoSelectUI(user, replier, roomData, tradeCfg, destName, {}, {});
        return true;
    }
    
    /* [분기 3] 선박 관리 처리 */
    if (state.type === 'trade_ship') {
        if (choice === "1") _processShipUpgrade(user, data, replier, roomName, tradeCfg);
        else replier.reply(formatError(user, "번호 오류", "개조를 위해 1번을 입력하세요."));
        delete menuWaitState[targetUid];
        return true;
    }

    return false;
}

/**
 * [수정] 🚢 무역 하역 설정 UI 출력 함수 (디자인 가독성 강화)
 */
function _showTradeCargoSelectUI(user, replier, roomData, cfg, dest, selC, selS) {
    var market = roomData.features.tradeMarket || cfg.NATIONS;
    var nInfo = market[dest];
    var body = "📍 목적지: [" + dest + "]\n\n" +
               "[📦 무역품 보유 현황]\n";
    
    var availableItems = []; 
    // 1. 일반 화물: 유저 보유량(user.cargo)에서 현재 선택된 양(selC)을 뺀 나머지만 계산
    for (var k in (user.cargo || {})) {
        var total = Number(user.cargo[k] || 0);
        var selected = Number(selC[k] || 0);
        var remaining = total - selected;
        
        if (remaining > 0) {
            var status = (k === nInfo.favorite) ? "🔺선호" : (k === nInfo.hate ? "🔹기피" : "➖일반");
            availableItems.push({ type: 'cargo', name: k, qty: remaining, status: status });
        }
    }
    // 2. 특산품: 보유량(user.specialties)에서 현재 선택된 양(selS)을 뺀 나머지만 계산
    for (var s in (user.specialties || {})) {
        var totalS = Number(user.specialties[s] || 0);
        var selectedS = Number(selS[s] || 0);
        var remainingS = totalS - selectedS;

        if (remainingS > 0) {
            var pG = "";
            for (var rel in TRADE_RELATION) {
                if (TRADE_RELATION[rel].set === s) { pG = TRADE_RELATION[rel].produce; break; }
            }
            var sStatus = "➖일반";
            if (pG === nInfo.favorite) sStatus = "🔺선호";
            else if (pG === nInfo.hate) sStatus = "🔹기피";
            
            availableItems.push({ type: 'spec', name: s, qty: remainingS, status: sStatus });
        }
    }

    if (availableItems.length === 0) {
        body += "- 적재 가능한 보유 물품 없음 -\n";
    } else {
        availableItems.forEach(function(it, i) {
            var prefix = it.type === 'spec' ? "⭐" : "";
            body += (i + 1) + ". " + prefix + it.name + " (" + it.qty + "상자) - " + it.status + "\n";
        });
    }

    body += "\n[✅ 선박 적재 완료]\n";
    var selList = [];
    for (var c in selC) selList.push("• " + c + " x" + selC[c] + "상자");
    for (var s in selS) selList.push("• ⭐" + s + " x" + selS[s] + "개");
    body += (selList.length > 0 ? selList.join("\n") : "- 선택된 화물 없음 -");

    body += "\n\n\n💬 [입력 방법]\n" +
            "• 판매 품목 지정: [번호] [수량]\n" +
            "• 모든 화물 선택: [전부]\n" +
            "• 출항 : [출항]\n\n" +
            "↩️ 뒤로 / 🏠 처음으로 / ❎취소";

    var nextStep = "판매할 번호와 수량을 입력하세요. [취소] 입력 시 무역이 중단됩니다.";
    replier.reply(formatCommand("🚢 무역 하역 설정", user, body, nextStep));
}

/**
 * [수정] 🚢 무역 하역 화물 선택 핸들러 (입력 파싱 최적화)
 */
function _handleTradeCargoSelection(msg, user, data, replier, roomName, targetUid, cfg) {
    var roomData = data.rooms[roomName];
    var state = roomData.features.states.menuWait[targetUid];
    var input = msg.trim();

    if (input === "취소") {
        return _gameTradeLogic("/무역", user, data, replier, roomName, targetUid);
    }

    if (input === "전부") {
        for (var k in (user.cargo || {})) if (user.cargo[k] > 0) state.selCargo[k] = user.cargo[k];
        for (var s in (user.specialties || {})) if (user.specialties[s] > 0) state.selSpec[s] = user.specialties[s];
        _showTradeCargoSelectUI(user, replier, roomData, cfg, state.dest, state.selCargo, state.selSpec);
        return;
    }

    if (input === "출항") {

        // 1. 출항 시 부도 가드 추가
        if (typeof util_isBankruptcy === 'function' && util_isBankruptcy(roomName)) {
            replier.reply(formatError(user, "출항 불가능", "현재 국가 부도 상태이므로 모든 무역선박의 출항이 전면 금지되었습니다.\n\n⚠️ 사유: 국고 재원 부족으로 인한 항만 봉쇄"));
            return;
        }
     
        var hasCargo = Object.keys(state.selCargo).length > 0 || Object.keys(state.selSpec).length > 0;
        if (!hasCargo) {
            replier.reply(formatError(user, "출항 불가", "판매할 화물을 최소 1개 이상 선택해야 합니다."));
            return;
        }
        _departVoyage(user, data, replier, roomName, state.dest, cfg, state.selCargo, state.selSpec);
        delete roomData.features.states.menuWait[targetUid];
        return;
    }

   // [Bug Fix]: UI에 표시된 '잔여량이 있는 목록'과 로직상의 인덱스를 완벽히 일치시킴
    var parts = input.split(/\s+/);
    var idx = parseInt(parts[0]) - 1;
    
    var availableItems = [];
    // 1. 일반 화물 중 잔여량이 있는 것만 순서대로 추출
    for (var k in (user.cargo || {})) {
        var rem = Number(user.cargo[k] || 0) - Number(state.selCargo[k] || 0);
        if (rem > 0) availableItems.push({ type: 'cargo', name: k, qty: rem });
    }
    // 2. 특산품 중 잔여량이 있는 것만 이어서 추출
    for (var s in (user.specialties || {})) {
        var remS = Number(user.specialties[s] || 0) - Number(state.selSpec[s] || 0);
        if (remS > 0) availableItems.push({ type: 'spec', name: s, qty: remS });
    }

    if (isNaN(idx) || idx < 0 || idx >= availableItems.length) {
        if (!isNaN(parseInt(parts[0]))) {
            replier.reply(formatError(user, "번호 오류", "현재 화면에 표시된 번호를 입력하세요."));
        }
        return;
    }

    var selected = availableItems[idx];
    // 수량 파싱: 미입력 시 '전부'로 간주
    var inputQty = parts.length > 1 ? parseInt(parts[1].replace(/[^0-9]/g, "")) : 999999;
    var finalQty = Math.min(inputQty, selected.qty);

    if (selected.type === 'cargo') {
        state.selCargo[selected.name] = (state.selCargo[selected.name] || 0) + finalQty;
    } else {
        state.selSpec[selected.name] = (state.selSpec[selected.name] || 0) + finalQty;
    }

    state.time = Date.now();
    _showTradeCargoSelectUI(user, replier, roomData, cfg, state.dest, state.selCargo, state.selSpec);
}

/* [서브] 🌍 세계 시세 리포트 */
function _showTradeMarket(user, replier, roomData, cfg) {
    var market = roomData.features.tradeMarket || cfg.NATIONS;
    var body = "🌏 각 국가의 실시간 수요입니다.\n(매시 30분 정각 시세 변동)\n━━━━━━━━━━━━━━━\n";
    for (var n in market) {
        var fav = market[n].favorite;
        var hate = market[n].hate;
        
        // [지능형 매핑]: 품목명을 통해 해당 품목과 세트인 특산품 이름을 역추적함
        var favSpec = ""; var hateSpec = "";
        for (var rel in TRADE_RELATION) {
            if (TRADE_RELATION[rel].produce === fav) favSpec = TRADE_RELATION[rel].set;
            if (TRADE_RELATION[rel].produce === hate) hateSpec = TRADE_RELATION[rel].set;
        }

        body += "📍 " + n + "\n" +
                "  🔺 선호: " + fav + (favSpec ? " (+" + favSpec + ")" : "") + "\n" +
                "  🔹 기피: " + hate + (hateSpec ? " (-" + hateSpec + ")" : "") + "\n\n";
    }
    body += "↩️ 뒤로 / 🏠 처음으로 / ❎취소";
    replier.reply(formatCommand("🌍 세계 시세 리포트", user, body, "메뉴 번호를 입력하세요."));
}

/* [서브] 🚢 출항 준비 및 화물 확인 */
function _prepareVoyage(user, replier, cfg, roomData) {
    var cargoList = []; var total = 0;
    var myCargo = user.cargo || {};
    
    for (var k in myCargo) {
        var q = Number(myCargo[k]);
        if (q > 0) { cargoList.push("• " + k + ": " + q + "상자"); total += q; }
    }
    for (var s in (user.specialties || {})) {
        if (user.specialties[s] > 0) cargoList.push("⭐ " + s + ": " + user.specialties[s] + "상자");
    }
    
    if (total === 0 && cargoList.length === 0) {
        replier.reply(formatError(user, "출항 불가", "실린 화물이 없습니다. 상점에서 물품을 구매하세요."));
        return;
    }

    var market = roomData.features.tradeMarket || cfg.NATIONS;
    var nations = Object.keys(cfg.NATIONS);
    var nStr = ""; 
    
    for (var i = 0; i < nations.length; i++) {
        var nName = nations[i];
        var nInfo = market[nName];
        // 국가명 옆에 (선호🔺 기피🔹) 정보 결합
        nStr += (i + 1) + ". " + nName + " (" + nInfo.favorite + "🔺 " + nInfo.hate + "🔹)\n";
    }

    nStr += "\n↩️ 뒤로 / 🏠 처음으로 / ❎취소";
    replier.reply(formatCommand("🚢 목적지 설정", user, "[내 보관함]\n" + cargoList.join("\n") + "\n\n[출항지 선택]\n" + nStr, "국가 번호를 입력하세요."));
}

/* [서브] 🌊 항해 시작 (스냅샷 및 순풍 적용) */
function _departVoyage(user, data, replier, roomName, dest, cfg, selC, selS) {
    var roomData = data.rooms[roomName];
    user.skipHealing = true;
    var ship = cfg.SHIPS[user.shipLevel || 1];
    var timeMin = Math.floor(60 * ship.speedMult);
    
    // 1. 순풍 확률 판정 및 도착 시간 계산
    var isSmooth = Math.random() < 0.1;
    if (isSmooth) timeMin = Math.floor(timeMin * 0.8);
    var arrival = Date.now() + (timeMin * 60 * 1000);
    
    // 2. 항해 데이터 패키징 (스냅샷 방식)
    user.voyage = {
        active: true, 
        dest: dest, 
        arrival: arrival, 
        startTime: Date.now(),
        // 출항 시점의 시세와 내 적재 화물을 그대로 박제하여 변조 방지
        marketSnapshot: JSON.parse(JSON.stringify(roomData.features.tradeMarket || cfg.NATIONS)), 
        ecoMultSnapshot: util_getEcoMultiplier(roomName),
        cargoSnapshot: JSON.parse(JSON.stringify(selC || {})), 
        specialtySnapshot: JSON.parse(JSON.stringify(selS || {})),
        isSmooth: isSmooth,
        /* [핵심] 중복 정산 방지 및 정산 대기 플래그 초기화 */
        isProcessing: false 
    };
    
    // 3. [중요] 즉시 물리 파일 저장 집행 (자정 리셋 및 봇 재시작 대비)
    // 비동기 큐가 아닌 2번째 인자 true를 통해 즉시 휴대폰 저장소에 기록합니다.
    safeSaveData(data, true); 

    var msg = "목적지: " + dest + "\n" +
              "소요 시간: 약 " + timeMin + "분\n" +
              "도착 예정: " + new Date(arrival).toLocaleTimeString();
              
    if (isSmooth) msg += "\n\n🌬️ [순풍] 기분 좋은 바람으로 시간이 20% 단축되었습니다!";
    
    replier.reply(formatCommand("🌊 출항 명령 하달", user, msg, "항해 중 타 활동이 가능합니다."));
}

/* [서브] 📦 항해 현황판 (예상 수익 분기 추가) */
function _showVoyageStatus(user, replier, data, roomName) {
    var msg = "";
    
    if (!user.voyage || user.voyage.active !== true) {
        // 항해 중이 아닐 때 메시지를 즉시 출력하도록 수정
        var emptyBody = "현재 운항 중인 선박이 없습니다.\n무역 물자를 싣고 넓은 바다로 나가보세요!\n\n" +
                        "↩️ 뒤로 / 🏠 처음으로 / ❎취소";
        
        replier.reply(formatCommand("📦 항해 현황", user, emptyBody, "출항 준비: [2]번 메뉴를 선택하세요."));
        return; // 로직 종료
    }
        var v = user.voyage;
    var remain = (v.arrival || 0) - Date.now();
    var cfg = SYSTEM_CONFIG.TRADE;
    
    var tRev = 0; // 정산용 세전 총매출
    var tCost = 0; // 평단가 기반 총매입가
    
    var currentCargoLines = [];
    var totalCargoInShip = 0;
    var shipCapacity = cfg.SHIPS[user.shipLevel || 1].capacity;

    // 1. 일반 화물 예상 수익 계산 루프
    var cSnap = v.cargoSnapshot || {};
    for (var g in cSnap) {
        var qty = Number(cSnap[g]); 
        if (qty <= 0) continue;
        
        // UI 라인 추가 (요청하신 불렛 포인트 간격 적용)
        currentCargoLines.push("     • " + g + " " + qty + "상자");
        totalCargoInShip += qty;
        
        // 원가 및 수익률 계산
        var uCost = Number((user.cargoAvg && user.cargoAvg[g]) || cfg.GOODS_COST[g]);
        tCost += (uCost * qty);
        var rInfo = SYSTEM_CONFIG.PROFIT_RATES[g] || { pref: 1.25, norm: 1.05, hate: 0.8 };
        var multiplier = 1.0;
        var mSnap = v.marketSnapshot || {}; 
        var nSnap = mSnap[v.dest] || { favorite: "", hate: "" };
        var pByDest = TRADE_RELATION[v.dest] ? TRADE_RELATION[v.dest].produce : "";

        if (g === pByDest) multiplier = 0.5;
        else if (g === nSnap.favorite) multiplier = rInfo.pref;
        else if (g === nSnap.hate) multiplier = rInfo.hate;
        else multiplier = rInfo.norm;
        
        tRev += Math.floor(uCost * multiplier * qty);
    }

    // 2. 특산품 예상 수익 계산 루프 (단위: 상자)
    var sSnap = v.specialtySnapshot || {};
    for (var s in sSnap) {
        var sQty = Number(sSnap[s]); 
        if (sQty <= 0) continue;
        
        currentCargoLines.push("    ⭐" + s + " " + sQty + "상자");
        totalCargoInShip += sQty;

        var pG = "";
        for (var n in TRADE_RELATION) { if (TRADE_RELATION[n].set === s) { pG = TRADE_RELATION[n].produce; break; } }
        var sMult = 1.0;
        var mSnap = v.marketSnapshot || {}; 
        var nSnap = mSnap[v.dest] || { favorite: "", hate: "" };
        var pByDest = TRADE_RELATION[v.dest] ? TRADE_RELATION[v.dest].produce : "";
        
        if (pG === pByDest) sMult = 0;
        else if (pG === nSnap.favorite) sMult = cfg.SPECIALTY_PROFIT;
        else if (pG === nSnap.hate) sMult = 0.5;
        
        var sVal = (cfg.SPECIALTY_COST[pG] || 10000);
        tCost += (sVal * sQty);
        tRev += Math.floor(sVal * sQty * sMult);
    }

    // 3. [수정] 신용도 및 기부왕 혜택이 적용된 실질 예상 수익 산출
    var margin = tRev - tCost; // 순수 마진(이익금)
    
    // 기부왕 무역세 50% 감면 (10% -> 5%)
    var taxRate = (user.title === "기부왕") ? 0.05 : 0.10;
    var taxAmount = Math.max(0, Math.floor(margin * taxRate));
    
    // 신용 등급별 수익 배율 적용 (90% ~ 60%)
    var crInfo = getCreditInfo(user.creditScore, roomName);
    var creditMult = util_getTradeCreditMult(crInfo.grade);
    
    // 최종 예상 이익 = (마진 - 세금) * 신용배율
    var estimatedNetProfit = Math.floor((margin - taxAmount) * creditMult);
    var finalReceipt = tCost + estimatedNetProfit; // 최종 수령액 = 원금 + 조정된 이익
    /* =====요청사항 끝===== */

    var cargoDisplay = "📦 적재함: " + totalCargoInShip + " / " + shipCapacity + " 칸\n" + currentCargoLines.join("\n") + "\n\n";

    var displayBody = "현재 [" + v.dest + "]로 항해 중\n\n" +
                      cargoDisplay +
                      "💰 총 예상 수령액: " + fp(finalReceipt) + "P\n" +
                      "💵 순수익(마진): " + (estimatedNetProfit >= 0 ? "+" : "") + fp(estimatedNetProfit) + "P\n" +
                      "📉 신용 적용: " + (creditMult * 100).toFixed(0) + "% (" + crInfo.label + ")\n\n" +
                      "🕒 남은 시간: " + (remain > 0 ? "약 " + Math.ceil(remain/60000) + "분" : "도착 완료");

    replier.reply(formatCommand("📦 항해 현황", user, displayBody, "정산은 도착 후 채팅 입력 시 자동 수행됩니다."));
}

/* [서브] 🛠️ 선박 관리 및 개조 */
function _manageShip(user, replier, cfg) {
    var cur = cfg.SHIPS[user.shipLevel || 1];
    var next = cfg.SHIPS[(user.shipLevel || 1) + 1];
    var body = "등급: " + cur.name + " (Lv." + (user.shipLevel || 1) + ")\n적재량: " + cur.capacity + "칸\n━━━━━━━━━━━━━━━\n";
    if (next) body += "[다음 단계 개조]\n• 대상: " + next.name + "\n• 적재: " + next.capacity + "칸\n• 비용: " + fp(next.upgradeCost) + "P\n\n(개조 시 1번 입력)";
    else body += "🎉 이미 최고 등급 선박(갤리온)을 보유 중입니다.";

    body += "\n\n💰 보유 포인트: " + fp(user.point) + "P\n\n↩️ 뒤로 / 🏠 처음으로 / ❎취소";
    replier.reply(formatCommand("🛠️ 선박 관리소", user, body, "개조하려면 1번을 입력하세요."));
}

/* [서브] 실제 선박 업그레이드 */
function _processShipUpgrade(user, data, replier, roomName, cfg) {
    var next = cfg.SHIPS[(user.shipLevel || 1) + 1];
    if (!next || user.point < next.upgradeCost) return replier.reply(formatError(user, "개조 불가", "비용 부족 또는 최고 등급입니다."));
    
    user.skipHealing = true;
    util_updatePoint(user, data.rooms[roomName], -next.upgradeCost, "선박 개조 비용", roomName);
    
    // 원자적 데이터 게이트웨이 사용 및 물리 저장 강제(true)
    util_setData(user, 'shipLevel', (user.shipLevel || 1) + 1, "선박 등급 업그레이드", roomName);
    safeSaveData(data, true); 
    
    replier.reply(formatCommand("🎊 선박 개조 완료", user, "축하합니다! 선박이 [" + next.name + "]으로 강화되었습니다."));
}
/**
 * [핵심 엔진] 무역 정산 및 재해 엔진 v1.5
 */
function _processTradeArrival(user, data, replier, roomName, targetUid) {
    // 0. [에러 방지] 변수 선언 및 데이터 존재 여부 최우선 검증
    if (!user || !user.voyage) return; // 항해 중이 아니면 즉시 종료
    var v = user.voyage; 
    var cfg = SYSTEM_CONFIG.TRADE;
    
    // 1. 현재 방 데이터 복구 (하단 로직용)
    var roomData = data.rooms[roomName]; 
    
    // 2. 실제 자산이 연동될 경제 구역 설정 (1:1방 연동용)
    var economyRoomName = (ALLOWED_ROOMS.indexOf(roomName) === -1) ? "내리다" : roomName;
    var economyRoomData = data.rooms[economyRoomName];

    // [중요] 기존 하단 코드들과의 호환성을 위해 변수를 다시 매핑함
    // 이 줄이 있어야 하단에서 roomData.bankReserve 등을 찾을 때 에러가 안 납니다.
    if (!roomData) roomData = economyRoomData;

    // [중복 방지] 이미 정산 로직이 도는 중이라면 통과
    if (v.isProcessing === true) return;

    // 1. [핵심] 정산 시 부도 가드 (메인 구역 기준으로 잔액 체크)
    if (typeof util_isBankruptcy === 'function' && util_isBankruptcy(economyRoomName)) {
        // 부도 상태일 때는 정산 잠금을 해제하여 부도 해제 시 다음 채팅에서 자동 정산되게 함
        v.isProcessing = false; 

        if (v.isAlerted === true) return; // 알림은 한 번만 출력
        v.isAlerted = true; 
        
        var bankMsg = "무역선이 항구에 도착했으나, [" + economyRoomName + "] 구역의 부도 상태로 인해\n" +
                      "정산금을 지급할 재원이 부족합니다.\n\n" +
                      "📦 상태: 화물 보존 및 입항 대기\n" +
                      "💰 조치: 국고 복구 후 채팅 입력 시 자동 정산";
        
        replier.reply(formatCommand("⚓ 입항 대기 (지불 정지)", user, bankMsg, "해제 기준: 국고 50% 복구"));
        safeSaveData(data, false);
        return; 
    }

    // 2. 부도가 아닐 경우 정산 시작 (잠금 처리)
    v.isProcessing = true; 
    v.isAlerted = false; // 부도가 풀렸으므로 알림 상태 초기화

   // [보안] 실시간 가방이 아닌, 출항 시 박제했던 스냅샷을 정산 대상으로 설정
    // 1. [Snapshot] 출항 시점의 고정 데이터들을 정산 대상으로 설정 (휘발성/롤백 방지)
    var cargoToSell = v.cargoSnapshot || user.cargo || {};
    var specialtyToSell = v.specialtySnapshot || user.specialties || {};
    var producedByDest = TRADE_RELATION[v.dest] ? TRADE_RELATION[v.dest].produce : "";

    // 수정: nationInfo 변수 선언 추가 (ReferenceError 해결)
    var nationInfo = (v.marketSnapshot && v.marketSnapshot[v.dest]) ? v.marketSnapshot[v.dest] : cfg.NATIONS[v.dest];
    
    var totalRevenue = 0; 
    var totalCost = 0; 
    var soldLog = []; 
    var disasterLog = ""; 
    var cargoSummary = []; 
    var piracyLog = ""; // <--- 누락 지뢰 1: 해적 로그 변수 선언
    var taxAmount = 0;  // <--- 누락 지뢰 2: 세금 변수 선언
    var taxTag = "";    // <--- 누락 지뢰 3: 세금 태그 변수 선언
    
    var triggeredDisaster = (Math.random() < 0.25) ? ["STORM", "FIRE", "CORRO", "PIRACY"][Math.floor(Math.random() * 4)] : null; 

    // [수정]: '해상왕' 칭호 장착 시 모든 부정적 이벤트(재해/해적) 발생 확률 0% 고정
    var seaKingTag = (user.title === "해상왕") ? " (🔱해상왕 가드)" : "";
    if (user.title === "해상왕") {
        triggeredDisaster = null;
    }

    // 2. 일반 화물 실정산 (매입가 그대로 적용 로직)
    for (var good in cargoToSell) {
        var count = Number(cargoToSell[good]); if (count <= 0) continue;
        
        // [수정] 모든 수치를 Number()로 감싸 계산 오류(NaN) 원천 차단
        var myPurchasePrice = Number((user.cargoAvg && user.cargoAvg[good]) || cfg.GOODS_COST[good] || 10000);
        totalCost += (myPurchasePrice * count); 

        var rateInfo = SYSTEM_CONFIG.PROFIT_RATES[good] || { pref: 1.25, norm: 1.05, hate: 0.8 };
        var multiplier = Number(multiplier || 1.0);

        if (good === producedByDest) {
            multiplier = 0.5;
            disasterLog += "\n🚫 [과잉 공급]: 자국 생산물 '" + good + "'은 반입 제한(반값)";
        } else {
            if (good === nationInfo.favorite) multiplier = rateInfo.pref;
            else if (good === nationInfo.hate) multiplier = rateInfo.hate;
            else multiplier = rateInfo.norm;
        }

        // 재해 처리 (수량/가치 차감)
        if (triggeredDisaster === "FIRE" && (good === "식료품" || good === "공예품")) {
            var lost = Math.ceil(count * 0.1); count -= lost;
            disasterLog += "\n🔥 [재해: 화재]: " + good + " " + lost + "상자 소실";
        } else if (triggeredDisaster === "CORRO" && (good === "공업품" || good === "귀금속")) {
            multiplier *= 0.9;
            disasterLog += "\n🧪 [재해: 부식]: 화물 가치 10% 하락";
        }

        // 최종 개별 매출 = 내 매입가 * 수익률% * 남은 수량
        var earn = Math.floor(myPurchasePrice * multiplier * count);
        totalRevenue += earn;

        if (count > 0 && multiplier > 0) {
            var sign = (multiplier >= 1.1) ? "🔺" : (multiplier <= 0.9 ? "🔹" : "➖");
            soldLog.push("• " + good + " x" + count + ": " + fp(earn) + "P " + sign);
        }
        
        // 가방 비우기
        if (user.cargo) user.cargo[good] = 0;
        if (user.cargoAvg) user.cargoAvg[good] = 0;
    }

    // 3. 특산품 정산 (specialtyToSell 스냅샷 기반 루프)
    for (var sName in specialtyToSell) {
        var sCount = Number(specialtyToSell[sName]); if (sCount <= 0) continue;
        var sMult = 1.0; var sTag = "";

        var parentGood = "";
        var sBasePrice = 10000; // 기본값 (폴백)

        // 해당 특산품의 상위 카테고리(produce) 및 그에 따른 기본 가격 탐색
        for (var n in TRADE_RELATION) {
            if (TRADE_RELATION[n].set === sName) { 
                parentGood = TRADE_RELATION[n].produce; 
                sBasePrice = cfg.SPECIALTY_COST[parentGood] || 10000;
                break; 
            }
        }

        if (parentGood === producedByDest) {
            sMult = 0;
            disasterLog += "\n🚫 [통관 거부]: 자국 특산품 '" + sName + "'은 전량 압수되었습니다.";
        } else if (parentGood === nationInfo.favorite) {
            sMult = cfg.SPECIALTY_PROFIT;
            sTag = "⭐ [세트수요]";
        } else if (parentGood === nationInfo.hate) {
            sMult = 0.5;
            sTag = "🔹 [수요급감]";
        }

        var sRev = Math.floor(sBasePrice * sCount * sMult);
        totalRevenue += sRev;
        if (sMult > 0) {
            soldLog.push("• [특] " + sName + " x" + sCount + ": " + fp(sRev) + "P " + sTag);
        }
        // 실제 유저의 특산품 가방 비움
        if (user.specialties) user.specialties[sName] = 0;
    }

    // 5. [핵심] 순수익(마진) 기반 차등 정산 로직
    var margin = totalRevenue - totalCost; // 순수 마진 산출
    var piracyLoot = 0;

    // 해적 약탈 (마진에서 10% 차감)
    if (triggeredDisaster === "PIRACY" && margin > 0) {
        piracyLoot = Math.floor(margin * 0.1);
        margin -= piracyLoot;
        disasterLog += "\n🏴‍☠️ [해적]: 마진의 10%(-" + fp(piracyLoot) + "P)를 약탈당했습니다.";
    }

    // 세금 계산 (기부왕 5%, 일반 10%)
    var taxRate = (user.title === "기부왕") ? 0.05 : 0.10;
    var taxAmount = margin > 0 ? Math.floor(margin * taxRate) : 0;
    var afterTaxMargin = margin - taxAmount;

    // 신용 등급 수익 배율 적용
    var crInfo = getCreditInfo(user.creditScore, roomName);
    var creditMult = util_getTradeCreditMult(crInfo.grade);
    var finalNetProfit = Math.floor(afterTaxMargin * creditMult); // 최종 조정된 순이익
    var creditLoss = Math.max(0, afterTaxMargin - finalNetProfit); // 신용 등급으로 인해 국고로 환수되는 금액

    // 폭풍우 수리비 (최종 수익에서 차감)
    var repairFee = 0;
    if (triggeredDisaster === "STORM") {
        repairFee = Math.floor(Math.abs(finalNetProfit) * 0.1 + 10000);
        finalNetProfit -= repairFee;
        disasterLog += "\n🌊 [폭풍우]: 선체 파손 수리비 " + fp(repairFee) + "P 지출";
    }

    // 6. 최종 지급액 확정 = 원금(보존) + 조정된 순이익
    var totalPayout = totalCost + finalNetProfit;

    // [핵심 수정] 실제 돈이 지급될 장부를 economyRoomData(내리다 방)로 지정하여 보안 롤백 해결
    util_updatePoint(user, economyRoomData, totalPayout, "무역 정산 완료 (원금+수익)", economyRoomName);
    
    // 국고 귀속 (세금 + 신용 삭감액) 역시 메인 금고에서 처리
    if (taxAmount > 0) util_updateReserve(economyRoomData, taxAmount, "무역세 징수", economyRoomName);
    if (creditLoss > 0) util_updateReserve(economyRoomData, creditLoss, "신용 등급 차등 수익 환수", economyRoomName);

    // 7. 특산품 발견 (15% 확률)
    var specialtyFound = "";
    if (Math.random() < cfg.SPECIALTY_CHANCE) {
        var newItem = nationInfo.specialty;
        user.specialties[newItem] = (user.specialties[newItem] || 0) + 1;
        specialtyFound = "\n\n✨ [" + v.dest + "]의 특산품 '" + newItem + "'을 발견했습니다!";
    }
    
    // [수정] 중복 선언 및 로직 제거, 정산 플래그 해제 통합
    user.voyage.active = false; 
    user.voyage.isProcessing = false; 
    user.tradeCount = (user.tradeCount || 0) + 1;
    var tCount = user.tradeCount;
    var rStub = { reply: function(m) { Api.replyRoom(roomName, m); } };

    if (tCount >= 200) {
        util_checkAndAwardTitle(user, rStub, "해상왕", 5104, "🔱", "내리다 해상 연맹", "누적 무역 200회 달성", "[장착 효과]: 바다의 지배자. 모든 항해 재해(폭풍우, 해적 등) 발생 확률이 0%가 됩니다.", roomName);
    } else if (tCount >= 150) {
        util_checkAndAwardTitle(user, rStub, "대항해사", 5103, "🧭", "내리다 해상 연맹", "누적 무역 150회 달성", "모든 항로를 파악한 바다의 전문가입니다.", roomName);
    } else if (tCount >= 100) {
        util_checkAndAwardTitle(user, rStub, "항해사", 5102, "🌊", "내리다 해상 연맹", "누적 무역 100회 달성", "파도를 읽고 배를 진두지휘하는 실력자입니다.", roomName);
    } else if (tCount >= 50) {
        util_checkAndAwardTitle(user, rStub, "견습선원", 5101, "⚓", "내리다 해상 연맹", "누적 무역 50회 달성", "바다의 기초를 배우기 시작한 유망주입니다.", roomName);
    }

    // 리포트용 변수 매핑 및 태그 생성
    var grossRevenue = totalRevenue; 
    var netProfit = finalNetProfit; 
    var cargoDisplay = (cargoSummary && cargoSummary.length > 0) ? cargoSummary.join(", ") : v.dest + " 수출품";
    var baseTax = cfg.BASE_TAX || 0.1;
    var taxTag = (taxRate > baseTax) ? " (자산가 누진 적용)" : "";

    var report = "📍 도착지: " + v.dest + " (" + cargoDisplay + ")\n\n" +
                 "💰 총 매출: " + fp(totalRevenue) + "P" + seaKingTag +
                 (piracyLog || "") + 
                 (disasterLog || "") + "\n" +
                 "⚖️ 무역세(" + (Number(taxRate || 0.1) * 100).toFixed(0) + "%): -" + fp(taxAmount) + "P" + taxTag + "\n\n" +
                 "💵 최종 수익: +" + fp(netProfit) + "P" + 
                 (specialtyFound || "");

    // 결과 메시지 생성 및 전송
    var resultMsg = formatCommand("🌊 [항해 일지: 무역 보고]", user, report, "누적 무역: " + user.tradeCount + "회 / 잔액: " + fp(user.point) + "P");
    Api.replyRoom(roomName, resultMsg);
    
    safeSaveData(data, true);
}

//==========섹터52==========

/**
 * [핵심 모듈] 통합 카지노 엔진 (사다리 & 바카라)
 * 기능: 메뉴 출력, 배팅 검증, 최근 결과 조회
 */

/* [메인] 카지노 로직 진입점 */
function _gameCasinoLogic(msg, user, data, replier, roomName, targetUid) {
    // 1. 공백 제거 (숫자 인식률 향상)
    var cleanMsg = msg.trim();

    // 수정: 모든 실행 경로에서 참조할 수 있도록 핵심 변수 선언부를 함수 최상단으로 이동 (참조 오류 해결)
    var MAIN_ZONE = "내리다";
    var mainRoomData = data.rooms[MAIN_ZONE];
    if (!user || !mainRoomData) return false;
    var nowTs = Date.now(); // 현재 시간 변수를 최상단에 선언하여 모든 조건문에서 공유

    // 카지노 데이터 구조 안전성 확보
    if (mainRoomData && !mainRoomData.features.casino) {
        mainRoomData.features.casino = {
            ladder: { round: 1, history: [], bets: {} },
            baccarat: { round: 1, history: [], bets: {} }
        };
    }
    var casino = mainRoomData.features.casino;

    // 현재 방의 메뉴 상태 저장소 참조
    if (!data.rooms[roomName].features.states) data.rooms[roomName].features.states = { menuWait: {} };
    var mState = data.rooms[roomName].features.states.menuWait;

    // [핵심 가드] 단체방 입장 제한
    if (user.isGroupChatTemp === true) {
        var inviteBody = "중앙 카지노는 VIP 고객님의 보안과\n" +
                         "쾌적한 환경을 위해 오직 [1:1 대화]를\n" +
                         "통해서만 게임을 제한하고 있습니다.\n" +
                         "https://open.kakao.com/me/nerida";
        replier.reply(formatCommand("📨 VIP 전용 안내", user, inviteBody, "봇의 오픈프로필 1:1 채팅방에서 만나요!"));
        return true;
    }

    // 1. 명령어 처리: /카지노
    if (cleanMsg === "/카지노") {
        if (typeof util_isBankruptcy === 'function' && util_isBankruptcy(roomName)) {
            var bankMsg = "🚨 [긴급: 카지노 임시 휴업]\n" +
                          "━━━━━━━━━━━━━━━\n" +
                          "현재 메인 구역의 국가 부도 선포로 인해\n" +
                          "모든 게임과 배팅이 전면 중단되었습니다.";
            replier.reply(formatCommand("🎰 카지노 영업 정지", user, bankMsg, "해제 기준: 국고 50% 복구"));
            return true; 
        }

        if (user.mining && user.mining.active === true) {
            replier.reply(formatError(user, "배팅 불가", "현재 광산에서 채굴 작업 중입니다."));
            return true;
        }

        // 1) 세션 갱신 및 입장 알림 (3분 미사용 시 또는 최초 입장 시 1회 발송)
        if (nowTs - (user.lastBotUseTime || 0) > 180000 || !user.casinoAuditStartTime) {
            user.casinoAuditStartTime = nowTs;
            user.casinoAuditStartAssets = Number(user.point || 0) + Number(user.bank || 0);
            user.casinoAuditAlertHistory = [];
            
            // 베릭방 입장 알림 발송 (3분에 1번)
            var entryLog = "🔔 [카지노 입장 알림]\n" +
                           "━━━━━━━━━━━━━━━\n" +
                           "👤 유저: " + user.name + "\n" +
                           "🆔 ID: " + targetUid + "\n" +
                           "📍 장소: 1:1 대화방 (" + roomName + ")\n" +
                           "💰 현재자산: " + fp(user.casinoAuditStartAssets) + " P\n" +
                           "━━━━━━━━━━━━━━━\n" +
                           "⚠️ 실시간 모니터링 중";
            try { Api.replyRoom("베릭방", entryLog); } catch(e) { Log.error("Entry Alert Fail: " + e); }
        }

        // 마지막 활동 시간 갱신 및 메뉴 상태 설정
        user.lastBotUseTime = nowTs; 
        mState[targetUid] = { type: 'casino_main', time: nowTs };

        var body = "현재 입장 가능한 게임룸입니다.\n\n" +
                   "1. 🌓 사다리 (2분 주기 / 1.90~4.0배)\n" +
                   "2. 🃏 바카라 (3분 주기 / 2.0~8.0배)\n" +
                   "3. 🕴️ 블랙잭 (개인전 / 딜러 대결)\n";
        
        replier.reply(formatCommand("🎰 내리다 중앙 카지노", user, body, "이동하실 게임 번호를 입력하세요."));
        safeSaveData(data);
        return true; 
    }

    /* 숫자 입력 처리 */
    var state = mState[targetUid];
    if (!state) return false; // 대기 상태가 없으면 종료

    // 2. 사다리 메뉴
    if (state.type === 'casino_main' && cleanMsg === "1") {
        mState[targetUid] = { type: 'casino_ladder', time: Date.now() };
        _showCasinoSubMenu(replier, user, "사다리", casino.ladder, 2);
        safeSaveData(data);
        return true;
    }

    // 3. 바카라 메뉴
    if (state.type === 'casino_main' && cleanMsg === "2") {
        mState[targetUid] = { type: 'casino_baccarat', time: Date.now() };
        _showCasinoSubMenu(replier, user, "바카라", casino.baccarat, 3);
        safeSaveData(data);
        return true;
    }

    // 3-1. 블랙잭 메뉴
    if (state.type === 'casino_main' && cleanMsg === "3") {
        if (typeof util_isBankruptcy === 'function' && util_isBankruptcy(roomName)) {
            replier.reply(formatError(user, "블랙잭 폐쇄", "국가 부도 선포로 인해 딜러들이 모두 휴가 중입니다."));
            return true;
        }
        
        // 뱅크 프로세스 상태 초기화 확인
        if (!data.rooms[roomName].features.states.bankProcess) {
            data.rooms[roomName].features.states.bankProcess = {};
        }

        // 배팅 금액 입력 상태로 전환
        data.rooms[roomName].features.states.bankProcess[targetUid] = { type: 'blackjack_bet_input', time: Date.now() };
        delete mState[targetUid];
        
        var minB = SYSTEM_CONFIG.ECO.GAMBLE_MIN || 2000;
        var maxB = SYSTEM_CONFIG.ECO.GAMBLE_MAX || 50000;
        replier.reply(formatCommand("🕴️ 블랙잭 테이블 입장", user, "딜러가 카드를 섞고 있습니다.\n배팅하실 금액을 입력해주세요.\n\n• 최소: " + fp(minB) + "P\n• 최대: " + fp(maxB) + "P", "취소: [취소]"));
        safeSaveData(data);
        return true;
    }

    // 4. 게임별 세부 기능
    if (state.type === 'casino_ladder' || state.type === 'casino_baccarat') {
        var gameType = (state.type.indexOf('ladder') !== -1) ? "ladder" : "baccarat"; 
        var gameObj = casino[gameType];
        var interval = (gameType === "ladder") ? 2 : 3;

        if (cleanMsg === "1") {
            mState[targetUid].type = state.type + "_sub"; 
            _showCasinoRoundInfo(replier, user, gameType, gameObj, interval, roomName);
        } else if (cleanMsg === "2") {
            mState[targetUid].type = state.type + "_sub"; 
            _showCasinoHistory(replier, user, gameType, gameObj);
        } else if (cleanMsg === "3") {
            mState[targetUid].type = state.type + "_sub";
            _showCasinoDailyHistory(replier, user, gameType);
        }
        safeSaveData(data);
        return true;
    }

    return false;
}

/* [서브] 카지노 게임별 2단계 메뉴 출력 */
function _showCasinoSubMenu(replier, user, title, obj, interval) {
    var now = new Date();
    var remainSec = (interval * 60) - ((now.getMinutes() % interval) * 60 + now.getSeconds());
    var min = Math.floor(remainSec / 60);
    var sec = remainSec % 60;

    var totalBet = 0;
    for (var uid in obj.bets) { totalBet += Number(obj.bets[uid].amount); }

    var lastResLine = "";
    var gKey = (title === "사다리") ? "ladder" : "baccarat";
    // [수정] 타입(gKey)이 일치하고, 바로 직전 회차(obj.round-1) 기록일 때만 출력
    if (user.lastCasinoResult && user.lastCasinoResult.type === gKey) {
        var lr = user.lastCasinoResult;
        if (Number(lr.round) === Number(obj.round) - 1) {
            var icon = lr.isWin ? "🎊" : "💀";
            var sign = lr.isWin ? "+" : "";
            lastResLine = "• 내 직전결과: " + lr.res + " [" + sign + fp(lr.profit) + "P] " + icon + "\n";
        }
    }

    var body = "진행 중인 회차 및 메뉴를 선택하세요.\n\n" +
               "[현재 회차 정보]\n" +
               "• 회차: 제 " + (obj.round || 1) + "회차\n" +
               lastResLine + // 요약 라인 삽입
               "• 남은 시간: " + (min > 0 ? min + "분 " : "") + sec + "초\n" +
               "• 총 판돈: " + fp(totalBet) + "P\n\n" +
               "1. 📈 진행 중인 회차 정보 (배팅 현황)\n" +
               "2. 📋 최근 10경기 결과\n" +
               "3. 🏆 금일 당첨 기록 확인";

    replier.reply(formatCommand((title === "사다리" ? "🪜 " : "🃏 ") + title + " 게임실", user, body, "원하시는 번호를 입력하세요."));
}

/**
 * @param {String} type - "ladder" 또는 "baccarat"
 */
function _showCasinoDailyHistory(replier, user, type) {
    var wins = (type === "ladder") ? (user.dailyLadderWins || []) : (user.dailyBaccaratWins || []);
    var titleStr = (type === "ladder") ? "🪜 사다리" : "🃏 바카라";
    
    var list = [];
    var totalProfit = 0;
    
    if (wins.length === 0) {
        list.push("(금일 당첨 기록이 없습니다)");
    } else {
        // 최대 15건까지만 출력 (말풍선 길이 제한 대비)
        var displayCount = Math.min(wins.length, 15);
        for (var i = 0; i < displayCount; i++) {
            var w = wins[i];
            var pickName = (type === "ladder") ? w.pick : w.res;
            list.push("• [" + w.round + "회] " + pickName + " : +" + fp(w.profit) + "P (" + w.time + ")");
            totalProfit += Number(w.profit);
        }
        if (wins.length > 15) list.push("...외 " + (wins.length - 15) + "건 더 있음");
    }

    var body = "[오늘의 승전보]\n" + list.join("\n") + "\n\n" +
               "📊 당일 누적 합계\n" +
               "• 당첨 횟수: " + wins.length + "회\n" +
               "• 누적 수익: +" + fp(totalProfit) + "P";

    replier.reply(formatCommand(titleStr + " 금일 당첨 리포트", user, body, "(↩️ 뒤로 / 🏠 처음으로)"));
}

/* [서브] 실시간 배팅 현황판 및 배팅 가이드 */
function _showCasinoRoundInfo(replier, user, type, obj, interval, roomName) {
    var now = new Date();
    var remainSec = (interval * 60) - ((now.getMinutes() % interval) * 60 + now.getSeconds());
    var totalBet = 0;
    var stats = {};

    // 배팅 리포트 집계
    for (var uid in obj.bets) {
        var b = obj.bets[uid];
        totalBet += Number(b.amount);
        stats[b.pick] = (stats[b.pick] || 0) + Number(b.amount);
    }

    var report = "";
    if (type === "ladder") {
        var picks = ["홀", "우3홀", "좌4홀", "짝", "좌3짝", "우4짝"];
        picks.forEach(function(p) {
            var amt = stats[p] || 0;
            var per = totalBet > 0 ? Math.floor((amt / totalBet) * 100) : 0;
            var icon = (p.indexOf("홀") !== -1) ? "🔵" : "🔴";
            report += icon + " " + p + " : " + fp(amt) + "P (" + per + "%)\n";
        });
    } else {
        var bPicks = { "P": "플레이어", "B": "뱅커", "T": "타이" };
        for (var k in bPicks) {
            var amt = stats[k] || 0;
            var per = totalBet > 0 ? Math.floor((amt / totalBet) * 100) : 0;
            report += "• " + bPicks[k] + " : " + fp(amt) + "P (" + per + "%)\n";
        }
    }

    var title = (type === "ladder" ? "사다리" : "바카라");
    var payoutMsg = (type === "ladder" ? "단일 x1.9 / 조합 x4.0" : "P x2.0 / B x1.95 / T x8.0");

    var minBetVal = SYSTEM_CONFIG.ECO.GAMBLE_MIN || 2000;
    var maxLimitVal = SYSTEM_CONFIG.ECO.GAMBLE_MAX || 50000;

    var bettingExample = (type === "ladder") ? "홀 5000" : "플레이어 10000";
    var subExample = (type === "ladder") ? "좌3짝 10000" : "타이 5000";

    var body = "실시간으로 집계된 배팅 비율입니다.\n" +
               "🕒 " + remainSec + "초 후 배팅이 마감됩니다.\n\n" +
               "[배팅 리포트]\n" + report + "\n" +
               "🏦 총 배팅액 : " + fp(totalBet) + "P\n" +
               "⚖️ 현재 배당률 : " + payoutMsg + "\n\n" +
               "최소 배팅금 : " + fp(minBetVal) + "P\n" +
               "최대 배팅금 : " + fp(maxLimitVal) + "P\n\n" + // 50,000P 자동 반영
               "💬 [배팅 입력 예시]\n" +
               "👉 " + bettingExample + "\n" +
               "👉 " + subExample + "\n\n" +
               "마감 5초전에는 배팅이 차단됩니다.";

    replier.reply(formatCommand("📈 제 " + (obj.round || 1) + "회차 " + title + " 현황", user, body, "(↩️ 뒤로 / 🏠 처음으로)"));
}

/* [서브] 최근 10경기 결과 내역 */
function _showCasinoHistory(replier, user, type, obj) {
    var list = [];
    var history = obj.history || [];
    
    if (history.length === 0) {
        list.push("데이터가 없습니다.");
    } else {
        history.forEach(function(h) {
            var icon = (h.res.indexOf("홀") !== -1 || h.res === "P" || h.res === "T") ? "🔵" : "🔴";
            var resName = h.res;
            if (type === "baccarat") resName = { "P": "플레이어", "B": "뱅커", "T": "타이" }[h.res];
            list.push("• " + h.round + "회차 : [" + resName + "] " + icon);
        });
    }

    var range = history.length > 0 ? " [" + history[history.length-1].round + " ~ " + history[0].round + "회차]" : "";
    var body = "[최근 경기 결과]" + range + "\n\n" + list.join("\n");
    
    replier.reply(formatCommand("📋 최근 10경기 결과 내역", user, body, "결과는 실시간 갱신됩니다."));
}

/* [입력 핸들러] 채팅 직접 배팅 처리 엔진 */
function _handleCasinoBet(msg, user, data, replier, roomName, targetUid) {
    var MAIN_ZONE = "내리다"; 
    var mainRoomData = data.rooms[MAIN_ZONE];

    var mState = data.rooms[roomName].features.states.menuWait;
    if (!mState || !mState[targetUid] || !mState[targetUid].type || mState[targetUid].type.indexOf("casino_") === -1) return false;

    // [부도 가드] 베팅 로직 진입 전 최우선 검증
    if (typeof util_isBankruptcy === 'function' && util_isBankruptcy(roomName)) {
        var bankMsg = "🚨 [긴급: 카지노 영업 정지]\n" +
                      "━━━━━━━━━━━━━━━\n" +
                      "국가 부도 선포로 인해 카지노 내 모든\n" +
                      "현금 거래 및 배팅이 전면 동결되었습니다.\n\n" +
                      "🎭 상태: 임시 휴업 (정부 관할)\n" +
                      "⚖️ 사유: 경제 회생을 위한 자금 통제";
        
        replier.reply(formatCommand("🎰 카지노 폐쇄 알림", user, bankMsg, "정부의 회생 조치를 기다려주세요."));
        return true; // 로직 종료 및 입력 차단
    }

    var state = mState[targetUid];
    var parts = msg.split(" ");
    if (parts.length < 2) return false;

    var pick = parts[0];
    var amt = parseInt(parts[1].replace(/,/g, ""));
    if (isNaN(amt) || amt <= 0) return false;

    // 1. 게임 타입 판별 보정 (Sub 상태 포함 인식)
    var gameType = (state.type.indexOf("ladder") !== -1) ? "ladder" : "baccarat";
    var casino = mainRoomData.features.casino[gameType]; 
    
    var interval = (gameType === "ladder") ? 2 : 3;

    // 2. 배팅 가능 선택지 검증
    var validPicks = (gameType === "ladder") ? ["홀", "짝", "좌3짝", "우3홀", "좌4홀", "우4짝"] : ["플레이어", "뱅커", "타이", "P", "B", "T"];
    if (validPicks.indexOf(pick) === -1) return false;

    // 3. 자금 및 한도 검증 (상수 참조 교정: CASINO.MIN_BET -> ECO.GAMBLE_MIN)
    var minLimit = SYSTEM_CONFIG.ECO.GAMBLE_MIN || 2000;
    var maxLimit = SYSTEM_CONFIG.ECO.GAMBLE_MAX;

    // 4. 시간 마감 가드 (5초 전 차단)
    var now = new Date();
    var secInCycle = (now.getMinutes() % interval) * 60 + now.getSeconds();
    var limit = (interval * 60) - 5;
    
    if (secInCycle >= limit) {
        replier.reply(formatError(user, "배팅 마감", "회차 마감 5초 전에는 배팅이 불가능합니다."));
        return true;
    }

    if (Number(user.point) < amt) {
        replier.reply(formatError(user, "포인트 부족", "보유 포인트가 부족합니다."));
        return true;
    } else if (amt < minLimit) {
        replier.reply(formatError(user, "배팅 금액 미달", "최소 배팅금은 " + fp(minLimit) + "P입니다."));
        return true;
    } else if (amt > maxLimit) {
        replier.reply(formatError(user, "한도 초과", (gameType === "ladder" ? "사다리" : "바카라") + "의 최대 한도는 " + fp(maxLimit) + "P입니다.\n(현재 입력: " + fp(amt) + "P)"));
        return true;
    }

    // 1인 1회 배팅 제한 가드 (이미 배팅 데이터가 존재하면 차단)
    if (casino.bets[targetUid]) {
        replier.reply(formatError(user, "중복 배팅 제한", "이미 이번 회차에 배팅을 완료하셨습니다.\n카지노는 게임 종류별로 회차당 1회만 참여 가능합니다."));
        return true;
    }

    // 5. 배팅 접수 처리 (바카라 한글 매핑 포함)
    var finalPick = pick;
    if (gameType === "baccarat") {
        var bMap = { "플레이어": "P", "뱅커": "B", "타이": "T", "P": "P", "B": "B", "T": "T" };
        finalPick = bMap[pick] || pick;
    }

    // 6. 포인트 차감 및 통계 기록
    user.skipHealing = true; 
    util_updatePoint(user, mainRoomData, -amt, "카지노 배팅 참여 (" + pick + ")", MAIN_ZONE);
    
    user.totalGambleCount = (user.totalGambleCount || 0) + 1;
    user.totalCasinoBet = (user.totalCasinoBet || 0) + amt;
    casino.bets[targetUid] = { pick: finalPick, amount: amt, name: user.name, uid: targetUid };

    // 7. 칭호 자동 부여 체크 (카지노 통합 판정 및 설명 수정)
    var winRate = (user.totalGambleWins / user.totalGambleCount) * 100;
    
    if (user.totalGambleCount >= 500) {
        util_checkAndAwardTitle(user, replier, "도박왕", 4003, "🎲", "내리다 카지노 협회", 
            "카지노 통합 500회 참여 달성", 
            "[장착 효과]: 모든 카지노 게임(사다리, 바카라, 블랙잭) 정산 시 배당률 +0.05 추가 적용", 
            roomName);
    } else if (user.totalGambleCount >= 100 && winRate >= 60) {
        util_checkAndAwardTitle(user, replier, "타짜", 4002, "🎴", "내리다 카지노 협회", 
            "카지노 통합 승률 60% 돌파", 
            "판을 읽는 날카로운 눈을 가졌습니다.", 
            roomName);
    } else if (user.totalGambleCount >= 100) {
        util_checkAndAwardTitle(user, replier, "꾼", 4001, "🃏", "내리다 카지노 협회", 
            "카지노 통합 100회 참여", 
            "카지노의 생리를 깨달은 승부사", 
            roomName);
    }
    
    var remain = (interval * 60) - secInCycle;
    var successMsg = "• 회차: 제 " + (casino.round || 1) + "회차\n" +
                     fp(amt) + "P 배팅 완료\n\n" +
                     "• 선택: " + pick + "\n" +
                     "💰 보유 포인트: " + fp(user.point) + "P\n" +
                     "🚫 최대 한도: " + fp(maxLimit) + "P";

    var displayTitle = (gameType === "ladder" ? "🪜 사다리 배팅 완료" : "🃏 바카라 배팅 완료");
    replier.reply(formatSimple(displayTitle, successMsg));

    // 배팅 완료 후 메뉴 대기 상태를 즉시 삭제하여 응답 대기 종료
    if (mState && mState[targetUid]) {
        delete mState[targetUid];
    }
    safeSaveData(data);
    return true;
}

/** [블랙잭 시작] 최초 카드 분배 및 스테이징 적용 */
function _startBlackjackGame(user, data, replier, roomName, targetUid, betAmt) {
    var roomData = data.rooms[roomName];
    user.skipHealing = true;
    
    // 포인트 선차감 (게이트웨이 준수)
    util_updatePoint(user, roomData, -betAmt, "블랙잭 배팅 참여", roomName);

    // 카드 생성 (1~10, JQK=10, A=11)
    var getCard = function() {
        var num = Math.floor(Math.random() * 13) + 1;
        if (num > 10) return 10; // J, Q, K
        if (num === 1) return 11; // A (기본 11)
        return num;
    };

    var pHand = [getCard(), getCard()];
    var dHand = [getCard(), getCard()];

    user.blackjackState = {
        bet: betAmt,
        playerHand: pHand,
        dealerHand: dHand,
        status: 'playing'
    };

    // 메뉴 선택 상태로 전환
    roomData.features.states.menuWait[targetUid] = { type: 'blackjack_action', time: Date.now() };

    var body = "🕴️ 딜러가 카드를 돌렸습니다.\n\n" +
               "🤖 딜러: [ ? ], [ " + dHand[1] + " ]\n" +
               "👤 나: [ " + pHand.join(", ") + " ]\n" +
               "💰 합계: " + _calcBJScore(pHand) + "점\n\n" +
               "1. 힛(Hit) - 카드 한 장 더\n" +
               "2. 스테이(Stay) - 멈추고 비교";

    replier.reply(formatCommand("🃏 블랙잭: 1:1 대결", user, body, "번호를 선택하세요."));
    safeSaveData(data);
}

/** [블랙잭 액션 핸들러] 힛/스테이 처리 */
function _handleBlackjackAction(msg, user, data, replier, roomName, targetUid) {
    var roomData = data.rooms[roomName];
    var state = user.blackjackState;
    if (!state) return false;

    if (msg === "1") { // HIT
        var newCard = Math.floor(Math.random() * 13) + 1;
        if (newCard > 10) newCard = 10;
        if (newCard === 1) newCard = 11;
        
        state.playerHand.push(newCard);
        var score = _calcBJScore(state.playerHand);

        if (score > 21) {
            _finishBlackjack(user, data, replier, roomName, targetUid, "BUST");
        } else {
            // 딜러의 블러핑 멘트 생성
            var bluffs = [
                "오호.. 점수가 꽤 높은데요? 욕심내다간 터질지도 모릅니다.",
                "제 바닥패가 그림(10)일 확률이 아주 높은데.. 괜찮으시겠습니까?",
                "지금 멈추면 비길 수도 있을 것 같군요.",
                "카드를 더 받으시다니, 대담하시네요."
            ];
            var bluffMsg = "\n\n💬 딜러: \"" + bluffs[Math.floor(Math.random() * bluffs.length)] + "\"";
            
            var body = "🤖 딜러: [ ? ], [ " + state.dealerHand[1] + " ]\n" +
                       "👤 나: [ " + state.playerHand.join(", ") + " ]\n" +
                       "💰 합계: " + score + "점" + bluffMsg + "\n\n" +
                       "1. 힛(Hit) / 2. 스테이(Stay)";
            replier.reply(formatCommand("🃏 블랙잭 진행 중", user, body));
            roomData.features.states.menuWait[targetUid].time = Date.now(); // 시간 연장
        }
        return true;
    } 
    else if (msg === "2") { // STAY
        _finishBlackjack(user, data, replier, roomName, targetUid, "STAY");
        return true;
    }
    return false;
}

/** [블랙잭 결과 정산] 도박왕 배당(+0.05) 적용 및 통합 메시지 출력 */
function _finishBlackjack(user, data, replier, roomName, targetUid, action) {
    var roomData = data.rooms[roomName];
    var state = user.blackjackState;
    var pScore = _calcBJScore(state.playerHand);
    var dScore = _calcBJScore(state.dealerHand);
    
    delete roomData.features.states.menuWait[targetUid];
    user.blackjackState = null;
    
    // [카운트 연동]
    user.totalGambleCount = (user.totalGambleCount || 0) + 1;

    // 1. 딜러 카드 드로우 (일단 규칙대로 뽑음)
    if (action === "STAY") {
        while (dScore < 17) {
            var c = Math.floor(Math.random() * 13) + 1;
            if (c > 10) c = 10; if (c === 1) c = 11;
            state.dealerHand.push(c);
            dScore = _calcBJScore(state.dealerHand);
        }
    }

    // 2. [승률 조작] 유저별 승률 연동 (기본 45% or 조작값)
    // 유저가 이미 버스트(21초과)라면 조작 없이 패배 확정
    if (pScore <= 21) {
        var targetWinRate = 45; // 기본 목표 승률 45%

        // [수정] 유저가 조작 상태라면 설정된 승률(gambleWinRate)을 우선 적용
        if (user.isManipulated && user.gambleWinRate > 0) {
            targetWinRate = user.gambleWinRate;
        }

        var isUserWin = (Math.random() * 100 < targetWinRate);

        if (isUserWin) {
            // [승리 시나리오]: 유저가 이겨야 함
            // 만약 딜러가 이기거나 비기고 있다면 -> 딜러를 강제 버스트(22)시킴
            if (dScore <= 21 && dScore >= pScore) {
                dScore = 22; 
            }
        } else {
            // [패배 시나리오]: 유저가 져야 함
            // 만약 딜러가 터졌거나 점수가 낮다면 -> 딜러 점수를 (유저+1)로 조작
            if (dScore > 21 || dScore < pScore) {
                dScore = pScore + 1;
                // 단, 21점을 넘길 순 없으므로 최대 21로 고정
                if (dScore > 21) dScore = 21;
            }
        }
    }

    // 3. 최종 승패 판정 (조작된 dScore 기준)
    var resultStr = ""; 
    var resultStatus = "LOSE"; 

    if (pScore > 21) { resultStr = "버스트(Bust) 패배! 💀"; resultStatus = "LOSE"; }
    else if (dScore > 21) { resultStr = "딜러 버스트! 승리! 🎊"; resultStatus = "WIN"; }
    else if (pScore > dScore) { resultStr = "점수 우위 승리! 🎊"; resultStatus = "WIN"; }
    else if (pScore < dScore) { resultStr = "딜러 점수 우위 패배! 💀"; resultStatus = "LOSE"; }
    else { resultStr = "무승부 (Push) 😐"; resultStatus = "PUSH"; }

    // 4. 배당률 산출 (도박왕 보너스 +0.05)
    var multiplier = 0;
    var bonusTag = "";

    if (resultStatus === "WIN") {
        multiplier = 1.90;
        if (user.title === "도박왕") {
            multiplier += 0.05; 
            bonusTag = " 👑도박왕";
        }
        user.totalGambleWins = (user.totalGambleWins || 0) + 1;
    } else if (resultStatus === "PUSH") {
        multiplier = 1.0; 
    }

    var prize = Math.floor(state.bet * multiplier);
    var finalMsg = "🤖 딜러 패: [ " + state.dealerHand.join(", ") + " ] (" + dScore + "점)\n" +
                   "👤 나의 패: [ " + state.playerHand.join(", ") + " ] (" + pScore + "점)\n\n" +
                   "📢 결과: " + resultStr;

    if (prize > 0 && resultStatus === "WIN") {
        // 1. [고정 세금 계산] 배팅금의 0.1배(10%)를 세금으로 책정
        var economyRoom = (ALLOWED_ROOMS.indexOf(roomName) === -1) ? "내리다" : roomName;

        if (!util_isBankSolvent(roomName, prize)) {
            replier.reply(formatError(user, "은행 지불 불능", "국가 부도 상태로 인해 상금을 지급할 수 없습니다.\n게임이 무효 처리되어 배팅금이 소멸되었습니다."));
            return; // 상태는 이미 상단에서 파기되었으므로 안전하게 종료
        }
        var taxAmount = Math.floor(state.bet * 0.1);
        var netIncome = prize; // prize는 이미 1.90배가 적용된 금액

        // 2. 세금 국고 환수 집행
        util_updateReserve(roomData, taxAmount, "블랙잭 이용세 징수", roomName);

        // 3. [상환 처리] 세후 금액으로 빚 상환 진행
        var res = processRepayment(user, netIncome, targetUid, roomName);

        // 4. 최종 실수령액 지급
        util_updatePoint(user, roomData, Number(res.actualGain), "블랙잭 정산 수익", roomName);

        // 5. UI 메시지 조립 (카지노 이용세 고정 수치 표시)
        finalMsg += "\n💰 획득: +" + fp(prize) + "P (1.90배 적용)";
        finalMsg += "\n\n⚖️ 세금(10%): -" + fp(taxAmount) + "P (카지노 이용세)";
        if (res.repayMsg) finalMsg += res.repayMsg;
        finalMsg += "\n💰 최종 수익: +" + fp(res.actualGain) + "P" + bonusTag;

        var nowStr = new Date().getHours() + ":" + ("0" + new Date().getMinutes()).slice(-2);
        if (!user.dailyBlackjackWins) user.dailyBlackjackWins = [];
        user.dailyBlackjackWins.unshift({ round: "BJ", res: "승리", profit: prize, time: nowStr });
        user.lastCasinoResult = { type: "blackjack", round: "BJ", res: "승리", profit: prize, isWin: true };
    } 
    else if (prize > 0 && resultStatus === "PUSH") {
        // 무승부 시에는 세금 없이 원금만 반환
        util_updatePoint(user, roomData, prize, "블랙잭 무승부 환급", roomName);
        finalMsg += "\n💰 환급: +" + fp(prize) + "P (배팅금 반환)";
        user.lastCasinoResult = { type: "blackjack", round: "BJ", res: "무승부", profit: 0, isWin: false };
    }
    else {
        user.lastCasinoResult = { type: "blackjack", round: "BJ", res: "패배", profit: -state.bet, isWin: false };
    }

    replier.reply(formatCommand("🏁 블랙잭 결과 Report", user, finalMsg + "\n\n🔁한번더 ❎그만", "내 잔액: " + fp(user.point) + "P"));
    
    user.blackjackState = null;
    roomData.features.states.menuWait[targetUid] = { type: 'blackjack_retry', time: Date.now() };
    
    safeSaveData(data);
}

/** [신규] 블랙잭 재도전(한번더/그만) 처리 핸들러 */
function _handleBlackjackRetry(msg, user, data, replier, roomName, targetUid) {
    var roomData = data.rooms[roomName];
    var mState = roomData.features.states.menuWait;
    var state = mState[targetUid];

    // 1. 시간 초과 체크 (30초)
    if (Date.now() - state.time > 30000) {
        delete mState[targetUid];
        replier.reply(formatError(user, "선택 시간 초과", "30초 이내에 선택하지 않아 블랙잭이 종료되었습니다."));
        return true;
    }

    // 2. 종료 (그만/취소)
    if (msg === "그만" || msg === "취소" || msg === "❎") {
        delete mState[targetUid];
        replier.reply(formatCommand("🚫 블랙잭 종료", user, "테이블에서 일어났습니다."));
        return true;
    }

    // 3. 재도전 (한번더/리트)
    if (msg === "한번더" || msg === "한번 더" || msg === "리트" || msg === "🔁") {
        // [부도 가드] 재확인
        if (typeof util_isBankruptcy === 'function' && util_isBankruptcy(roomName)) {
            delete mState[targetUid];
            replier.reply(formatError(user, "블랙잭 폐쇄", "국가 부도 선포로 인해 딜러들이 휴업 중입니다."));
            return true;
        }

        // 상태 전환: 메뉴 대기(retry) -> 금액 입력 대기(bet_input)
        delete mState[targetUid];
        
        // 섹터 22-1 등에서 처리하는 입력 대기 상태로 전환 (즉시 배팅 가능)
        data.rooms[roomName].features.states.bankProcess[targetUid] = { type: 'blackjack_bet_input', time: Date.now() };
        
        var minB = SYSTEM_CONFIG.ECO.GAMBLE_MIN || 2000;
        var maxB = SYSTEM_CONFIG.ECO.GAMBLE_MAX || 50000;
        
        replier.reply(formatCommand("🕴️ 블랙잭 재도전", user, "배팅하실 금액을 입력해주세요.\n\n• 최소: " + fp(minB) + "P\n• 최대: " + fp(maxB) + "P", "취소: [취소]"));
        return true;
    }

    return false;
}

/** 점수 계산기 (A처리 포함) */
function _calcBJScore(hand) {
    var score = 0; var aces = 0;
    hand.forEach(function(c) { if (c === 11) aces++; score += c; });
    while (score > 21 && aces > 0) { score -= 10; aces--; } // A를 11에서 1로 변환
    return score;
}
